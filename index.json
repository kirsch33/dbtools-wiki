{
  "DOCUMENTATION_MANIFEST.html": {
    "href": "DOCUMENTATION_MANIFEST.html",
    "title": "Documentation Manifest | DBTools Developer Documentation",
    "summary": "Documentation Manifest Last Updated: 2026-01-24 Total Units: 25 Completed: 25 In Progress: 0 Status Legend Status Meaning pending Not started in_progress Currently being documented draft Written but not verified verified Reviewed and source-anchored deferred Blocked by external factor Architecture Documentation Document Status Assignee Notes architecture/overview.md draft docs-run-20260124-020412 Complete (301 lines) architecture/build-pipeline.md draft initial-session Complete (462 lines) architecture/test-pipeline.md draft docs-run-20260124-020412 Complete (596 lines) architecture/project-references.md draft docs-run-20260124-020412 Complete (534 lines) architecture/ilrepack-embedding.md draft docs-run-20260124-020412 Complete (601 lines) architecture/sandbox-validator.md draft docs-run-20260124-020412 Complete (376 lines) architecture/theme-system.md draft docs-run-20260124-020412 Complete (697 lines) Project Documentation Document Status Assignee Notes projects/core.md draft docs-run-20260124-020412 Complete (745 lines) projects/app.md draft docs-run-20260124-020412 Complete (849 lines) projects/loader.md draft docs-run-20260124-020412 Complete (515 lines) projects/sandbox.md draft docs-run-20260124-020412 Complete (486 lines) projects/themes.md draft docs-run-20260124-020412 Complete (509 lines) Tool Documentation Common Tools Document Status Assignee Notes tools/common/elements-from-list-3d.md draft docs-run-20260124-020412 Complete (430 lines) tools/common/elevation-tags.md draft docs-run-20260124-020412 Complete (401 lines) tools/common/tdv.md draft docs-run-20260124-020412 Complete (393 lines) tools/common/gm.md draft docs-run-20260124-020412 Complete (433 lines) Structural Tools Document Status Assignee Notes tools/structural/analytical-snap.md draft docs-run-20260124-020412 Complete (299 lines) tools/structural/foundation-tags.md draft docs-run-20260124-020412 Complete (376 lines) tools/structural/framing-joins.md draft docs-run-20260124-020412 Complete (175 lines) tools/structural/joist-girder-weight.md draft docs-run-20260124-020412 Complete (287 lines) tools/structural/organize-foundation.md draft docs-run-20260124-020412 Complete (282 lines) tools/structural/sgt.md draft docs-run-20260124-020412 Complete (377 lines) Testing Tools Document Status Assignee Notes tools/testing/vtc.md draft docs-run-20260124-020412 Complete (411 lines) Developer Guides Document Status Assignee Notes developing/new-tool-guide.md draft docs-run-20260124-020412 Complete (1060 lines) developing/modularity.md draft docs-run-20260124-020412 Complete (738 lines) Summary Statistics Category Documents Total Lines Architecture 7 ~3,567 Projects 5 ~3,104 Tools - Common 4 ~1,657 Tools - Structural 6 ~1,796 Tools - Testing 1 ~411 Developer Guides 2 ~1,798 Total 25 ~12,333 Verification Checklist Template Each completed document must have: [x] All code references include file:line source anchors [x] No assumptions without evidence [x] Cross-references to related documents [ ] Examples tested where applicable [x] UNVERIFIED markers for uncertain claims [ ] Reviewed by human or verified AI session Session Log Date Session Documents Touched Notes 2026-01-16 initial-setup All stubs created Infrastructure setup 2026-01-16 initial-session build-pipeline.md Proof-of-concept complete 2026-01-24 docs-run-20260124-020412 Batch 1: overview.md, test-pipeline.md, project-references.md, core.md, loader.md, gm.md 6 docs completed 2026-01-24 docs-run-20260124-020412 Batch 2: ilrepack-embedding.md, theme-system.md, app.md 3 docs completed 2026-01-24 docs-run-20260124-020412 Batch 3: themes.md, sandbox.md, sandbox-validator.md, sgt.md 4 docs completed 2026-01-24 docs-run-20260124-020412 Batch 4: tdv.md, elevation-tags.md, foundation-tags.md, elements-from-list-3d.md 4 docs completed 2026-01-24 docs-run-20260124-020412 Batch 5: analytical-snap.md, framing-joins.md, joist-girder-weight.md, organize-foundation.md, vtc.md 5 docs completed 2026-01-24 docs-run-20260124-020412 Batch 6: new-tool-guide.md, modularity.md 2 developer guides completed How to Update This Manifest Before starting work, mark document as in_progress Add your session ID to Assignee column After completing, change status to draft After verification, change to verified Add entry to Session Log"
  },
  "DOCUMENTATION_ROADMAP.html": {
    "href": "DOCUMENTATION_ROADMAP.html",
    "title": "Documentation Roadmap | DBTools Developer Documentation",
    "summary": "Documentation Roadmap Created: 2026-01-24 Last Updated: 2026-01-24 (Session 2) Status: Active This document tracks all planned documentation work for the DBTools wiki. It serves as a feature/issue tracker for documentation efforts. Quick Status Phase Status Progress Phase 1: Infrastructure Complete 2/2 Phase 2: Theming Complete 3/3 Phase 3: Developer Guides Complete 5/5 Phase 4: User Documentation Complete 13/13 Phase 5: Diagrams Complete 4/4 Phase 6: XML Audit Not Started 0/10 Phase 1: Documentation Infrastructure 1.1 Documentation Roadmap Status: Complete File: DOCUMENTATION_ROADMAP.md (this file) Description: Create feature/issue tracker for documentation work 1.2 Website Structure Redesign Status: Complete Priority: High Description: Split site into user-facing and developer-facing sections Implemented Structure: wiki/ ├── user-guide/ # END-USER facing (non-developers) │ ├── index.md # User guide home │ ├── installation.md # Install/uninstall, admin reqs │ ├── getting-started.md # Quick start for users │ ├── toc.yml │ └── tools/ # HOW TO USE each tool (11 guides) │ ├── gm.md │ ├── sgt.md │ ├── tdv.md │ ├── foundation-tags.md │ ├── elevation-tags.md │ ├── elements-from-list-3d.md │ ├── analytical-snap.md │ ├── framing-joins.md │ ├── joist-girder-weight.md │ ├── organize-foundation.md │ └── vtc.md ├── developer-guide/ # DEVELOPER facing │ ├── index.md # Developer guide home │ ├── architecture/ # Architecture docs │ ├── projects/ # Project docs │ ├── tools/ # Technical tool docs │ ├── developing/ # Tool development guides │ └── troubleshooting.md ├── templates/modern/styles/main.css # Custom theming ├── images/ # Logo, favicon └── index.md # Site home Tasks: [x] Create user-guide/ directory structure [x] Move existing docs to developer-guide/ [x] Update root toc.yml with new navigation [x] Create section index pages [x] Update cross-references in existing docs Phase 2: Website Theming 2.1 Custom CSS Status: Complete Priority: High File: templates/modern/styles/main.css Token Color Usage Primary #1946B9 Links, headers, accents Primary Light #3D6AD4 Hover states Secondary #FEC425 Highlights, call-to-action Secondary Light #FFD54F Secondary hover Paper #181820 Dark theme background Surface #222228 Cards, panels Body #E6E6E6 Body text Tasks: [x] Create templates/modern/styles/main.css [x] Override DocFX default colors with brand palette [x] Style code blocks, tables, blockquotes [x] Ensure accessibility (contrast ratios) [x] Test dark/light theme toggle 2.2 Logo & Favicon Status: Complete Priority: High Tasks: [x] Copy db_tools_icon.png to images/logo.png [x] Create favicon.ico [x] Update docfx.json with logo/favicon paths 2.3 DocFX Configuration Status: Complete Priority: High File: docfx.json Tasks: [x] Fix _gitContribute.repo URL [x] Add custom template reference [x] Configure _appLogoPath and _appFaviconPath [x] Set default theme preference Phase 3: Advanced Developer Guides All guides created under developer-guide/developing/ with cross-links. 3.1 Settings Packs Guide Status: Complete Priority: High File: developer-guide/developing/settings-packs.md Content: [x] What are settings packs? [x] Defining in manifest.yml [x] Settings model with Options pattern [x] SettingsPack UI integration [x] Configuration section naming conventions [x] Real examples from GM, SGT, FoundationTags 3.2 Feature Warnings Guide Status: Complete Priority: High File: developer-guide/developing/feature-warnings.md Content: [x] Warning system architecture [x] Defining warnings in manifest.yml [x] Warning lifecycle (trigger, display, dismiss) [x] disableTools mechanism [x] Warning UI in Settings window [x] IWarningPublisher usage [x] Real examples with code 3.3 Hooks Guide Status: Complete Priority: High File: developer-guide/developing/hooks.md Content: [x] Hook system architecture [x] DbtHookHost internals [x] Available hook types: [x] IViewActivatedHookHandler [x] IContextualRibbonHookHandler [x] Registering hooks in ToolModule [x] Writing custom hook handlers [x] Hook execution order and lifecycle [x] Real examples from existing tools [x] Creating new hook types (extension guide) 3.4 Sandbox Integration Guide Status: Complete Priority: High File: developer-guide/developing/sandbox-integration.md Content: [x] What is the Sandbox? [x] Why validation matters [x] Registering sandbox windows in manifest [x] Design-time ViewModels [x] SandboxMode detection [x] DistValidator checks [x] Running sandbox validation locally [x] Troubleshooting validation failures 3.5 Testing Tools Guide Status: Complete Priority: High File: developer-guide/developing/testing-tools.md Content: [x] Test project structure [x] Test categories (headless vs Revit integration) [x] TestSupport library usage [x] Writing headless tests [x] Writing Revit integration tests [x] Test doubles and stubs (legitimate vs illegitimate) [x] Running tests locally [x] CI integration [x] Debugging test failures [x] Real examples from GM.Tests, SGT.Tests 3.6 Update new-tool-guide.md Status: Complete (existing doc maintained) Priority: Medium File: developer-guide/developing/new-tool-guide.md Phase 4: User-Facing Documentation 4.1 Installation Guide Status: Complete Priority: High File: user-guide/installation.md Content: [x] System requirements (Revit versions, Windows version) [x] Download location [x] Installer workflow (what it does step-by-step) [x] Installation directory structure [x] Where settings are stored (%APPDATA%/DBTools/) [x] Admin requirements (if any) [x] Silent install options (if applicable) [x] Uninstallation process [x] Troubleshooting installation issues 4.2 Getting Started Guide Status: Complete Priority: High File: user-guide/getting-started.md Content: [x] First launch experience [x] Finding the DB Tools ribbon tab [x] Overview of available tools [x] Quick example: running a simple tool [x] Where to find help 4.3 Tool User Guides Status: Complete Priority: Medium Each tool has a user-facing guide at user-guide/tools/<tool>.md: Tool Status File GM (Global Mapper) Complete gm.md SGT (Super Girt Tool) Complete sgt.md TDV (Transfer Drafting Views) Complete tdv.md Foundation Tags Complete foundation-tags.md Elevation Tags Complete elevation-tags.md Elements From List 3D Complete elements-from-list-3d.md Analytical Snap Complete analytical-snap.md Framing Joins Complete framing-joins.md Joist Girder Weight Complete joist-girder-weight.md Organize Foundation Complete organize-foundation.md VTC Complete vtc.md Each guide includes: What the tool does (non-technical) When to use it (scenario table) Quick Start steps UI description Settings explanation (if applicable) Workflows (step-by-step) Tips and tricks Troubleshooting FAQ Phase 5: Diagrams & Visuals Mermaid diagrams added to key documents. 5.1 Architecture Diagram Status: Complete File: developer-guide/architecture/overview.md Added: Component diagram showing project relationships, discovery flow sequence diagram 5.2 Build Pipeline Diagram Status: Complete File: developer-guide/architecture/build-pipeline.md Added: Build targets flowchart showing Preflight → Build → Package phases 5.3 Tool Module Lifecycle Diagram Status: Complete File: developer-guide/developing/new-tool-guide.md Added: State diagram showing Discovered → Instantiated → Registered → Active lifecycle 5.4 Hook Execution Diagram Status: Complete (already existed) File: developer-guide/developing/hooks.md Existing: Component overview flowchart, registration sequence, execution flow sequence diagrams Phase 6: XML Comment Audit Systematic review of XML documentation comments in source code. Priority Order Project Status Est. Files Priority DBTools.Core Not Started ~50 1 (Highest) DBTools.App Not Started ~30 2 DBTools.Themes Not Started ~5 3 DBTools.Loader Not Started ~5 4 DBTools.Sandbox Not Started ~10 5 Tools/Common/GM Not Started ~40 6 Tools/Structural/SGT Not Started ~30 7 Tools/Common/TDV Not Started ~15 8 Tools/Structural/* Not Started ~40 9 Tools/Common/* Not Started ~20 10 Audit Checklist (per project) [ ] Public classes have <summary> [ ] Public methods have <summary>, <param>, <returns> [ ] Public properties have <summary> [ ] Complex logic has <remarks> [ ] Obsolete items have migration notes [ ] Stale/misleading comments removed [ ] IntelliSense reads naturally [ ] Consistency with naming conventions Execution Notes Parallel Work These can be worked on in parallel: Phase 2 (Theming) - independent of content Phase 5 (Diagrams) - can be added anytime Phase 6 (XML Audit) - separate from wiki Dependencies Phase 1.2 (Structure) ├── Phase 3 (Dev Guides) - need new paths └── Phase 4 (User Docs) - need new paths Phase 2 (Theming) - independent Phase 3 + 4 complete → Phase 5 (Diagrams) - add to final docs All content complete → Phase 6 (XML Audit) Session Continuity When picking up work: Check this roadmap for current status Update status as you work Commit changes frequently Update \"Last Updated\" date Completed Work 2026-01-24: Session 2 - Website Restructure, User Guides & Diagrams PR: https://github.com/kirsch33/dbtools/pull/198 (continued) Completed: Website restructured into user-guide / developer-guide split Custom CSS theming with DBTools brand colors Logo and favicon added 5 advanced developer guides (settings-packs, feature-warnings, hooks, sandbox-integration, testing-tools) 11 user-facing tool guides (all tools) Installation and Getting Started guides Updated navigation and index pages Mermaid diagrams added to architecture overview, build pipeline, and new-tool-guide Commits: 52da0ffc - docs: restructure site (user/developer split), add theming, add advanced dev guides 25fed669 - docs: add user guides for GM, SGT, TDV, Foundation Tags 6d000f73 - docs: add user guides for remaining 7 tools 4657b14a - docs: update roadmap - phases 1-4 complete e7c015b0 - docs: add Mermaid diagrams to architecture and developer guides 2026-01-24: Session 1 - Initial Documentation Completed: 26 documentation files (~12,700 lines) All architecture docs All project docs All tool technical docs (developer-facing) Developer guides (new-tool-guide, modularity) Troubleshooting guide Updated manifest and index Branch: docs-run-20260124-020412"
  },
  "api/index.html": {
    "href": "api/index.html",
    "title": "API Reference | DBTools Developer Documentation",
    "summary": "API Reference This section contains auto-generated API documentation from XML doc comments in the source code. Coverage Status Current XML doc comment coverage is approximately 33%. Areas with gaps will show minimal documentation. Project Coverage Notes DBTools.Core ~22% Needs improvement DBTools.App ~37% Moderate DBTools.Themes ~1% Critical gap SGT ~50% Best documented GM ~23% Large codebase Improving Coverage To improve API documentation: Add /// XML doc comments to public members Include at minimum: <summary>, <param>, <returns> Run docfx build to regenerate Example: /// <summary> /// Executes a transaction with the specified action. /// </summary> /// <param name=\"action\">The action to execute within the transaction.</param> /// <returns>True if the transaction succeeded; otherwise, false.</returns> /// <exception cref=\"InvalidOperationException\">Thrown when no document is active.</exception> public bool Execute(Action action) { // ... } Namespaces Once API metadata is generated via docfx metadata, namespace links will appear here: DBTools.Core DBTools.App DBTools.Themes DBTools.GM DBTools.SGT Note: Run docfx docfx.json (not docfx-conceptual.json) to generate API documentation from XML comments."
  },
  "articles/architecture/build-pipeline.html": {
    "href": "articles/architecture/build-pipeline.html",
    "title": "Build Pipeline | DBTools Developer Documentation",
    "summary": "Build Pipeline Overview DBTools uses a sophisticated build pipeline designed for: Multi-year Revit support (2024, 2025, 2026) Multi-framework targeting (net48 for Revit 2024, net8.0-windows for 2025+) WSL/Windows interoperability (development in WSL, builds via Windows dotnet.exe) Assembly merging (ILRepack for net48, AssemblyLoadContext for net8) Centralized artifacts (all outputs to .artifacts/, no per-project bin/obj) Source: csharp/build.sh:1-162, csharp/build/Build.cs:1-200 Quick Reference # Fast incremental build (default) bash csharp/build.sh # Clean + full rebuild bash csharp/build.sh --clean # Build specific Revit year bash csharp/build.sh -y 2025 BuildAll # Debug configuration bash csharp/build.sh --debug # Build only the app (skip tests) bash csharp/build.sh BuildApp # Clean outputs only bash csharp/build.sh Clean Source: csharp/build.sh:33-61 Architecture Build System Stack ┌─────────────────────────────────────────────────────────────┐ │ build.sh │ │ (Bash wrapper - WSL/Git Bash compatible) │ ├─────────────────────────────────────────────────────────────┤ │ Windows dotnet.exe │ │ (via wslpath/cygpath conversion) │ ├─────────────────────────────────────────────────────────────┤ │ NUKE Build │ │ (Build.cs, BuildTargets.cs, etc.) │ ├─────────────────────────────────────────────────────────────┤ │ MSBuild + .NET SDK │ │ (Directory.Build.props/targets, *.csproj) │ └─────────────────────────────────────────────────────────────┘ Key Files File Purpose build.sh Entry point - WSL/Git Bash wrapper build/Build.cs NUKE orchestration, parameters, cleanup build/BuildTargets.cs Build targets, Revit path resolution build/BuildMerging.cs ILRepack assembly merging (net48) build/BuildHelpers.cs Path conversion utilities build/ArtifactManagement.cs Metadata, fingerprinting, promotion Directory.Build.props Centralized project properties Directory.Build.targets Build targets, NUKE enforcement Version.props Product version build/Revit.props Revit-specific TFM definitions Source: csharp/build/Build.cs:17-24 Entry Point: build.sh The build script (build.sh) is the required entry point for all builds. Direct dotnet build is blocked by MSBuild. WSL Detection The script auto-detects the environment and configures appropriate path conversion: if [[ -f /proc/version ]] && grep -qi microsoft /proc/version 2>/dev/null; then # WSL environment WIN_DOTNET_EXE=\"/mnt/c/Program Files/dotnet/dotnet.exe\" to_win_path() { wslpath -w \"$1\"; } else # Git Bash or other WIN_DOTNET_EXE=\"/c/Program Files/dotnet/dotnet.exe\" to_win_path() { cygpath -w \"$1\"; } fi Source: csharp/build.sh:6-15 Build Server Cleanup The script ensures MSBuild daemon processes are terminated on exit to prevent file locks: cleanup_build_servers() { \"$WIN_DOTNET_EXE\" build-server shutdown 2>/dev/null || true } trap cleanup_build_servers EXIT INT TERM Source: csharp/build.sh:17-20 Vendored Dependencies Before non-Clean targets, the script checks for vendored UI assemblies and builds them if missing: ensure_vendored_deps() { local vendor_root=\"$SCRIPT_DIR/.artifacts/vendor\" local missing=false for tfm in net48 net8.0-windows; do [[ -f \"$vendor_root/handycontrol/$tfm/DBTools.HandyControl.dll\" ]] || missing=true [[ -f \"$vendor_root/controlzex/$tfm/DBTools.ControlzEx.dll\" ]] || missing=true [[ -f \"$vendor_root/fluentribbon/$tfm/DBTools.Fluent.Ribbon.dll\" ]] || missing=true done if $missing; then echo \"Vendored UI assemblies missing; building them now...\" bash \"$SCRIPT_DIR/build-vendored-deps.sh\" fi } Source: csharp/build.sh:116-130 NUKE Build System Parameters Parameter Default Description --Configuration Release Build configuration --Years 2024 2025 2026 Revit years to target --SkipClean true Skip clean for fast incremental builds --DryRun false Simulate actions without executing --ValidateManifests true Validate embedded manifests --ValidateTools true Validate tool UIs Source: csharp/build/Build.cs:36-51 Key Targets BuildAll ├── PreflightRevitInstalls ├── BuildCore ├── BuildApp ├── VendoredStageUiToYearOutputs ├── BuildTests ├── FlattenYearOutputs ├── PromoteToDist ├── WriteMetadata └── ValidateDist Target Description BuildAll Full build with validation BuildOnly Build without validation (CI use) BuildApp Build DBTools.App only BuildCore Build DBTools.Core only BuildTests Build all test projects Clean Delete staging/intermediate outputs PromoteToDist Copy validated outputs to dist/ Source: csharp/build/Build.cs:165-177 Revit Path Resolution NUKE auto-detects Revit installations using ricaun.Nuke: var installs = RevitInstallationUtils.InstalledRevit ?? Array.Empty<RevitInstallation>(); foreach (var inst in installs) Serilog.Log.Information(\" - Version={Version}, Location={Location}\", inst.Version, inst.InstallLocation); Override with parameters if needed: --Revit2024Dir --Revit2025Dir --Revit2026Dir Source: csharp/build/BuildTargets.cs:35-78 MSBuild Configuration Directory.Build.props The centralized props file establishes: Artifact paths - All outputs to .artifacts/ Year-based organization - bin/{Config}/{Year}/{TFM}/ Design-time support - XAML designer compatibility Code analysis - Warnings as errors, nullable enabled Centralized Artifacts <PropertyGroup> <BaseArtifactsDir>$(MSBuildThisFileDirectory).artifacts\\</BaseArtifactsDir> <BaseIntermediateOutputPath>$(BaseArtifactsDir)obj\\</BaseIntermediateOutputPath> <BaseOutputPath>$(BaseArtifactsDir)bin\\</BaseOutputPath> </PropertyGroup> Source: csharp/Directory.Build.props:12-14 Year-Based Output <PropertyGroup Condition=\"'$(DesignTimeBuild)'!='true'\"> <DBT_OutputYear Condition=\"'$(RevitYear)'!=''\">$(RevitYear)</DBT_OutputYear> <DBT_OutputYear Condition=\"'$(RevitYear)'==''\">shared</DBT_OutputYear> <OutputPath>$(BaseOutputPath)$(Configuration)\\$(DBT_OutputYear)\\</OutputPath> </PropertyGroup> This produces: .artifacts/ ├── bin/ │ ├── Release/ │ │ ├── 2024/ │ │ │ └── net48/ │ │ ├── 2025/ │ │ │ └── net8.0-windows/ │ │ └── 2026/ │ │ └── net8.0-windows/ │ └── Debug/ │ └── ... └── obj/ └── ... Source: csharp/Directory.Build.props:105-121 Code Quality Settings <PropertyGroup> <TreatWarningsAsErrors>true</TreatWarningsAsErrors> <LangVersion>latest</LangVersion> <Nullable>enable</Nullable> <EnableNETAnalyzers>true</EnableNETAnalyzers> <AnalysisLevel>latest-recommended</AnalysisLevel> </PropertyGroup> Source: csharp/Directory.Build.props:142-150 Directory.Build.targets NUKE Entry Point Enforcement Direct dotnet build from CLI is blocked to ensure consistent builds: <Target Name=\"DBT_EnforceEntryPoint\" BeforeTargets=\"CoreCompile\" Condition=\"'$(DesignTimeBuild)'!='true' and '$(DBT_Entry)'!='true'\"> <Error Code=\"DBT0001\" Text=\"Direct builds are blocked. Use ./csharp/build.sh\" /> </Target> Only builds via build.sh (which sets DBT_Entry=true) are allowed. Source: csharp/Directory.Build.targets:32-37 WPF Designer Fixes The targets file includes several fixes for WPF/XAML designer compatibility: Platform target override for designer (AnyCPU instead of x64) Intermediate path fixes for wpftmp projects Reference resolution before XAML compilation Duplicate file removal for generated code Source: csharp/Directory.Build.targets:8-63 Multi-Year Targeting Target Framework Matrix Revit Year .NET Version TFM 2024 .NET Framework 4.8 net48 2025 .NET 8 net8.0-windows 2026 .NET 8 net8.0-windows Revit.props Defines canonical TFMs for Revit-facing projects: <PropertyGroup> <RevitTargetFrameworks>net48;net8.0-windows</RevitTargetFrameworks> </PropertyGroup> Source: csharp/build/Revit.props Conditional Compilation Projects use conditional compilation for version-specific code: #if REVIT2024 // net48-specific code #elif REVIT2025 || REVIT2026 // net8-specific code #endif Assembly Merging ILRepack (net48 / Revit 2024) For Revit 2024 (net48), dependencies are merged into DBTools.dll using ILRepack: // Merge ALL DLLs except whitelist: var keepSeparate = new HashSet<string> { \"DBTools.dll\", // Primary assembly \"DBTools.Loader.dll\", // Entry point \"DBTools.HandyControl.dll\", \"DBTools.Fluent.Ribbon.dll\", \"DBTools.ControlzEx.dll\", \"DBTools.Themes.dll\", // Revit API (shouldn't be in output) \"RevitAPI.dll\", \"RevitAPIUI.dll\", }; Why merge? Revit add-ins share the AppDomain Without merging, different add-ins with same dependency versions can conflict ILRepack internalizes types to prevent conflicts What stays separate? WPF theme assemblies (need file Location for pack:// URIs) Loader assembly (Revit's entry point) Logging abstractions (shared type identity) Source: csharp/build/BuildMerging.cs:17-65 AssemblyLoadContext (net8 / Revit 2025+) For Revit 2025+ (net8), isolation is achieved via AssemblyLoadContext: Each add-in gets its own load context Dependencies are isolated without merging No ILRepack needed Source: csharp/build/BuildMerging.cs:11-14 Artifact Structure Build Outputs .artifacts/ ├── bin/ │ └── Release/ │ ├── 2024/ │ │ └── net48/ │ │ ├── DBTools.dll (merged) │ │ ├── DBTools.Loader.dll │ │ ├── DBTools.Themes.dll │ │ └── DBTools.*.dll (UI assemblies) │ ├── 2025/ │ │ └── net8.0-windows/ │ │ ├── DBTools.dll │ │ ├── DBTools.Loader.dll │ │ └── *.dll (dependencies) │ └── 2026/ │ └── net8.0-windows/ │ └── ... ├── tests/ │ └── Release/ │ ├── 2024/ │ ├── 2025/ │ └── 2026/ ├── vendor/ │ ├── handycontrol/ │ ├── controlzex/ │ └── fluentribbon/ └── .staging/ └── {BuildId}/ ├── bundle/ ├── installer/ └── logs/ Distribution After PromoteToDist, production payloads are in: .artifacts/dist/ ├── 2024/ ├── 2025/ └── 2026/ Troubleshooting Common Issues Problem Solution \"Direct builds are blocked\" (DBT0001) Use build.sh instead of dotnet build \"Windows dotnet.exe not found\" Ensure .NET SDK installed on Windows side \"Vendored UI assemblies missing\" Run build-vendored-deps.sh XAML designer errors Build once via build.sh to populate artifacts MSBuild daemon file locks Script auto-cleans; or run dotnet build-server shutdown Verbose Logging # Add --Verbose for detailed NUKE output bash csharp/build.sh --Verbose BuildAll Clean Rebuild # Full clean + rebuild bash csharp/build.sh --clean BuildAll Related Documentation Project References - Dependency relationships ILRepack & Embedding - Assembly merging details Test Pipeline - Testing infrastructure Verification Status Check Status Source anchors for all claims Yes UNVERIFIED markers where needed No (all verified) Cross-references added Yes Examples tested N/A (documentation) No assumptions without evidence Yes Verified by: initial-wiki-session Date: 2026-01-16"
  },
  "articles/architecture/ilrepack-embedding.html": {
    "href": "articles/architecture/ilrepack-embedding.html",
    "title": "ILRepack and Assembly Embedding | DBTools Developer Documentation",
    "summary": "ILRepack and Assembly Embedding This document describes how DBTools merges and embeds assemblies to achieve a minimal deployment footprint while avoiding conflicts with other Revit add-ins. Overview DBTools uses two complementary strategies to manage dependencies: Strategy Framework Purpose ILRepack net48 only Merges most dependencies INTO DBTools.dll Embedding Both TFMs Embeds assemblies as resources, loaded on-demand Both strategies aim to: Minimize deployment files (ideally just DBTools.dll + DBTools.Loader.dll + WPF theme DLLs) Avoid conflicts with other Revit add-ins that may load different versions of shared libraries Prevent GAC/Revit-provided assemblies from being used instead of our versions Source: csharp/build/BuildMerging.cs:11-22 Why ILRepack? The Revit Add-in Conflict Problem Revit add-ins share a single AppDomain (net48) or AssemblyLoadContext (net8). When multiple add-ins depend on the same library (e.g., Serilog, Newtonsoft.Json), the first-loaded version wins. Problems this causes: Type identity mismatches (your code expects Serilog 4.0, but Serilog 2.0 was loaded first) Missing method exceptions (newer API called on older assembly) Mysterious crashes when reflection fails ILRepack's solution: Merge dependencies INTO DBTools.dll with internalized types Types become internal to your assembly, invisible to other add-ins No conflict possible because types aren't shared Source: csharp/build/BuildMerging.cs:17-21 net48 vs net8.0-windows Strategy Differences net48 (Revit 2024) Uses both ILRepack merging AND embedding: +-------------------+ | DBTools.dll | | (ILRepack'd) | <-- Contains merged types from Serilog, M.E.*, etc. +-------------------+ | +-- Embedded resources: ricaun.Revit.UI.*.dll (loaded from bytes) | +-- Separate files: DBTools.Fluent.Ribbon.dll, DBTools.Themes.dll, etc. net8.0-windows (Revit 2025/2026) Uses embedding only (no ILRepack): +-------------------+ | DBTools.dll | | (standard) | +-------------------+ | +-- Embedded resources: ALL dependencies (DBTools.Core, Serilog, M.E.*, etc.) | +-- Separate files: DBTools.Fluent.Ribbon.dll, DBTools.Themes.dll, etc. Why no ILRepack for net8? .NET 8's AssemblyLoadContext provides natural isolation Each add-in can have its own isolated context ILRepack has compatibility issues with some .NET 8 assemblies Source: csharp/build/BuildMerging.cs:13-14, csharp/src/DBTools.Loader/AssemblyResolution/EmbeddedAssemblyResolver.cs:32-37 ILRepack Merging (net48) Target: MergeNet48Assemblies The build target MergeNet48Assemblies performs the merge: Target MergeNet48Assemblies => _ => _ .Description(\"Merge ALL dependencies into DBTools.dll for net48 via ILRepack (except WPF themes)\") .DependsOn(FlattenYearOutputs) .After(BuildApp, BuildTests) .Before(PromoteToDist) Source: csharp/build/BuildMerging.cs:23-28 What Gets Merged (Everything Except Whitelist) The strategy is \"merge everything EXCEPT a small whitelist\": var keepSeparate = new HashSet<string>(StringComparer.OrdinalIgnoreCase) { \"DBTools.dll\", // Primary assembly (merging INTO this) \"DBTools.Loader.dll\", // Entry point loaded by Revit \"DBTools.HandyControl.dll\", // WPF theme - needs file Location \"DBTools.Fluent.Ribbon.dll\", // WPF theme - needs file Location \"DBTools.ControlzEx.dll\", // WPF theme - needs file Location \"DBTools.Themes.dll\", // WPF theme - needs file Location \"Microsoft.Extensions.Logging.Abstractions.dll\", // Shared with sandbox // Revit API (shouldn't be in output) \"RevitAPI.dll\", \"RevitAPIUI.dll\", \"AdWindows.dll\", \"UIFramework.dll\" }; Source: csharp/build/BuildMerging.cs:50-65 Prefix-Based Exclusions Some assemblies are excluded by prefix (because NuGet adds version numbers): var keepSeparatePrefixes = new[] { \"ricaun.Revit.UI\" }; Why ricaun assemblies aren't merged: ILRepack corrupts ricaun IL, causing runtime crashes Instead, ricaun assemblies are EMBEDDED as resources Source: csharp/build/BuildMerging.cs:68-70 Internalization with Exclusions ILRepack internalizes merged types, but some namespaces must stay public: var excludeFile = yearDir / \"ilrepack-exclude.txt\"; File.WriteAllText(excludeFile, \"^DBTools\\\\.Core\\\\.\\n^Serilog\\\\.\\n^Microsoft\\\\.Extensions\\\\.\\n^Microsoft\\\\.Bcl\\\\.\\n^System\\\\.\\n^ricaun\\\\.Revit\\\\.\"); Namespace Why Public DBTools.Core.* Base classes used by tools Serilog.* Reflection-based sink discovery Microsoft.Extensions.* DI and configuration Microsoft.Bcl.* Polyfill interfaces (IAsyncDisposable) System.* Polyfill types Source: csharp/build/BuildMerging.cs:115-127 ILRepack Command The actual merge command: args.Append($\"/internalize:\\\"{excludeFile}\\\" \"); // Internalize with exclusions args.Append(\"/allowdup \"); // Handle duplicate polyfill types args.Append(\"/ndebug \"); // Skip debug info args.Append($\"/lib:\\\"{revitPath}\\\" \"); // Resolve Revit API references args.Append($\"/out:\\\"{dbToolsDll}\\\" \"); // Output to DBTools.dll args.Append($\"\\\"{backupOriginal}\\\" \"); // Primary assembly // + all assemblies to merge Source: csharp/build/BuildMerging.cs:129-144 Assembly Embedding Strategy Build Target: DBT_EmbedCopyLocalAssemblies The embedding happens during MSBuild via a custom target: <Target Name=\"DBT_EmbedCopyLocalAssemblies\" AfterTargets=\"ResolveReferences\" Condition=\"'$(DesignTimeBuild)'!='true'\"> Source: csharp/src/DBTools.App/DBTools.App.csproj:234-236 Resource Naming Convention Embedded assemblies use a logical name pattern: DBTools.EmbeddedAssemblies.{AssemblyName}.dll For example: DBTools.EmbeddedAssemblies.Serilog.dll DBTools.EmbeddedAssemblies.DBTools.Core.dll <ItemGroup> <_EmbedLogical Include=\"@(_EmbedIdentity->'DBTools.EmbeddedAssemblies.%(Name).dll')\"> <SourcePath>%(OriginalItemSpec)</SourcePath> </_EmbedLogical> <EmbeddedResource Include=\"%(_EmbedLogicalDistinct.SourcePath)\" LogicalName=\"%(_EmbedLogicalDistinct.Identity)\" /> </ItemGroup> Source: csharp/src/DBTools.App/DBTools.App.csproj:262-268 Exclusions from Embedding Revit-provided assemblies (never copy/embed): <_EmbedCandidate Remove=\"@(_EmbedCandidate)\" Condition=\"'%(Filename)%(Extension)' == 'RevitAPI.dll'\" /> <_EmbedCandidate Remove=\"@(_EmbedCandidate)\" Condition=\"'%(Filename)%(Extension)' == 'Newtonsoft.Json.dll'\" /> WPF theme assemblies (need file Location): <_EmbedCandidate Remove=\"@(_EmbedCandidate)\" Condition=\"$([System.String]::Copy('%(Filename)').StartsWith('DBTools.Fluent.Ribbon'))\" /> <_EmbedCandidate Remove=\"@(_EmbedCandidate)\" Condition=\"$([System.String]::Copy('%(Filename)').StartsWith('DBTools.ControlzEx'))\" /> <_EmbedCandidate Remove=\"@(_EmbedCandidate)\" Condition=\"$([System.String]::Copy('%(Filename)').StartsWith('DBTools.Themes'))\" /> Source: csharp/src/DBTools.App/DBTools.App.csproj:241-251 Runtime Assembly Resolution EmbeddedAssemblyResolver The resolver is installed early during add-in startup: public static void Install(Assembly mainAssembly, string? deployedDir = null) { // ... #if NET8_0_OR_GREATER var alc = AssemblyLoadContext.GetLoadContext(mainAssembly) ?? AssemblyLoadContext.Default; alc.Resolving += (context, name) => ResolveNet8(context, mainAssembly, name); #else AppDomain.CurrentDomain.AssemblyResolve += (_, args) => Resolve(mainAssembly, args.Name); #endif } Source: csharp/src/DBTools.Loader/AssemblyResolution/EmbeddedAssemblyResolver.cs:24-38 Resolution Flow (net48) Assembly requested (e.g., \"Serilog\") | v 1. Already loaded in AppDomain? YES -> Return existing (prevents duplicates) | v 2. Try embedded resource: \"DBTools.EmbeddedAssemblies.Serilog.dll\" FOUND -> Assembly.Load(bytes) | v 3. Check if merged via ILRepack (TryGetMergedAssembly) MERGED -> Return mainAssembly | v 4. DBTools.* namespace? Try file-based fallbacks FOUND -> Assembly.LoadFrom(path) | v 5. Return null (let CLR handle) Source: csharp/src/DBTools.Loader/AssemblyResolution/EmbeddedAssemblyResolver.cs:40-95 Merged Assembly Detection (net48) For ILRepack'd assemblies, the resolver returns the main assembly: private static Assembly? TryGetMergedAssembly(Assembly mainAssembly, string requestedName) { // WPF themes NOT merged if (requestedName.Equals(\"DBTools.Fluent.Ribbon\", ...) || requestedName.Equals(\"DBTools.ControlzEx\", ...) || requestedName.Equals(\"DBTools.Themes\", ...) || requestedName.Equals(\"DBTools.Loader\", ...)) return null; // DBTools.Core is merged if (requestedName.Equals(\"DBTools.Core\", ...)) return mainAssembly; // Other merged deps if (requestedName.StartsWith(\"Serilog\", ...) || requestedName.StartsWith(\"Microsoft.Extensions\", ...) || requestedName.Equals(\"YamlDotNet\", ...)) return mainAssembly; return null; } Source: csharp/src/DBTools.Loader/AssemblyResolution/EmbeddedAssemblyResolver.cs:223-263 Resolution Flow (net8) private static Assembly? ResolveNet8(AssemblyLoadContext alc, Assembly mainAssembly, AssemblyName requested) { // 1. Already loaded? Return it var alreadyLoaded = alc.Assemblies.FirstOrDefault(...); if (alreadyLoaded != null) return alreadyLoaded; // 2. Try embedded resource var resourceName = ResourcePrefix + requestedName + \".dll\"; using var stream = mainAssembly.GetManifestResourceStream(resourceName); if (stream != null) { return alc.LoadFromStream(ms); // Load into same ALC } // 3. File-based fallbacks for WPF assemblies return TryLoadFromFileFallbacksNet8(alc, mainAssembly, requestedName); } Source: csharp/src/DBTools.Loader/AssemblyResolution/EmbeddedAssemblyResolver.cs:146-189 WPF Theme Assemblies: Why They Stay Separate The pack:// URI Problem WPF's XAML parser uses pack:// URIs to locate resources within assemblies: <ResourceDictionary Source=\"pack://application:,,,/DBTools.Fluent.Ribbon;component/Themes/Generic.xaml\" /> The parser uses Assembly.Location to resolve these URIs. Assemblies loaded from byte arrays have Location = \"\", breaking resource lookup. Source: csharp/src/DBTools.Loader/AssemblyResolution/EmbeddedAssemblyResolver.cs:93-94, csharp/src/DBTools.App/DBTools.App.csproj:244-251 Which Assemblies Need File Location Assembly Reason DBTools.Fluent.Ribbon Contains BAML for ribbon controls DBTools.ControlzEx Contains BAML for window behaviors DBTools.HandyControl Contains BAML for HandyControl widgets DBTools.Themes Contains merged theme dictionaries Source: csharp/build/BuildMerging.cs:53-57 File-Based Resolution Fallbacks For WPF assemblies, the resolver tries file-based loading: private static Assembly? TryLoadFromFileFallbacks(Assembly mainAssembly, string requestedName) { // 1. Check %APPDATA%/DBTools/vendor/<type>/<tfm>/ var appDataPath = Path.Combine( Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData), \"DBTools\", \"vendor\", vendorType, vendorTfm, dllName); if (File.Exists(appDataPath)) return Assembly.LoadFrom(appDataPath); // 2. Check deployed directory (next to DBTools.Loader.dll) return TryLoadFromDeployedDir(deployedDir, dllName); } Source: csharp/src/DBTools.Loader/AssemblyResolution/EmbeddedAssemblyResolver.cs:101-129 Preloading Critical Assemblies (net48) The GAC Problem On net48, AssemblyResolve only fires when an assembly CAN'T be found. If an older version exists in the GAC or was loaded by another add-in, the CLR uses it instead of asking our resolver. Solution: Preload During Startup Before any code uses these assemblies, DBTools.Loader preloads them from embedded resources: #if !NET8_0_OR_GREATER PreloadEmbeddedConfigurationAssemblies(assembly); PreloadEmbeddedSerilogAssemblies(assembly); #endif Source: csharp/src/DBTools.Loader/Addin/AddinEntry.cs:25-28 Configuration Assembly Preload private static void PreloadEmbeddedConfigurationAssemblies(Assembly mainAssembly) { var configAssemblies = new[] { \"Microsoft.Extensions.Primitives\", \"Microsoft.Extensions.FileProviders.Abstractions\", \"Microsoft.Extensions.FileProviders.Physical\", \"Microsoft.Extensions.Configuration.Abstractions\", \"Microsoft.Extensions.Configuration\", \"Microsoft.Extensions.Configuration.FileExtensions\", \"Microsoft.Extensions.Configuration.Json\", \"Microsoft.Extensions.Configuration.Binder\" }; foreach (var name in configAssemblies) { var alreadyLoaded = GetLoadedAssemblyBySimpleName(name); if (alreadyLoaded != null) continue; var resourceName = \"DBTools.EmbeddedAssemblies.\" + name + \".dll\"; using (var stream = mainAssembly.GetManifestResourceStream(resourceName)) { if (stream == null) continue; using (var ms = new MemoryStream()) { stream.CopyTo(ms); Assembly.Load(ms.ToArray()); } } } } Source: csharp/src/DBTools.Loader/Addin/AddinEntry.cs:109-143 Serilog Assembly Preload Critical: Dependencies must be loaded BEFORE dependents: var serilogAssemblies = new[] { // 1. Base abstractions first \"Microsoft.Extensions.Logging.Abstractions\", \"Microsoft.Extensions.DependencyInjection.Abstractions\", // 2. M.E.Logging (depends on Abstractions) \"Microsoft.Extensions.Logging\", // 3. Serilog core \"Serilog\", // 4. Serilog extensions (depend on above) \"Serilog.Extensions.Logging\", \"Serilog.Enrichers.Thread\", \"Serilog.Sinks.File\" }; Source: csharp/src/DBTools.Loader/Addin/AddinEntry.cs:150-170 Forbidden Host Assemblies Build-Time Guardrails The build prevents certain assemblies from landing in output: <ItemGroup> <ForbiddenHostAssembly Include=\"RevitAPI.dll\" /> <ForbiddenHostAssembly Include=\"RevitAPIUI.dll\" /> <ForbiddenHostAssembly Include=\"AdWindows.dll\" /> <ForbiddenHostAssembly Include=\"UIFramework.dll\" /> <ForbiddenHostAssembly Include=\"Newtonsoft.Json.dll\" /> <ForbiddenHostAssembly Include=\"System.Runtime.dll\" /> <ForbiddenHostAssembly Include=\"System.ObjectModel.dll\" /> </ItemGroup> Source: csharp/src/DBTools.App/DBTools.App.csproj:169-177 Automatic Cleanup A build target removes forbidden assemblies if transitive dependencies copied them: <Target Name=\"DBT_RemoveForbiddenAfterCopy\" AfterTargets=\"CopyFilesToOutputDirectory\" BeforeTargets=\"FailIfHostAssembliesInOutput\"> <Delete Files=\"@(_DBT_ForbiddenToClear)\" /> </Target> Source: csharp/src/DBTools.App/DBTools.App.csproj:181-196 Build Failure on Violation If any forbidden assemblies remain after cleanup, the build fails: <Target Name=\"FailIfHostAssembliesInOutput\"> <Error Text=\"Forbidden host assemblies detected in output: @(_ForbiddenInOutput).\" Condition=\"'@(_ForbiddenInOutput)' != ''\" /> </Target> Source: csharp/src/DBTools.App/DBTools.App.csproj:198-211 Summary: What Goes Where Assembly Type net48 net8.0-windows Location DBTools.Core ILRepack merged Embedded resource Inside DBTools.dll Serilog.* ILRepack merged Embedded resource Inside DBTools.dll M.E.DI/Config ILRepack merged Embedded resource Inside DBTools.dll YamlDotNet ILRepack merged Embedded resource Inside DBTools.dll ricaun.Revit.* Embedded resource Embedded resource Inside DBTools.dll DBTools.Themes Separate file Separate file Next to DBTools.dll DBTools.Fluent.Ribbon Separate file Separate file Next to DBTools.dll DBTools.ControlzEx Separate file Separate file Next to DBTools.dll DBTools.HandyControl Separate file Separate file Next to DBTools.dll DBTools.Loader Separate file Separate file Next to DBTools.dll RevitAPI/UI Never copied Never copied Revit provides Troubleshooting Issue: \"Type X not found\" or \"Method Y not found\" Cause: Assembly version mismatch - another add-in loaded a different version first. Solutions: Ensure dependencies are embedded or merged Check if the assembly is in keepSeparate whitelist unnecessarily Preload the assembly during startup Issue: WPF resource not found (pack:// URI failure) Cause: WPF assembly loaded from bytes instead of file. Solutions: Ensure WPF assemblies are in keepSeparate whitelist Verify DLLs are deployed next to DBTools.Loader.dll Check EmbeddedAssemblyResolver file fallback paths Issue: ILRepack crash or corrupted IL Cause: Some assemblies have IL that ILRepack can't process. Solutions: Add to keepSeparatePrefixes to exclude from merge Embed as resource instead of merging Check ILRepack version compatibility Issue: Duplicate type definitions after merge Cause: Multiple assemblies define the same polyfill type. Solution: ILRepack /allowdup flag handles this: args.Append(\"/allowdup \"); // Handle duplicate polyfill types Source: csharp/build/BuildMerging.cs:131 Related Documentation Architecture Overview - High-level system architecture Project References - How projects reference each other Build Pipeline - Build system details DBTools.Loader - Assembly loading at runtime Verification Status Check Status Source anchors for all claims Yes UNVERIFIED markers where needed No (all verified) Cross-references added Yes Examples tested N/A No assumptions without evidence Yes Verified by: docs-run-20260124-020412 Date: 2026-01-24"
  },
  "articles/architecture/overview.html": {
    "href": "articles/architecture/overview.html",
    "title": "Architecture Overview | DBTools Developer Documentation",
    "summary": "Architecture Overview DBTools is a modular Revit add-in suite built with modern C#/.NET practices. It provides a collection of productivity tools for structural engineers working in Autodesk Revit. High-Level Architecture +-----------------------------------------------------------------------------------+ | Revit Host | +-----------------------------------------------------------------------------------+ | | v v +-------------------+ +----------------------+ | DBTools.Loader | <-- Revit .addin manifest | Revit API | | (Entry Point) | points here | (RevitAPI.dll, | +-------------------+ | RevitAPIUI.dll) | | +----------------------+ | Loads DBTools.dll, installs ^ | EmbeddedAssemblyResolver | v | +-------------------+ References +----------------------+ | | DBTools.App | -----------------> | DBTools.Core |-+ | (DBTools.dll) | | (Core Library) | | | +----------------------+ | - AddinEntry | ^ | - Tool Modules | | | - Ribbon UI | References | | - Commands | -----------------> +----------------------+ +-------------------+ | DBTools.Themes | | | (WPF Resources) | | Discovers via manifest.yml +----------------------+ v +-------------------+ | Tool Modules | | (File-linked) | | - GM, SGT, TDV | | - Settings | | - Structural/* | +-------------------+ Source: csharp/src/DBTools.Loader/Addin/AddinEntry.cs:12-38 Project Organization The solution follows a layered architecture with clear separation of concerns: Core Projects Project Purpose Target Frameworks DBTools.Loader Revit entry point; loads DBTools.dll and resolves embedded assemblies net48, net8.0-windows DBTools.App Main application assembly (outputs as DBTools.dll); contains ribbon UI and tool registration net48, net8.0-windows DBTools.Core Core library with shared infrastructure (DI, logging, settings, Revit abstractions) net48, net8.0-windows DBTools.Themes WPF theme resources and styling (HandyControl, Fluent.Ribbon) net48, net8.0-windows DBTools.Sandbox Standalone WPF app for UI development without Revit net48, net8.0-windows Source: csharp/src/ directory structure Tool Projects (File-Linked into DBTools.App) Tools are organized under csharp/src/Tools/ and compiled into the main DBTools.dll assembly via MSBuild file linking: Tools/ +-- Common/ | +-- GM/ # Global Mapper | +-- TDV/ # Type Data Viewer | +-- ElevationTags/ | +-- 3DElementsFromList/ +-- Structural/ | +-- SGT/ # Structural Grid Tool | +-- FoundationTags/ | +-- FramingJoins/ | +-- JoistGirderWeight/ | +-- OrganizeFoundationTypes/ | +-- AnalyticalSnapToLevel/ +-- Settings/ # Settings management tool +-- Testing/ +-- VTC/ # View Test Coordinator Source: csharp/src/DBTools.App/DBTools.App.csproj:62-78 (file linking configuration) Tool source files are linked (not copied) into the DBTools.App project: <Compile Include=\"..\\Tools\\**\\*.cs\" Exclude=\"..\\Tools\\**\\Tests\\**\\*.cs;..\\Tools\\**\\obj\\**\\*.cs\" Link=\"Tools\\%(RecursiveDir)%(Filename)%(Extension)\" /> Source: csharp/src/DBTools.App/DBTools.App.csproj:64-66 Multi-Year Revit Support DBTools supports multiple Revit versions through dual target frameworks: Revit Version Target Framework Runtime Revit 2024 net48 .NET Framework 4.8 Revit 2025+ net8.0-windows .NET 8 Source: csharp/build/Revit.props:2-6 The build system auto-detects installed Revit versions and builds for all available years: <DBT_RevitLegacyTFM>net48</DBT_RevitLegacyTFM> <DBT_RevitModernTFM>net8.0-windows</DBT_RevitModernTFM> <DBT_RevitTargetFrameworks>$(DBT_RevitLegacyTFM);$(DBT_RevitModernTFM)</DBT_RevitTargetFrameworks> Source: csharp/build/Revit.props:3-5 Tool Discovery and Registration DBTools uses a YAML manifest-driven tool discovery system. Each tool declares its module, commands, and UI configuration in a manifest.yml file. Manifest Structure id: DBTools.GM assembly: DBTools moduleType: DBTools.GM.GmToolModule order: 0 sandboxWindows: - id: DBTools.GM.Main displayName: \"Global Mapper\" windowType: \"DBTools.GM.Shell.UI.Views.GmWindow\" tool: ribbonTools: - internalName: DBTools.GM commandType: DBTools.GM.Features.GmCommand availabilityType: DBTools.App.Tools.Availability.DbtDocumentAvailability displayText: \"Global Mapper\" iconBaseKey: gm controlKind: PushButton Source: csharp/src/Tools/Common/GM/manifest.yml:1-26 Discovery Flow Manifest Loading: DbtToolManifestLoader scans embedded resources for manifest.yml files Module Instantiation: DbtToolModuleCatalog creates DbtToolModule instances via reflection Service Registration: Each module's RegisterServices(), RegisterSettings(), and RegisterHooks() are called Ribbon Tool Registration: RegisterRibbonToolsFromManifest() parses ribbon definitions and registers commands Source: csharp/src/DBTools.Core/Tools/DbtToolModuleCatalog.cs:11-64 Tool Module Base Class All tools inherit from DbtToolModule, which provides hooks for: RegisterSettings() - Bind configuration sections to strongly-typed options RegisterServices() - Register tool-specific DI services RegisterSettingsPacks() - Register settings UI definitions RegisterHooks() - Register event handlers (e.g., DocumentOpened, ViewActivated) Source: csharp/src/DBTools.Core/Tools/DbtToolModule.cs:9-49 Dependency Injection Architecture DBTools uses Microsoft.Extensions.DependencyInjection with a two-tier service scope pattern: Singleton Services (Application Lifetime) IDbtLoggingHost - Serilog-based logging infrastructure IConfiguration - Settings from settings.json DbtToolRegistry - Discovered tool registrations ISafeExecutor - Centralized error handling ISettingsProvider - Settings read/write access Scoped Services (Per-Command Lifetime) IRevitRunScope - Active command execution context IRevitCallGate - Thread-safe Revit API access ITransactionRunner - Transaction management ITransactionGroupService - Transaction grouping Source: csharp/src/DBTools.App/Bootstrap/DbtServiceBootstrapper.cs:68-130 Assembly Loading Strategy Loader Bootstrap The DBTools.Loader assembly is the Revit entry point. It: Locates DBTools.dll in the same directory Installs EmbeddedAssemblyResolver for runtime dependency resolution Pre-loads critical assemblies (Configuration, Serilog) on net48 Reflectively creates and invokes DBTools.App.AddinEntry Source: csharp/src/DBTools.Loader/Addin/AddinEntry.cs:17-47 Embedded Dependencies Dependencies are embedded as resources in DBTools.dll to minimize deployment complexity: <EmbeddedResource Include=\"%(_EmbedLogicalDistinct.SourcePath)\" LogicalName=\"%(_EmbedLogicalDistinct.Identity)\" /> Source: csharp/src/DBTools.App/DBTools.App.csproj:267-268 The resolver uses different strategies per framework: Framework Strategy net48 ILRepack merges most assemblies; ricaun.* embedded as resources net8.0 All dependencies embedded as resources, loaded via AssemblyLoadContext Source: csharp/src/DBTools.Loader/AssemblyResolution/EmbeddedAssemblyResolver.cs:14-96 WPF Theme Assemblies WPF assemblies (Fluent.Ribbon, ControlzEx, HandyControl) cannot be embedded because they require Assembly.Location for pack:// URI resolution. These are: Vendored/renamed to avoid conflicts with pyRevit (e.g., DBTools.Fluent.Ribbon) Deployed as files alongside DBTools.dll Source: csharp/src/DBTools.Loader/AssemblyResolution/EmbeddedAssemblyResolver.cs:134-143 Build System Overview The build uses NUKE (C# build automation) invoked via build.sh: # Fast incremental build (default) bash csharp/build.sh # Clean rebuild bash csharp/build.sh --clean # Build specific Revit year bash csharp/build.sh -y 2025 BuildAll # Common targets bash csharp/build.sh BuildAll # Build everything bash csharp/build.sh BuildApp # Build DBTools.dll only bash csharp/build.sh BuildSandbox # Build UI sandbox bash csharp/build.sh PromoteToDist # Stage for deployment Source: csharp/build.sh:33-60 Key build features: Centralized Artifacts: All outputs go to csharp/.artifacts/ (not per-project bin/obj) Vendored Dependencies: UI assemblies built via build-vendored-deps.sh Strict Analysis: TreatWarningsAsErrors=true, Roslyn analyzers enabled Multi-Year: Builds for all detected Revit installations Source: csharp/Directory.Build.props:8-28 For detailed build pipeline documentation, see Build Pipeline. Error Handling Philosophy All entrypoints execute within ISafeExecutor, which: Catches and logs all exceptions Displays user-friendly error dialogs Prevents silent failures Centralizes error reporting Source: csharp/src/DBTools.App/Bootstrap/DbtServiceBootstrapper.cs:435-436 Non-Negotiable Rules: No fallbacks that hide failures No silent exception swallowing No returning defaults as if nothing failed Related Documentation Build Pipeline - Detailed build system reference Test Pipeline - Testing infrastructure Project References - Dependency relationships DBTools.Core - Core library documentation DBTools.Loader - Revit entry point Verification Status Check Status Source anchors for all claims Yes UNVERIFIED markers where needed No (all verified) Cross-references added Yes Examples tested N/A No assumptions without evidence Yes Verified by: docs-run-20260124-020412 Date: 2026-01-24"
  },
  "articles/architecture/project-references.html": {
    "href": "articles/architecture/project-references.html",
    "title": "Project References and Dependency Management | DBTools Developer Documentation",
    "summary": "Project References and Dependency Management This document describes how DBTools projects reference each other, manage dependencies, and use file linking patterns. Project Dependency Graph +-----------------------+ | DBTools.Themes | | (WPF theme resources)| +-----------+-----------+ | +------------------------+------------------------+ | | +---------v---------+ +---------v---------+ | DBTools.Core |<----------------------------+ DBTools.App | | (shared services, | | (assembly output: | | UI, Revit infra) | | DBTools.dll) | +---------+---------+ +---------+---------+ ^ ^ | | +-----------+-----------+ +-----------+-----------+ | | | | +-------+-------+ +-------+-------+ +-------+-------+ +-------+-------+ | DBTools.GM | | DBTools.SGT | | File-linked | | File-linked | | (XAML design) | | (XAML design) | | tool sources | | tool assets | +---------------+ +---------------+ +---------------+ +---------------+ ^ ^ | | +-------+-------+ +-------+-------+ |DBTools.GM.Tests| |DBTools.SGT.Tests| +---------------+ +---------------+ +-------------------+ +-------------------+ | DBTools.Loader | | DBTools.Sandbox | | (Revit entrypoint)| | (standalone exe) | +-------------------+ +-------------------+ Source: csharp/src/DBTools.App/DBTools.App.csproj:56-59 Key Relationships From To Reference Type Purpose DBTools.App DBTools.Core ProjectReference Core services, UI infrastructure DBTools.App DBTools.Themes ProjectReference WPF theme resources DBTools.Core DBTools.Themes ProjectReference ComponentResourceKey definitions Tool projects DBTools.Core ProjectReference Shared infrastructure Test projects DBTools.App + DBTools.Core ProjectReference Test compilation DBTools.Sandbox DBTools.Core + DBTools.Themes ProjectReference Standalone preview File Linking vs Project References DBTools uses two distinct patterns for code sharing: Pattern 1: Project References (Standard) Used when the referenced assembly should be included as a separate DLL in output. <!-- From DBTools.Core.csproj:165 --> <ProjectReference Include=\"..\\DBTools.Themes\\DBTools.Themes.csproj\" /> Source: csharp/src/DBTools.Core/DBTools.Core.csproj:165 When to use: Shared infrastructure code (Core, Themes) Code that defines types needed at runtime via reflection WPF resources that use pack:// URIs Pattern 2: File Linking (Compile-time inclusion) Used when source files should be compiled directly into another assembly. <!-- From DBTools.App.csproj:64-67 --> <Compile Include=\"..\\Tools\\**\\*.cs\" Exclude=\"..\\Tools\\**\\Tests\\**\\*.cs;..\\Tools\\**\\obj\\**\\*.cs\" Link=\"Tools\\%(RecursiveDir)%(Filename)%(Extension)\" /> Source: csharp/src/DBTools.App/DBTools.App.csproj:64-67 When to use: Tool source code compiled into DBTools.dll Shared test utilities across test projects Polyfill files for net48 compatibility File Linking Patterns in Detail Tool Source Files into DBTools.App All tool code from src/Tools/ is file-linked into DBTools.App: <!-- C# source files --> <Compile Include=\"..\\Tools\\**\\*.cs\" Exclude=\"..\\Tools\\**\\Tests\\**\\*.cs;..\\Tools\\**\\obj\\**\\*.cs\" Link=\"Tools\\%(RecursiveDir)%(Filename)%(Extension)\" /> <!-- XAML files --> <Page Include=\"..\\Tools\\**\\*.xaml\" Exclude=\"..\\Tools\\**\\obj\\**\\*.xaml;..\\Tools\\**\\Properties\\DesignTimeResources.xaml\" Link=\"Tools\\%(RecursiveDir)%(Filename)%(Extension)\" /> <!-- Icon assets --> <EmbeddedResource Include=\"..\\Tools\\**\\Assets\\*.png\" Link=\"Resources\\Icons\\%(RecursiveDir)%(Filename)%(Extension)\" /> Source: csharp/src/DBTools.App/DBTools.App.csproj:63-78 Why file linking for tools? Single deployable assembly (DBTools.dll) Eliminates plugin DLL proliferation Tool projects exist primarily for XAML designer support Shared Test Utilities Test projects link shared test infrastructure: <!-- From DBTools.GM.Tests.csproj:62-79 --> <Compile Include=\"..\\..\\..\\..\\..\\testing\\TestSupport\\ApsEnv.cs\" Link=\"TestSupport\\ApsEnv.cs\" /> <Compile Include=\"..\\..\\..\\..\\..\\testing\\TestSupport\\CommonTestDoubles.cs\" Link=\"TestSupport\\CommonTestDoubles.cs\" /> <Compile Include=\"..\\..\\..\\..\\..\\testing\\TestSupport\\TestHost\\RevitHost.cs\" Link=\"TestSupport\\TestHost\\RevitHost.cs\" /> <!-- ... more linked files ... --> Source: csharp/src/Tools/Common/GM/Tests/DBTools.GM.Tests.csproj:62-79 BCL Polyfills for net48 Polyfill files enable C# 10+ features on .NET Framework: <!-- From Directory.Build.props:215-219 --> <Compile Include=\"$(MSBuildThisFileDirectory)build/BuildSupport/Polyfills/IsExternalInit.cs\" Condition=\"'$(TargetFramework)'=='net48'\" /> <Compile Include=\"$(MSBuildThisFileDirectory)build/BuildSupport/Polyfills/StringExtensions.cs\" Condition=\"'$(TargetFramework)'=='net48'\" /> Source: csharp/Directory.Build.props:215-219 Centralized Package Management Directory.Packages.props All NuGet package versions are centralized: <Project> <PropertyGroup> <ManagePackageVersionsCentrally>true</ManagePackageVersionsCentrally> <CentralPackageTransitivePinningEnabled>true</CentralPackageTransitivePinningEnabled> </PropertyGroup> <ItemGroup> <!-- Package versions defined once --> <PackageVersion Include=\"CommunityToolkit.Mvvm\" Version=\"8.2.2\" /> <PackageVersion Include=\"Microsoft.Extensions.DependencyInjection\" Version=\"8.0.1\" /> <!-- ... --> </ItemGroup> </Project> Source: csharp/Directory.Packages.props:1-5 Consuming Packages Projects reference packages without specifying versions: <!-- From DBTools.Core.csproj:107-127 --> <PackageReference Include=\"CSharpFunctionalExtensions\" /> <PackageReference Include=\"Ardalis.GuardClauses\" /> <PackageReference Include=\"AutoMapper\" /> <PackageReference Include=\"Serilog\" /> Source: csharp/src/DBTools.Core/DBTools.Core.csproj:107-127 Version Pinning Strategy Package Category Version Strategy Rationale M.E.* (DI, Config, Logging) 8.x Match Revit 2026 .NET 8 runtime Serilog 4.x/6.x/8.x Compatible with both TFMs BCL packages (System.Memory) Pinned Align with vendored Fluent.Ribbon Source: csharp/Directory.Packages.props:73-95 Multi-Targeting Configuration Target Framework Definitions All Revit-facing projects target both frameworks: <!-- From Revit.props:2-6 --> <PropertyGroup Label=\"Revit TFMs\"> <DBT_RevitLegacyTFM>net48</DBT_RevitLegacyTFM> <DBT_RevitModernTFM>net8.0-windows</DBT_RevitModernTFM> <DBT_RevitTargetFrameworks>$(DBT_RevitLegacyTFM);$(DBT_RevitModernTFM)</DBT_RevitTargetFrameworks> </PropertyGroup> Source: csharp/build/Revit.props:2-6 Consuming in Projects <!-- Standard pattern in all Revit projects --> <TargetFrameworks>$(DBT_RevitTargetFrameworks)</TargetFrameworks> Source: csharp/src/DBTools.Core/DBTools.Core.csproj:3 Revit API Reference Patterns References are conditional on TFM and build type: <!-- net48 references Revit 2024 --> <ItemGroup Condition=\"'$(TargetFramework)'=='net48'\"> <Reference Include=\"RevitAPI\"> <HintPath>$(REVIT2024_DIR)\\RevitAPI.dll</HintPath> <Private>false</Private> </Reference> </ItemGroup> <!-- net8 references Revit 2025/2026 --> <ItemGroup Condition=\"'$(TargetFramework)'=='net8.0-windows'\"> <Reference Include=\"RevitAPI\" Condition=\"'$(REVIT_NET8_DIR)'!=''\"> <HintPath>$(REVIT_NET8_DIR)\\RevitAPI.dll</HintPath> <Private>false</Private> </Reference> </ItemGroup> Source: csharp/src/DBTools.App/DBTools.App.csproj:110-165 Vendored Dependencies Why Vendored? Some UI libraries are vendored (renamed) to avoid conflicts with other Revit add-ins: <!-- From DBTools.Core.csproj:144-152 --> <Reference Include=\"DBTools.Fluent.Ribbon\"> <HintPath>$(DBT_VendorArtifactsRoot)fluentribbon\\$(TargetFramework)\\DBTools.Fluent.Ribbon.dll</HintPath> <Private>true</Private> </Reference> <Reference Include=\"DBTools.ControlzEx\"> <HintPath>$(DBT_VendorArtifactsRoot)controlzex\\$(TargetFramework)\\DBTools.ControlzEx.dll</HintPath> <Private>true</Private> </Reference> Source: csharp/src/DBTools.Core/DBTools.Core.csproj:144-152 Vendored Libraries Original Vendored As Reason Fluent.Ribbon DBTools.Fluent.Ribbon Avoid pyRevit conflicts ControlzEx DBTools.ControlzEx Avoid pyRevit conflicts HandyControl DBTools.HandyControl Avoid host conflicts Source: csharp/src/DBTools.Themes/DBTools.Themes.csproj:53-70 Assembly Embedding (DBTools.App) Embedded Assembly Strategy DBTools.App embeds most dependencies into the main DLL: <!-- From DBTools.App.csproj:234-270 --> <Target Name=\"DBT_EmbedCopyLocalAssemblies\" AfterTargets=\"ResolveReferences\" Condition=\"'$(DesignTimeBuild)'!='true'\"> <ItemGroup> <_EmbedCandidate Include=\"@(ReferenceCopyLocalPaths)\" Condition=\"...\" /> <!-- Exclude host-provided assemblies --> <_EmbedCandidate Remove=\"@(_EmbedCandidate)\" Condition=\"'%(Filename)%(Extension)' == 'RevitAPI.dll'\" /> </ItemGroup> <ItemGroup> <EmbeddedResource Include=\"%(_EmbedLogicalDistinct.SourcePath)\" LogicalName=\"%(_EmbedLogicalDistinct.Identity)\" /> </ItemGroup> </Target> Source: csharp/src/DBTools.App/DBTools.App.csproj:234-270 What Gets Embedded Embedded Not Embedded Reason DBTools.Core RevitAPI/RevitAPIUI Revit provides at runtime Serilog.* Newtonsoft.Json Revit provides M.E.DependencyInjection DBTools.Fluent.Ribbon WPF needs file-based Location AutoMapper DBTools.ControlzEx WPF needs file-based Location Test Project References Reference Strategy Test projects reference both App and Core: <!-- From DBTools.GM.Tests.csproj:83-86 --> <ItemGroup> <ProjectReference Include=\"..\\..\\..\\..\\DBTools.App\\DBTools.App.csproj\" /> <ProjectReference Include=\"..\\..\\..\\..\\DBTools.Core\\DBTools.Core.csproj\" /> </ItemGroup> Source: csharp/src/Tools/Common/GM/Tests/DBTools.GM.Tests.csproj:83-86 Why reference both? Tool code is file-linked into App (need App for tool types) Core exposes internal types via InternalsVisibleTo Tests need access to both layers InternalsVisibleTo Declarations <!-- From DBTools.Core.csproj:27-32 --> <ItemGroup> <InternalsVisibleTo Include=\"DBTools.App\" /> <InternalsVisibleTo Include=\"DBTools.GM.Tests\" /> <InternalsVisibleTo Include=\"DBTools.SGT.Tests\" /> <InternalsVisibleTo Include=\"DBTools.TDV.Tests\" /> </ItemGroup> Source: csharp/src/DBTools.Core/DBTools.Core.csproj:27-32 Common Pitfalls and Solutions Pitfall 1: Circular Reference Between Themes and Core Problem: DBTools.Core needs theme resources; themes might need Core types. Solution: Theme dictionaries that need Core types are kept as raw Resource XAML (not compiled BAML): <!-- From DBTools.Themes.csproj:38-46 --> <ItemGroup> <Page Remove=\"Themes\\App.Converters.xaml\" /> <Resource Include=\"Themes\\App.Converters.xaml\" /> </ItemGroup> Source: csharp/src/DBTools.Themes/DBTools.Themes.csproj:38-46 Pitfall 2: Forbidden Host Assemblies in Output Problem: Transitive dependencies may copy Revit-provided DLLs to output. Solution: Build targets explicitly remove forbidden assemblies: <!-- From DBTools.App.csproj:169-177 --> <ItemGroup> <ForbiddenHostAssembly Include=\"RevitAPI.dll\" /> <ForbiddenHostAssembly Include=\"Newtonsoft.Json.dll\" /> <!-- ... --> </ItemGroup> <Target Name=\"DBT_RemoveForbiddenAfterCopy\" AfterTargets=\"CopyFilesToOutputDirectory\"> <Delete Files=\"@(_DBT_ForbiddenToClear)\" /> </Target> Source: csharp/src/DBTools.App/DBTools.App.csproj:169-196 Pitfall 3: XAML Designer Cannot Load x64 Assemblies Problem: XDesProc.exe is 32-bit; DBTools.App is x64 for Revit. Solution: Override PlatformTarget during design-time builds: <!-- From Directory.Build.targets:27-30 --> <PropertyGroup Condition=\"'$(DBT_IsDesignerBuild)'=='true' and '$(TargetFramework)'=='net48'\"> <PlatformTarget>AnyCPU</PlatformTarget> <Prefer32Bit>false</Prefer32Bit> </PropertyGroup> Source: csharp/Directory.Build.targets:27-30 Pitfall 4: Test Projects Missing Revit API Types Problem: Revit API references aren't transitive. Solution: Test projects explicitly reference Revit APIs: <!-- From DBTools.GM.Tests.csproj:95-109 --> <ItemGroup Condition=\"'$(TargetFramework)'=='net48'\"> <Reference Include=\"RevitAPI\"> <HintPath>$(REVIT2024_DIR)\\RevitAPI.dll</HintPath> <Private>false</Private> </Reference> </ItemGroup> Source: csharp/src/Tools/Common/GM/Tests/DBTools.GM.Tests.csproj:95-109 Pitfall 5: DBTools.Themes Polyfill Conflicts Problem: Themes is referenced by other net48 projects; polyfill types could conflict. Solution: Themes explicitly removes polyfill files: <!-- From DBTools.Themes.csproj:24-29 --> <ItemGroup Condition=\"'$(TargetFramework)'=='net48'\"> <Compile Remove=\"$(MSBuildThisFileDirectory)../../build/BuildSupport/Polyfills/IsExternalInit.cs\" /> <Compile Remove=\"$(MSBuildThisFileDirectory)../../build/BuildSupport/Polyfills/StringExtensions.cs\" /> </ItemGroup> Source: csharp/src/DBTools.Themes/DBTools.Themes.csproj:24-29 Build Configuration Inheritance Directory.Build.props Flow csharp/Directory.Build.props | +-- Imports Version.props (version numbers) +-- Imports build/Revit.props (TFM definitions) +-- Sets artifact paths (.artifacts/) +-- Configures analyzers, warnings +-- Defines shared package references Source: csharp/Directory.Build.props:1-6 Directory.Build.targets Flow csharp/Directory.Build.targets | +-- Enforces NUKE entrypoint (DBT_Entry) +-- Handles WPF temp project intermediates +-- Copies vendored DLLs for XAML designer +-- Cleans up wpftmp artifacts Source: csharp/Directory.Build.targets:1-312 Quick Reference: Adding a New Project Tool Project Checklist Create project in src/Tools/{Category}/{ToolName}/ Use standard template: <TargetFrameworks>$(DBT_RevitTargetFrameworks)</TargetFrameworks> <ProjectReference Include=\"..\\..\\..\\DBTools.Core\\DBTools.Core.csproj\" /> Add conditional Revit API references (copy from existing tool) Tool sources are automatically file-linked into DBTools.App via wildcard Test Project Checklist Create in src/Tools/{Category}/{ToolName}/Tests/ Reference both App and Core: <ProjectReference Include=\"..\\..\\..\\..\\DBTools.App\\DBTools.App.csproj\" /> <ProjectReference Include=\"..\\..\\..\\..\\DBTools.Core\\DBTools.Core.csproj\" /> Link shared test utilities from testing/TestSupport/ Add explicit Revit API references (not transitive) Related Documentation Build Pipeline - How projects are built ILRepack & Embedding - Assembly merging details Architecture Overview - High-level system architecture Verification Status Check Status Source anchors for all claims Yes UNVERIFIED markers where needed No (all verified) Cross-references added Yes Examples tested N/A No assumptions without evidence Yes Verified by: docs-run-20260124-020412 Date: 2026-01-24"
  },
  "articles/architecture/sandbox-validator.html": {
    "href": "articles/architecture/sandbox-validator.html",
    "title": "Sandbox Validator Architecture | DBTools Developer Documentation",
    "summary": "Sandbox Validator Architecture Overview The Sandbox Validator is a critical build-time validation system that verifies the integrity of DBTools dist outputs before deployment. It runs as part of the BuildAll target and catches XAML errors, manifest misconfigurations, binding failures, and assembly merge issues that would otherwise only manifest at runtime inside Revit. The validator operates in two modes: Headless mode (--headless): Used by the build pipeline for automated validation Interactive mode: A UI gallery for manual testing and development Source: csharp/src/DBTools.Sandbox/App.xaml.cs:21-77 Architecture Diagram NUKE BuildAll | v +-------------------+ | ValidateDist | | (BuildTargets) | +-------------------+ | | --headless --dist-dir <path> v +-------------------+ | DBTools.Sandbox | | (net48/net8) | +-------------------+ | +-----------------------------+-----------------------------+ | | | v v v +---------------+ +------------------+ +------------------+ | DistValidator | | ManifestValidator| | ToolWindowValidator| +---------------+ +------------------+ +------------------+ | | | | - Theme validation | - Manifest parsing | - Window instantiation | - Core window tests | - ModuleType checks | - Design-time VM binding | - Merge validation | - RibbonTool validation | - Tab interaction tests | - Binding error capture | - Assembly resolution | - Row expansion tests v v v +---------------+ +------------------+ +------------------+ | WindowGhost | | Assembly | | DbtSandboxCatalog| | Validator | | MetadataInspector| | (Discovery) | +---------------+ +------------------+ +------------------+ Source: csharp/build/BuildTargets.cs:1151-1259 Key Components DistValidator The main orchestrator that coordinates all validation steps. It: Resolves and validates the dist directory structure Ensures the validator runtime matches the dist target (net48 for Revit 2024, net8 for 2025+) Installs assembly resolvers for dist and Revit dependencies Activates sandbox mode to enable design-time ViewModels Runs theme, core window, manifest, and tool validations Source: csharp/src/DBTools.Sandbox/Validation/DistValidator.cs:15-327 Required Dist Layout The validator expects these files in the dist directory: File Purpose DBTools.Loader.dll Add-in entry point loader DBTools.dll Main merged assembly DBTools.Themes.dll Theme resource dictionaries DBTools.HandyControl.dll UI control library DBTools.ControlzEx.dll Window chrome library DBTools.Fluent.Ribbon.dll Ribbon UI library Source: csharp/src/DBTools.Sandbox/Validation/DistValidator.cs:149-167 ManifestValidator Validates that all tool manifests are correctly formed and that their referenced types exist: Loads manifest entries via DbtToolManifestLoader Verifies moduleType derives from DbtToolModule Validates commandType implements IExternalCommand Validates availabilityType implements IExternalCommandAvailability Uses metadata inspection (not runtime loading) to avoid Revit API dependencies Source: csharp/src/DBTools.Sandbox/Validation/ManifestValidator.cs:10-178 ToolWindowValidator Validates tool UI by instantiating windows with design-time ViewModels: Discovers sandbox windows via DbtSandboxCatalog Instantiates each window type and its design-time ViewModel Validates window layout via WindowGhostValidator Tests interactive behaviors: Tab cycling: Switches through all tabs in TabControl and Fluent.RibbonTabControl Row expansion: Toggles DataGrid row details visibility Preview modes: Cycles through preview modes for tools like SGT Source: csharp/src/DBTools.Sandbox/Validation/ToolWindowValidator.cs:13-412 WindowGhostValidator Performs \"ghost\" window validation by forcing layout passes without showing the window: Fixed size pass: Measures/arranges at 800x600 (typical window size) Infinite size pass: Catches controls that crash calculating \"desired\" size Content validation: Separately validates the window's content element Error localization: Walks visual tree to identify the failing element Source: csharp/src/DBTools.Sandbox/Validation/WindowGhostValidator.cs:9-129 BindingErrorListener Captures WPF data binding errors that normally fail silently: // Listens to WPF's binding trace source PresentationTraceSources.DataBindingSource.Listeners.Add(listener); PresentationTraceSources.DataBindingSource.Switch.Level = SourceLevels.Error; These silent failures are a major source of \"ghost UI\" issues - buttons that don't work, missing text, broken controls. The listener converts them into hard build failures. Source: csharp/src/DBTools.Sandbox/Validation/BindingErrorListener.cs:13-118 MergeValidator Validates the assembly merge/embedding strategy differs by target framework: net48 (ILRepack merge): Verifies sentinel types from merged assemblies exist in DBTools.dll Checks that assemblies like DynamicData.dll don't exist separately Validates internalization exclusions preserved required public types net8 (Embedded payloads): Verifies DBTools.EmbeddedAssemblies.DBTools.Core.dll resource exists Checks resource streams are loadable and have reasonable size Source: csharp/src/DBTools.Sandbox/Validation/MergeValidator.cs:17-222 Sandbox Window Configuration Tools opt into sandbox validation by adding sandboxWindows entries to their manifest.yml: # Example: csharp/src/Tools/Common/GM/manifest.yml id: DBTools.GM assembly: DBTools moduleType: DBTools.GM.GmToolModule order: 0 sandboxWindows: - id: DBTools.GM.Main displayName: \"Global Mapper\" group: \"Common\" windowType: \"DBTools.GM.Shell.UI.Views.GmWindow\" designTimeViewModelType: \"DBTools.GM.Shell.DesignTime.GmShellDesignTimeViewModel\" - id: DBTools.GM.MappingReport displayName: \"Global Mapper - Mapping Report\" group: \"Common\" windowType: \"DBTools.GM.Features.Mapping.UI.Views.GmMappingReportWindow\" designTimeViewModelType: \"DBTools.GM.Features.Mapping.DesignTime.GmMappingReportDesignTimeViewModel\" Source: csharp/src/Tools/Common/GM/manifest.yml:1-27 Required Fields Field Description id Unique identifier for the sandbox entry displayName Human-readable name shown in the sandbox gallery group Category for grouping related windows windowType Fully-qualified type name of the WPF Window designTimeViewModelType ViewModel providing mock data for validation assembly (Optional) Assembly containing the types; defaults to manifest's assembly Source: csharp/src/DBTools.Core/Tools/DbtSandboxCatalog.cs:24-46 Discovery Mechanism The DbtSandboxCatalog discovers sandbox windows by: Loading manifests embedded as resources in DBTools.dll Parsing sandboxWindows entries from each manifest Validating required fields and uniqueness of IDs Building DbtSandboxWindowSpec objects for runtime use public static IReadOnlyList<DbtSandboxWindowSpec> Discover(Assembly rootAssembly) { var entries = DbtToolManifestLoader.LoadEntries(rootAssembly); var specs = new List<DbtSandboxWindowSpec>(); foreach (var entry in entries) { foreach (var window in entry.Manifest.SandboxWindows ?? new List<>()) { // Validate and create spec... specs.Add(new DbtSandboxWindowSpec(...)); } } return specs; } Source: csharp/src/DBTools.Core/Tools/DbtSandboxCatalog.cs:8-59 SandboxMode Activation SandboxMode is a global flag that tells tool windows they're running outside Revit: namespace DBTools.Core.Compat; public static class SandboxMode { private static bool _isActive; public static bool IsActive => _isActive; public static void Activate() => _isActive = true; } Windows check this flag to: Skip Revit API calls Use design-time ViewModels Disable features requiring document context Skip UIErrorProtection.Attach in Loaded handlers Source: csharp/src/DBTools.Core/Compat/SandboxMode.cs:1-24 The SandboxModeActivator ensures the flag is set in all loaded assembly copies (handles ILMerge scenarios where multiple SandboxMode types exist): Source: csharp/src/DBTools.Sandbox/Validation/SandboxModeActivator.cs:9-119 Build Pipeline Integration The ValidateDist target in NUKE runs the validator: Target ValidateDist => _ => _ .Description(\"Validate dist outputs via DBTools.Sandbox headless runner\") .DependsOn(BuildSandbox) .After(PromoteToDist) .OnlyWhenDynamic(() => Configuration == \"Release\") .OnlyWhenDynamic(() => !SkipValidation) .Executes(() => { foreach (var year in RevitYears) { var tfm = year == 2024 ? \"net48\" : \"net8.0-windows\"; var validatorExe = ArtifactsDir / \"sandbox\" / Configuration / tfm / \"DBTools.Sandbox.exe\"; var args = new List<string> { \"--headless\", \"--dist-dir\", distDir, ValidateManifests ? \"--validate-manifests\" : \"--skip-validate-manifests\", ValidateTools ? \"--validate-tools\" : \"--skip-validate-tools\" }; // Execute with 3-minute timeout... } }); Source: csharp/build/BuildTargets.cs:1151-1259 Command-Line Options Flag Description --headless Run in validation mode (no UI) --dist-dir <path> Path to dist year folder (e.g., .artifacts/dist/Release/2026) --validate-manifests / --skip-validate-manifests Toggle manifest validation --validate-tools / --skip-validate-tools Toggle tool UI validation --screenshot --tool-id <id> --output <path> Capture tool window screenshot --list List available tool IDs for screenshot mode Source: csharp/src/DBTools.Sandbox/Validation/SandboxValidateOptions.cs:7-113 Validation Checks Summary Always Run (No Skip Flags) Check Description Dist layout Required files exist Runtime match net48 validator for 2024, net8 for 2025+ Theme validation DbtThemeValidator.ValidateOrThrow() Core windows AlertWindow, SettingsWindow, LoggerWindow Binding errors Silent WPF binding failures Merge/embed ILRepack (net48) or embedded payload (net8) With --validate-manifests Check Description Manifest parsing YAML structure, required keys ModuleType Derives from DbtToolModule RibbonTool commandType Implements IExternalCommand RibbonTool availabilityType Implements IExternalCommandAvailability With --validate-tools Check Description Window instantiation Parameterless constructor works ViewModel binding DataContext assignment succeeds Layout passes Fixed and infinite size measure/arrange Tab cycling All tabs can be selected Row expansion DataGrid row details toggle Preview modes Mode switching (e.g., SGT elevation/section/3D) Troubleshooting Validation Failures \"Window layout validation failed\" The window crashed during Measure, Arrange, or UpdateLayout. Common causes: Missing StaticResource: A resource key referenced in XAML doesn't exist in the merged resource dictionaries Constructor throws: The window constructor requires Revit context Binding converter crash: A value converter throws when given design-time data Solution: Check the exception message for the failing element name. Look for XAML bindings or resources that assume runtime context. \"WPF binding errors detected\" Silent binding failures were captured. The error message lists each failure: System.Windows.Data Error: 40 : BindingExpression path error: 'PropertyName' property not found on 'object' 'DesignTimeViewModel' Solution: Ensure design-time ViewModels expose all properties the XAML binds to. \"ILRepack merge validation failed\" Types that should have been merged exist as separate DLLs, or expected types are missing. Solution: Check csharp/build/ilrepack.txt for the merge whitelist configuration. \"Sandbox window ' ' failed to instantiate\" The window or ViewModel couldn't be created. Check: Does the window have a parameterless constructor? Does the ViewModel have a parameterless constructor? Is SandboxMode.IsActive checked before Revit API calls? Orphaned Validator Processes The build system kills orphaned DBTools.Sandbox.exe processes before validation to prevent stale state: Source: csharp/build/BuildTargets.cs:1292-1314 If validation hangs, check Task Manager for zombie sandbox processes. Related Documentation Test Pipeline - How tests use sandbox infrastructure Build Pipeline - Overall build and validation flow ILRepack & Embedding - Assembly merge strategy validated here Documentation Status: Complete Last Updated: January 2026"
  },
  "articles/architecture/test-pipeline.html": {
    "href": "articles/architecture/test-pipeline.html",
    "title": "Test Pipeline | DBTools Developer Documentation",
    "summary": "Test Pipeline This document describes the DBTools testing infrastructure, including test categories, execution methods, and shared test utilities. Overview DBTools uses a dual-tier testing strategy: Headless Tests - Run via dotnet test without Revit, validating build artifacts and cloud integrations Revit Integration Tests - Run inside a live Revit process using the ricaun.RevitTest adapter Source: csharp/invoke-revit-tests.sh:1-6 Test Categories Category System Tests are categorized using NUnit's [Category] attribute to enable selective execution: Category Description DA-Compatible RequiresRevitUI Needs UIApplication, UIDocument, TaskDialog, or STA thread No RequiresActiveDocument Needs an open Revit document with elements No Local Runs only in local Revit environment No Slow Takes >5 seconds, may be excluded from quick runs Yes Integration Requires external dependencies (network, cloud) Yes Source: csharp/testing/TestSupport/TestCategories.cs:14-42 DA vs Local Execution DA (Design Automation): Filter out UI-dependent tests: dotnet test --filter \"Category!=RequiresRevitUI&Category!=RequiresActiveDocument\" Local: Run all tests inside Revit Source: csharp/testing/TestSupport/TestCategories.cs:10-12 Test Project Organization Directory Structure csharp/testing/ DBTools.BuildArtifacts.Tests/ # Headless artifact validation DBTools.DA.Tests/ # Design Automation tests (cloud/headless) TestSupport/ # Shared test infrastructure GM/ # GM-specific test doubles SGT/ # SGT-specific test doubles TestHost/ # Revit host integration RevitTestModels/ # Test .rvt files by year 2024/GM/, 2024/SGT/ 2025/GM/, 2025/SGT/ 2026/GM/, 2026/SGT/ csharp/src/Tools/ Common/GM/Tests/ # GM integration tests Structural/SGT/Tests/ # SGT integration tests Testing/VTC/Tests/ # VTC tests Common/TDV/Tests/ # TDV tests Headless Test Projects DBTools.BuildArtifacts.Tests Validates build output without Revit: Assembly existence and validity per Revit year Target framework correctness (net48 for 2024, net8.0 for 2025+) Forbidden reference detection (RevitAPI, AdWindows) Namespace presence verification Embedded XAML resource validation Source: csharp/testing/DBTools.BuildArtifacts.Tests/AssemblyManifestTests.cs:14-20 Run command: dotnet test csharp/testing/DBTools.BuildArtifacts.Tests/DBTools.BuildArtifacts.Tests.csproj -c Release DBTools.DA.Tests Design Automation and APS integration tests: Links APS test files from tool directories (e.g., GM/Tests/APS/) Uses shared test utilities via <Compile Include> links Runs against Autodesk cloud services Source: csharp/testing/DBTools.DA.Tests/DBTools.DA.Tests.csproj:43-48 Run command: dotnet test csharp/testing/DBTools.DA.Tests/DBTools.DA.Tests.csproj -c Release Configuration: Uses da.runsettings for APS bucket configuration: <TestRunParameters> <Parameter name=\"APS_BUCKET\" value=\"dbtools-tests\" /> <Parameter name=\"APS_REGION\" value=\"US\" /> </TestRunParameters> Source: csharp/testing/da.runsettings:1-8 Tool-Specific Test Projects Each tool has its own test project under csharp/src/Tools/*/Tests/: Project Target Frameworks Revit Years DBTools.GM.Tests net48, net8.0-windows 2024, 2025, 2026 DBTools.SGT.Tests net48, net8.0-windows 2024, 2025, 2026 DBTools.TDV.Tests net48, net8.0-windows 2024, 2025, 2026 DBTools.VTC.Tests net48, net8.0-windows 2024, 2025, 2026 Source: csharp/src/Tools/Common/GM/Tests/DBTools.GM.Tests.csproj:4, csharp/src/Tools/Structural/SGT/Tests/DBTools.SGT.Tests.csproj:4 Key dependencies: ricaun.RevitTest.TestAdapter - Revit test execution ricaun.Revit.UI.Tasks - UI task scheduling NUnit 3 with test adapter Source: csharp/src/Tools/Common/GM/Tests/DBTools.GM.Tests.csproj:35-44 Test Runner: invoke-revit-tests.sh The primary test runner script for Revit integration tests. Prerequisites Required: gum (interactive terminal UI tool) # Install via Homebrew (macOS/Linux) brew install gum # Or Debian/Ubuntu sudo apt install gum # Or Go go install github.com/charmbracelet/gum@latest Source: csharp/invoke-revit-tests.sh:8-17 Basic Usage # Run all GM tests with smart mode (recommended) bash csharp/invoke-revit-tests.sh --smart --tool GM # Run SGT tests for Revit 2025 bash csharp/invoke-revit-tests.sh --smart --tool SGT -y 2025 # Run specific test by filter bash csharp/invoke-revit-tests.sh -f \"FullyQualifiedName~SomeTestName\" # Run specific fixture bash csharp/invoke-revit-tests.sh --smart --fixture GmAdapterTests Source: csharp/invoke-revit-tests.sh:202-204 Command-Line Options Test Execution Flag Description Default -y, --year YEAR Revit year: 2024, 2025, or 2026 2026 --debug, -d Use Debug configuration Auto-detect --release, -r Use Release configuration Auto-detect -f, --filter \"...\" VSTest filter (must include FullyQualifiedName) None -v, --verbosity N 0=quiet, 1=normal, 2=verbose 1 --timeout-minutes N Revit test timeout 4 --show-log Display DBTools log file path after completion Off Source: csharp/invoke-revit-tests.sh:130-140 Revit Instance Modes Flag Behavior --reuse Use existing Revit; fail if none running --persist Open new Revit and leave running after tests --close Open new Revit and close after tests (default) Source: csharp/invoke-revit-tests.sh:142-146 Smart Mode (Recommended) bash csharp/invoke-revit-tests.sh --smart --tool GM Smart mode auto-detects: If build changed since last test: opens fresh Revit (--persist) If build unchanged and session has Revit: reuses existing (--reuse) Source: csharp/invoke-revit-tests.sh:148-150 Tool/Fixture Shortcuts Flag Description --tool TOOL Run tests for GM, SGT, TDV, or VTC --fixture FIXTURE Run tests for specific fixture class Source: csharp/invoke-revit-tests.sh:149-150 Running Single Tests Recommended (via test runner): # Exact match bash csharp/invoke-revit-tests.sh --smart -y 2026 -f \"FullyQualifiedName=DBTools.GM.Tests.GmAdapterTests.SomeTest\" # Partial match (contains) bash csharp/invoke-revit-tests.sh --smart -f \"FullyQualifiedName~SomeTestName\" Headless projects only: dotnet test csharp/testing/DBTools.BuildArtifacts.Tests/DBTools.BuildArtifacts.Tests.csproj \\ -c Release --filter \"FullyQualifiedName~Metadata\" Source: csharp/invoke-revit-tests.sh:204, AGENTS.md Test Discovery The runner includes built-in test discovery: # List all available tests bash csharp/invoke-revit-tests.sh --discover # Rebuild test registry from source bash csharp/invoke-revit-tests.sh --discover --generate # Show test count summary bash csharp/invoke-revit-tests.sh --discover --summary # Filter by tool bash csharp/invoke-revit-tests.sh --discover --tool GM # Show only DA-compatible tests bash csharp/invoke-revit-tests.sh --discover --da-only # Show only local-only tests bash csharp/invoke-revit-tests.sh --discover --local-only Source: csharp/invoke-revit-tests.sh:171-180 Registry is stored at: .artifacts/metadata/test-registry.json Source: csharp/invoke-revit-tests.sh:647 Test History The runner tracks test execution history: # Show test run history bash csharp/invoke-revit-tests.sh --history # Show tests not run in last N days bash csharp/invoke-revit-tests.sh --show-stale 7 # Show tests that failed on last run bash csharp/invoke-revit-tests.sh --show-failed # Show error details for failed tests bash csharp/invoke-revit-tests.sh --get-errors \"GM\" Source: csharp/invoke-revit-tests.sh:183-189 History is stored at: .artifacts/test-history.json Source: csharp/invoke-revit-tests.sh:60 Parallel AI Agent Support For parallel test execution by multiple AI agents: # Agent 1 bash csharp/invoke-revit-tests.sh --smart --session agent-001 --tool GM # Agent 2 bash csharp/invoke-revit-tests.sh --smart --session agent-002 --tool SGT Each --session ID gets its own Revit instance for isolation. Source: csharp/invoke-revit-tests.sh:153-168 Session Management # List active sessions bash csharp/invoke-revit-tests.sh --sessions # Clean up stale sessions (dead Revit PIDs) bash csharp/invoke-revit-tests.sh --kill-orphans Source: csharp/invoke-revit-tests.sh:193-196 TestSupport Infrastructure Shared test utilities in csharp/testing/TestSupport/: Common Test Doubles Located in CommonTestDoubles.cs: Class Purpose RecordingNotifier Records error/success banner invocations RecordingOverlay Records progress overlay method calls InlineExecutor Runs actions inline (no async dispatch) InlineTransactionRunner Executes without Revit transactions InlineTransactionGroupService Executes without transaction groups Source: csharp/testing/TestSupport/CommonTestDoubles.cs:15-339 Test Host Integration RevitHost (TestHost/RevitHost.cs): Manages Revit context for async test execution Handles inline vs queued execution modes Integrates with RevitTestTaskBinder Source: csharp/testing/TestSupport/TestHost/RevitHost.cs:12-109 RevitAmbientScope (TestHost/RevitAmbientScope.cs): Provides ambient UIApplication access during tests Test Path Resolution TestPathResolver (TestPathResolver.cs): Resolves test model paths from dbtools.testparams.json Located at %APPDATA%/DBTools/dbtools.testparams.json Written by invoke-revit-tests.sh before test execution // Get model path var path = TestPathResolver.ResolveTestModelPath(\"2026\", \"GM\", \"gm_test_model.rvt\"); Source: csharp/testing/TestSupport/TestPathResolver.cs:10-65 Test Logging TestLoggingBridge (TestLoggingBridge.cs): Centralizes test logging setup Bridges to production logging when Revit is running Falls back to console mirroring in standalone mode [OneTimeSetUp] public void GlobalSetup() { TestLoggingBridge.Initialize(); } [OneTimeTearDown] public void GlobalTeardown() { TestLoggingBridge.Shutdown(); } Source: csharp/testing/TestSupport/TestLoggingBridge.cs:14-143 Tool-Specific Test Doubles GM (TestSupport/GM/): GmTestDataBuilder - Builds test data for GM GmRealisticTestDoubles - Production-like test doubles GmShellViewModelTestFactory - Creates shell ViewModels for testing SGT (TestSupport/SGT/): SgtTestDataBuilder - Builds test data for SGT SgtRealisticTestDoubles - Production-like test doubles InMemorySgtUiStateStore - In-memory UI state store Test Fixture Base Classes GmTestFixture Base class for GM integration tests: [NonParallelizable] public abstract class GmTestFixture { protected UIApplication UiApp { get; private set; } protected Document? Doc { get; private set; } protected IRevitCallGate? Gate { get; private set; } protected ITransactionRunner? TxRunner { get; private set; } [OneTimeSetUp] public virtual void GlobalSetup(UIApplication app) { // Opens gm_test_model.rvt // Initializes call gate and transaction runner } } Features: Opens tool-specific test model automatically Provides ResolveTypeIds(), ResolveStyleIds(), ResolveMaterialIds() helpers Manages document lifecycle Source: csharp/src/Tools/Common/GM/Tests/GMTestFixture.cs:14-128 Test Models Located in csharp/testing/RevitTestModels/: RevitTestModels/ model_info.txt 2024/ GM/gm_test_model.rvt SGT/sgt_test_model.rvt SGT/_LinkedModels/sgt_test_linked_model.rvt 2025/ GM/gm_test_model.rvt SGT/sgt_test_model.rvt SGT/_LinkedModels/sgt_test_linked_model.rvt 2026/ GM/gm_test_model.rvt SGT/sgt_test_model.rvt SGT/_LinkedModels/sgt_test_linked_model.rvt Each year has its own model versions for forward compatibility testing. Configuration Files .runsettings Revit Tests: Generated at runtime by invoke-revit-tests.sh: <RunSettings> <NUnit> <Version>2026</Version> <Language>ENU</Language> <Open>true</Open> <Close>false</Close> <Verbosity>2</Verbosity> <Timeout>4</Timeout> </NUnit> </RunSettings> Source: csharp/invoke-revit-tests.sh:1425-1442 DA Tests: csharp/testing/da.runsettings for APS configuration. Source: csharp/testing/da.runsettings:1-8 Test Parameters (dbtools.testparams.json) Written to %APPDATA%/DBTools/instances/<worktree-id>/dbtools.testparams.json: { \"ModelsDirectory\": \"C:\\\\...\\\\csharp\\\\testing\\\\RevitTestModels\", \"Year\": 2026 } Source: csharp/invoke-revit-tests.sh:1446-1451 Build Integration Tests depend on artifacts from build.sh: # Build all (required before running tests) bash csharp/build.sh BuildAll # Build tests specifically bash csharp/build.sh BuildTests The test runner validates artifact freshness: Checks .artifacts/metadata/build.json for source fingerprint Fails if artifacts are stale relative to source Source: csharp/invoke-revit-tests.sh:1201-1363 Guardrails (from AGENTS.md) Prime Directive When a test fails, investigate and fix PRODUCTION CODE first. Do not change tests or infrastructure to simulate missing production behavior. Forbidden Test Patterns Use test doubles only for TRUE externals (Revit API, filesystem, network) Never mock your own services/orchestrators Never assert only that mocks were called Every test must assert at least one real outcome Legitimate vs Illegitimate Stubbing Legitimate (external): Revit API File system Network Time/Random Illegitimate (your code): Your own services Orchestrators/handlers Anything in src/ you wrote Quick Reference Task Command Run GM tests (smart mode) bash csharp/invoke-revit-tests.sh --smart --tool GM Run SGT tests for 2025 bash csharp/invoke-revit-tests.sh --smart --tool SGT -y 2025 Run single test bash csharp/invoke-revit-tests.sh --smart -f \"FullyQualifiedName~TestName\" Run headless artifact tests dotnet test csharp/testing/DBTools.BuildArtifacts.Tests/ -c Release Run DA tests dotnet test csharp/testing/DBTools.DA.Tests/ -c Release List all tests bash csharp/invoke-revit-tests.sh --discover Show failed tests bash csharp/invoke-revit-tests.sh --show-failed Build before tests bash csharp/build.sh BuildAll Related Documentation Build Pipeline - Build system and artifact generation Architecture Overview - High-level system architecture Project References - Project structure and dependencies Verification Status Check Status Source anchors for all claims Yes UNVERIFIED markers where needed No (all verified) Cross-references added Yes Examples tested N/A No assumptions without evidence Yes Verified by: docs-run-20260124-020412 Date: 2026-01-24"
  },
  "articles/architecture/theme-system.html": {
    "href": "articles/architecture/theme-system.html",
    "title": "Theme System | DBTools Developer Documentation",
    "summary": "Theme System DBTools implements a comprehensive WPF theming system that provides a cohesive dark theme across all windows and controls. The system is designed to work within Revit's add-in environment while avoiding conflicts with other add-ins. Architecture Overview +-----------------------------------------------------------------------------------+ | DBTools Theme Stack | +-----------------------------------------------------------------------------------+ | | | +-------------------+ +--------------------+ +------------------------+ | | | DBTools.Themes | | Vendored Libraries | | DBTools.Core | | | | (Resources) | | (UI Frameworks) | | (Theme Loading) | | | +-------------------+ +--------------------+ +------------------------+ | | | | | | | v v v | | +----------------+ +---------------------+ +------------------------+ | | | App.Theme.xaml | --> | DBTools.HandyControl| --> | DbtWindowInitHelper | | | | (Root Dict) | | DBTools.Fluent.Ribbon| | DbtThemeValidator | | | +----------------+ | DBTools.ControlzEx | +------------------------+ | | | +---------------------+ | | v | | +---------------------------+ | | | Merged Dictionaries | | | | - App.Tokens.xaml | | | | - App.Brushes.xaml | | | | - App.Controls.Base.xaml | | | | - App.DataGrid.xaml | | | | - App.Menus.xaml | | | | - App.Components.xaml | | | | - App.FluentRibbon.xaml | | | +---------------------------+ | +-----------------------------------------------------------------------------------+ Source: csharp/src/DBTools.Themes/Themes/App.Theme.xaml:1-21 Project Structure The DBTools.Themes project contains all theme resources and references vendored UI libraries: DBTools.Themes/ +-- DBTools.Themes.csproj # Project configuration with vendored refs +-- BrushKeys.cs # ComponentResourceKey definitions +-- Assets/ | +-- db_tools_icon.png # Window icon +-- Themes/ +-- App.Theme.xaml # Root theme dictionary +-- App.Tokens.xaml # Spacing, sizing, typography tokens +-- App.Brushes.xaml # Color/brush definitions +-- App.Converters.xaml # Value converters +-- App.Controls.Base.xaml # Basic control styles +-- App.DataGrid.xaml # DataGrid-specific styles +-- App.Menus.xaml # Menu/ContextMenu styles +-- App.Components.xaml # Composite component styles +-- App.FluentRibbon.xaml # Fluent.Ribbon theme bridge Source: csharp/src/DBTools.Themes/DBTools.Themes.csproj:1-72 Vendored UI Libraries DBTools uses renamed/vendored copies of third-party UI libraries to avoid assembly conflicts with other Revit add-ins (especially pyRevit): Library Vendored Name Purpose HandyControl DBTools.HandyControl Base theme framework Fluent.Ribbon DBTools.Fluent.Ribbon Ribbon window/controls ControlzEx DBTools.ControlzEx Window chrome behaviors Source: csharp/src/DBTools.Themes/DBTools.Themes.csproj:54-71 Why Vendored Libraries? WPF theme assemblies cannot be ILRepack-merged or embedded as resources because they require Assembly.Location for pack:// URI resolution. The vendoring process: Clones upstream repos to vendor/ Renames assembly names and updates pack URIs Builds renamed assemblies to csharp/.artifacts/vendor/ Deploys alongside DBTools.dll Source: csharp/build-vendored-deps.sh:1-446 Theme Loading Mechanism Window-Scoped Theming DBTools applies themes at the window level (not application level) because Revit's Application.Resources are shared across all add-ins. This prevents theme pollution between add-ins. public static void EnsureWindowScopedTheme(Window window) { WpfUiThread.EnsurePackUriSupport(); if (!ResourceDictionaryHelper.HasSource(window.Resources, ThemeSource)) { window.Resources.MergedDictionaries.Add(new ResourceDictionary { Source = new Uri(ThemeSource, UriKind.Absolute) }); } DbtThemeValidator.FreezeFreezablesOrThrow(window.Resources); } Source: csharp/src/DBTools.Core/UI/Windows/DbtWindowInitHelper.cs:91-108 Theme Initialization Flow Window Constructor: DbtWindowInitHelper.Initialize() is called Pack URI Support: WpfUiThread.EnsurePackUriSupport() ensures pack:// scheme is registered Dictionary Merge: App.Theme.xaml is merged into Window.Resources Resource Freeze: All freezable resources are frozen to prevent runtime leaks Validation: Theme contract is validated (dictionary order, completeness) Source: csharp/src/DBTools.Core/UI/Windows/DbtWindowInitHelper.cs:44-78 Theme Opt-Out Windows can opt out of DBTools theming via IThemeOptOut: public interface IThemeOptOut { bool UseDefaultTheme { get; set; } } Source: csharp/src/DBTools.Core/UI/Windows/DbtWindowBase.cs:13-21 ResourceDictionary Structure Root Theme Dictionary App.Theme.xaml is the root dictionary that merges all theme components: <ResourceDictionary xmlns=\"http://schemas.microsoft.com/winfx/2006/xaml/presentation\"> <ResourceDictionary.MergedDictionaries> <!-- HandyControl Foundation --> <ResourceDictionary Source=\"pack://application:,,,/DBTools.HandyControl;component/Themes/SkinDark.xaml\"/> <ResourceDictionary Source=\"pack://application:,,,/DBTools.HandyControl;component/Themes/Theme.xaml\"/> <!-- Fluent.Ribbon for ribbon windows --> <ResourceDictionary Source=\"pack://application:,,,/DBTools.Fluent.Ribbon;component/Themes/Generic.xaml\"/> <!-- DBTools Custom Themes --> <ResourceDictionary Source=\"App.Tokens.xaml\"/> <ResourceDictionary Source=\"App.Brushes.xaml\"/> <ResourceDictionary Source=\"App.Converters.xaml\"/> <ResourceDictionary Source=\"App.Controls.Base.xaml\"/> <ResourceDictionary Source=\"App.DataGrid.xaml\"/> <ResourceDictionary Source=\"App.Menus.xaml\"/> <ResourceDictionary Source=\"App.Components.xaml\"/> <ResourceDictionary Source=\"App.FluentRibbon.xaml\"/> </ResourceDictionary.MergedDictionaries> </ResourceDictionary> Source: csharp/src/DBTools.Themes/Themes/App.Theme.xaml:1-21 Dictionary Order Contract The merged dictionary order is locked and validated at runtime: private static readonly IReadOnlyList<string> ExpectedMergedDictionarySources = new[] { \"pack://application:,,,/DBTools.HandyControl;component/Themes/SkinDark.xaml\", \"pack://application:,,,/DBTools.HandyControl;component/Themes/Theme.xaml\", \"pack://application:,,,/DBTools.Fluent.Ribbon;component/Themes/Generic.xaml\", \"pack://application:,,,/DBTools.Themes;component/Themes/App.Tokens.xaml\", \"pack://application:,,,/DBTools.Themes;component/Themes/App.Brushes.xaml\", // ... additional dictionaries }; Source: csharp/src/DBTools.Core/UI/Theming/DbtThemeValidator.cs:20-33 Design Tokens Spacing Tokens Standard spacing values for consistent layouts: <Thickness x:Key=\"Spacing4\">4</Thickness> <Thickness x:Key=\"Spacing8\">8</Thickness> <Thickness x:Key=\"Spacing12\">12</Thickness> <Thickness x:Key=\"Spacing16\">16</Thickness> <Thickness x:Key=\"Spacing32\">32</Thickness> <!-- Scalar variants for non-Thickness contexts --> <sys:Double x:Key=\"Spacing8.Value\">8</sys:Double> Source: csharp/src/DBTools.Themes/Themes/App.Tokens.xaml:5-18 Typography Tokens <sys:Double x:Key=\"FontSize.Caption\">11</sys:Double> <sys:Double x:Key=\"FontSize.Body.Small\">12</sys:Double> <sys:Double x:Key=\"FontSize.Body\">13</sys:Double> <sys:Double x:Key=\"FontSize.Subtitle\">14</sys:Double> <sys:Double x:Key=\"FontSize.Title\">16</sys:Double> <sys:Double x:Key=\"FontSize.Header\">20</sys:Double> Source: csharp/src/DBTools.Themes/Themes/App.Tokens.xaml:66-72 Corner Radius Tokens <CornerRadius x:Key=\"Radius4\">4</CornerRadius> <CornerRadius x:Key=\"Radius6\">6</CornerRadius> <CornerRadius x:Key=\"Radius8\">8</CornerRadius> <CornerRadius x:Key=\"Radius12\">12</CornerRadius> Source: csharp/src/DBTools.Themes/Themes/App.Tokens.xaml:43-46 Color System BrushKeys (ComponentResourceKeys) All brushes are defined using ComponentResourceKey to enable reliable cross-template resolution: public static class BrushKeys { public static ComponentResourceKey Primary => new(typeof(BrushKeys), \"Brush.Primary\"); public static ComponentResourceKey PrimaryLight => new(typeof(BrushKeys), \"Brush.PrimaryLight\"); public static ComponentResourceKey Paper => new(typeof(BrushKeys), \"Brush.Paper\"); public static ComponentResourceKey Surface => new(typeof(BrushKeys), \"Brush.Surface\"); public static ComponentResourceKey Body => new(typeof(BrushKeys), \"Brush.Body\"); // ... 130+ additional keys } Source: csharp/src/DBTools.Themes/BrushKeys.cs:1-139 Brand Colors DBTools uses a blue/gold brand palette: <!-- Core Brand Colors --> <SolidColorBrush x:Key=\"{x:Static theme:BrushKeys.Primary}\" Color=\"#FF1946B9\"/> <SolidColorBrush x:Key=\"{x:Static theme:BrushKeys.PrimaryLight}\" Color=\"#FF3D6AD4\"/> <SolidColorBrush x:Key=\"{x:Static theme:BrushKeys.Secondary}\" Color=\"#FFFEC425\"/> <SolidColorBrush x:Key=\"{x:Static theme:BrushKeys.SecondaryLight}\" Color=\"#FFFFD54F\"/> Source: csharp/src/DBTools.Themes/Themes/App.Brushes.xaml:14-19 Surface Colors Dark theme surfaces with subtle differentiation: <SolidColorBrush x:Key=\"{x:Static theme:BrushKeys.Paper}\" Color=\"#FF181820\"/> <SolidColorBrush x:Key=\"{x:Static theme:BrushKeys.Surface}\" Color=\"#FF222228\"/> <SolidColorBrush x:Key=\"{x:Static theme:BrushKeys.SurfaceAlt}\" Color=\"#FF1C1C22\"/> <SolidColorBrush x:Key=\"{x:Static theme:BrushKeys.CardSurface}\" Color=\"#FF1E1E24\"/> Source: csharp/src/DBTools.Themes/Themes/App.Brushes.xaml:24-30 Text Colors (WCAG Compliant) Text colors maintain minimum 4.5:1 contrast ratio for accessibility: <!-- WCAG AA compliant - min 4.5:1 contrast ratio on dark backgrounds --> <SolidColorBrush x:Key=\"{x:Static theme:BrushKeys.Body}\" Color=\"#FFE6E6E6\"/> <SolidColorBrush x:Key=\"{x:Static theme:BrushKeys.BodyLight}\" Color=\"#FFBDBDBD\"/> <SolidColorBrush x:Key=\"{x:Static theme:BrushKeys.TextMuted}\" Color=\"#FF999999\"/> Source: csharp/src/DBTools.Themes/Themes/App.Brushes.xaml:35-40 Status Colors Semantic colors for success, warning, error, and info states: <SolidColorBrush x:Key=\"{x:Static theme:BrushKeys.Success}\" Color=\"#FF4CAF50\"/> <SolidColorBrush x:Key=\"{x:Static theme:BrushKeys.Warning}\" Color=\"#FFFFA000\"/> <SolidColorBrush x:Key=\"{x:Static theme:BrushKeys.Error}\" Color=\"#FFCF6679\"/> <SolidColorBrush x:Key=\"{x:Static theme:BrushKeys.Info}\" Color=\"#FF1946B9\"/> Source: csharp/src/DBTools.Themes/Themes/App.Brushes.xaml:84-95 Window Base Classes DbtWindowBase Standard modal window with theme and progress overlay support: public class DbtWindowBase : Window, IWindowWithOwnerProvider, IThemeOptOut { public DbtWindowBase() { DbtWindowInitHelper.Initialize(this, nameof(DbtWindowBase)); } } Source: csharp/src/DBTools.Core/UI/Windows/DbtWindowBase.cs:27-32 The XAML style applies default theme properties and progress overlay: <Style TargetType=\"{x:Type core:DbtWindowBase}\" BasedOn=\"{StaticResource {x:Type Window}}\"> <Setter Property=\"Icon\" Value=\"pack://application:,,,/DBTools.Themes;component/Assets/db_tools_icon.png\"/> <Setter Property=\"Background\" Value=\"{DynamicResource {x:Static theme:BrushKeys.Paper}}\"/> <Setter Property=\"Foreground\" Value=\"{DynamicResource {x:Static theme:BrushKeys.Body}}\"/> <Setter Property=\"ContentTemplate\"> <Setter.Value> <DataTemplate> <Grid> <ContentPresenter/> <Border Panel.ZIndex=\"1000\" ...> <progress:ProgressOverlayControl .../> </Border> </Grid> </DataTemplate> </Setter.Value> </Setter> </Style> Source: csharp/src/DBTools.Themes/Themes/App.Controls.Base.xaml:13-33 DbtRibbonWindowBase Ribbon window for tool UIs with tab-based navigation: public class DbtRibbonWindowBase : RibbonWindow, IWindowWithOwnerProvider, IThemeOptOut { public DbtRibbonWindowBase() { DbtWindowInitHelper.Initialize(this, nameof(DbtRibbonWindowBase)); } } Source: csharp/src/DBTools.Core/UI/Windows/DbtRibbonWindowBase.cs:15-19 Fluent.Ribbon Theme Bridge App.FluentRibbon.xaml maps all 196+ Fluent.Ribbon internal brush keys to DBTools theme colors: <!-- Window Chrome --> <SolidColorBrush x:Key=\"Fluent.Ribbon.Brushes.RibbonWindow.Background\" Color=\"{Binding Source={StaticResource {x:Static theme:BrushKeys.Paper}}, Path=Color}\"/> <!-- Tab Control --> <SolidColorBrush x:Key=\"Fluent.Ribbon.Brushes.RibbonTabItem.Selected.Background\" Color=\"{Binding Source={StaticResource {x:Static theme:BrushKeys.SelectionGoldStrong}}, Path=Color}\"/> <!-- Buttons --> <SolidColorBrush x:Key=\"Fluent.Ribbon.Brushes.Button.MouseOver.Background\" Color=\"{Binding Source={StaticResource {x:Static theme:BrushKeys.Hover}}, Path=Color}\"/> Source: csharp/src/DBTools.Themes/Themes/App.FluentRibbon.xaml:24-211 TransitioningControl Hotfix A style override prevents animation failures during tab switching: <Style TargetType=\"{x:Type fluent:TransitioningControl}\"> <Setter Property=\"Template\"> <Setter.Value> <ControlTemplate TargetType=\"{x:Type fluent:TransitioningControl}\"> <Border ...> <Grid> <ContentPresenter x:Name=\"PART_CurrentContent\" .../> <ContentPresenter x:Name=\"PART_PreviousContent\" .../> </Grid> </Border> </ControlTemplate> </Setter.Value> </Setter> </Style> Source: csharp/src/DBTools.Themes/Themes/App.FluentRibbon.xaml:53-97 Control Styles Standard Controls Implicit styles override WPF defaults with theme colors: <Style TargetType=\"Button\" BasedOn=\"{StaticResource {x:Type Button}}\"> <Setter Property=\"MinWidth\" Value=\"88\"/> <Setter Property=\"MinHeight\" Value=\"36\"/> <Setter Property=\"Background\" Value=\"{DynamicResource {x:Static theme:BrushKeys.Surface}}\"/> <Setter Property=\"Foreground\" Value=\"{DynamicResource {x:Static theme:BrushKeys.Body}}\"/> <Setter Property=\"BorderBrush\" Value=\"{DynamicResource {x:Static theme:BrushKeys.Divider}}\"/> <Style.Triggers> <Trigger Property=\"IsMouseOver\" Value=\"True\"> <Setter Property=\"Background\" Value=\"{DynamicResource {x:Static theme:BrushKeys.SecondaryHover}}\"/> </Trigger> </Style.Triggers> </Style> Source: csharp/src/DBTools.Themes/Themes/App.Controls.Base.xaml:73-92 DataGrid Styles Custom DataGrid with accent stripe and enhanced selection: <Style TargetType=\"DataGridRow\" BasedOn=\"{StaticResource {x:Type DataGridRow}}\"> <Setter Property=\"Template\"> <Setter.Value> <ControlTemplate TargetType=\"DataGridRow\"> <Border x:Name=\"DGR_Border\" ...> <Grid> <Grid.ColumnDefinitions> <ColumnDefinition Width=\"3\"/> <!-- Accent stripe --> <ColumnDefinition Width=\"*\"/> </Grid.ColumnDefinitions> <Border x:Name=\"AccentStripe\" Grid.Column=\"0\" Background=\"Transparent\"/> <SelectiveScrollingGrid Grid.Column=\"1\"> <!-- Row content --> </SelectiveScrollingGrid> </Grid> </Border> <ControlTemplate.Triggers> <Trigger Property=\"IsSelected\" Value=\"True\"> <Setter TargetName=\"AccentStripe\" Property=\"Background\" Value=\"{DynamicResource {x:Static theme:BrushKeys.DataGridAccentStripe}}\"/> </Trigger> </ControlTemplate.Triggers> </ControlTemplate> </Setter.Value> </Setter> </Style> Source: csharp/src/DBTools.Themes/Themes/App.DataGrid.xaml:24-101 Menu Styles Full custom templates avoid Revit add-in styling conflicts: <Style x:Key=\"ContextMenu\" TargetType=\"ContextMenu\"> <Setter Property=\"Background\" Value=\"{DynamicResource {x:Static theme:BrushKeys.Surface}}\"/> <Setter Property=\"BorderBrush\" Value=\"{DynamicResource {x:Static theme:BrushKeys.Divider}}\"/> <Setter Property=\"Template\"> <Setter.Value> <ControlTemplate TargetType=\"ContextMenu\"> <Border Background=\"{TemplateBinding Background}\" CornerRadius=\"4\" SnapsToDevicePixels=\"True\"> <Border.Effect> <DropShadowEffect BlurRadius=\"8\" ShadowDepth=\"2\" Opacity=\"0.35\"/> </Border.Effect> <ScrollViewer> <ItemsPresenter/> </ScrollViewer> </Border> </ControlTemplate> </Setter.Value> </Setter> </Style> Source: csharp/src/DBTools.Themes/Themes/App.Menus.xaml:9-42 Component Styles Cards Elevated card surfaces with shadows: <Style x:Key=\"Card\" TargetType=\"Border\"> <Setter Property=\"Background\" Value=\"{DynamicResource {x:Static theme:BrushKeys.CardSurface}}\"/> <Setter Property=\"BorderBrush\" Value=\"{DynamicResource {x:Static theme:BrushKeys.CardBorder}}\"/> <Setter Property=\"CornerRadius\" Value=\"{DynamicResource Radius8}\"/> <Setter Property=\"Padding\" Value=\"{DynamicResource Card.Padding}\"/> </Style> <Style x:Key=\"Card.Elevated\" TargetType=\"Border\" BasedOn=\"{StaticResource Card}\"> <Setter Property=\"Effect\"> <Setter.Value> <DropShadowEffect BlurRadius=\"18\" ShadowDepth=\"4\" Opacity=\"0.35\"/> </Setter.Value> </Setter> </Style> Source: csharp/src/DBTools.Themes/Themes/App.Components.xaml:205-225 Toolbar Chips Toggle buttons styled as filter chips: <Style x:Key=\"ToolbarChip\" TargetType=\"ToggleButton\"> <Setter Property=\"Background\" Value=\"{DynamicResource {x:Static theme:BrushKeys.ToolbarChipBackground}}\"/> <Setter Property=\"Template\"> <Setter.Value> <ControlTemplate TargetType=\"ToggleButton\"> <Border x:Name=\"Chip\" CornerRadius=\"{DynamicResource Radius6}\" ...> <ContentPresenter/> </Border> <ControlTemplate.Triggers> <Trigger Property=\"IsChecked\" Value=\"True\"> <Setter TargetName=\"Chip\" Property=\"Background\" Value=\"{DynamicResource {x:Static theme:BrushKeys.ToolbarChipSelected}}\"/> </Trigger> </ControlTemplate.Triggers> </ControlTemplate> </Setter.Value> </Setter> </Style> Source: csharp/src/DBTools.Themes/Themes/App.Components.xaml:29-91 Theme Validation Startup Validation DbtThemeValidator.ValidateOrThrow() performs comprehensive theme validation: Incremental Merge Test: Merges each dictionary one-by-one to pinpoint failures Freezable Freeze: Freezes all brushes to prevent runtime leaks Contract Assertion: Validates merged dictionary order matches expected Ghost Validation: Creates invisible control tree to force template evaluation public static void ValidateOrThrow() { WpfUiThread.EnsurePackUriSupport(); // Incremental merge to pinpoint first broken dictionary var scratch = new ResourceDictionary(); foreach (var source in ExpectedMergedDictionarySources) { scratch.MergedDictionaries.Add(new ResourceDictionary { Source = new Uri(source, UriKind.Absolute) }); } FreezeFreezablesOrThrow(scratch); AssertMergedDictionariesContract(themeRoot); GhostValidate(themeRoot); } Source: csharp/src/DBTools.Core/UI/Theming/DbtThemeValidator.cs:52-92 Ghost Validation Creates an invisible visual tree to force template instantiation and catch deferred failures: private static void GhostValidate(ResourceDictionary themeRoot) { var root = new Grid { Width = 800, Height = 600 }; root.Resources.MergedDictionaries.Add(themeRoot); root.Children.Add(BuildProbeContent(root)); root.Measure(new Size(root.Width, root.Height)); root.Arrange(new Rect(0, 0, root.Width, root.Height)); root.UpdateLayout(); } Source: csharp/src/DBTools.Core/UI/Theming/DbtThemeValidator.cs:229-248 Using the Theme In XAML Reference brushes via DynamicResource and BrushKeys: <Window xmlns:theme=\"clr-namespace:DBTools.Themes;assembly=DBTools.Themes\"> <Border Background=\"{DynamicResource {x:Static theme:BrushKeys.Surface}}\"> <TextBlock Text=\"Hello\" Foreground=\"{DynamicResource {x:Static theme:BrushKeys.Body}}\"/> </Border> </Window> In Code Use SetResourceReference for dynamic binding: window.SetResourceReference(Window.BackgroundProperty, BrushKeys.Paper); window.SetResourceReference(Window.ForegroundProperty, BrushKeys.Body); Source: csharp/src/DBTools.Core/UI/Windows/DbtWindowInitHelper.cs:151-155 Extending the Theme Adding New Brushes Add ComponentResourceKey property in BrushKeys.cs: public static ComponentResourceKey MyNewBrush => new(typeof(BrushKeys), \"Brush.MyNew\"); Add brush definition in App.Brushes.xaml: <SolidColorBrush x:Key=\"{x:Static theme:BrushKeys.MyNewBrush}\" Color=\"#FF123456\"/> Adding New Styles Create new keyed style in appropriate dictionary: <Style x:Key=\"MyCustomButton\" TargetType=\"Button\" BasedOn=\"{StaticResource {x:Type Button}}\"> <Setter Property=\"Background\" Value=\"{DynamicResource {x:Static theme:BrushKeys.Primary}}\"/> </Style> For implicit styles, omit the x:Key: <Style TargetType=\"MyCustomControl\"> <Setter Property=\"Background\" Value=\"{DynamicResource {x:Static theme:BrushKeys.Surface}}\"/> </Style> XAML Resource File Types Some XAML files reference DBTools.Core types and cannot be compiled as BAML: <!-- These files are raw resources, not compiled BAML --> <Page Remove=\"Themes\\App.Converters.xaml\"/> <Page Remove=\"Themes\\App.Controls.Base.xaml\"/> <Page Remove=\"Themes\\App.Components.xaml\"/> <Resource Include=\"Themes\\App.Converters.xaml\"/> <Resource Include=\"Themes\\App.Controls.Base.xaml\"/> <Resource Include=\"Themes\\App.Components.xaml\"/> Source: csharp/src/DBTools.Themes/DBTools.Themes.csproj:38-46 Related Documentation Architecture Overview - High-level system architecture Project References - Project dependency graph Files Reviewed File Purpose csharp/src/DBTools.Themes/DBTools.Themes.csproj Project configuration csharp/src/DBTools.Themes/BrushKeys.cs ComponentResourceKey definitions csharp/src/DBTools.Themes/Themes/App.Theme.xaml Root theme dictionary csharp/src/DBTools.Themes/Themes/App.Tokens.xaml Design tokens csharp/src/DBTools.Themes/Themes/App.Brushes.xaml Color definitions csharp/src/DBTools.Themes/Themes/App.Controls.Base.xaml Base control styles csharp/src/DBTools.Themes/Themes/App.DataGrid.xaml DataGrid styles csharp/src/DBTools.Themes/Themes/App.Menus.xaml Menu styles csharp/src/DBTools.Themes/Themes/App.Components.xaml Component styles csharp/src/DBTools.Themes/Themes/App.FluentRibbon.xaml Fluent.Ribbon bridge csharp/src/DBTools.Themes/Themes/App.Converters.xaml Value converters csharp/src/DBTools.Core/UI/Theming/DbtThemeValidator.cs Theme validation csharp/src/DBTools.Core/UI/Windows/DbtWindowBase.cs Window base class csharp/src/DBTools.Core/UI/Windows/DbtRibbonWindowBase.cs Ribbon window base csharp/src/DBTools.Core/UI/Windows/DbtWindowInitHelper.cs Theme loading logic csharp/src/DBTools.Core/UI/Windows/ResourceDictionaryHelper.cs Dictionary utilities csharp/build-vendored-deps.sh Vendored library build script"
  },
  "articles/developing/modularity.html": {
    "href": "articles/developing/modularity.html",
    "title": "Leveraging DBTools Modularity | DBTools Developer Documentation",
    "summary": "Leveraging DBTools Modularity DBTools is designed as a modular Revit add-in platform where tools share common infrastructure while maintaining clear boundaries. This guide explains how to leverage the shared services from DBTools.Core and DBTools.Themes to build tools that integrate seamlessly with the platform. Philosophy DBTools follows these modularity principles: Shared Infrastructure, Independent Tools - Core services are centralized; tools are self-contained Dependency Injection First - All services are resolved through DI, enabling testing and flexibility Contract-Driven - Interfaces define contracts; implementations can vary per context Error Handling at Boundaries - All entrypoints run inside ISafeExecutor Window-Scoped Theming - Each window owns its theme resources to avoid cross-add-in conflicts Source: csharp/src/DBTools.App/Bootstrap/DbtServiceBootstrapper.cs:69-130 Two-Tier DI Architecture DBTools uses a two-tier dependency injection model: Tier Lifetime Purpose Examples Singleton Application lifetime Infrastructure services ISafeExecutor, IAlertService, ISettingsProvider, DbtToolRegistry Scoped Per-command lifetime Revit context services ITransactionRunner, IRevitCallGate, IRevitRunScope Source: csharp/src/DBTools.App/Bootstrap/DbtServiceBootstrapper.cs:77-79 Shared Services from DBTools.Core ISafeExecutor The central error handling service. All tool entrypoints must execute within ISafeExecutor. public interface ISafeExecutor { Task RunAsync(Func<Task> action, ILogger logger, IErrorNotifier? notifier = null, CancellationToken ct = default); Task RunAsync(Func<Task> action, ILogger logger, IErrorNotifier? notifier, SafeExecutor.SafeExecuteOptions? opts, CancellationToken ct = default); } Source: csharp/src/DBTools.Core/Execution/ISafeExecutor.cs:6-16 What it provides: Correlation IDs for log tracing Execution timing Exception logging with full stack traces and inner exceptions User notification via banners Automatic debug mode activation on fatal errors Lifecycle hooks (OnSuccessAsync, OnCancelAsync, OnErrorAsync) Source: csharp/src/DBTools.Core/Execution/SafeExecutor.cs:12-467 Usage in a command: // Commands automatically use ISafeExecutor via DbtToolCommand base class public sealed class GmCommand : DbtToolCommand { protected override async Task RunAsync(IDbtToolContext context) { var exec = context.Resolve<ISafeExecutor>(); // For nested async operations that need error handling: await exec.RunAsync(async () => { // Your work here }, context.Logger, context.ErrorNotifier); } } Source: csharp/src/Tools/Common/GM/Features/GmCommand.cs:32-93 ITransactionRunner Unified API for executing Revit model modifications with automatic transaction management. public interface ITransactionRunner { Task RunAsync(string name, Action action, CancellationToken ct = default); Task<T> RunAsync<T>(string name, Func<T> action, CancellationToken ct = default); Task RunAsync(string name, Action<Document> action, CancellationToken ct = default); Task<T> RunAsync<T>(string name, Func<Document, T> action, CancellationToken ct = default); Task RunAsync(string name, Action<UIApplication, Document> action, CancellationToken ct = default); Task<T> RunAsync<T>(string name, Func<UIApplication, Document, T> action, CancellationToken ct = default); // Overloads with explicit Document parameter Task RunAsync(Document doc, string name, Action<Document> action, CancellationToken ct = default); Task<T> RunAsync<T>(Document doc, string name, Func<Document, T> action, CancellationToken ct = default); } Source: csharp/src/DBTools.Core/Revit/Transactions/ITransactionRunner.cs:6-53 Key behaviors: Auto-selects transaction type: SubTransaction if doc.IsModifiable, otherwise new Transaction Cross-document protection Failure handling with SilentFailuresPreprocessor Usage example: public class FoundationTypeOrganizer { private readonly ITransactionRunner _tx; public FoundationTypeOrganizer(ITransactionRunner tx, Document doc, ILogger logger) { _tx = tx; // ... } public async Task OrganizeAsync() { await _tx.RunAsync(\"Organize Foundation Types\", doc => { // Modify document - transaction is automatic }); } } Source: csharp/src/Tools/Structural/OrganizeFoundationTypes/Features/FoundationTypeOrganizer.cs:19-27 ITransactionGroupService Manages transaction groups for operations requiring multiple transactions to appear as a single undo item. public interface ITransactionGroupService { bool IsActive { get; } Task BeginAsync(string name, CancellationToken ct = default); Task FinalizeAsync(bool commit, CancellationToken ct = default); Task RunAsync(string name, bool commit, Func<Task> work, CancellationToken ct = default); } Source: csharp/src/DBTools.Core/Revit/Transactions/ITransactionGroupService.cs:3-14 Usage for batch operations: public class TdvService { private readonly ITransactionRunner _tx; private readonly ITransactionGroupService _group; public TdvService(IRevitCallGate gate, ITransactionRunner tx, ITransactionGroupService group, ILogger<TdvService> logger) { _tx = tx; _group = group; // ... } public async Task ApplyMultipleChangesAsync() { await _group.RunAsync(\"Batch Apply\", commit: true, async () => { // Multiple transactions appear as one undo item await _tx.RunAsync(\"Step 1\", doc => { /* ... */ }); await _tx.RunAsync(\"Step 2\", doc => { /* ... */ }); await _tx.RunAsync(\"Step 3\", doc => { /* ... */ }); }); } } Source: csharp/src/Tools/Common/TDV/Revit/Services/TdvService.cs:20-23 IAlertService Service for showing alert dialogs with various body types. public interface IAlertService { AlertResult Show(AlertRequest request); bool Confirm(string message, string title = \"DB Tools\"); T? SelectSingle<T>(IEnumerable<T> items, Func<T, string> displayFunc, string windowTitle, string header, string? message = null, AlertWindowOptions? options = null) where T : class; IReadOnlyList<T> SelectMultiple<T>(IEnumerable<T> items, Func<T, string> displayFunc, string windowTitle, string header, string? message = null, AlertWindowOptions? options = null) where T : class; } Source: csharp/src/DBTools.Core/UI/Alerts/Services/IAlertService.cs:5-26 Usage examples: // Simple confirmation var alerts = context.Resolve<IAlertService>(); if (alerts.Confirm(\"Delete 15 elements?\", \"Confirm Delete\")) { // Proceed } // Single selection var selectedLevel = alerts.SelectSingle( levels, level => level.Name, windowTitle: \"Select Level\", header: \"Target Level\", message: \"Choose the level to place elements on\"); // Multiple selection var selectedTypes = alerts.SelectMultiple( familyTypes, t => t.Name, windowTitle: \"Select Types\", header: \"Types to Process\"); Source: csharp/src/DBTools.Core/UI/Alerts/Services/AlertService.cs:51-183 ILogger DBTools uses Microsoft.Extensions.Logging with Serilog as the provider. // Resolve from DI var logger = context.Resolve<ILogger<MyService>>(); // Or use the context's logger var logger = context.Logger; // Structured logging logger.LogInformation(\"Processing {Count} elements in {Document}\", elements.Count, doc.Title); logger.LogWarning(\"[GM] Failed to compute DocumentKey: {Message}\", ex.Message); logger.LogError(ex, \"[{Command}] execution failed.\", GetType().Name); Source: csharp/src/DBTools.App/Bootstrap/DbtServiceBootstrapper.cs:381-386 Important: Always use structured logging with named placeholders, not string interpolation. IRevitRunScope Represents a single Revit run scope (command, modeless session, or test). Provides access to the current Revit context. public interface IRevitRunScope { UIApplication UIApplication { get; } IRevitCallGate CallGate { get; } ITransactionRunner TransactionRunner { get; } ITransactionGroupService TransactionGroupService { get; } UIDocument GetActiveUiDocument(); Document GetActiveDocument(); Document GetLockedDocument(Document expectedDocument, string? context = null); } Source: csharp/src/DBTools.Core/Revit/Execution/IRevitRunScope.cs:11-20 Run Scope Profiles: Profile Use Case Description InlineUi Modal commands, RevitTest Executes directly on Revit UI thread QueuedModeless Long-running/modeless tools Uses ExternalEvent/RevitTask Source: csharp/src/DBTools.Core/Revit/Execution/IRevitRunScope.cs:22-36 ISettingsProvider / IOptionsMonitor Type-safe settings access with persistence and hot-reload support. public interface ISettingsProvider { TSettings Get<TSettings>() where TSettings : class, new(); Task SaveAsync<TSettings>(string section, TSettings settings, CancellationToken ct = default) where TSettings : class; } Source: csharp/src/DBTools.Core/Settings/ISettingsProvider.cs:1-8 Usage: // Via ISettingsProvider (singleton) var settings = context.Resolve<ISettingsProvider>(); var gmSettings = settings.Get<GmSettings>(); // Via IOptionsMonitor (for reactive updates) var monitor = context.Resolve<IOptionsMonitor<GmSettings>>(); var currentSettings = monitor.CurrentValue; Source: csharp/src/DBTools.App/Bootstrap/DiAppRuntime.cs:78 Shared UI from DBTools.Themes BrushKeys All theme brushes are defined using ComponentResourceKey for reliable cross-template resolution: public static class BrushKeys { // Brand colors public static ComponentResourceKey Primary => new(typeof(BrushKeys), \"Brush.Primary\"); public static ComponentResourceKey Secondary => new(typeof(BrushKeys), \"Brush.Secondary\"); // Surface colors public static ComponentResourceKey Paper => new(typeof(BrushKeys), \"Brush.Paper\"); public static ComponentResourceKey Surface => new(typeof(BrushKeys), \"Brush.Surface\"); public static ComponentResourceKey CardSurface => new(typeof(BrushKeys), \"Brush.CardSurface\"); // Text colors (WCAG AA compliant) public static ComponentResourceKey Body => new(typeof(BrushKeys), \"Brush.Body\"); public static ComponentResourceKey TextSecondary => new(typeof(BrushKeys), \"Brush.TextSecondary\"); public static ComponentResourceKey TextMuted => new(typeof(BrushKeys), \"Brush.TextMuted\"); // Status colors public static ComponentResourceKey Success => new(typeof(BrushKeys), \"Brush.Success\"); public static ComponentResourceKey Warning => new(typeof(BrushKeys), \"Brush.Warning\"); public static ComponentResourceKey Error => new(typeof(BrushKeys), \"Brush.Error\"); // DataGrid specific public static ComponentResourceKey DataGridRowSelected => new(typeof(BrushKeys), \"Brush.DataGrid.RowSelected\"); public static ComponentResourceKey DataGridAccentStripe => new(typeof(BrushKeys), \"Brush.DataGrid.AccentStripe\"); // ... 130+ additional keys } Source: csharp/src/DBTools.Themes/BrushKeys.cs:9-139 Usage in XAML: <Window xmlns:theme=\"clr-namespace:DBTools.Themes;assembly=DBTools.Themes\"> <Border Background=\"{DynamicResource {x:Static theme:BrushKeys.Surface}}\"> <TextBlock Text=\"Hello\" Foreground=\"{DynamicResource {x:Static theme:BrushKeys.Body}}\"/> </Border> </Window> Design Tokens Standard spacing, sizing, and typography values for consistent layouts: <!-- Spacing --> <Thickness x:Key=\"Spacing4\">4</Thickness> <Thickness x:Key=\"Spacing8\">8</Thickness> <Thickness x:Key=\"Spacing16\">16</Thickness> <!-- Padding --> <Thickness x:Key=\"Pad8\">8</Thickness> <Thickness x:Key=\"Card.Padding\">16,12</Thickness> <!-- Corner radius --> <CornerRadius x:Key=\"Radius4\">4</CornerRadius> <CornerRadius x:Key=\"Radius8\">8</CornerRadius> <!-- Typography --> <sys:Double x:Key=\"FontSize.Body\">13</sys:Double> <sys:Double x:Key=\"FontSize.Title\">16</sys:Double> <sys:Double x:Key=\"FontSize.Header\">20</sys:Double> Source: csharp/src/DBTools.Themes/Themes/App.Tokens.xaml:5-72 Window Base Classes DbtWindowBase Standard modal window with automatic theme loading and progress overlay: public class DbtWindowBase : Window, IWindowWithOwnerProvider, IThemeOptOut { public DbtWindowBase() { DbtWindowInitHelper.Initialize(this, nameof(DbtWindowBase)); } public IWindowOwnerProvider? OwnerProvider { get; set; } public bool UseDefaultTheme { get; set; } } Source: csharp/src/DBTools.Core/UI/Windows/DbtWindowBase.cs:27-47 DbtRibbonWindowBase Ribbon window for tools with tab-based navigation: public class DbtRibbonWindowBase : RibbonWindow, IWindowWithOwnerProvider, IThemeOptOut { public DbtRibbonWindowBase() { DbtWindowInitHelper.Initialize(this, nameof(DbtRibbonWindowBase)); } } Source: csharp/src/DBTools.Core/UI/Windows/DbtRibbonWindowBase.cs:15-35 What window bases provide: Window-scoped theme loading (avoids cross-add-in conflicts) Revit window ownership binding Progress overlay integration UI error protection DBTools icon Source: csharp/src/DBTools.Core/UI/Windows/DbtWindowInitHelper.cs:44-78 DI Patterns Creating a Tool Module Every tool implements DbtToolModule to register its services: public sealed class GmToolModule : DbtToolModule { public override void RegisterServices(IServiceCollection services, DbtToolManifest manifest) { Guard.NotNull(services, nameof(services)); Guard.NotNull(manifest, nameof(manifest)); services.AddGmServices(); // Extension method for cleaner registration } } Source: csharp/src/Tools/Common/GM/GmToolModule.cs:10-18 DbtToolModule Base Class public abstract class DbtToolModule { /// <summary>Registers tool settings types (Options pattern).</summary> public virtual void RegisterSettings(IServiceCollection services, IConfiguration configuration, DbtToolManifest manifest) { } /// <summary>Registers services required by this tool module.</summary> public virtual void RegisterServices(IServiceCollection services, DbtToolManifest manifest) { } /// <summary>Registers settings pack definitions for the Settings UI.</summary> public virtual void RegisterSettingsPacks(IServiceCollection services, DbtToolManifest manifest) { } /// <summary>Registers hook handlers with the tool registry.</summary> public virtual void RegisterHooks(DbtToolRegistry registry, DbtToolManifest manifest) { } } Source: csharp/src/DBTools.Core/Tools/DbtToolModule.cs:9-49 Service Registration Patterns public static class GmServiceCollectionExtensions { public static IServiceCollection AddGm(this IServiceCollection services) { // === Pure/shared logic (scoped) === services.AddScoped<IProjectLifecycleService, ProjectLifecycleService>(); services.AddScoped<INamingSimilarityService, NamingSimilarityService>(); // === Services with complex initialization === services.AddScoped<IGmMappingService>(sp => { var logger = sp.GetRequiredService<ILogger<GmMappingService>>(); var usage = sp.GetRequiredService<IUsageIndexService>(); var tx = sp.GetRequiredService<ITransactionRunner>(); // ... resolve other dependencies return new GmMappingService(logger, usage, tx, writers); }); // === Revit infrastructure (scoped) === services.AddScoped<ICategoryService, CategoryService>(); services.AddScoped<IElementQuery, ElementQueryService>(); // === UI services === services.AddScoped<IReportWindowService, ReportWindowService>(); return services; } } Source: csharp/src/Tools/Common/GM/Shell/DI/Services.cs:28-108 Resolving Services in Commands protected override async Task RunAsync(IDbtToolContext context) { // Single service var alerts = context.Resolve<IAlertService>(); // Multiple services (tuple pattern) var (tx, groups, mapping, planner, lifecycle) = context.Resolve< ITransactionRunner, ITransactionGroupService, IGmMappingService, IGmPlanningService, IProjectLifecycleService>(); } Source: csharp/src/Tools/Common/GM/Features/GmCommand.cs:59-91 Best Practices 1. Always Use ISafeExecutor at Entrypoints // DO: Inherit from DbtToolCommand (uses ISafeExecutor internally) public sealed class MyCommand : DbtToolCommand { protected override async Task RunAsync(IDbtToolContext context) { // ISafeExecutor wraps this automatically } } // DON'T: Create IExternalCommand without error handling public class BadCommand : IExternalCommand { public Result Execute(...) { // No error handling - will crash Revit } } Source: csharp/src/DBTools.Core/Revit/Execution/DbtToolCommand.cs:35-126 2. Prefer Scoped Services for Revit-Dependent Code // DO: Scoped registration for services that need Revit context services.AddScoped<ICategoryService, CategoryService>(); services.AddScoped<IElementQuery, ElementQueryService>(); // DON'T: Singleton for services that capture Document references services.AddSingleton<IBadService, ServiceThatHoldsDocument>(); // Memory leak! 3. Use Transaction Services, Not Raw Transactions // DO: Use ITransactionRunner await _tx.RunAsync(\"Create Wall\", doc => { Wall.Create(doc, curve, levelId, false); }); // DON'T: Create raw Transaction objects using var tx = new Transaction(doc, \"Create Wall\"); tx.Start(); Wall.Create(doc, curve, levelId, false); tx.Commit(); // Manual error handling required 4. Reference Theme Brushes via BrushKeys <!-- DO: Use BrushKeys for reliable resolution --> <Border Background=\"{DynamicResource {x:Static theme:BrushKeys.Surface}}\"/> <!-- DON'T: Use string keys (fragile) --> <Border Background=\"{DynamicResource Brush.Surface}\"/> 5. Inherit from Window Base Classes // DO: Inherit from DbtWindowBase public partial class MyToolWindow : DbtWindowBase { // Theme, progress overlay, error protection all included } // DON'T: Use raw Window public partial class MyToolWindow : Window { // No theme, no error protection, no Revit ownership } Anti-Patterns to Avoid 1. Service Locator Pattern // DON'T: Use AppRuntime.Resolve outside of command constructors public class BadService { public void DoWork() { var alerts = AppRuntime.Resolve<IAlertService>(); // Hidden dependency } } // DO: Inject via constructor public class GoodService { private readonly IAlertService _alerts; public GoodService(IAlertService alerts) { _alerts = alerts; } } 2. Silent Failures // DON'T: Swallow exceptions try { DoWork(); } catch { /* silent failure */ } // DON'T: Return defaults pretending success catch (Exception) { return new List<Element>(); } // DO: Let ISafeExecutor handle errors await executor.RunAsync(async () => { DoWork(); // Exception propagates to error handling }, logger, notifier); 3. Capturing Document References // DON'T: Hold Document references in singleton services public class BadService { private readonly Document _doc; // Will become stale! public BadService(Document doc) => _doc = doc; } // DO: Accept Document per-call public class GoodService { public void DoWork(Document doc) { // Fresh reference each call } } 4. Raw Console/MessageBox Output // DON'T: Use Console or MessageBox Console.WriteLine(\"Debug info\"); MessageBox.Show(\"Error occurred\"); // DO: Use logging and IAlertService _logger.LogDebug(\"Debug info\"); _alerts.Show(new AlertRequest(\"Error\", new MessageBodyViewModel(\"Error occurred\"))); 5. Bypassing Theme System // DON'T: Use hard-coded colors <Border Background=\"#222228\"/> // DO: Use theme brushes <Border Background=\"{DynamicResource {x:Static theme:BrushKeys.Surface}}\"/> Related Documentation DBTools.Core Project - Complete Core API reference Theme System - Detailed theming documentation Architecture Overview - System-wide architecture Quick Reference Table Need Service Lifetime Error handling at entrypoints ISafeExecutor Singleton Model modifications ITransactionRunner Scoped Batch undo operations ITransactionGroupService Scoped User dialogs IAlertService Singleton Logging ILogger<T> Singleton Revit context IRevitRunScope Scoped Thread-safe API access IRevitCallGate Scoped Settings access ISettingsProvider Singleton Reactive settings IOptionsMonitor<T> Singleton"
  },
  "articles/developing/new-tool-guide.html": {
    "href": "articles/developing/new-tool-guide.html",
    "title": "Creating New Tools in DBTools | DBTools Developer Documentation",
    "summary": "Creating New Tools in DBTools This guide covers the complete process of creating a new tool for the DBTools Revit add-in platform. By the end, you'll understand the tool module system, manifest configuration, command implementation, and UI patterns. Overview DBTools uses a manifest-driven plugin architecture. Each tool: Lives in its own folder under csharp/src/Tools/ Declares metadata via manifest.yml Implements a DbtToolModule subclass for DI registration Provides one or more DbtToolCommand implementations Optionally includes WPF UI, settings, and hooks Key architectural principle: Tool source files are file-linked into DBTools.App at build time. Individual tool .csproj files exist for IDE navigation and per-tool test projects, but the final DBTools.dll assembly contains all tool code compiled together. Source: csharp/src/DBTools.App/DBTools.App.csproj:61-78 Prerequisites Before creating a new tool: Ensure you can build the solution: bash csharp/build.sh Understand the target Revit versions (net48 for 2024, net8.0-windows for 2025+) Decide on a tool category: Common, Structural, Testing, or new category Choose a unique tool ID (e.g., DBTools.MyTool) Step 1: Directory Structure Create your tool folder under the appropriate category: csharp/src/Tools/ Common/ # General-purpose tools GM/ # Global Mapper (complex example) ElevationTags/ # Simple example Structural/ # Structural engineering tools SGT/ # Super Girt Tool (complex example) FramingJoins/ # Simple example Testing/ # Testing/debug tools Minimal Tool Structure csharp/src/Tools/<Category>/<ToolName>/ Assets/ my_tool.png # 32x32 icon for ribbon (required) my_tool_16.png # 16x16 small icon (optional) Features/ MyToolCommand.cs # IExternalCommand implementation manifest.yml # Tool metadata and ribbon config <ToolName>ToolModule.cs # DI registration DBTools.<ToolName>.csproj # Project file (for IDE/tests) Complex Tool Structure (with UI) csharp/src/Tools/<Category>/<ToolName>/ Assets/ *.png # Icons Bootstrap/ ServiceExtensions.cs # DI extension methods Features/ Commands/ MyToolCommand.cs Logic/ MyService.cs IMyService.cs Shell/ DI/ Services.cs # Detailed DI registrations DesignTime/ MyWindowDesignTimeViewModel.cs UI/ Views/ MyWindow.xaml MyWindow.xaml.cs ViewModels/ MyWindowViewModel.cs Shared/ Models/ Contracts/ Tests/ # Separate test project folder DBTools.<ToolName>.Tests.csproj Properties/ DesignTimeResources.xaml # For XAML designer manifest.yml <ToolName>ToolModule.cs DBTools.<ToolName>.csproj Source: Reference structure from csharp/src/Tools/Common/GM/ and csharp/src/Tools/Structural/SGT/ Step 2: Project File (.csproj) Create a project file for IDE support and test isolation. The project file is NOT used for the main build (files are linked into DBTools.App), but it enables: IntelliSense and navigation Per-tool test projects Design-time XAML preview Minimal Project File <Project Sdk=\"Microsoft.NET.Sdk\"> <PropertyGroup> <TargetFrameworks>$(DBT_RevitTargetFrameworks)</TargetFrameworks> <LangVersion>latest</LangVersion> <Nullable>enable</Nullable> <ImplicitUsings>enable</ImplicitUsings> <RootNamespace>DBTools.MyTool</RootNamespace> </PropertyGroup> <!-- Exclude Revit-dependent code during design-time builds --> <ItemGroup Condition=\"'$(DesignTimeBuild)'=='true' or '$(DBT_IsSandboxBuild)'=='true'\"> <Compile Remove=\"**\\Revit\\**\\*.cs\" /> </ItemGroup> <ItemGroup Condition=\"'$(DBT_IsSandboxBuild)'=='true'\"> <Compile Remove=\"Features\\MyToolCommand.cs\" /> <Compile Remove=\"MyToolToolModule.cs\" /> </ItemGroup> <ItemGroup> <Compile Remove=\"Tests\\**\\*.cs\" /> </ItemGroup> <PropertyGroup Condition=\"'$(TargetFramework)'=='net48'\"> <NoWarn>$(NoWarn);CS0618;MA0038;MA0051;MA0048;MA0016;MA0098;MA0004;CA1068;CA1707;CA1725</NoWarn> <PlatformTarget>x64</PlatformTarget> <Prefer32Bit>false</Prefer32Bit> </PropertyGroup> <PropertyGroup Condition=\"'$(TargetFramework)'=='net8.0-windows'\"> <NoWarn>$(NoWarn);CS0618;MA0038;MA0048;MA0016;MA0051;MA0098;MA0004;CA1707;CA1725;CA1068;MSB3277</NoWarn> <Nullable>enable</Nullable> <SupportedOSPlatformVersion>6.1</SupportedOSPlatformVersion> </PropertyGroup> <ItemGroup> <ProjectReference Include=\"..\\..\\..\\DBTools.Core\\DBTools.Core.csproj\" /> </ItemGroup> <!-- Embed icons --> <ItemGroup> <EmbeddedResource Include=\"Assets\\\\*.png\"> <Link>Resources\\\\Icons\\\\%(Filename)%(Extension)</Link> </EmbeddedResource> </ItemGroup> <!-- Required packages --> <ItemGroup> <PackageReference Include=\"ricaun.Revit.UI.Tasks\" /> </ItemGroup> <!-- Revit API references --> <ItemGroup Condition=\"'$(DesignTimeBuild)'!='true' and '$(DBT_IsSandboxBuild)'!='true' and '$(TargetFramework)'=='net48'\"> <Reference Include=\"RevitAPI\"> <HintPath>$(REVIT2024_DIR)\\RevitAPI.dll</HintPath> <Private>false</Private> </Reference> <Reference Include=\"RevitAPIUI\"> <HintPath>$(REVIT2024_DIR)\\RevitAPIUI.dll</HintPath> <Private>false</Private> </Reference> <Reference Include=\"WindowsBase\" /> </ItemGroup> <ItemGroup Condition=\"'$(DesignTimeBuild)'!='true' and '$(DBT_IsSandboxBuild)'!='true' and '$(TargetFramework)'=='net8.0-windows'\"> <Reference Include=\"RevitAPI\" Condition=\"'$(REVIT_NET8_DIR)'!='' and Exists('$(REVIT_NET8_DIR)\\\\RevitAPI.dll')\"> <HintPath>$(REVIT_NET8_DIR)\\RevitAPI.dll</HintPath> <Private>false</Private> </Reference> <Reference Include=\"RevitAPIUI\" Condition=\"'$(REVIT_NET8_DIR)'!='' and Exists('$(REVIT_NET8_DIR)\\\\RevitAPIUI.dll')\"> <HintPath>$(REVIT_NET8_DIR)\\RevitAPIUI.dll</HintPath> <Private>false</Private> </Reference> </ItemGroup> </Project> Source: csharp/src/Tools/Structural/FramingJoins/DBTools.Structural.FramingJoins.csproj:1-69 For Tools with WPF UI Add the following to your .csproj: <PropertyGroup> <UseWPF>true</UseWPF> </PropertyGroup> <!-- Additional packages for MVVM --> <ItemGroup> <PackageReference Include=\"CommunityToolkit.Mvvm\" /> </ItemGroup> <!-- Fluent Ribbon if using ribbon-based window --> <ItemGroup> <Reference Include=\"DBTools.Fluent.Ribbon\"> <HintPath>$(DBT_VendorArtifactsRoot)fluentribbon\\$(TargetFramework)\\DBTools.Fluent.Ribbon.dll</HintPath> <Private>true</Private> </Reference> <Reference Include=\"DBTools.ControlzEx\"> <HintPath>$(DBT_VendorArtifactsRoot)controlzex\\$(TargetFramework)\\DBTools.ControlzEx.dll</HintPath> <Private>true</Private> </Reference> </ItemGroup> <!-- Design-time resources --> <ItemGroup> <Page Update=\"Properties\\DesignTimeResources.xaml\"> <SubType>Designer</SubType> <Generator>MSBuild:Compile</Generator> <ContainsDesignTimeResources>true</ContainsDesignTimeResources> </Page> </ItemGroup> Source: csharp/src/Tools/Common/GM/DBTools.GM.csproj:1-94 Step 3: manifest.yml (Complete Schema) The manifest file declares your tool's metadata, ribbon configuration, and optional settings. Complete Schema Reference # Required: Unique tool identifier id: DBTools.MyTool # Required: Assembly name (without .dll) - always \"DBTools\" for main tools assembly: DBTools # Required: Fully-qualified type name of DbtToolModule subclass moduleType: DBTools.MyTool.MyToolToolModule # Required: Load order (lower = earlier). Use 0 unless you need ordering. order: 0 # Optional: Sandbox windows for design-time preview sandboxWindows: - id: DBTools.MyTool.Main displayName: \"My Tool\" group: \"Common\" # or \"Structural\", \"Testing\" windowType: \"DBTools.MyTool.Shell.UI.Views.MyToolWindow\" designTimeViewModelType: \"DBTools.MyTool.Shell.DesignTime.MyToolDesignTimeViewModel\" # Required: Tool configuration tool: # Optional: Settings configuration settings: configSection: Tools.MyTool # Section in settings.json # Optional: Settings packs for Settings window settingsPacks: - key: common.my_tool title: \"My Tool\" warnings: - id: core.my_tool.warning title: \"My Tool Disabled\" message: \"Tool is disabled due to a configuration issue.\" disableTools: - DBTools.MyToolCommand # Required: Ribbon button definitions ribbonTools: - internalName: DBTools.MyToolCommand commandType: DBTools.MyTool.Features.MyToolCommand availabilityType: DBTools.App.Tools.Availability.DbtDocumentAvailability runProfile: InlineUi displayText: \"My Tool\" iconBaseKey: my_tool tooltip: \"Launch My Tool\" controlKind: PushButton order: 50 Manifest Properties Reference Property Required Description id Yes Unique identifier (e.g., DBTools.MyTool) assembly Yes Assembly name without .dll (always DBTools) moduleType Yes Full type name of DbtToolModule subclass order Yes Load order (0 for most tools) sandboxWindows No Design-time preview windows tool.settings.configSection No settings.json section for Options pattern tool.settingsPacks No Settings window configuration tool.ribbonTools Yes At least one ribbon button definition Ribbon Tool Properties Property Required Description internalName Yes Unique button identifier commandType Yes Full type name of command class availabilityType No IExternalCommandAvailability implementation runProfile No InlineUi (default), BackgroundWork, etc. displayText Yes Button label (use \\n for line breaks) iconBaseKey Yes Icon filename without extension tooltip Yes Button tooltip text controlKind Yes PushButton, SplitButtonItem, PulldownButtonItem, StackedButtonItem splitGroup No Group name for split/pulldown/stacked buttons order Yes Button order within panel groupDisplayText No Header text for pulldown groups groupTooltip No Tooltip for pulldown header groupIconBaseKey No Icon for pulldown header Source: csharp/src/DBTools.Core/Tools/DbtToolManifest.cs:1-68 and csharp/src/DBTools.Core/Tools/DbtToolManifestLoader.cs:287-307 Example: Simple Tool id: DBTools.Structural.FramingJoins assembly: DBTools moduleType: DBTools.Structural.FramingJoins.FramingJoinsToolModule order: 0 tool: ribbonTools: - internalName: DBTools.AllowJoinSelected commandType: DBTools.Structural.FramingJoins.AllowJoinSelectedCommand availabilityType: DBTools.App.Tools.Availability.DbtStructuralFramingSelectionAvailability runProfile: InlineUi displayText: \"Allow Join\" iconBaseKey: allow_join tooltip: \"Allow structural framing joins for selected elements\" controlKind: SplitButtonItem splitGroup: framing_joins order: 0 - internalName: DBTools.DisallowJoinSelected commandType: DBTools.Structural.FramingJoins.DisallowJoinSelectedCommand availabilityType: DBTools.App.Tools.Availability.DbtStructuralFramingSelectionAvailability runProfile: InlineUi displayText: \"Disallow Join\" iconBaseKey: disallow_join tooltip: \"Disallow structural framing joins for selected elements\" controlKind: SplitButtonItem splitGroup: framing_joins order: 1 Source: csharp/src/Tools/Structural/FramingJoins/manifest.yml:1-27 Example: Complex Tool with UI id: DBTools.GM assembly: DBTools moduleType: DBTools.GM.GmToolModule order: 0 sandboxWindows: - id: DBTools.GM.Main displayName: \"Global Mapper\" group: \"Common\" windowType: \"DBTools.GM.Shell.UI.Views.GmWindow\" designTimeViewModelType: \"DBTools.GM.Shell.DesignTime.GmShellDesignTimeViewModel\" - id: DBTools.GM.MappingReport displayName: \"Global Mapper - Mapping Report\" group: \"Common\" windowType: \"DBTools.GM.Features.Mapping.UI.Views.GmMappingReportWindow\" designTimeViewModelType: \"DBTools.GM.Features.Mapping.DesignTime.GmMappingReportDesignTimeViewModel\" tool: ribbonTools: - internalName: DBTools.GM commandType: DBTools.GM.Features.GmCommand availabilityType: DBTools.App.Tools.Availability.DbtDocumentAvailability runProfile: InlineUi displayText: \"Global Mapper\" iconBaseKey: gm tooltip: \"Open Global Mapper\" controlKind: PushButton order: 30 Source: csharp/src/Tools/Common/GM/manifest.yml:1-27 Step 4: ToolModule Class The DbtToolModule subclass registers services with the DI container. Minimal Implementation For simple tools with no custom services: using DBTools.Core.Tools; namespace DBTools.Structural.FramingJoins; public sealed class FramingJoinsToolModule : DbtToolModule { } Source: csharp/src/Tools/Structural/FramingJoins/FramingJoinsToolModule.cs:1-8 With Service Registration using DBTools.Core.Tools; using DBTools.Core.Compat; using Microsoft.Extensions.DependencyInjection; namespace DBTools.MyTool; public sealed class MyToolToolModule : DbtToolModule { public override void RegisterServices(IServiceCollection services, DbtToolManifest manifest) { Guard.NotNull(services, nameof(services)); Guard.NotNull(manifest, nameof(manifest)); // Register tool-specific services services.AddScoped<IMyService, MyService>(); services.AddScoped<MyOtherService>(); } } Source: csharp/src/Tools/Common/GM/GmToolModule.cs:1-19 With Hooks using DBTools.Core.Tools; using DBTools.Core.Compat; using Microsoft.Extensions.DependencyInjection; namespace DBTools.SGT; public sealed class SgtToolModule : DbtToolModule { public override void RegisterServices(IServiceCollection services, DbtToolManifest manifest) { Guard.NotNull(services, nameof(services)); Guard.NotNull(manifest, nameof(manifest)); services.AddSgtServices(); services.AddSingleton<SgtContextualRibbonInjector, SgtContextualRibbonInjector>(); } public override void RegisterHooks(DbtToolRegistry registry, DbtToolManifest manifest) { Guard.NotNull(registry, nameof(registry)); Guard.NotNull(manifest, nameof(manifest)); // Register contextual ribbon hook registry.RegisterHook<IContextualRibbonInjector, SgtContextualRibbonInjector>(); } } Source: csharp/src/Tools/Structural/SGT/SgtToolModule.cs:1-27 DbtToolModule Virtual Methods Method Purpose RegisterSettings Register Options pattern settings types RegisterServices Register services for DI container RegisterSettingsPacks Register settings pack definitions RegisterHooks Register event hooks (ViewActivated, ContextualRibbon) Source: csharp/src/DBTools.Core/Tools/DbtToolModule.cs:1-50 Step 5: Command Implementation Commands implement DbtToolCommand (not IExternalCommand directly) to get automatic error handling, logging, and run scope management. Basic Command Structure using System; using System.Threading.Tasks; using Autodesk.Revit.Attributes; using DBTools.Core.Compat; using DBTools.Core.Revit.Execution; using Microsoft.Extensions.Logging; namespace DBTools.MyTool.Features; [Transaction(TransactionMode.Manual)] public sealed class MyToolCommand : DbtToolCommand { protected override async Task RunAsync(IDbtToolContext context) { Guard.EnsureNotNull(context, nameof(context)); var logger = context.Logger; var doc = context.Document; var uidoc = context.UIDocument; logger.LogDebug(\"[MyTool] Starting execution\"); // Your tool logic here await Task.CompletedTask.ConfigureAwait(false); } protected override SafeExecutor.SafeExecuteOptions CreateExecuteOptions( Autodesk.Revit.UI.ExternalCommandData commandData) { return new SafeExecutor.SafeExecuteOptions { Name = \"My Tool\", ShowCompletionToUser = true, SuppressCompletionBanner = false }; } } With Transaction [Transaction(TransactionMode.Manual)] public sealed class AllowJoinSelectedCommand : DbtToolCommand { protected override async Task RunAsync(IDbtToolContext context) { Guard.EnsureNotNull(context, nameof(context)); var uidoc = context.UIDocument; var doc = context.Document; var logger = context.Logger; // Get selection var selectedIds = uidoc.Selection.GetElementIds(); if (selectedIds == null || selectedIds.Count == 0) { throw new InvalidOperationException(\"Please select elements.\"); } // Create transaction runner var gate = new ModalInlineCallGate(context.UIApplication); var tx = new DBTools.Core.Revit.Transactions.CallGateTransactionRunner(gate); int modified = 0; await tx.RunAsync(doc, \"DB Tools - Allow Join\", d => { foreach (var id in selectedIds) { var elem = doc.GetElement(id) as FamilyInstance; if (elem == null) continue; StructuralFramingUtils.AllowJoinAtEnd(elem, 0); StructuralFramingUtils.AllowJoinAtEnd(elem, 1); modified++; } }).ConfigureAwait(false); logger.LogDebug(\"[AllowJoin] Modified {Count} elements.\", modified); // Show result var alerts = context.Resolve<IAlertService>(); _ = alerts.Show(new AlertRequest( \"Allow Join\", new MessageBodyViewModel($\"Allowed joins on {modified} element(s).\")) { Buttons = new[] { new AlertButtonSpec(\"ok\", \"OK\") { IsDefault = true } } }); } } Source: csharp/src/Tools/Structural/FramingJoins/Features/AllowJoinSelectedCommand.cs:1-89 IDbtToolContext Properties Property Description UIApplication Revit UIApplication UIDocument Active UIDocument Document Active Document Logger ILogger for the command Resolve<T>() Resolve service from DI Source: csharp/src/DBTools.Core/Revit/Execution/DbtToolCommand.cs:1-239 Step 6: UI Implementation (MVVM Pattern) For tools with UI, follow the MVVM pattern with DBTools conventions. Window Base Classes Class Use Case DbtWindowBase Modal dialogs DbtRibbonWindowBase Windows with Fluent Ribbon Source: csharp/src/DBTools.Core/UI/Windows/DbtWindowBase.cs:1-48 XAML Window Template <?xml version=\"1.0\" encoding=\"utf-8\"?> <core:DbtWindowBase x:Class=\"DBTools.MyTool.Shell.UI.Views.MyToolWindow\" xmlns=\"http://schemas.microsoft.com/winfx/2006/xaml/presentation\" xmlns:x=\"http://schemas.microsoft.com/winfx/2006/xaml\" xmlns:d=\"http://schemas.microsoft.com/expression/blend/2008\" xmlns:mc=\"http://schemas.openxmlformats.org/markup-compatibility/2006\" xmlns:core=\"clr-namespace:DBTools.Core.UI.Windows;assembly=DBTools.Core\" xmlns:theme=\"clr-namespace:DBTools.Themes;assembly=DBTools.Themes\" xmlns:dt=\"clr-namespace:DBTools.MyTool.Shell.DesignTime\" d:DataContext=\"{d:DesignInstance Type=dt:MyToolDesignTimeViewModel, IsDesignTimeCreatable=True}\" Title=\"My Tool\" Width=\"800\" Height=\"600\" MinWidth=\"600\" MinHeight=\"400\" ResizeMode=\"CanResize\" mc:Ignorable=\"d\"> <Window.Resources> <ResourceDictionary> <ResourceDictionary.MergedDictionaries> <ResourceDictionary Source=\"pack://application:,,,/DBTools.Themes;component/Themes/App.Theme.xaml\" /> </ResourceDictionary.MergedDictionaries> </ResourceDictionary> </Window.Resources> <Grid> <!-- Your UI content --> </Grid> </core:DbtWindowBase> Source: csharp/src/Tools/Common/GM/Shell/UI/Views/GmWindow.xaml:1-26 ViewModel Pattern Use CommunityToolkit.Mvvm for MVVM implementation: using CommunityToolkit.Mvvm.ComponentModel; using CommunityToolkit.Mvvm.Input; namespace DBTools.MyTool.Shell.UI.ViewModels; public partial class MyToolWindowViewModel : ObservableObject { [ObservableProperty] private string _searchText = string.Empty; [ObservableProperty] private bool _isBusy; [RelayCommand] private async Task ExecuteAsync() { IsBusy = true; try { // Do work } finally { IsBusy = false; } } } Design-Time ViewModel Create a design-time ViewModel for XAML preview: using System.Windows.Input; using DBTools.Core.UI; namespace DBTools.MyTool.Shell.DesignTime; /// <summary> /// Design-time ViewModel for XAML Designer support. /// DO NOT instantiate at runtime. /// </summary> [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)] public sealed class MyToolDesignTimeViewModel { // Commands - use DesignTimeRelayCommand for all public ICommand ExecuteCommand => DesignTimeRelayCommand.Instance; public ICommand CloseCommand => DesignTimeRelayCommand.Instance; // Properties with sample data public string SearchText { get; set; } = \"Sample search\"; public bool IsBusy => false; public MyToolDesignTimeViewModel() { // Initialize sample data for designer preview } } Source: csharp/src/Tools/Common/GM/Shell/DesignTime/GmShellDesignTimeViewModel.cs:1-250 Step 7: Settings (Optional) Defining Settings Create a settings class: namespace DBTools.MyTool.Settings; public sealed class MyToolSettings { public bool EnableFeatureX { get; set; } = true; public int Threshold { get; set; } = 50; } Registering Settings In your ToolModule: public override void RegisterSettings( IServiceCollection services, IConfiguration configuration, DbtToolManifest manifest) { Guard.NotNull(services, nameof(services)); Guard.NotNull(configuration, nameof(configuration)); Guard.NotNull(manifest, nameof(manifest)); var section = manifest.Tool?.Settings?.ConfigSection ?? \"Tools.MyTool\"; services.Configure<MyToolSettings>(configuration.GetSection(section)); } Using Settings public sealed class MyService { private readonly MyToolSettings _settings; public MyService(IOptionsMonitor<MyToolSettings> options) { _settings = options.CurrentValue; } } settings.json Structure { \"Tools\": { \"MyTool\": { \"EnableFeatureX\": true, \"Threshold\": 75 } } } Step 8: Hooks (Optional) Available Hook Interfaces Interface Purpose IViewActivatedHookHandler React to view changes IContextualRibbonInjector Add contextual ribbon tabs Source: csharp/src/DBTools.Core/Tools/DbtHookHost.cs:14-23 ViewActivated Hook using DBTools.Core.Tools; using Autodesk.Revit.UI; using Autodesk.Revit.UI.Events; namespace DBTools.MyTool.Features.Hooks; public sealed class MyViewActivatedHandler : IViewActivatedHookHandler { public Task OnViewActivatedAsync( UIControlledApplication application, ViewActivatedEventArgs args, CancellationToken ct) { // React to view changes return Task.CompletedTask; } } Register in your ToolModule: public override void RegisterHooks(DbtToolRegistry registry, DbtToolManifest manifest) { registry.RegisterHook<IViewActivatedHookHandler, MyViewActivatedHandler>(); } public override void RegisterServices(IServiceCollection services, DbtToolManifest manifest) { services.AddSingleton<MyViewActivatedHandler>(); } Step 9: Availability Types Availability types control when ribbon buttons are enabled. Built-in Availability Types Type Description DbtDocumentAvailability Requires an open document DbtActiveViewAvailability Requires an active view DbtSelectionAvailability Requires selected elements Source: csharp/src/DBTools.App/Tools/Availability/DbtDocumentAvailability.cs:1-17 Custom Availability using Autodesk.Revit.DB; using Autodesk.Revit.UI; namespace DBTools.App.Tools.Availability; public sealed class MyCustomAvailability : IExternalCommandAvailability { public bool IsCommandAvailable(UIApplication applicationData, CategorySet selectedCategories) { var doc = applicationData?.ActiveUIDocument?.Document; if (doc == null) return false; // Custom logic return selectedCategories?.Contains(Category.GetCategory(doc, BuiltInCategory.OST_Walls)) == true; } } Step 10: File Linking (How It Works) Tool source files are compiled into DBTools.dll via file linking in DBTools.App.csproj: <!-- Tool Source Files --> <ItemGroup Label=\"Tool Source Files\"> <Compile Include=\"..\\Tools\\**\\*.cs\" Exclude=\"..\\Tools\\**\\Tests\\**\\*.cs;..\\Tools\\**\\obj\\**\\*.cs\" Link=\"Tools\\%(RecursiveDir)%(Filename)%(Extension)\" /> </ItemGroup> <!-- Tool XAML Files --> <ItemGroup Label=\"Tool XAML Files\"> <Page Include=\"..\\Tools\\**\\*.xaml\" Exclude=\"..\\Tools\\**\\obj\\**\\*.xaml;..\\Tools\\**\\Properties\\DesignTimeResources.xaml\" Link=\"Tools\\%(RecursiveDir)%(Filename)%(Extension)\" /> </ItemGroup> <!-- Tool Icons --> <ItemGroup Label=\"Tool Embedded Assets\"> <EmbeddedResource Include=\"..\\Tools\\**\\Assets\\*.png\" Link=\"Resources\\Icons\\%(RecursiveDir)%(Filename)%(Extension)\" /> </ItemGroup> <!-- Tool Manifests --> <ItemGroup> <EmbeddedResource Include=\"..\\Tools\\**\\manifest.yml\" LogicalName=\"DBTools.ToolManifests.%(RecursiveDir)%(Filename)%(Extension)\" /> </ItemGroup> Source: csharp/src/DBTools.App/DBTools.App.csproj:61-78, 218-222 Step 11: Testing Setup Test Project Structure csharp/src/Tools/<Category>/<ToolName>/Tests/ DBTools.<ToolName>.Tests.csproj MyToolCommandTests.cs MyServiceTests.cs Test Project File <Project Sdk=\"Microsoft.NET.Sdk\"> <PropertyGroup> <TargetFramework>net8.0-windows</TargetFramework> <IsPackable>false</IsPackable> <Nullable>enable</Nullable> <ImplicitUsings>enable</ImplicitUsings> </PropertyGroup> <ItemGroup> <PackageReference Include=\"Microsoft.NET.Test.Sdk\" /> <PackageReference Include=\"xunit\" /> <PackageReference Include=\"xunit.runner.visualstudio\" /> <PackageReference Include=\"NSubstitute\" /> </ItemGroup> <ItemGroup> <ProjectReference Include=\"..\\..\\..\\..\\DBTools.App\\DBTools.App.csproj\" /> <ProjectReference Include=\"..\\..\\..\\..\\testing\\TestSupport\\DBTools.TestSupport.csproj\" /> </ItemGroup> </Project> Running Tests # Run all tests for a tool bash csharp/invoke-revit-tests.sh --smart --tool MyTool -y 2025 # Run specific test bash csharp/invoke-revit-tests.sh --smart -f \"FullyQualifiedName~MyTestName\" Common Patterns and Best Practices 1. Service Extension Pattern Centralize DI registration in an extension method: // Bootstrap/MyToolServiceExtensions.cs namespace DBTools.MyTool.Bootstrap; public static class MyToolServiceExtensions { public static IServiceCollection AddMyToolServices(this IServiceCollection services) { Guard.NotNull(services, nameof(services)); services.AddScoped<IMyService, MyService>(); services.AddScoped<MyOtherService>(); return services; } } Then in ToolModule: services.AddMyToolServices(); Source: csharp/src/Tools/Common/GM/Bootstrap/GmServiceExtensions.cs:1-16 2. Error Handling Never swallow exceptions. Use ISafeExecutor for top-level error handling (provided by DbtToolCommand): // DON'T do this: try { DoWork(); } catch { } // Silent failure // DO this: // Exceptions propagate to DbtToolCommand's ISafeExecutor DoWork(); // Let exceptions propagate 3. Logging Use the injected logger, not Console.WriteLine: var logger = context.Logger; logger.LogDebug(\"[MyTool] Processing {Count} elements\", count); logger.LogWarning(\"[MyTool] Skipped invalid element {Id}\", elementId); logger.LogError(ex, \"[MyTool] Failed to process\"); 4. Transactions Always name transactions descriptively: await tx.RunAsync(doc, \"DB Tools - My Tool Operation\", d => { // Modifications here }).ConfigureAwait(false); 5. Icon Naming Main icon: my_tool.png (32x32) Small icon: my_tool_16.png (16x16, optional) Match the iconBaseKey in manifest (without extension) 6. Namespace Conventions DBTools.<ToolName> # Root namespace DBTools.<ToolName>.Bootstrap # DI extensions DBTools.<ToolName>.Features # Commands and feature logic DBTools.<ToolName>.Features.Commands # Revit commands DBTools.<ToolName>.Features.Logic # Business logic DBTools.<ToolName>.Shell # Application shell DBTools.<ToolName>.Shell.DI # Detailed DI registrations DBTools.<ToolName>.Shell.UI # Views and ViewModels DBTools.<ToolName>.Shell.DesignTime # Design-time ViewModels DBTools.<ToolName>.Shared # Shared types/contracts Checklist: New Tool Completion [ ] Created directory structure under csharp/src/Tools/<Category>/<ToolName>/ [ ] Added manifest.yml with unique id and valid ribbonTools [ ] Created <ToolName>ToolModule.cs extending DbtToolModule [ ] Implemented command(s) extending DbtToolCommand [ ] Added icon(s) in Assets/ folder [ ] Created .csproj file for IDE support [ ] Build passes: bash csharp/build.sh [ ] Tool appears in Revit ribbon [ ] Command executes successfully [ ] (Optional) Created test project [ ] (Optional) Added UI with design-time preview Cross-References Architecture Overview DI Container Guide UI Theming Guide Testing Guide"
  },
  "articles/projects/app.html": {
    "href": "articles/projects/app.html",
    "title": "DBTools.App | DBTools Developer Documentation",
    "summary": "DBTools.App Purpose: Main application assembly containing all tools and bootstrapping logic. Output: DBTools.dll Target Frameworks: net48, net8.0-windows Overview DBTools.App is the main application assembly that compiles to DBTools.dll. It is loaded by DBTools.Loader and serves as the host for all tool implementations, the dependency injection container, ribbon composition, and Revit lifecycle management. This project uses file linking to compile tool source code from src/Tools/ into the single DBTools.dll assembly. Individual tool projects exist primarily for IDE organization, isolated testing, and XAML designer support, but at runtime everything executes within this unified assembly. Source: csharp/src/DBTools.App/DBTools.App.csproj:1-13 Responsibilities Responsibility Implementation Application entry point AddinEntry implements IExternalApplication Runtime initialization AppRuntimeFactory creates DiAppRuntime DI container setup DbtServiceBootstrapper.Build() registers all services Tool discovery DbtToolModuleCatalog.Discover() scans embedded YAML manifests Ribbon composition DbtRibbonComposer creates tab, panels, and buttons Hook coordination DbtHookHost dispatches view-activated and contextual ribbon events Test API hosting TestApiHost enables API calls from test harnesses File-linked tool compilation MSBuild items compile src/Tools/**/*.cs into this assembly Source: csharp/src/DBTools.App/Addin/AddinEntry.cs:29-247 Key Components AddinEntry (Application Entry Point) The AddinEntry class is the inner application entry point, loaded by DBTools.Loader.AddinEntry after assembly resolution is configured. public class AddinEntry : IExternalApplication { public static IRevitTask? RevitTask { get; private set; } private static DbtHookHost? _hookHost; private static DbtToolRegistry? _toolRegistry; private static DbtRibbonComposer? _ribbonComposer; public Result OnStartup(UIControlledApplication application) { ... } public Result OnShutdown(UIControlledApplication application) { ... } } Source: csharp/src/DBTools.App/Addin/AddinEntry.cs:29-43 Key Static Fields: RevitTask - The IRevitTask for marshaling work to Revit's UI thread _hookHost - Coordinates view-activated and contextual ribbon hooks _toolRegistry - Registry of discovered tool commands _ribbonComposer - Manages ribbon tab/panel creation Source: csharp/src/DBTools.App/Addin/AddinEntry.cs:33-36 Bootstrap System AppRuntimeFactory Factory class that creates the application runtime: public static class AppRuntimeFactory { public static IAppRuntime Create() => new DiAppRuntime(); } Source: csharp/src/DBTools.App/Bootstrap/AppRuntimeFactory.cs:5-8 DiAppRuntime The DI-based implementation of IAppRuntime that owns the service provider: public sealed class DiAppRuntime : IAppRuntime { private readonly IServiceProvider _root; public DiAppRuntime() { var root = DbtServiceBootstrapper.Build(); _root = root.Services; _logger = _root.GetRequiredService<ILogger<DiAppRuntime>>(); _settings = _root.GetRequiredService<ISettingsProvider>(); } public IAppRunScope CreateRunScope(UIApplication uiapp, RevitRunScopeProfile profile) { var scope = _root.GetRequiredService<IServiceScopeFactory>().CreateScope(); var rsFactory = scope.ServiceProvider.GetRequiredService<IRevitRunScopeFactory>(); var accessor = scope.ServiceProvider.GetRequiredService<IRevitRunScopeAccessor>(); var rs = rsFactory.CreateScope(uiapp, profile); accessor.Current = rs; return new DiRunScope(scope); } } Source: csharp/src/DBTools.App/Bootstrap/DiAppRuntime.cs:17-62 DbtServiceBootstrapper The central DI container builder that registers all services: public static class DbtServiceBootstrapper { public static DbtServiceRoot Build(Action<IServiceCollection>? configure = null) { // 1. Create logging host // 2. Load configuration from settings.json // 3. Register core services // 4. Discover and register tool modules // 5. Start hosted services } } Source: csharp/src/DBTools.App/Bootstrap/DbtServiceBootstrapper.cs:163-248 Service Categories Registered: Logging - IDbtLoggingHost, ILoggerFactory, ILogger<T> Debug - IDebugModeService (session-only) Settings - IOptionsMonitor<T>, IOptionsWriter, ISettingsProvider Revit Scope - IRevitRunScopeFactory, IRevitRunScopeAccessor, IRevitCallGate Transactions - ITransactionRunner, ITransactionGroupService Execution - ISafeExecutor, IAlertService Hosted Services - ILoggerWindowManager, HostedServiceCoordinator Source: csharp/src/DBTools.App/Bootstrap/DbtServiceBootstrapper.cs:376-437 DbtServiceRoot Container holding all initialized services: public sealed class DbtServiceRoot { public IServiceProvider Services { get; } public IConfiguration Configuration { get; } public IDbtLoggingHost LoggingHost { get; } public DbtToolRegistry ToolRegistry { get; } public IReadOnlyList<DbtToolModule> ToolModules { get; } } Source: csharp/src/DBTools.App/Bootstrap/DbtServiceBootstrapper.cs:34-67 Ribbon Composition DbtRibbonComposer Composes the DB Tools ribbon from tool specifications: public sealed class DbtRibbonComposer : IDisposable { public void Compose(DbtToolRegistry registry, Flags flags) { // 1. Create ribbon tab // 2. Create panels in defined order // 3. Build control plans for each tool // 4. Execute plans in order (push buttons, split buttons, pulldowns, stacked) // 5. Subscribe to settings changes } } Source: csharp/src/DBTools.App/Features/Ribbon/DbtRibbonComposer.cs:19-102 Control Kind Description PushButton Standard button SplitButtonItem Primary + dropdown items PulldownButtonItem Dropdown menu StackedButtonItem 2-3 buttons in vertical stack Source: csharp/src/DBTools.App/Features/Ribbon/DbtRibbonComposer.cs:159-252 Panel Order: Settings Common Structural Testing Any additional panels (alphabetical) Source: csharp/src/DBTools.App/Features/Ribbon/DbtRibbonComposer.cs:109-121 RibbonDefinition Defines ribbon constants (tab name, panel names, command names): public static class RibbonDefinition { public const string TabName = SettingsConstants.Ribbon.TabName; public static class Panels { public const string Settings = SettingsConstants.Ribbon.Panels.Settings; public const string Structural = SettingsConstants.Ribbon.Panels.Structural; public const string Testing = SettingsConstants.Ribbon.Panels.Testing; public const string Common = SettingsConstants.Ribbon.Panels.Common; } } Source: csharp/src/DBTools.App/Features/Ribbon/RibbonDefinition.cs:5-21 Availability Predicates Located in Tools/Availability/, these classes control when ribbon buttons are enabled. DbtDocumentAvailability Requires an active document to be open: public sealed class DbtDocumentAvailability : IExternalCommandAvailability { public bool IsCommandAvailable(UIApplication applicationData, CategorySet selectedCategories) { return applicationData?.ActiveUIDocument?.Document != null; } } Source: csharp/src/DBTools.App/Tools/Availability/DbtDocumentAvailability.cs:10-16 DbtSelectionAvailability Base class requiring element selection, with optional category filtering: public class DbtSelectionAvailability : IExternalCommandAvailability { protected virtual BuiltInCategory[]? RequiredCategories => null; protected virtual bool IsElementMatch(Element element) => true; public bool IsCommandAvailable(UIApplication applicationData, CategorySet selectedCategories) { // Check for selection and optional category/element matching } } Source: csharp/src/DBTools.App/Tools/Availability/DbtSelectionAvailability.cs:13-52 DbtStructuralFramingSelectionAvailability Requires structural framing selection: public sealed class DbtStructuralFramingSelectionAvailability : DbtSelectionAvailability { protected override BuiltInCategory[]? RequiredCategories => new[] { BuiltInCategory.OST_StructuralFraming }; } Source: csharp/src/DBTools.App/Tools/Availability/DbtSelectionAvailability.cs:57-60 Hooks System AppHookModule The application-level hook module that registers view-activated handlers: public sealed class AppHookModule : DbtToolModule { public override void RegisterServices(IServiceCollection services, DbtToolManifest manifest) { services.AddSingleton<ViewActivatedHookHandler, ViewActivatedHookHandler>(); } public override void RegisterHooks(DbtToolRegistry registry, DbtToolManifest manifest) { registry.RegisterHook<IViewActivatedHookHandler, ViewActivatedHookHandler>(); } } Source: csharp/src/DBTools.App/Features/Hooks/AppHookModule.cs:7-22 TestApiHost Static host for test harness integration, providing API access outside Revit command context: public static class TestApiHost { public static bool IsInitialized { get; private set; } public static void Initialize(UIControlledApplication app) { // Create ExternalEvent handler and UIApplication.Idling subscription } public static Task<object?> RunAsync(Func<object, Task<object?>> work) { // Queue work and raise ExternalEvent } } Source: csharp/src/DBTools.App/Addin/TestApiHost.cs:9-123 OnStartup Sequence The complete startup flow with source references: 1. Set Revit year from VersionNumber (for per-instance log files) > Source: AddinEntry.cs:55-66 2. Initialize AppRuntime via AppRuntimeFactory.Create() > Source: AddinEntry.cs:72 3. Resolve ISafeExecutor, DbtToolRegistry, DbtHookHost > Source: AddinEntry.cs:74-76 4. Validate theme (mandatory - fails startup if broken) > Source: AddinEntry.cs:106-113 5. Detect RevitTest environment > Source: AddinEntry.cs:116, 573-629 6. Register deferred UI startup handlers (ApplicationInitialized, Idling) > Source: AddinEntry.cs:125-127 7. Execute startup task via ISafeExecutor.RunAsync: a. Try binding global window owner (may be deferred) b. Initialize DialogGuardianHook c. Initialize RevitTaskService (if not RevitTest) d. Attach DbtHookHost (if not RevitTest) e. Initialize TestApiHost (if not RevitTest) > Source: AddinEntry.cs:133-178 8. Create ribbon synchronously (Revit API requirement): a. Get Flags settings b. Create DbtRibbonComposer c. Call Compose() with registry and flags d. Publish warning changes > Source: AddinEntry.cs:217-244 9. Return Result.Succeeded > Source: AddinEntry.cs:246 Deferred UI Startup Certain operations run after ApplicationInitialized/Idling to ensure Revit is fully ready: private static Task RunDeferredUiStartupAsync(...) { return executor.RunAsync(async () => { // 1. Ensure global window owner is bound await EnsureGlobalWindowOwnerBoundAsync(logger); // 2. Apply ribbon special effects (visual styling) await RibbonSpecialEffects.ApplyAsync(logger); // 3. Show logger window if debug mode enabled loggerWindowManager.ShowIfDebugEnabled(); }, ...); } Source: csharp/src/DBTools.App/Addin/AddinEntry.cs:421-479 OnShutdown Sequence 1. Wait for startup task completion (5s timeout) > Source: AddinEntry.cs:265-274 2. Unregister deferred UI handlers > Source: AddinEntry.cs:276 3. Detach DbtHookHost > Source: AddinEntry.cs:278 4. Shutdown DialogGuardianHook > Source: AddinEntry.cs:281 5. Shutdown TestApiHost > Source: AddinEntry.cs:284 6. Dispose RevitTaskService > Source: AddinEntry.cs:287 7. Dispose DbtRibbonComposer > Source: AddinEntry.cs:292 8. Stop hosted services > Source: AddinEntry.cs:303 9. Dispose logging host > Source: AddinEntry.cs:306 Source: csharp/src/DBTools.App/Addin/AddinEntry.cs:250-325 File Linking Strategy DBTools.App compiles tool source code via MSBuild file linking. Source files remain in their respective src/Tools/ directories but are compiled into the single DBTools.dll assembly. Source File Linking <ItemGroup Label=\"Tool Source Files\"> <Compile Include=\"..\\Tools\\**\\*.cs\" Exclude=\"..\\Tools\\**\\Tests\\**\\*.cs;..\\Tools\\**\\obj\\**\\*.cs\" Link=\"Tools\\%(RecursiveDir)%(Filename)%(Extension)\" /> </ItemGroup> Source: csharp/src/DBTools.App/DBTools.App.csproj:63-67 XAML File Linking <ItemGroup Label=\"Tool XAML Files\"> <Page Include=\"..\\Tools\\**\\*.xaml\" Exclude=\"..\\Tools\\**\\obj\\**\\*.xaml;..\\Tools\\**\\Properties\\DesignTimeResources.xaml\" Link=\"Tools\\%(RecursiveDir)%(Filename)%(Extension)\" /> </ItemGroup> Source: csharp/src/DBTools.App/DBTools.App.csproj:69-73 Tool Assets (Embedded Icons) <ItemGroup Label=\"Tool Embedded Assets\"> <EmbeddedResource Include=\"..\\Tools\\**\\Assets\\*.png\" Link=\"Resources\\Icons\\%(RecursiveDir)%(Filename)%(Extension)\" /> </ItemGroup> Source: csharp/src/DBTools.App/DBTools.App.csproj:75-78 Tool Manifests (Embedded YAML) <ItemGroup> <EmbeddedResource Include=\"manifest.yml\" LogicalName=\"DBTools.ToolManifests.DBTools.AppHooks.yml\" /> <EmbeddedResource Include=\"..\\Tools\\**\\manifest.yml\" LogicalName=\"DBTools.ToolManifests.%(RecursiveDir)%(Filename)%(Extension)\" /> </ItemGroup> Source: csharp/src/DBTools.App/DBTools.App.csproj:218-222 Why File Linking? Single assembly deployment - Reduces complexity and potential conflicts IDE organization - Tools can have separate projects for development Isolated testing - Test projects reference tool projects directly XAML designer support - Individual projects can have design-time resources Tool Module Discovery Tools are discovered via embedded YAML manifests during DbtServiceBootstrapper.Build(): var rootAssembly = typeof(DbtServiceBootstrapper).Assembly; var discovery = DbtToolModuleCatalog.Discover(rootAssembly); foreach (var entry in discovery.Entries) { var module = entry.Module; module.RegisterSettings(services, configuration, entry.Manifest); module.RegisterServices(services, entry.Manifest); module.RegisterSettingsPacks(services, entry.Manifest); module.RegisterHooks(registry, entry.Manifest); RegisterRibbonToolsFromManifest(registry, rootAssembly, entry.Manifest); } Source: csharp/src/DBTools.App/Bootstrap/DbtServiceBootstrapper.cs:194-237 Manifest Structure Example tool manifest (manifest.yml): id: DBTools.GM assembly: DBTools moduleType: DBTools.GM.GmToolModule order: 0 sandboxWindows: - id: DBTools.GM.Main displayName: \"Global Mapper\" windowType: \"DBTools.GM.Shell.UI.Views.GmWindow\" tool: ribbonTools: - internalName: DBTools.GM commandType: DBTools.GM.Features.GmCommand availabilityType: DBTools.App.Tools.Availability.DbtDocumentAvailability runProfile: InlineUi displayText: \"Global Mapper\" iconBaseKey: gm tooltip: \"Open Global Mapper\" controlKind: PushButton order: 30 Source: csharp/src/Tools/Common/GM/manifest.yml:1-27 Dependencies Project References Project Purpose DBTools.Core Core infrastructure and abstractions DBTools.Themes WPF theme resources Source: csharp/src/DBTools.App/DBTools.App.csproj:57-59 NuGet Packages Package Purpose Microsoft.Extensions.DependencyInjection DI container Microsoft.Extensions.Options.ConfigurationExtensions Options pattern Microsoft.Extensions.Configuration.* Configuration binding ricaun.Revit.UI Ribbon utilities ricaun.Revit.UI.Tasks RevitTask for async CommunityToolkit.Mvvm MVVM for tools JsonDiffPatch.Net JSON diff (tools) AutoMapper Object mapping (tools) HelixToolkit.Wpf.SharpDX 3D visualization (tools) Source: csharp/src/DBTools.App/DBTools.App.csproj:27-87 Vendored Assemblies Assembly Purpose DBTools.Fluent.Ribbon Ribbon UI for tool windows DBTools.ControlzEx Window chrome and behaviors Source: csharp/src/DBTools.App/DBTools.App.csproj:89-98 Revit API References net48: <Reference Include=\"RevitAPI\"> <HintPath>$(REVIT2024_DIR)\\RevitAPI.dll</HintPath> <Private>false</Private> </Reference> Source: csharp/src/DBTools.App/DBTools.App.csproj:114-134 net8.0-windows: <Reference Include=\"RevitAPI\" Condition=\"'$(REVIT_NET8_DIR)'!=''\"> <HintPath>$(REVIT_NET8_DIR)\\RevitAPI.dll</HintPath> <Private>false</Private> </Reference> Source: csharp/src/DBTools.App/DBTools.App.csproj:143-165 Assembly Embedding All CopyLocal dependencies (except forbidden host assemblies) are embedded as resources for single-DLL deployment: <Target Name=\"DBT_EmbedCopyLocalAssemblies\" AfterTargets=\"ResolveReferences\"> <ItemGroup> <_EmbedCandidate Include=\"@(ReferenceCopyLocalPaths)\" ... /> <!-- Exclude Revit host assemblies --> <_EmbedCandidate Remove=\"...\" Condition=\"'%(Filename)%(Extension)' == 'RevitAPI.dll'\" /> <!-- Exclude WPF theme assemblies (need file Location for pack:// URIs) --> <_EmbedCandidate Remove=\"...\" Condition=\"StartsWith('DBTools.Fluent.Ribbon')\" /> </ItemGroup> <EmbeddedResource Include=\"%(_EmbedLogicalDistinct.SourcePath)\" LogicalName=\"DBTools.EmbeddedAssemblies.%(Name).dll\" /> </Target> Source: csharp/src/DBTools.App/DBTools.App.csproj:234-270 Forbidden Host Assemblies These assemblies must never be in the output (Revit provides them): <ItemGroup> <ForbiddenHostAssembly Include=\"RevitAPI.dll\" /> <ForbiddenHostAssembly Include=\"RevitAPIUI.dll\" /> <ForbiddenHostAssembly Include=\"AdWindows.dll\" /> <ForbiddenHostAssembly Include=\"UIFramework.dll\" /> <ForbiddenHostAssembly Include=\"Newtonsoft.Json.dll\" /> </ItemGroup> Source: csharp/src/DBTools.App/DBTools.App.csproj:169-177 Build Configuration Project Properties <PropertyGroup> <TargetFrameworks>$(DBT_RevitTargetFrameworks)</TargetFrameworks> <AssemblyName>DBTools</AssemblyName> <RootNamespace>DBTools.App</RootNamespace> <UseWPF>true</UseWPF> <ILRepackEnabled>false</ILRepackEnabled> </PropertyGroup> Source: csharp/src/DBTools.App/DBTools.App.csproj:2-13 InternalsVisibleTo Test assemblies can access internal types: <ItemGroup> <InternalsVisibleTo Include=\"DBTools.GM.Tests\" /> <InternalsVisibleTo Include=\"DBTools.SGT.Tests\" /> <InternalsVisibleTo Include=\"DBTools.TDV.Tests\" /> <InternalsVisibleTo Include=\"DBTools.Testing.Tests\" /> </ItemGroup> Source: csharp/src/DBTools.App/DBTools.App.csproj:15-20 Warning Suppressions Tool code suppressions consolidated from individual tool projects: <NoWarn>$(NoWarn);CS0618;CS0649;CS8600;CS8602;CS8603;CS8604;CS8619;CS8620; MA0038;MA0051;MA0048;MA0016;MA0098;MA0004;MA0008;MA0015; CA1068;CA1707;CA1716;CA1720;CA1722;CA1725;CA1822</NoWarn> Source: csharp/src/DBTools.App/DBTools.App.csproj:136-138 File Structure csharp/src/DBTools.App/ +-- DBTools.App.csproj +-- manifest.yml # AppHooks module manifest +-- GlobalUsings.cs +-- GlobalSuppressions.cs +-- AssemblyInfo.cs +-- Addin/ | +-- AddinEntry.cs # IExternalApplication entry point | +-- TestApiHost.cs # Test harness API host +-- Bootstrap/ | +-- AppRuntimeFactory.cs # Creates DiAppRuntime | +-- DiAppRuntime.cs # IAppRuntime implementation | +-- DbtServiceBootstrapper.cs # DI container builder | +-- Startup.cs # Legacy startup helper +-- Features/ | +-- Hooks/ | | +-- AppHookModule.cs # Application-level hooks | | +-- ViewActivatedHookHandler.cs | | +-- DialogGuardianHook.cs | +-- Ribbon/ | +-- DbtRibbonComposer.cs # Ribbon composition | +-- RibbonDefinition.cs # Tab/panel constants | +-- RibbonRegistry.cs # Runtime button registry | +-- RibbonSettingsListener.cs | +-- RibbonSpecialEffects.cs | +-- RevitRibbonBuilder.cs +-- Tools/ | +-- Availability/ | +-- DbtDocumentAvailability.cs | +-- DbtSelectionAvailability.cs | +-- DbtActiveViewAvailability.cs +-- Resources/ +-- (Ribbon icons - embedded resources) RevitTest Environment Detection AddinEntry detects when running under ricaun.RevitTest and adjusts behavior: private static bool DetectRevitTestEnvironment(UIControlledApplication application, ILogger logger) { bool hostBoundToRevitTest = RevitTaskAccessor.RevitTask != null; bool hasRevitTestAssembly = AppDomain.CurrentDomain.GetAssemblies() .Any(a => a.GetName().Name == \"ricaun.RevitTest.Application\" || a.GetName().Name == \"ricaun.RevitTest\"); bool isRevitTestFlag = RevitExecutionContext.IsRevitTest; return hostBoundToRevitTest || hasRevitTestAssembly || isRevitTestFlag; } Source: csharp/src/DBTools.App/Addin/AddinEntry.cs:573-629 Skipped in RevitTest: RevitTaskService initialization (test host provides its own) DbtHookHost attachment TestApiHost initialization Error Handling Startup Errors Fatal errors during startup show a message box and return Result.Failed: private static void TryShowStartupError(string message) { // Try WPF MessageBox first MessageBox.Show(message, \"DB Tools\", MessageBoxButton.OK, MessageBoxImage.Error, ...); // Fall back to Win32 MessageBoxW if WPF fails MessageBoxW(IntPtr.Zero, text, caption, MB_OK | MB_ICONERROR); } Source: csharp/src/DBTools.App/Addin/AddinEntry.cs:481-535 Theme Validation Theme validation is mandatory - if it fails, startup aborts: try { DbtThemeValidator.ValidateOrThrow(); } catch (Exception ex) { logger.LogError(ex, \"[AddinEntry] Theme validation failed; aborting add-in startup.\"); TryShowStartupError($\"DB Tools theme failed to load:\\n\\n{ex.GetBaseException().Message}\"); return Result.Failed; } Source: csharp/src/DBTools.App/Addin/AddinEntry.cs:104-113 Troubleshooting \"Theme validation failed\" Error Cause: WPF theme assemblies (Fluent.Ribbon, ControlzEx) not found. Solution: Ensure %APPDATA%/DBTools/vendor/ contains theme assemblies Or rebuild with bash csharp/build.sh --clean BuildAll Ribbon Not Appearing Possible Causes: Tool manifests not embedded (check build output) Tool command type not found (check namespace/assembly in manifest) Availability type resolution failed (check availabilityType in manifest) Diagnosis: Enable debug mode and check log file for errors during Compose(). Tools Disabled Unexpectedly Check: Availability predicate in manifest.yml Flags settings (some tools check flags.EnableTesting) IExternalCommandAvailability implementation returning false Related Documentation Architecture Overview - High-level system architecture Project References - How projects relate DBTools.Loader - Bootstrap assembly that loads DBTools.App DBTools.Core - Core infrastructure library Source Files Reviewed File Purpose csharp/src/DBTools.App/DBTools.App.csproj Project configuration csharp/src/DBTools.App/Addin/AddinEntry.cs Application entry point csharp/src/DBTools.App/Addin/TestApiHost.cs Test harness API csharp/src/DBTools.App/Bootstrap/AppRuntimeFactory.cs Runtime factory csharp/src/DBTools.App/Bootstrap/DiAppRuntime.cs DI-based runtime csharp/src/DBTools.App/Bootstrap/DbtServiceBootstrapper.cs DI container builder csharp/src/DBTools.App/Bootstrap/Startup.cs Legacy startup helper csharp/src/DBTools.App/Features/Ribbon/DbtRibbonComposer.cs Ribbon composition csharp/src/DBTools.App/Features/Ribbon/RibbonDefinition.cs Ribbon constants csharp/src/DBTools.App/Features/Hooks/AppHookModule.cs Application hooks csharp/src/DBTools.App/Tools/Availability/DbtDocumentAvailability.cs Document availability csharp/src/DBTools.App/Tools/Availability/DbtSelectionAvailability.cs Selection availability csharp/src/DBTools.App/manifest.yml AppHooks manifest csharp/src/Tools/Common/GM/manifest.yml Example tool manifest csharp/src/DBTools.Core/Tools/DbtHookHost.cs Hook coordination (Core) UNVERIFIED Items"
  },
  "articles/projects/core.html": {
    "href": "articles/projects/core.html",
    "title": "DBTools.Core | DBTools Developer Documentation",
    "summary": "DBTools.Core DBTools.Core is the foundational library providing shared infrastructure for all DBTools components. It contains Revit execution abstractions, transaction management, safe execution patterns, logging infrastructure, settings management, tool module system, and shared UI components. Overview DBTools.Core serves as the central infrastructure layer, abstracting away Revit API complexities while providing consistent patterns for error handling, logging, and dependency injection across all tools. Property Value Assembly Name DBTools.Core.dll Target Frameworks net48, net8.0-windows WPF Support Yes (UseWPF=true) Nullable Enabled Source: csharp/src/DBTools.Core/DBTools.Core.csproj:1-10 Responsibilities Revit Execution Abstraction - Thread-safe API access via call gates and run scopes Transaction Management - Unified transaction/subtransaction handling with automatic rollback Safe Execution - Centralized error handling with user notification and logging Logging Infrastructure - Serilog-based structured logging with UI sink Settings System - Type-safe options pattern with persistence and validation Tool Module System - Discovery, registration, and lifecycle management for tools Shared UI Components - Window bases, alert dialogs, progress overlays, and behaviors Key Components Revit Execution Layer IRevitCallGate The unified entry point for executing Revit API callbacks, supporting both inline (modal) and queued (modeless) execution modes. public interface IRevitCallGate { bool InGate { get; } Task<T> RunAsync<T>(Func<UIApplication, T> work, CancellationToken ct = default, RevitCallMode mode = RevitCallMode.Auto); Task RunAsync(Action<UIApplication> work, CancellationToken ct = default, RevitCallMode mode = RevitCallMode.Auto); } Source: csharp/src/DBTools.Core/Revit/Execution/IRevitCallGate.cs:8-28 Mode Description Auto Execute inline if valid context exists; otherwise queue InlineOnly Execute inline only; throw if context unavailable ForceQueue Always queue via ExternalEvent/RevitTask RequiresActiveView Require an active UIDocument before executing Source: csharp/src/DBTools.Core/Revit/Execution/IRevitCallGate.cs:30-51 IRevitRunScope Represents a single Revit run scope (command, modeless session, or test). Owns UI/document context plus call gate and transaction services. public interface IRevitRunScope { UIApplication UIApplication { get; } IRevitCallGate CallGate { get; } ITransactionRunner TransactionRunner { get; } ITransactionGroupService TransactionGroupService { get; } UIDocument GetActiveUiDocument(); Document GetActiveDocument(); Document GetLockedDocument(Document expectedDocument, string? context = null); } Source: csharp/src/DBTools.Core/Revit/Execution/IRevitRunScope.cs:11-20 Profile Use Case Implementation InlineUi Modal commands and RevitTest ModalInlineCallGate + CallGateTransactionRunner QueuedModeless Long-running/modeless tools ModelessQueuedCallGate + RevitTaskService Source: csharp/src/DBTools.Core/Revit/Execution/IRevitRunScope.cs:22-36 ModalInlineCallGate Call-gate implementation that executes delegates inline on the Revit UI thread using a supplied UIApplication. Used for modal command execution. public sealed class ModalInlineCallGate : IRevitCallGate { public ModalInlineCallGate(UIApplication uiapp) { ... } public bool InGate => _inGate.Value; public Task<T> RunAsync<T>(Func<UIApplication, T> work, ...) { ... } } Source: csharp/src/DBTools.Core/Revit/Execution/ModalInlineCallGate.cs:10-74 Transaction Management ITransactionRunner Provides a unified API for executing Revit model modifications with automatic transaction management. public interface ITransactionRunner { Task RunAsync(string name, Action action, CancellationToken ct = default); Task<T> RunAsync<T>(string name, Func<T> action, CancellationToken ct = default); Task RunAsync(string name, Action<Document> action, CancellationToken ct = default); Task<T> RunAsync<T>(string name, Func<Document, T> action, CancellationToken ct = default); // Additional overloads with UIApplication access and explicit Document } Source: csharp/src/DBTools.Core/Revit/Transactions/ITransactionRunner.cs:6-53 CallGateTransactionRunner The primary implementation that wraps all Revit API calls in properly managed transactions: Auto-selects transaction type: Uses SubTransaction if doc.IsModifiable (already in transaction), otherwise creates new Transaction Cross-document protection: Prevents starting transactions on Document B while Document A is modifiable Failure handling: Attaches SilentFailuresPreprocessor to suppress non-critical Revit warnings Source: csharp/src/DBTools.Core/Revit/Transactions/CallGateTransactionRunner.cs:9-390 Usage Example: // Basic modification with automatic transaction await _transactionRunner.RunAsync(\"Create Wall\", doc => { Wall.Create(doc, curve, levelId, false); }); // Get a result from a transaction var wallId = await _transactionRunner.RunAsync(\"Create Wall\", doc => { var wall = Wall.Create(doc, curve, levelId, false); return wall.Id; }); Source: csharp/src/DBTools.Core/Revit/Transactions/CallGateTransactionRunner.cs:64-79 ITransactionGroupService Manages transaction groups for operations requiring multiple undoable transactions to appear as a single undo item. public interface ITransactionGroupService { bool IsActive { get; } Task BeginAsync(string name, CancellationToken ct = default); Task FinalizeAsync(bool commit, CancellationToken ct = default); Task RunAsync(string name, bool commit, Func<Task> work, CancellationToken ct = default); } Source: csharp/src/DBTools.Core/Revit/Transactions/ITransactionGroupService.cs:1-14 Safe Execution ISafeExecutor The central error handling service. All tool entrypoints must execute within ISafeExecutor. public interface ISafeExecutor { Task RunAsync(Func<Task> action, ILogger logger, IErrorNotifier? notifier = null, CancellationToken ct = default); Task RunAsync(Func<Task> action, ILogger logger, IErrorNotifier? notifier, SafeExecutor.SafeExecuteOptions? opts, CancellationToken ct = default); } Source: csharp/src/DBTools.Core/Execution/ISafeExecutor.cs:6-16 SafeExecutor Implementation Provides comprehensive error handling: Correlation IDs: Each execution gets a unique GUID for log correlation Timing: Tracks elapsed milliseconds for performance analysis Exception logging: Logs full exception details including inner exceptions and XAML parse context User notification: Shows error banners via IErrorNotifier Debug mode: Automatically enables debug mode and shows logger window on fatal errors Lifecycle hooks: Optional OnSuccessAsync, OnCancelAsync, OnErrorAsync callbacks Source: csharp/src/DBTools.Core/Execution/SafeExecutor.cs:12-467 SafeExecuteOptions: public sealed class SafeExecuteOptions { public string? Name { get; set; } public bool LogStart { get; set; } = true; public bool ShowCompletionToUser { get; set; } public Guid? CorrelationId { get; set; } public Func<Task>? OnSuccessAsync { get; set; } public Func<Task>? OnCancelAsync { get; set; } public Func<Exception, Task>? OnErrorAsync { get; set; } public NotifyKindKind NotifyKind { get; set; } = NotifyKindKind.Success; } Source: csharp/src/DBTools.Core/Execution/SafeExecutor.cs:451-466 DbtToolCommand Base Class Abstract base class for Revit commands that enforces ISafeExecutor usage, run-scope creation, and centralized error notification. public abstract class DbtToolCommand : IExternalCommand { public Result Execute(ExternalCommandData commandData, ref string message, ElementSet elements) { // Wraps execution in ISafeExecutor, creates run scope } protected abstract Task RunAsync(IDbtToolContext context); // Convenience methods protected static T GetService<T>(IDbtToolContext context) where T : notnull; protected static Task<T> RunInRevitAsync<T>(IDbtToolContext context, Func<UIApplication, T> work, ...); protected static bool? ShowToolWindow<TWindow>(Func<TWindow> windowFactory) where TWindow : Window; } Source: csharp/src/DBTools.Core/Revit/Execution/DbtToolCommand.cs:35-238 Tool Context IDbtToolContext Ambient context provided to DBT tool commands, wrapping the current Revit run scope, DI scope, and shared services. public interface IDbtToolContext { ExternalCommandData CommandData { get; } UIApplication UIApplication { get; } UIDocument UIDocument { get; } Document Document { get; } IAppRunScope RunScope { get; } IRevitRunScope RevitRunScope { get; } ILogger Logger { get; } IErrorNotifier ErrorNotifier { get; } RevitRunScopeProfile RunProfile { get; } T Resolve<T>() where T : notnull; } Source: csharp/src/DBTools.Core/Revit/Execution/IDbtToolContext.cs:14-27 Runtime AppRuntime Static accessor for the application runtime. Provides global access to services when DI is not available (e.g., Revit's parameterless constructor requirement). public static class AppRuntime { public static bool IsInitialized { get; } public static void Initialize(IAppRuntime runtime); public static void InitializeIfNeeded(Func<IAppRuntime> factory); public static ILogger Logger { get; } public static ISettingsProvider Settings { get; } public static IAppRunScope CreateRunScope(UIApplication uiapp, RevitRunScopeProfile profile); public static T Resolve<T>() where T : notnull; } Source: csharp/src/DBTools.Core/Runtime/AppRuntime.cs:8-155 IAppRuntime Interface for the application runtime container. public interface IAppRuntime { ILogger Logger { get; } ISettingsProvider Settings { get; } IAppRunScope CreateRunScope(UIApplication uiapp, RevitRunScopeProfile profile); T Resolve<T>() where T : notnull; } Source: csharp/src/DBTools.Core/Runtime/IAppRuntime.cs:8-16 IAppRunScope Scoped DI container for per-command lifetimes. public interface IAppRunScope : IDisposable { T Resolve<T>() where T : notnull; } Source: csharp/src/DBTools.Core/Runtime/IAppRunScope.cs:5-8 Logging Infrastructure IDbtLoggingHost Central logging host that implements ILoggerFactory directly. public interface IDbtLoggingHost : ILoggerFactory, IDisposable { SerilogUiSink UiSink { get; } bool IsDebugMode { get; } void SetDebugMode(bool enabled); ILoggerFactory LoggerFactory { get; } string InstanceId { get; } int? RevitYear { get; } string? LogFilePath { get; } } Source: csharp/src/DBTools.Core/Logging/DbtLoggingHost.cs:21-33 DbtLoggingHost Implementation Features: Serilog integration: Uses Serilog with structured logging UI sink: Feeds log entries to the Logger Window File sink: Custom DbtTextFileSink avoids version conflicts with Serilog.Sinks.File Thread enrichment: Adds thread ID to all log entries Instance identification: Unique instance ID per Revit process Log rotation: Automatic cleanup of old log files by age, count, and total size Source: csharp/src/DBTools.Core/Logging/DbtLoggingHost.cs:35-226 Log File Naming: dbtools-{revitYear}-{instanceId}-{timestamp}-{nonce}.log Source: csharp/src/DBTools.Core/Logging/DbtLoggingHost.cs:88-100 Settings System ISettingsProvider Interface for reading and persisting settings. public interface ISettingsProvider { TSettings Get<TSettings>() where TSettings : class, new(); Task SaveAsync<TSettings>(string section, TSettings settings, CancellationToken ct = default) where TSettings : class; } Source: csharp/src/DBTools.Core/Settings/ISettingsProvider.cs:1-8 DbtSettingsRegistry Registry for settings pack definitions, enabling the Settings Window to discover and display tool-specific settings. public sealed class DbtSettingsRegistry { public IReadOnlyCollection<IDbtSettingsPackDefinition> Definitions { get; } public void Register(IDbtSettingsPackDefinition definition); public bool Unregister(string key); public IEnumerable<IDbtSettingsPackDefinition> ForPanel(string ribbonPanel); public IEnumerable<IDbtSettingsWarningDefinition> WarningDefinitions(); } Source: csharp/src/DBTools.Core/Settings/DbtSettingsRegistry.cs:8-62 DbtToolSettingsPack Generic container for tool settings with validation support. public sealed class DbtToolSettingsPack<TOptions> : IDbtToolSettingsPack { public string Key { get; } public string Title { get; } public string RibbonPanel { get; } public Type OptionsType { get; } public object Context { get; } public object CreateDefaultOptions(); public object BuildOptionsSnapshot(); public Task<DbtSettingsValidationResult> ValidateAsync(CancellationToken ct = default); public FrameworkElement View { get; } } Source: csharp/src/DBTools.Core/Settings/DbtToolSettingsPack.cs:37-85 Tool Module System DbtToolModule Base class for tool modules to contribute DI services and tool registrations. public abstract class DbtToolModule { public virtual void RegisterSettings(IServiceCollection services, IConfiguration configuration, DbtToolManifest manifest) { } public virtual void RegisterServices(IServiceCollection services, DbtToolManifest manifest) { } public virtual void RegisterSettingsPacks(IServiceCollection services, DbtToolManifest manifest) { } public virtual void RegisterHooks(DbtToolRegistry registry, DbtToolManifest manifest) { } } Source: csharp/src/DBTools.Core/Tools/DbtToolModule.cs:9-49 DbtToolRegistry Central registry for tool registrations and hook handlers. public sealed class DbtToolRegistry { public ReadOnlyCollection<DbtToolRegistration> Tools { get; } public IReadOnlyDictionary<Type, IReadOnlyCollection<Type>> HookRegistrations { get; } public void RegisterTool(DbtToolRegistration registration); public void RegisterHook<THook, TImplementation>() where THook : class where TImplementation : class, THook; public Type[] GetHookImplementations<THook>() where THook : class; } Source: csharp/src/DBTools.Core/Tools/DbtToolRegistry.cs:9-83 DbtToolRegistration Encapsulates a tool command registration with ribbon configuration. public sealed class DbtToolRegistration { public Type CommandType { get; } public Type? AvailabilityType { get; } public RevitRunScopeProfile RunProfile { get; } public DbtToolRibbonSpec Ribbon { get; } public Func<Flags, bool>? AvailabilityPredicate { get; init; } } Source: csharp/src/DBTools.Core/Tools/DbtToolRegistration.cs:8-38 DbtToolManifest YAML manifest structure for tool discovery. public sealed class DbtToolManifest { public string Id { get; set; } public string Assembly { get; set; } public string ModuleType { get; set; } public int? Order { get; set; } public List<DbtSandboxWindowManifest>? SandboxWindows { get; set; } public DbtToolMetadataManifest? Tool { get; set; } } Source: csharp/src/DBTools.Core/Tools/DbtToolManifest.cs:5-13 DbtHookHost Coordinates application-level hooks, dispatching events to registered handlers. Supported Hook Interfaces: IViewActivatedHookHandler - Called when views are activated IContextualRibbonInjector - For contextual ribbon panel initialization public sealed class DbtHookHost { public void Attach(UIControlledApplication application); public Task AttachAsync(UIControlledApplication application, CancellationToken ct); public void Detach(UIControlledApplication application); } Source: csharp/src/DBTools.Core/Tools/DbtHookHost.cs:28-244 UI Components DbtWindowBase Modal-first base window for DBT. Hosts the progress overlay and central UI error boundary. public class DbtWindowBase : Window, IWindowWithOwnerProvider, IThemeOptOut { public IWindowOwnerProvider? OwnerProvider { get; set; } public bool UseDefaultTheme { get; set; } } Source: csharp/src/DBTools.Core/UI/Windows/DbtWindowBase.cs:27-47 IAlertService Service for showing alert dialogs with various body types. public interface IAlertService { AlertResult Show(AlertRequest request); bool Confirm(string message, string title = \"DB Tools\"); T? SelectSingle<T>(IEnumerable<T> items, Func<T, string> displayFunc, ...); IReadOnlyList<T> SelectMultiple<T>(IEnumerable<T> items, Func<T, string> displayFunc, ...); } Source: csharp/src/DBTools.Core/UI/Alerts/Services/IAlertService.cs:5-26 IErrorNotifier Interface for displaying error/success banners to users. public interface IErrorNotifier { void ShowBanner(string title, string message); // Error (red) void ShowSuccessBanner(string title, string message); // Success (green) } Source: csharp/src/DBTools.Core/Execution/IErrorNotifier.cs:1-10 Dependencies NuGet Packages Package Purpose Newtonsoft.Json JSON serialization CSharpFunctionalExtensions Result types and functional patterns Ardalis.GuardClauses Argument validation AutoMapper Object mapping UnitsNet Units and measurements Serilog + extensions Structured logging Microsoft.Extensions.DependencyInjection Dependency injection Microsoft.Extensions.Configuration.* Configuration binding CommunityToolkit.Mvvm MVVM base classes DynamicData Reactive collections System.Reactive Reactive extensions Ookii.Dialogs.Wpf Native file dialogs ricaun.Revit.UI.Tasks Revit async task support Source: csharp/src/DBTools.Core/DBTools.Core.csproj:102-161 Vendored Assemblies Assembly Purpose DBTools.Fluent.Ribbon Ribbon UI for tool windows DBTools.ControlzEx Window chrome and behaviors Source: csharp/src/DBTools.Core/DBTools.Core.csproj:144-152 Project References Project Purpose DBTools.Themes WPF theme resources Source: csharp/src/DBTools.Core/DBTools.Core.csproj:165 Directory Structure DBTools.Core/ +-- Assets/ # Shared resources (icons) +-- Compat/ # Cross-framework compatibility utilities +-- Constants/ # Application-wide constants +-- Execution/ # Safe execution, error handling +-- Hosting/ # Service hosting infrastructure +-- IO/ # File system utilities +-- Logging/ # Serilog infrastructure, UI sink +-- Notifications/ # Banner notifications +-- Revit/ | +-- Context/ # Revit context accessors | +-- Execution/ # Call gates, run scopes, tool context | +-- Transactions/ # Transaction runners and groups | +-- Utilities/ # Revit helpers (RevitId, Failures, etc.) +-- Runtime/ # AppRuntime, IAppRunScope +-- Sandbox/ # Sandbox mode stubs +-- Settings/ # Settings infrastructure +-- Tools/ # Tool module system +-- UI/ +-- Alerts/ # Alert dialog system +-- Behaviors/ # WPF attached behaviors +-- Converters/ # Value converters +-- Icons/ # Icon loading +-- Progress/ # Progress overlay +-- Theming/ # Theme validation +-- Windows/ # Window base classes Public API Summary Revit Execution IRevitCallGate - Thread-safe Revit API execution IRevitRunScope - Command execution scope IRevitRunScopeFactory - Factory for run scopes DbtToolCommand - Base class for Revit commands IDbtToolContext - Command context interface Transaction Management ITransactionRunner - Transaction execution ITransactionGroupService - Transaction grouping Safe Execution ISafeExecutor - Centralized error handling IErrorNotifier - User notification Logging IDbtLoggingHost - Logging host interface ILogSink - Custom sink interface Settings ISettingsProvider - Settings access DbtSettingsRegistry - Settings pack registry IDbtToolSettingsPack - Settings pack interface Tool System DbtToolModule - Tool module base class DbtToolRegistry - Tool registration DbtToolManifest - Manifest structure DbtHookHost - Hook coordination UI DbtWindowBase - Window base class IAlertService - Alert dialogs IWindowOwnerProvider - Window ownership Usage Examples Creating a Tool Command public class MyToolCommand : DbtToolCommand { protected override async Task RunAsync(IDbtToolContext context) { var myService = context.Resolve<IMyService>(); // Execute Revit API work await context.RevitRunScope.TransactionRunner.RunAsync(\"My Operation\", doc => { // Modify document }); } } Using the Call Gate // Get element data from Revit (thread-safe) var result = await callGate.RunAsync(uiapp => { var doc = uiapp.ActiveUIDocument.Document; return doc.GetElement(elementId); }, ct, RevitCallMode.RequiresActiveView); Registering a Tool Module public class MyToolModule : DbtToolModule { public override void RegisterServices(IServiceCollection services, DbtToolManifest manifest) { services.AddSingleton<IMyService, MyService>(); } public override void RegisterHooks(DbtToolRegistry registry, DbtToolManifest manifest) { registry.RegisterHook<IViewActivatedHookHandler, MyViewHandler>(); } } Extension Points Custom Call Gates - Implement IRevitCallGate for specialized execution modes Hook Handlers - Register implementations of IViewActivatedHookHandler or IContextualRibbonInjector Settings Packs - Create DbtToolSettingsPack<T> instances for tool-specific settings UI Alert Bodies - Implement IAlertBody for custom alert dialog content Build Considerations Conditional Compilation Sandbox builds (DBT_IsSandboxBuild): Revit-dependent files excluded, sandbox stubs used Designer builds (DBT_IsDesignerBuild): Revit sources excluded for XAML designer wpftmp builds: Special handling for temporary projects during BAML compilation Source: csharp/src/DBTools.Core/DBTools.Core.csproj:12-99 InternalsVisibleTo Test projects and DBTools.App have access to internal types: DBTools.App DBTools.GM.Tests DBTools.SGT.Tests DBTools.TDV.Tests Source: csharp/src/DBTools.Core/DBTools.Core.csproj:27-32 Related Documentation Architecture Overview - System-wide architecture Project References - Inter-project dependencies DBTools.Loader - Revit entry point Verification Status Check Status Source anchors for all claims Yes UNVERIFIED markers where needed No (all verified) Cross-references added Yes Examples tested N/A No assumptions without evidence Yes Verified by: docs-run-20260124-020412 Date: 2026-01-24"
  },
  "articles/projects/loader.html": {
    "href": "articles/projects/loader.html",
    "title": "DBTools.Loader | DBTools Developer Documentation",
    "summary": "DBTools.Loader Purpose: Revit entry point assembly that bootstraps DBTools. Output: DBTools.Loader.dll Target Frameworks: net48, net8.0-windows Overview DBTools.Loader is the critical bootstrap component that Revit loads directly via the .addin manifest. Its sole responsibility is to load DBTools.dll (the main application assembly) and install the assembly resolver infrastructure that handles embedded dependencies. This project is intentionally minimal to reduce startup failure risk. All application logic lives in DBTools.App; the loader exists only to: Find and load DBTools.dll Install the EmbeddedAssemblyResolver Forward Revit lifecycle calls to DBTools.App.AddinEntry Source: csharp/src/DBTools.Loader/Addin/AddinEntry.cs:13-47 Responsibilities Responsibility Implementation Revit entry point IExternalApplication implementation with [AppLoader] attribute Load main assembly LoadMainAssembly() loads DBTools.dll from deployed directory Install assembly resolver EmbeddedAssemblyResolver.Install() handles runtime resolution Pre-load critical assemblies net48 only: Configuration and Serilog assemblies pre-loaded to beat GAC Forward lifecycle OnStartup/OnShutdown delegated to inner DBTools.App.AddinEntry Source: csharp/src/DBTools.Loader/Addin/AddinEntry.cs:17-47 Key Components AddinEntry (Revit Entry Point) The AddinEntry class is the Revit-facing entry point. It implements IExternalApplication and is decorated with [AppLoader] from ricaun.Revit.UI for enhanced loading behavior. [AppLoader] public sealed class AddinEntry : IExternalApplication { private IExternalApplication? _inner; public Result OnStartup(UIControlledApplication application) { // Bootstrap sequence here... } } Source: csharp/src/DBTools.Loader/Addin/AddinEntry.cs:12-14 Key Fields: _inner: Stores the instantiated DBTools.App.AddinEntry for forwarding lifecycle calls Source: csharp/src/DBTools.Loader/Addin/AddinEntry.cs:15 EmbeddedAssemblyResolver Static class that installs hooks into the CLR's assembly resolution mechanism. Handles loading dependencies from embedded resources within DBTools.dll. internal static class EmbeddedAssemblyResolver { private const string ResourcePrefix = \"DBTools.EmbeddedAssemblies.\"; private static int _installed; private static string? _deployedDir; public static void Install(Assembly mainAssembly, string? deployedDir = null) { // Installs AssemblyResolve (net48) or ALC.Resolving (net8) handler } } Source: csharp/src/DBTools.Loader/AssemblyResolution/EmbeddedAssemblyResolver.cs:14-38 LoaderCompat Provides cross-TFM compatibility utilities for the loader. Abstracts differences between .NET Framework and .NET 8. internal static class LoaderCompat { internal static string VendorTfm => #if NET8_0_OR_GREATER \"net8.0-windows\"; #else \"net48\"; #endif internal static Assembly LoadAssemblyFromPath(string path) { #if NET8_0_OR_GREATER return AssemblyLoadContext.Default.LoadFromAssemblyPath(path); #else return Assembly.LoadFrom(path); #endif } } Source: csharp/src/DBTools.Loader/Compat/LoaderCompat.cs:10-35 Bootstrap Sequence OnStartup Flow The complete startup sequence with line numbers: 1. Validate application parameter > Source: AddinEntry.cs:19 2. Get deployed directory (where DBTools.Loader.dll lives) > Source: AddinEntry.cs:21 3. Load DBTools.dll from deployed directory > Source: AddinEntry.cs:22 4. Verify embedded payload is present > Source: AddinEntry.cs:23 5. Install EmbeddedAssemblyResolver > Source: AddinEntry.cs:24 6. [net48 only] Pre-load Configuration assemblies > Source: AddinEntry.cs:26 7. [net48 only] Pre-load Serilog assemblies > Source: AddinEntry.cs:27 8. Resolve DBTools.App.AddinEntry type via reflection > Source: AddinEntry.cs:30-31 9. Create instance of DBTools.App.AddinEntry > Source: AddinEntry.cs:33-34 10. Store instance and forward OnStartup call > Source: AddinEntry.cs:36-37 Source: csharp/src/DBTools.Loader/Addin/AddinEntry.cs:17-38 Sequence Diagram Revit DBTools.Loader DBTools.dll (DBTools.App) | | | |--OnStartup(app)----------->| | | | | | GetDeployedDirectory() | | LoadMainAssembly() | | |--------load-------------->| | | | | EnsureEmbeddedPayloadPresent() | | EmbeddedAssemblyResolver.Install()| | | | | [net48: PreloadEmbedded*()] | | | | | Activator.CreateInstance()------->| | | | | |------OnStartup(app)------>| | | | |<-------Result.Succeeded----|<-------Result-------------| Assembly Loading Strategy net48 Strategy (ILRepack + Embedded) On .NET Framework 4.8, dependencies are handled via two mechanisms: 1. ILRepack (Merged into DBTools.dll): DBTools.Core Serilog, Microsoft.Extensions., YamlDotNet, System. polyfills These types exist directly in DBTools.dll; no resolution needed 2. Embedded Resources (for ricaun.Revit.*): Stored as DBTools.EmbeddedAssemblies.<name>.dll Loaded via Assembly.Load(byte[]) at runtime ILRepack corrupts some IL, so these stay as resources Source: csharp/src/DBTools.Loader/AssemblyResolution/EmbeddedAssemblyResolver.cs:223-263 3. Pre-loaded Assemblies: Configuration assemblies are pre-loaded before any code uses them to ensure DBTools' versions load before GAC/Revit's conflicting versions: var configAssemblies = new[] { \"Microsoft.Extensions.Primitives\", \"Microsoft.Extensions.FileProviders.Abstractions\", \"Microsoft.Extensions.FileProviders.Physical\", \"Microsoft.Extensions.Configuration.Abstractions\", \"Microsoft.Extensions.Configuration\", \"Microsoft.Extensions.Configuration.FileExtensions\", \"Microsoft.Extensions.Configuration.Json\", \"Microsoft.Extensions.Configuration.Binder\" }; Source: csharp/src/DBTools.Loader/Addin/AddinEntry.cs:111-121 Serilog assemblies are also pre-loaded in dependency order: var serilogAssemblies = new[] { \"Microsoft.Extensions.Logging.Abstractions\", \"Microsoft.Extensions.DependencyInjection.Abstractions\", \"Microsoft.Extensions.Logging\", \"Serilog\", \"Serilog.Extensions.Logging\", \"Serilog.Enrichers.Thread\", \"Serilog.Sinks.File\" }; Source: csharp/src/DBTools.Loader/Addin/AddinEntry.cs:154-170 Why Pre-load? On net48, AssemblyResolve only fires when an assembly cannot be found. If the GAC or another add-in already loaded a different version, our resolver never runs. Pre-loading ensures our versions are loaded first. Source: csharp/src/DBTools.Loader/Addin/AddinEntry.cs:104-108 net8.0-windows Strategy (All Embedded) On .NET 8, all dependencies are embedded as resources and loaded via AssemblyLoadContext: alc.Resolving += (context, name) => ResolveNet8(context, mainAssembly, name); Source: csharp/src/DBTools.Loader/AssemblyResolution/EmbeddedAssemblyResolver.cs:33-34 Resolution loads from embedded resources via stream: using var stream = mainAssembly.GetManifestResourceStream(resourceName); if (stream != null) { using var ms = new MemoryStream(); stream.CopyTo(ms); ms.Position = 0; return alc.LoadFromStream(ms); } Source: csharp/src/DBTools.Loader/AssemblyResolution/EmbeddedAssemblyResolver.cs:168-176 WPF Assembly Fallback WPF assemblies (Fluent.Ribbon, ControlzEx, HandyControl) cannot be embedded because they require Assembly.Location for pack:// URI resolution. These are loaded from files: Search Order: %APPDATA%/DBTools/vendor/<type>/<tfm>/ (traditional install) Deployed directory (next to DBTools.Loader.dll) Source: csharp/src/DBTools.Loader/AssemblyResolution/EmbeddedAssemblyResolver.cs:101-129 Vendor Type Detection: private static string? GetVendorTypeForAssembly(string requestedName) { if (requestedName.StartsWith(\"DBTools.Fluent.Ribbon\", ...)) return \"fluentribbon\"; if (requestedName.Equals(\"DBTools.ControlzEx\", ...)) return \"controlzex\"; if (requestedName.Equals(\"DBTools.HandyControl\", ...)) return \"handycontrol\"; return null; } Source: csharp/src/DBTools.Loader/AssemblyResolution/EmbeddedAssemblyResolver.cs:134-143 Duplicate Load Prevention Both resolution paths check for already-loaded assemblies first to prevent type identity mismatches: // Critical for ricaun.Revit.* which AppLoader may have already loaded var alreadyLoaded = AppDomain.CurrentDomain.GetAssemblies() .FirstOrDefault(a => string.Equals(a.GetName().Name, requestedName, ...)); if (alreadyLoaded != null) return alreadyLoaded; Source: csharp/src/DBTools.Loader/AssemblyResolution/EmbeddedAssemblyResolver.cs:50-61 Dependencies NuGet Packages Package Purpose ricaun.Revit.UI Provides [AppLoader] attribute for enhanced Revit loading Source: csharp/src/DBTools.Loader/DBTools.Loader.csproj:20 Note: ricaun.Revit.UI is a compile-time dependency that ensures ricaun is loaded EARLY when Revit loads DBTools.Loader.dll. This is required for RevitTaskService to work correctly in DBTools.App. Source: csharp/src/DBTools.Loader/DBTools.Loader.csproj:16-18 Revit API References Conditional based on target framework: net48: <Reference Include=\"RevitAPI\"> <HintPath>$(REVIT2024_DIR)\\RevitAPI.dll</HintPath> <Private>false</Private> </Reference> Source: csharp/src/DBTools.Loader/DBTools.Loader.csproj:23-34 net8.0-windows: <Reference Include=\"RevitAPI\" Condition=\"'$(REVIT_NET8_DIR)'!=''\"> <HintPath>$(REVIT_NET8_DIR)\\RevitAPI.dll</HintPath> <Private>false</Private> </Reference> Source: csharp/src/DBTools.Loader/DBTools.Loader.csproj:36-47 Runtime Dependencies DBTools.dll - Must be present in same directory as DBTools.Loader.dll Source: csharp/src/DBTools.Loader/Addin/AddinEntry.cs:67-69 Error Handling Startup Errors The loader has minimal error handling - it must either succeed or fail fast: Missing DBTools.dll: if (!File.Exists(mainPath)) throw new FileNotFoundException(\"DBTools.dll not found next to DBTools.Loader.dll.\", mainPath); Source: csharp/src/DBTools.Loader/Addin/AddinEntry.cs:68-69 Missing Embedded Payload (net8 only): var hasCore = Array.Exists(resources, r => string.Equals(r, \"DBTools.EmbeddedAssemblies.DBTools.Core.dll\", ...)); if (!hasCore) { throw new InvalidOperationException( \"DBTools.dll is missing embedded dependencies...\"); } Source: csharp/src/DBTools.Loader/Addin/AddinEntry.cs:89-96 Type Resolution Failure: var type = assembly.GetType(\"DBTools.App.AddinEntry\", throwOnError: true) ?? throw new InvalidOperationException(\"DBTools.App.AddinEntry type not found.\"); Source: csharp/src/DBTools.Loader/Addin/AddinEntry.cs:30-31 Silent Failures (Intentional) Pre-load failures during net48 startup are logged to Debug output but don't fail startup: catch (Exception ex) { // Silent continue - the EmbeddedAssemblyResolver will handle on-demand loading System.Diagnostics.Debug.WriteLine($\"[DBTools.Loader] Preload failed for {name}: {ex.Message}\"); } Source: csharp/src/DBTools.Loader/Addin/AddinEntry.cs:192-196 This is acceptable because the EmbeddedAssemblyResolver can still load these assemblies on-demand if pre-loading fails. Build Configuration Project Properties <TargetFrameworks>$(DBT_RevitTargetFrameworks)</TargetFrameworks> <AssemblyName>DBTools.Loader</AssemblyName> <RootNamespace>DBTools.Loader</RootNamespace> <CopyLocalLockFileAssemblies>true</CopyLocalLockFileAssemblies> Source: csharp/src/DBTools.Loader/DBTools.Loader.csproj:3-13 CopyLocalLockFileAssemblies: Set to true to copy NuGet dependencies (ricaun) to output for AppLoader/Debug scenarios. Source: csharp/src/DBTools.Loader/DBTools.Loader.csproj:13 Suppressed Warnings <NoWarn>$(NoWarn);MSB3277</NoWarn> MSB3277 (assembly version conflicts) is suppressed because Revit host references surface unavoidable conflicts. Source: csharp/src/DBTools.Loader/DBTools.Loader.csproj:10-11 File Structure csharp/src/DBTools.Loader/ +-- DBTools.Loader.csproj +-- Addin/ | +-- AddinEntry.cs # IExternalApplication entry point +-- AssemblyResolution/ | +-- EmbeddedAssemblyResolver.cs # Runtime assembly loading +-- Compat/ +-- LoaderCompat.cs # Cross-TFM utilities Integration with AppLoader DBTools.Loader uses ricaun's [AppLoader] attribute which provides: Automatic Revit version detection Enhanced error reporting Integration with ricaun.RevitTest for automated testing The AppLoader may have already loaded shared assemblies (like ricaun.Revit.*). The resolver explicitly checks for already-loaded assemblies to prevent duplicate loading which would cause type identity mismatches. Source: csharp/src/DBTools.Loader/AssemblyResolution/EmbeddedAssemblyResolver.cs:51-53 Troubleshooting \"DBTools.dll not found\" Error Cause: DBTools.dll is not in the same directory as DBTools.Loader.dll. Solution: Ensure the deployment copies both files together. \"Missing embedded dependencies\" Error (net8) Cause: DBTools.dll was built without the embedded assembly step. Solution: Rebuild using bash csharp/build.sh BuildAll. Source: csharp/src/DBTools.Loader/Addin/AddinEntry.cs:93-96 Assembly Resolution Failures Symptoms: FileNotFoundException or TypeLoadException for dependency types. Diagnosis: Check if the assembly is in embedded resources (DBTools.EmbeddedAssemblies.<name>.dll) For WPF assemblies, check %APPDATA%/DBTools/vendor/ or deployed directory Enable assembly binding logging (FUSLOGVW.exe) on net48 Related Documentation Architecture Overview - High-level system architecture Project References - How projects relate DBTools.Core - Core library documentation Verification Status Check Status Source anchors for all claims Yes UNVERIFIED markers where needed Yes (addin manifest) Cross-references added Yes Examples tested N/A No assumptions without evidence Yes Verified by: docs-run-20260124-020412 Date: 2026-01-24"
  },
  "articles/projects/sandbox.html": {
    "href": "articles/projects/sandbox.html",
    "title": "DBTools.Sandbox | DBTools Developer Documentation",
    "summary": "DBTools.Sandbox The DBTools.Sandbox project is a standalone WPF application that enables development, testing, and validation of DBTools UI windows without running Revit. It provides both an interactive gallery for browsing tool windows and a headless validation mode used during CI builds. Source: csharp/src/DBTools.Sandbox/DBTools.Sandbox.csproj:1-54 Overview Purpose Sandbox exists to solve a fundamental Revit development challenge: tool UI windows normally require Revit to be running, which makes iterative UI development slow and makes CI validation difficult. Sandbox provides: Interactive Development: Launch tool windows with design-time ViewModels to preview UI without Revit Build-Time Validation: Catch XAML errors, missing resources, and binding failures during CI Screenshot Capture: Generate UI screenshots for documentation or visual regression testing Key Concepts Design-Time ViewModels: Each sandbox-enabled window must provide a ViewModel that works without Revit services Sandbox Mode: A global flag (SandboxMode.IsActive) that windows check to avoid calling Revit-dependent code Dist-Driven Discovery: Sandbox loads windows from the built dist/ payload, validating the actual shipped assemblies Project Structure csharp/src/DBTools.Sandbox/ ├── App.xaml.cs # Application entry, mode switching ├── MainWindow.xaml.cs # Interactive gallery window ├── SandboxAppRuntime.cs # IAppRuntime implementation for sandbox ├── SandboxDiagnostics.cs # Logging utilities ├── SandboxSettingsProvider.cs # Settings stub for sandbox mode ├── HeadlessUiSuppression.cs # Suppresses OS dialogs in CI └── Validation/ ├── DistValidator.cs # Main validation orchestrator ├── ToolWindowValidator.cs # Tool window instantiation/layout ├── ManifestValidator.cs # Manifest schema validation ├── WindowGhostValidator.cs # WPF layout pass validation ├── MergeValidator.cs # ILRepack/embedded payload checks ├── BindingErrorListener.cs # WPF binding error capture ├── SandboxValidateOptions.cs # CLI argument parsing ├── SandboxModeActivator.cs # Cross-assembly mode activation ├── SandboxScreenshotHandler.cs # Screenshot capture mode ├── DistDirLocator.cs # Dist directory resolution ├── DistAssemblyResolver.cs # Assembly loading for dist payload ├── RevitDirLocator.cs # Revit installation discovery ├── DistValidationReflection.cs # Reflection helpers ├── AssemblyMetadataInspector.cs # PE metadata inspection └── XamlExceptionDiagnostics.cs # XAML error formatting Operating Modes Interactive Mode (Default) Launch the sandbox gallery to browse and open tool windows: # From csharp/.artifacts/sandbox/Release/net8.0-windows/ DBTools.Sandbox.exe Source: csharp/src/DBTools.Sandbox/App.xaml.cs:109-137 The interactive mode: Initializes SandboxAppRuntime for service resolution Loads DBTools.dll from the dist payload Discovers all sandboxWindows from tool manifests Displays a grouped gallery of launchable windows Headless Validation Mode Used by the build system to validate dist output: DBTools.Sandbox.exe --headless --dist-dir \"path/to/dist/Release/2026\" Source: csharp/src/DBTools.Sandbox/App.xaml.cs:45-57 Headless mode performs comprehensive validation without showing any UI: Theme resource validation Core window instantiation Tool manifest validation Tool window XAML validation WPF binding error detection Screenshot Mode Capture window screenshots for documentation: # List available tools DBTools.Sandbox.exe --screenshot --list # Capture specific tool DBTools.Sandbox.exe --screenshot --tool-id DBTools.GM.Main --output gm.png Source: csharp/src/DBTools.Sandbox/Validation/SandboxScreenshotHandler.cs:24-49 Key Components SandboxAppRuntime Minimal IAppRuntime implementation that provides essential services without Revit: internal sealed class SandboxAppRuntime : IAppRuntime, IDisposable { // Provides: ILogger, ISettingsProvider, ILoggerFactory, IAlertService public T Resolve<T>() where T : notnull { ... } } Source: csharp/src/DBTools.Sandbox/SandboxAppRuntime.cs:17-90 Services provided: IDbtLoggingHost - Real logging to %APPDATA%/DBTools/Logs/dbtools-SANDBOX-*.log ISettingsProvider - Stub implementation returning defaults ILoggerFactory - Creates category-scoped loggers IAlertService - Real alert service for error display SandboxMode Global flag that windows check to avoid Revit-dependent code paths: public static class SandboxMode { public static bool IsActive => _isActive; public static void Activate() { _isActive = true; } } Source: csharp/src/DBTools.Core/Compat/SandboxMode.cs:1-24 Windows should check this before calling Revit services: if (!SandboxMode.IsActive) { // Call Revit-dependent code } DbtSandboxCatalog Discovers sandbox windows from tool manifests: public static IReadOnlyList<DbtSandboxWindowSpec> Discover(Assembly rootAssembly) { var entries = DbtToolManifestLoader.LoadEntries(rootAssembly); // Extract sandboxWindows from each manifest } Source: csharp/src/DBTools.Core/Tools/DbtSandboxCatalog.cs:8-60 Validates that each sandbox window entry has: id - Unique identifier displayName - Human-readable name group - Category for gallery grouping windowType - Fully-qualified Window class name designTimeViewModelType - ViewModel for sandbox mode Tool Manifest Integration Tools register sandbox windows via manifest.yml: id: DBTools.GM assembly: DBTools moduleType: DBTools.GM.GmToolModule sandboxWindows: - id: DBTools.GM.Main displayName: \"Global Mapper\" group: \"Common\" windowType: \"DBTools.GM.Shell.UI.Views.GmWindow\" designTimeViewModelType: \"DBTools.GM.Shell.DesignTime.GmShellDesignTimeViewModel\" Source: csharp/src/Tools/Common/GM/manifest.yml:1-15 Schema Fields Field Required Description id Yes Unique window identifier (e.g., DBTools.GM.Main) displayName Yes Gallery display name group Yes Gallery category grouping windowType Yes Fully-qualified Window type name designTimeViewModelType Yes Design-time ViewModel type assembly No Assembly name (defaults to manifest's assembly) Source: csharp/src/DBTools.Core/Tools/DbtToolManifestLoader.cs:121-153 Validation System The validation system runs during BuildAll to catch UI issues before deployment. DistValidator (Orchestrator) Main validation entry point that coordinates all validators: internal static class DistValidator { public static int Run(SandboxValidateOptions options, ILogger? logger = null) { // 1. Validate dist layout // 2. Install assembly resolver // 3. Validate theme resources // 4. Validate core windows // 5. Validate manifests (optional) // 6. Validate tool windows (optional) } } Source: csharp/src/DBTools.Sandbox/Validation/DistValidator.cs:15-118 ToolWindowValidator Instantiates each sandbox window with its design-time ViewModel: internal static class ToolWindowValidator { public static void ValidateOrThrow(Assembly dbtoolsAssembly, ILogger? logger = null) { var specs = DiscoverSpecs(dbtoolsAssembly); foreach (var spec in specs) { // 1. Load window type from assembly // 2. Create window instance // 3. Create design-time ViewModel // 4. Set DataContext // 5. Run WindowGhostValidator // 6. Validate tab interactions // 7. Validate row expansion } } } Source: csharp/src/DBTools.Sandbox/Validation/ToolWindowValidator.cs:13-173 Additional validations performed: Tab cycling - Switches through all tabs to catch transition errors DataGrid row expansion - Toggles row details visibility Preview mode switching - Tests mode transitions (e.g., SGT preview modes) Source: csharp/src/DBTools.Sandbox/Validation/ToolWindowValidator.cs:201-368 WindowGhostValidator Forces WPF layout passes to catch XAML errors: internal static class WindowGhostValidator { public static void Validate(Window window) { // Pass 1: Fixed 800x600 size ValidateLayoutPass(window, new Size(800, 600), \"fixed size\"); // Pass 2: Infinite size (catches DesiredSize calculation errors) ValidateLayoutPass(window, new Size(PositiveInfinity, PositiveInfinity), \"infinite size\"); } } Source: csharp/src/DBTools.Sandbox/Validation/WindowGhostValidator.cs:9-129 BindingErrorListener Captures WPF binding errors that normally fail silently: internal sealed class BindingErrorListener : TraceListener { // Hooks into PresentationTraceSources.DataBindingSource // Collects \"System.Windows.Data Error:\" messages // ThrowIfErrors() fails validation if any binding errors occurred } Source: csharp/src/DBTools.Sandbox/Validation/BindingErrorListener.cs:13-118 This catches issues like: Missing StaticResource references Broken binding paths Type conversion failures MergeValidator Validates assembly merge/embedding is correct: For net48 (ILRepack): Verifies expected types exist inside DBTools.dll Ensures merged assemblies don't exist as separate files For net8 (Embedded Payload): Verifies DBTools.EmbeddedAssemblies.DBTools.Core.dll resource exists Checks resource isn't corrupted (minimum size validation) Source: csharp/src/DBTools.Sandbox/Validation/MergeValidator.cs:17-222 CLI Arguments Argument Description --headless Run validation only, no UI --screenshot Run screenshot capture mode --dist-dir <path> Path to dist directory or year folder --revit-dir <path> Override Revit installation path --validate-manifests Enable manifest validation (default: true) --skip-validate-manifests Disable manifest validation --validate-tools Enable tool window validation (default: true) --skip-validate-tools Disable tool window validation --list List available tools (screenshot mode) --tool-id <id> Tool to capture (screenshot mode) --output <path> Screenshot output path Source: csharp/src/DBTools.Sandbox/Validation/SandboxValidateOptions.cs:7-113 Build Integration The sandbox validator is invoked automatically during BuildAll: bash csharp/build.sh BuildAll # Internally runs: DBTools.Sandbox.exe --headless --dist-dir ... The build system also handles orphaned processes: static void KillOrphanedSandboxValidatorProcesses() { // Kills any lingering DBTools.Sandbox processes from previous builds } Source: csharp/build/BuildTargets.cs:1292 Creating a Sandbox-Enabled Window 1. Create Design-Time ViewModel public class MyWindowDesignTimeViewModel : INotifyPropertyChanged { public MyWindowDesignTimeViewModel() { // Initialize with sample data Items = new ObservableCollection<ItemModel> { new ItemModel { Name = \"Sample 1\" }, new ItemModel { Name = \"Sample 2\" } }; } public ObservableCollection<ItemModel> Items { get; } } 2. Add Parameterless Constructor to Window public partial class MyWindow : Window { // Required for sandbox mode public MyWindow() { InitializeComponent(); if (SandboxMode.IsActive) { // Skip Revit-dependent initialization return; } // Normal initialization... } } 3. Register in manifest.yml sandboxWindows: - id: MyTool.Main displayName: \"My Tool Window\" group: \"Common\" windowType: \"MyNamespace.UI.Views.MyWindow\" designTimeViewModelType: \"MyNamespace.DesignTime.MyWindowDesignTimeViewModel\" 4. Test Locally # Build bash csharp/build.sh BuildAll # Launch interactive sandbox csharp/.artifacts/sandbox/Release/net8.0-windows/DBTools.Sandbox.exe Multi-Framework Support Sandbox targets both net48 and net8.0-windows to validate both Revit 2024 (net48) and Revit 2025+ (net8) distributions: <TargetFrameworks>$(DBT_RevitTargetFrameworks)</TargetFrameworks> Source: csharp/src/DBTools.Sandbox/DBTools.Sandbox.csproj:3 The validator automatically selects the compatible year folder: net48 sandbox validates Revit 2024 (year <= 2024) net8 sandbox validates Revit 2025+ (year >= 2025) Source: csharp/src/DBTools.Sandbox/Validation/DistDirLocator.cs:75-80 Headless UI Suppression In CI environments, the sandbox suppresses all OS-level dialogs: SetErrorMode - Suppresses Win32 critical error dialogs WerSetFlags - Suppresses Windows Error Reporting UI Trace listeners - Disables Debug.Assert popups Source: csharp/src/DBTools.Sandbox/HeadlessUiSuppression.cs:17-120 This prevents CI builds from hanging on modal dialogs. Troubleshooting \"Dist payload not found\" The sandbox requires a built dist payload: bash csharp/build.sh BuildAll Window crashes in sandbox but works in Revit Check for Revit-dependent code not guarded by SandboxMode.IsActive: // Wrong - crashes in sandbox var doc = AppRuntime.Resolve<IRevitService>().Document; // Right - sandbox-safe if (!SandboxMode.IsActive) { var doc = AppRuntime.Resolve<IRevitService>().Document; } Binding errors in validation The BindingErrorListener will report silent WPF binding failures. Check: Missing StaticResource keys in XAML Incorrect binding paths Missing value converters \"Type not found\" during validation Ensure the window and ViewModel types: Have fully-qualified names in the manifest Are public classes Have public parameterless constructors Related Documentation Architecture: Sandbox Validator - Detailed validation architecture DBTools.App - How App discovers tools via manifests Tool Manifest Schema - Complete manifest documentation See Also DbtSandboxWindowSpec - Window specification model DbtSandboxCatalog - Window discovery from manifests DbtToolManifestLoader - Manifest parsing and validation"
  },
  "articles/projects/themes.html": {
    "href": "articles/projects/themes.html",
    "title": "DBTools.Themes | DBTools Developer Documentation",
    "summary": "DBTools.Themes The DBTools.Themes project provides a unified dark theme system for all DBTools WPF applications. It establishes design tokens, brush definitions, and control styles that ensure visual consistency across the application while avoiding conflicts with Revit's host environment. Overview DBTools.Themes solves several key challenges: Host Isolation: Revit's UI can interfere with WPF resource dictionaries. This project uses vendored, renamed libraries (e.g., DBTools.HandyControl instead of HandyControl) to prevent conflicts with pyRevit or other add-ins. Consistent Branding: Implements the DBTools brand colors (deep blue #1946B9 and golden yellow #FEC425) across all UI controls. WCAG Accessibility: Text colors are designed to meet WCAG AA contrast requirements (min 4.5:1 ratio on dark backgrounds). Template Boundary Crossing: The BrushKeys system using ComponentResourceKey allows brushes to propagate correctly across DataTemplate and ControlTemplate boundaries. Source: csharp/src/DBTools.Themes/DBTools.Themes.csproj:1-73 Project Structure DBTools.Themes/ ├── DBTools.Themes.csproj # Project configuration ├── BrushKeys.cs # ComponentResourceKey definitions ├── Assets/ │ └── db_tools_icon.png # Application icon └── Themes/ ├── App.Theme.xaml # Root dictionary (entry point) ├── App.Tokens.xaml # Design tokens (spacing, sizing) ├── App.Brushes.xaml # Color/brush definitions ├── App.Converters.xaml # Value converters ├── App.Controls.Base.xaml # Base control styles ├── App.DataGrid.xaml # DataGrid-specific styles ├── App.Menus.xaml # Menu/ContextMenu styles ├── App.Components.xaml # Higher-level component styles └── App.FluentRibbon.xaml # Fluent.Ribbon theme bridge Source: csharp/src/DBTools.Themes/DBTools.Themes.csproj:38-51 Key Files App.Theme.xaml - Root Entry Point The root resource dictionary that merges all theme components. This is what consuming projects reference. <ResourceDictionary.MergedDictionaries> <!-- HandyControl Foundation --> <ResourceDictionary Source=\"pack://application:,,,/DBTools.HandyControl;component/Themes/SkinDark.xaml\"/> <ResourceDictionary Source=\"pack://application:,,,/DBTools.HandyControl;component/Themes/Theme.xaml\"/> <!-- Fluent.Ribbon for ribbon windows --> <ResourceDictionary Source=\"pack://application:,,,/DBTools.Fluent.Ribbon;component/Themes/Generic.xaml\" /> <!-- DBTools Custom Themes --> <ResourceDictionary Source=\"App.Tokens.xaml\" /> <ResourceDictionary Source=\"App.Brushes.xaml\" /> <!-- ... additional dictionaries ... --> </ResourceDictionary.MergedDictionaries> Source: csharp/src/DBTools.Themes/Themes/App.Theme.xaml:1-22 BrushKeys.cs - ComponentResourceKey System Defines strongly-typed keys for all theme brushes. This pattern enables brushes to work correctly inside DataTemplate and ControlTemplate boundaries where DynamicResource with string keys may fail. public static class BrushKeys { public static ComponentResourceKey Primary => new(typeof(BrushKeys), \"Brush.Primary\"); public static ComponentResourceKey Secondary => new(typeof(BrushKeys), \"Brush.Secondary\"); // ... 100+ additional keys } Usage in XAML: <Border Background=\"{DynamicResource {x:Static theme:BrushKeys.Primary}}\" /> Source: csharp/src/DBTools.Themes/BrushKeys.cs:1-140 Design Tokens Design tokens provide consistent spacing, sizing, typography, and other visual constants. Spacing Tokens Token Value Usage Spacing4 4px Tight spacing (icon margins) Spacing8 8px Standard spacing Spacing12 12px Medium spacing Spacing16 16px Large spacing Spacing32 32px Section spacing Scalar variants (Spacing8.Value, etc.) are provided for properties that require Double instead of Thickness. Source: csharp/src/DBTools.Themes/Themes/App.Tokens.xaml:5-18 Padding Tokens Token Value Usage Pad4 4px uniform Compact padding Pad8 8px uniform Standard padding Pad16 16px uniform Large padding Pad8x4 8px H, 4px V Button padding Card.Padding 16px H, 12px V Card content Source: csharp/src/DBTools.Themes/Themes/App.Tokens.xaml:24-56 Gap Tokens Directional margins for layout: Token Value Description TGap8 Top 8px Top margin BGap8 Bottom 8px Bottom margin LGap8 Left 8px Left margin RGap8 Right 8px Right margin VGap8 Top/Bottom 8px Vertical margin HGap8 Left 8px Horizontal gap Source: csharp/src/DBTools.Themes/Themes/App.Tokens.xaml:30-64 Typography Tokens Token Size Usage FontSize.Caption 11px Captions, timestamps FontSize.Body.Small 12px Secondary text FontSize.Body 13px Default body text FontSize.Subtitle 14px Subtitles FontSize.Title 16px Section titles FontSize.Header 20px Page headers Source: csharp/src/DBTools.Themes/Themes/App.Tokens.xaml:66-72 Corner Radius Tokens Token Value Usage Radius4 4px Buttons, inputs Radius6 6px Cards, chips Radius8 8px Dialogs, overlays Radius12 12px Large surfaces Source: csharp/src/DBTools.Themes/Themes/App.Tokens.xaml:43-46 Control Size Tokens Token Value Usage MinHeight.Control 32px Minimum control height Size.CheckBox.Box 18px Checkbox dimensions Size.ToggleTrack.Width 44px Toggle switch track Size.DataGridRow.MinHeight 32px Grid row height Size.ScrollBar.Width 10px Scrollbar width Source: csharp/src/DBTools.Themes/Themes/App.Tokens.xaml:98-114 Color System (App.Brushes.xaml) The color system is built around the DBTools brand colors with carefully designed semantic roles. Brand Colors Key Color Description Primary #1946B9 Deep blue - primary actions PrimaryLight #3D6AD4 Hover state PrimaryDark #0D2E7A Pressed state Secondary #FEC425 Golden yellow - accents SecondaryLight #FFD54F Hover state SecondaryDark #C79100 Pressed state Source: csharp/src/DBTools.Themes/Themes/App.Brushes.xaml:14-19 Surface Colors Neutral dark palette with reduced blue tint: Key Color Description Paper #181820 Window background Surface #222228 Card/panel background SurfaceAlt #1C1C22 Alternate surface SurfaceHover #2A2A32 Hover state CardSurface #1E1E24 Card background CardSurfaceElevated #282830 Elevated cards Source: csharp/src/DBTools.Themes/Themes/App.Brushes.xaml:24-30 Text Colors (WCAG Compliant) Key Color Contrast Description Body / Text #E6E6E6 ~12:1 Primary text BodyLight / TextSecondary #BDBDBD ~9:1 Secondary text TextMuted / Muted #999999 ~7:1 Muted text OnAccent #FFFFFF - Text on colored bg OnSecondary #181820 - Text on yellow Source: csharp/src/DBTools.Themes/Themes/App.Brushes.xaml:35-44 Selection & Highlight Colors Alpha transparency reference: #33 = 20%, #44 = 27%, #55 = 33%, #66 = 40%, #99 = 60% Key Color Description Selection #441946B9 (27%) Standard selection SelectionStrong #661946B9 (40%) Strong selection SelectionGold #33FEC425 (20%) Row highlighting SelectionGoldStrong #55FEC425 (33%) Strong gold Hover #33FEC425 (20%) Hover state Source: csharp/src/DBTools.Themes/Themes/App.Brushes.xaml:59-78 Status Colors Key Color Description Success #4CAF50 Success state Warning #FFA000 Warning state Error #CF6679 Error state Info #1946B9 Informational Each status color has Light and Background variants for subtle backgrounds. Source: csharp/src/DBTools.Themes/Themes/App.Brushes.xaml:84-95 Specialized Brush Categories The brush system includes specialized categories for: DataGrid: Header, row, cell, selection colors Input Controls: Background, border, focus states Buttons: Primary, secondary, accent, danger variants Checkbox/Toggle: Box, checked, indeterminate states Tabs: Background, indicator, hover states ScrollBar/Slider: Track, thumb, hover/pressed states VTC Diff View: Add/remove/missing background colors Source: csharp/src/DBTools.Themes/Themes/App.Brushes.xaml:100-232 BrushKeys System Why ComponentResourceKey? WPF has a limitation where DynamicResource with string keys doesn't always resolve correctly inside DataTemplate or ControlTemplate boundaries. ComponentResourceKey solves this by creating type-safe keys that the resource system can resolve across template boundaries. Key Categories The BrushKeys class defines 100+ keys organized into categories: Category Example Keys Count Brand Primary, Secondary, PrimaryLight 6 Surface Paper, Surface, CardSurface 7 Text Body, Text, TextMuted 10 Border Border, Divider, BorderSubtle 4 Selection Selection, SelectionGold, Hover 12 Status Success, Warning, Error, Info 12 DataGrid DataGridHeader, DataGridRow, etc. 14 Input InputBackground, InputBorder 5 Button ButtonPrimary, ButtonDanger 10 Checkbox CheckBox, CheckChecked 6 Toggle ToggleTrackOn, ToggleThumb 7 Tab TabBackground, TabIndicator 5 ScrollBar ScrollBarTrack, ScrollBarThumb 4 Slider SliderTrack, SliderThumb 5 Progress ProgressTrack, ProgressFill 3 Toolbar ToolbarChipBackground, etc. 6 VTC Diff VtcDiffAddBackground, etc. 4 Source: csharp/src/DBTools.Themes/BrushKeys.cs:11-139 Usage Pattern In XAML: xmlns:theme=\"clr-namespace:DBTools.Themes;assembly=DBTools.Themes\" <Border Background=\"{DynamicResource {x:Static theme:BrushKeys.CardSurface}}\" BorderBrush=\"{DynamicResource {x:Static theme:BrushKeys.CardBorder}}\" /> In Code: var brush = (Brush)FindResource(BrushKeys.Primary); Control Styles Window Styles The theme provides implicit styles for DbtWindowBase and DbtRibbonWindowBase: Sets the DBTools icon Applies Paper background and Body foreground Includes progress overlay support via ProgressOverlayService Source: csharp/src/DBTools.Themes/Themes/App.Controls.Base.xaml:13-55 Base Control Styles TextBlock Foreground: Body brush TextWrapping: Wrap TextTrimming: CharacterEllipsis Button MinWidth: 88px, MinHeight: 36px Hover: SecondaryHover background, Secondary border Pressed: PrimaryHover background, Primary border TextBox Background: InputBackground Border: InputBorder (hover: Secondary, focus: FocusBorder) Validation error: Red border with tooltip ComboBox Custom dropdown template with dark popup background Drop shadow effect on dropdown Proper dark theme item highlighting CheckBox / RadioButton Custom templates with theme-consistent colors Checked: CheckChecked background Indeterminate: CheckIndeterminate fill (yellow) Source: csharp/src/DBTools.Themes/Themes/App.Controls.Base.xaml:61-449 DataGrid Styles Comprehensive DataGrid theming with: Row Features: Yellow accent stripe on left edge Gold hover highlighting (DataGridRowHover) Blue selection with yellow accent (DataGridRowSelected) Keyboard focus indicator (DataGridRowFocus) Cell Features: Focus state with primary border Edit mode with secondary border Conflict highlighting support Column Header: Hover state Sort direction indicators (yellow arrows) Resizable column grippers Source: csharp/src/DBTools.Themes/Themes/App.DataGrid.xaml:1-476 Component Styles (App.Components.xaml) Higher-level UI component styles: Style Key Target Description ToolBar ToolBar Dark themed toolbar StatusBar StatusBar Dark themed status bar ToolbarChip ToggleButton Pill-shaped filter buttons OverlayCard Border Modal dialog container Card Border Standard card surface Card.Elevated Border Card with drop shadow Dbt.Section GroupBox Section with accent stripe Dbt.Callout Border Info callout box WarningBar Border Warning message container Typography Styles: HeaderText, SubtitleText, BodyText, DescriptionText, CaptionText Source: csharp/src/DBTools.Themes/Themes/App.Components.xaml:1-414 Menu Styles Custom templates for proper dark theme rendering in Revit: ContextMenu: Dark background, rounded corners, drop shadow MenuItem: Hover highlighting, keyboard shortcut display MenuSeparator: Subtle divider Source: csharp/src/DBTools.Themes/Themes/App.Menus.xaml:1-136 Vendored Library Integration Why Vendored Libraries? Revit hosts multiple add-ins that may use conflicting versions of UI libraries like HandyControl or Fluent.Ribbon. By vendoring and renaming these libraries, DBTools avoids: Assembly version conflicts Resource dictionary collisions pyRevit theme interference Vendored Assemblies Original Vendored Purpose HandyControl DBTools.HandyControl Control library foundation Fluent.Ribbon DBTools.Fluent.Ribbon Ribbon window support ControlzEx DBTools.ControlzEx Window chrome (dependency) <Reference Include=\"DBTools.HandyControl\"> <HintPath>$(DBT_VendorArtifactsRoot)handycontrol\\$(TargetFramework)\\DBTools.HandyControl.dll</HintPath> </Reference> Source: csharp/src/DBTools.Themes/DBTools.Themes.csproj:55-71 Fluent.Ribbon Theme Bridge App.FluentRibbon.xaml provides a complete dark theme override with 196 brush key mappings to integrate Fluent.Ribbon with the DBTools color system. Key integrations: Window chrome (title bar, caption buttons) Ribbon tabs and groups All control variants (buttons, checkboxes, textboxes) Gallery and backstage views Source: csharp/src/DBTools.Themes/Themes/App.FluentRibbon.xaml:1-575 Build Configuration Target Frameworks The project multi-targets: net48 (Revit 2024 and earlier) net8.0-windows (Revit 2025+) XAML Compilation Some XAML files are kept as raw resources (not compiled to BAML) to avoid requiring a project reference to DBTools.Core: <Page Remove=\"Themes\\App.Converters.xaml\" /> <Resource Include=\"Themes\\App.Converters.xaml\" /> Source: csharp/src/DBTools.Themes/DBTools.Themes.csproj:38-46 Dependency Rules Critical: DBTools.Themes must NOT reference DBTools.Core to avoid circular dependencies. Theme dictionaries that need Core types are defined in Core and merged via pack URIs. Source: csharp/src/DBTools.Themes/DBTools.Themes.csproj:31-34 How to Extend Adding New Brushes Add the ComponentResourceKey to BrushKeys.cs: public static ComponentResourceKey MyNewBrush => new(typeof(BrushKeys), \"Brush.MyNew\"); Define the brush in App.Brushes.xaml: <SolidColorBrush x:Key=\"{x:Static theme:BrushKeys.MyNewBrush}\" Color=\"#FF123456\" /> Adding New Tokens Add to App.Tokens.xaml following existing patterns: <sys:Double x:Key=\"Size.MyNew\">24</sys:Double> <Thickness x:Key=\"Pad.MyNew\">8,4</Thickness> Creating New Control Styles For base controls, add to App.Controls.Base.xaml For higher-level components, add to App.Components.xaml Use DynamicResource with BrushKeys for all colors Use token resources for spacing/sizing Adding Converters Implement converter in DBTools.Core.UI.Converters Add resource entry in App.Converters.xaml: <conv:MyConverter x:Key=\"Converter.MyConverter\" /> Cross-References Theme System Architecture - Detailed architecture documentation DBTools.Core - Theme loading and initialization Value Converters Available converters (defined in App.Converters.xaml): Key Type Description Converter.BoolToVisibility BooleanToVisibilityConverter Standard bool-to-visibility Converter.InverseBoolToVisibility InverseBooleanToVisibilityConverter Inverted visibility Converter.NullToVisibility NullToVisibilityConverter Collapsed when not null Converter.NullToInverseVisibility NullToInverseVisibilityConverter Collapsed when null Converter.RowKindToVisibility RowKindToVisibilityConverter DataGrid row type filtering Source: csharp/src/DBTools.Themes/Themes/App.Converters.xaml:1-12"
  },
  "articles/tools/common/elements-from-list-3d.html": {
    "href": "articles/tools/common/elements-from-list-3d.html",
    "title": "Elements From List 3D | DBTools Developer Documentation",
    "summary": "Elements From List 3D Elements From List 3D is a utility tool module that provides two related commands for creating and visualizing 3D elements in Revit: placing family instances from CSV coordinate data, and creating filled regions from selected wall and caisson elements. Overview The tool module contains two ribbon commands: Command Description Availability 3D Elements From List Creates family instances at coordinates specified in a CSV file Document open Filled Regions From Elements Creates filled regions from selected walls and caissons Elements selected Source: csharp/src/Tools/Common/3DElementsFromList/manifest.yml:6-24 Features 3D Elements From List Command CSV Import: Reads coordinate data from user-selected CSV files Flexible Column Ordering: Supports any column order with case-insensitive headers Optional ID Column: Maps CSV id field to element parameter Auto-Family Loading: Automatically loads the required family if not present in project Multi-Format Support: Handles integers, decimals, negative values, and scientific notation Source: csharp/src/Tools/Common/3DElementsFromList/Features/ElementsFromList3DCommand.cs:13-72 Filled Regions From Elements Command Wall Support: Creates rectangular filled regions from wall bounding boxes Caisson Support: Creates circular filled regions from caisson diameter parameters Style Matching: Uses \"solid gray\" non-masking filled region type Invisible Lines: Applies invisible line style to region boundaries Automatic Comments: Sets \"DB Tools\" comment on created regions Source: csharp/src/Tools/Common/3DElementsFromList/Features/FilledRegionsFromElementsCommand.cs:12-62 Architecture Module Structure csharp/src/Tools/Common/3DElementsFromList/ +-- ElementsFromList3DToolModule.cs # Tool module registration +-- DBTools.ElementsFromList3D.csproj # Project file +-- manifest.yml # Tool manifest +-- Features/ | +-- ElementsFromList3DCommand.cs # CSV import command | +-- FilledRegionsFromElementsCommand.cs # Filled region command | +-- CsvCoordinateParser.cs # Pure CSV parsing logic | +-- CsvElementPlacer.cs # Element placement service | +-- FilledRegionCreator.cs # Region creation service +-- Assets/ | +-- 3d_elements_icon.png # Command icon | +-- filled_regions_icon.png # Command icon +-- Tests/ +-- CsvCoordinateParserTests.cs # Parser unit tests +-- TEST_SUMMARY.md # Test documentation Source: Directory structure of csharp/src/Tools/Common/3DElementsFromList/ Data Flow +------------------------+ | ElementsFromList3DCommand | +-----------+------------+ | (User selects CSV file) | v +------------------------+ | CsvCoordinateParser | | (Pure parsing logic) | +-----------+------------+ | (CoordinateRecords) | v +------------------------+ | CsvElementPlacer | | (Revit integration) | +-----------+------------+ | +-----------------+-----------------+ | | v v +------------------+ +-------------------+ | FamilyLoader | | Transaction | | (Load/find family)| | (Create instances)| +------------------+ +-------------------+ Separation of Concerns The tool follows a clean separation pattern: Layer Class Responsibility Command ElementsFromList3DCommand Entry point, file selection, result display Parsing CsvCoordinateParser Pure CSV logic, no Revit/file dependencies Placement CsvElementPlacer Revit API integration, transaction management Source: csharp/src/Tools/Common/3DElementsFromList/Features/CsvCoordinateParser.cs:59-63 Key Classes Entry Points Class File Purpose ElementsFromList3DToolModule ElementsFromList3DToolModule.cs:5-7 Empty tool module; uses manifest-driven registration ElementsFromList3DCommand Features/ElementsFromList3DCommand.cs:17-72 CSV import command entry point FilledRegionsFromElementsCommand Features/FilledRegionsFromElementsCommand.cs:16-62 Filled region command entry point Source: csharp/src/Tools/Common/3DElementsFromList/ElementsFromList3DToolModule.cs:5-7 Domain Types Type File Purpose CoordinateRecord Features/CsvCoordinateParser.cs:12-35 Immutable struct holding X, Y, Z, and optional ID CsvParseResult Features/CsvCoordinateParser.cs:40-57 Result type with success/failure semantics Source: csharp/src/Tools/Common/3DElementsFromList/Features/CsvCoordinateParser.cs:12-35 Services Class File Purpose CsvCoordinateParser Features/CsvCoordinateParser.cs:63-153 Static parser with Parse(), ParseContent(), ParseFile() methods CsvElementPlacer Features/CsvElementPlacer.cs:17-143 Creates family instances from coordinate records FilledRegionCreator Features/FilledRegionCreator.cs:16-248 Creates filled regions from walls and caissons Source: csharp/src/Tools/Common/3DElementsFromList/Features/CsvElementPlacer.cs:17-31 CSV Format The CSV parser accepts files with the following format: Required Columns x - X coordinate (feet in Revit internal units) y - Y coordinate (feet in Revit internal units) z - Z coordinate (feet in Revit internal units) Optional Columns id - Identifier string (written to element's \"ID\" parameter if available) Format Rules Feature Behavior Header case Case-insensitive (X, x, X all valid) Column order Any order allowed Extra columns Ignored Whitespace Trimmed from headers and values Empty rows Skipped Invalid rows Skipped (row with unparseable numbers) Number format Integer, decimal, negative, scientific notation Line endings Windows (\\r\\n), Unix (\\n), Mac (\\r) Source: csharp/src/Tools/Common/3DElementsFromList/Features/CsvCoordinateParser.cs:70-114 Example CSV id,x,y,z P001,100.5,200.25,10.0 P002,150.0,250.5,10.0 P003,200.75,300.0,10.0 Source: csharp/src/Tools/Common/3DElementsFromList/Tests/CsvCoordinateParserTests.cs:453-471 Configuration Manifest id: DBTools.ElementsFromList3D assembly: DBTools moduleType: DBTools.ElementsFromList3D.ElementsFromList3DToolModule order: 0 tool: ribbonTools: - internalName: DBTools.ElementsFromList3D commandType: DBTools.ElementsFromList3D.ElementsFromList3DCommand availabilityType: DBTools.App.Tools.Availability.DbtDocumentAvailability runProfile: InlineUi displayText: \"3D Elements\\nFrom List\" iconBaseKey: 3d_elements tooltip: \"Create 3D elements from a CSV file\" controlKind: PushButton order: 10 - internalName: DBTools.FilledRegionsFromElements commandType: DBTools.ElementsFromList3D.FilledRegionsFromElementsCommand availabilityType: DBTools.App.Tools.Availability.DbtSelectionAvailability runProfile: InlineUi displayText: \"Filled Regions\\nFrom Elements\" iconBaseKey: filled_regions tooltip: \"Create filled regions from selected elements\" controlKind: PushButton order: 11 Source: csharp/src/Tools/Common/3DElementsFromList/manifest.yml:1-24 Availability Conditions Command Availability Type Condition 3D Elements From List DbtDocumentAvailability Any document open Filled Regions From Elements DbtSelectionAvailability Elements selected Source: csharp/src/Tools/Common/3DElementsFromList/manifest.yml:9,18 Family Dependency The 3D Elements command requires a specific family: Property Value File name 3D-Elements-From-List.rfa Family name 3D-Elements-From-List Category Generic Model (OST_GenericModel) Expected parameter ID (string, for CSV ID mapping) Source: csharp/src/Tools/Common/3DElementsFromList/Features/CsvElementPlacer.cs:23-24 The placer first searches for an existing family symbol in the document, then loads from the installed family library path if not found. Source: csharp/src/Tools/Common/3DElementsFromList/Features/CsvElementPlacer.cs:113-142 Filled Region Requirements The Filled Regions command requires specific project resources: Resource Requirement Filled Region Type Name contains \"solid\" AND \"gray\", non-masking Graphics Style <Invisible lines> (exact name) Caisson Family Concrete-Caisson (family name, case-insensitive) Caisson Diameter Type parameter b (double) Source: csharp/src/Tools/Common/3DElementsFromList/Features/FilledRegionCreator.cs:111-140 API Reference CsvCoordinateParser The static parser provides three entry points: public static class CsvCoordinateParser { // Parse from string array (already split lines) public static CsvParseResult Parse(IReadOnlyList<string> lines); // Parse from content string (handles line splitting) public static CsvParseResult ParseContent(string csvContent); // Parse from file path (handles file I/O) public static CsvParseResult ParseFile(string filePath); } Source: csharp/src/Tools/Common/3DElementsFromList/Features/CsvCoordinateParser.cs:72,121,135 CoordinateRecord Immutable value type for parsed coordinates: public readonly struct CoordinateRecord : IEquatable<CoordinateRecord> { public double X { get; } public double Y { get; } public double Z { get; } public string? Id { get; } } Source: csharp/src/Tools/Common/3DElementsFromList/Features/CsvCoordinateParser.cs:12-25 CsvParseResult Result type with explicit success/failure: public sealed class CsvParseResult { public IReadOnlyList<CoordinateRecord> Records { get; } public string? Error { get; } public bool IsSuccess => Error == null; public static CsvParseResult Success(IReadOnlyList<CoordinateRecord> records); public static CsvParseResult Failure(string error); } Source: csharp/src/Tools/Common/3DElementsFromList/Features/CsvCoordinateParser.cs:40-57 CsvElementPlacer Creates elements within a transaction: public sealed class CsvElementPlacer { public CsvElementPlacer(ITransactionRunner tx, Document doc, ILogger logger); public (int CreatedCount, int FailedCount, string? ErrorMessage) Run(string csvPath); } Source: csharp/src/Tools/Common/3DElementsFromList/Features/CsvElementPlacer.cs:26-33 FilledRegionCreator Creates filled regions from selected elements: public sealed class FilledRegionCreator { public FilledRegionCreator(ITransactionRunner tx, Document doc, View activeView, ILogger logger); public (int CreatedCount, int SkippedCount) Run(ICollection<ElementId> selectedIds); } Source: csharp/src/Tools/Common/3DElementsFromList/Features/FilledRegionCreator.cs:23-31 Testing The tool includes comprehensive unit tests for the CSV parser: Test Categories Category Test Count Description Basic Success Cases 5 Valid CSV parsing scenarios Column Order Variations 4 Different header orderings Whitespace Handling 4 Trimming and empty row skipping Number Formats 6 Integer, negative, scientific notation Error Cases 6 Null, empty, missing columns Invalid Data Handling 3 Malformed rows ParseContent (String) 5 Line ending variations CoordinateRecord 5 Equality and hash code CsvParseResult 2 Success/failure factories Integration Scenarios 2 Real-world CSV examples Total: 42 tests Source: csharp/src/Tools/Common/3DElementsFromList/Tests/TEST_SUMMARY.md:14-104 Running Tests # Build test assemblies bash csharp/build.sh BuildTests # Run parser tests (headless, no Revit required) dotnet test csharp/testing/DBTools.BuildArtifacts.Tests/DBTools.BuildArtifacts.Tests.csproj \\ -c Release --filter \"FullyQualifiedName~CsvCoordinateParser\" Source: csharp/src/Tools/Common/3DElementsFromList/Tests/DBTools.ElementsFromList3D.Tests.csproj:19-20 User Workflow Creating 3D Elements Click 3D Elements From List in the ribbon Select a CSV file with x, y, z columns Tool parses CSV and validates format Family is loaded if not present Elements are created at each coordinate Summary dialog shows created/failed counts Creating Filled Regions Select wall or caisson elements in the view Click Filled Regions From Elements in the ribbon Tool identifies element types (wall vs. caisson) For walls: creates rectangular regions from bounding box For caissons: creates circular regions from diameter Summary dialog shows created/skipped counts Error Handling The tool follows DBTools error handling conventions: Error Condition Behavior CSV file not found Returns error message, no elements created Missing x/y/z columns Returns error message with column requirement Invalid number format Skips row, continues processing Family not found Attempts auto-load; fails with clear message if unavailable No levels in document Throws with descriptive message No selection (regions) Throws with user instruction No suitable region type Logs warning, returns with all skipped Source: csharp/src/Tools/Common/3DElementsFromList/Features/CsvElementPlacer.cs:36-45 All commands display results via the alert service with appropriate variant (Info/Error). Source: csharp/src/Tools/Common/3DElementsFromList/Features/ElementsFromList3DCommand.cs:49-66 Related Documentation Architecture Overview - DBTools architecture and tool discovery Global Mapper - Example of a complex tool module Source Files Reviewed File Purpose manifest.yml Tool declaration and ribbon configuration ElementsFromList3DToolModule.cs Module registration ElementsFromList3DCommand.cs CSV import command FilledRegionsFromElementsCommand.cs Filled region command CsvCoordinateParser.cs Pure CSV parsing logic CsvElementPlacer.cs Element creation service FilledRegionCreator.cs Region creation service DBTools.ElementsFromList3D.csproj Project configuration CsvCoordinateParserTests.cs Unit tests TEST_SUMMARY.md Test documentation"
  },
  "articles/tools/common/elevation-tags.html": {
    "href": "articles/tools/common/elevation-tags.html",
    "title": "Elevation Tags | DBTools Developer Documentation",
    "summary": "Elevation Tags Elevation Tags is a Revit add-in tool that automatically aligns spot elevation tags in floor and ceiling plan views, ensuring consistent text positioning relative to leader endpoints. Overview Elevation Tags provides two modes of operation: Automatic Update: Tags are aligned when activating floor/ceiling plan views Manual Update: Users can trigger alignment on-demand via the ribbon button The tool calculates precise text positioning based on: Tag type font metrics (size, width scale, font family) View scale factor Leader direction Configurable offsets and text position preferences Source: csharp/src/Tools/Common/ElevationTags/Features/ElevationTagsAutoUpdater.cs:59-91 Features Feature Description Auto-Update on View Activation Automatically aligns elevation tags when opening floor/ceiling plan views Manual Alignment Command Ribbon button to align tags in the active view on-demand Regex Tag Filtering Configure which tags to align using regex patterns (up to 3 patterns) Text Position Control Position text above or below the tag origin Offset Adjustments Fine-tune horizontal and vertical positioning with model-unit offsets Warning System Tool can be disabled via warnings, preventing accidental auto-updates Source: csharp/src/Tools/Common/ElevationTags/Settings/ElevationTagsSettings.cs:21-56 User Interface Ribbon Button The tool adds a single ribbon button: Display Text: \"Align Elevation Tags\" Tooltip: \"Align elevation tags in the active view\" Icon: align_elevation_tags_icon.png Availability: Only enabled when an active view is present Source: csharp/src/Tools/Common/ElevationTags/manifest.yml:18-26 Settings Panel The settings UI provides controls for: Auto-Update Toggle - Enable/disable automatic updates on view activation Tag Name Patterns - Regex patterns to match elevation tag names (max 3) Alignment Offsets - Horizontal and vertical offset values with spinner controls Text Position - Radio buttons for Above/Below positioning Source: csharp/src/Tools/Common/ElevationTags/Settings/ElevationTagsSettingsPackView.xaml:43-259 Architecture Module Structure csharp/src/Tools/Common/ElevationTags/ +-- DBTools.ElevationTags.csproj # Project file +-- ElevationTagsToolModule.cs # DI registration entry point +-- manifest.yml # Tool manifest +-- Assets/ | +-- align_elevation_tags_icon.png +-- Features/ | +-- AlignElevationTagsInViewCommand.cs # Ribbon command | +-- ElevationTagsAutoUpdater.cs # Core alignment logic +-- Hooks/ | +-- ElevationTagsViewActivatedTask.cs # View activation handler +-- Settings/ +-- ElevationTagsSettings.cs # Settings model +-- ElevationTagsSettingsPackContext.cs # Settings UI context +-- ElevationTagsSettingsPackView.xaml # Settings UI view +-- ElevationTagsSettingsPackView.xaml.cs Source: Directory structure of csharp/src/Tools/Common/ElevationTags/ Data Flow +---------------------------+ | View Activation / Command | +-----------+---------------+ | v +---------------------------+ | ElevationTagsViewActivated| | Task / Command | +-----------+---------------+ | | Retrieves settings, creates updater v +---------------------------+ | ElevationTagsAutoUpdater | +-----------+---------------+ | +----------------------+----------------------+ | | | v v v +--------------+ +-----------------+ +------------------+ | Collect Tags | | Compute Layout | | Update Positions | | (Regex Match)| | Inputs | | (Transaction) | +--------------+ +-----------------+ +------------------+ Key Classes Class File Purpose ElevationTagsToolModule ElevationTagsToolModule.cs:14-92 Tool module registration; registers settings, services, and settings packs AlignElevationTagsInViewCommand Features/AlignElevationTagsInViewCommand.cs:19-48 Ribbon command entry point; creates updater and runs alignment ElevationTagsAutoUpdater Features/ElevationTagsAutoUpdater.cs:15-232 Core alignment logic; computes text positions and updates spot dimensions ElevationTagsViewActivatedTask Hooks/ElevationTagsViewActivatedTask.cs:20-66 View activation hook; triggers auto-update on floor/ceiling plan views ElevationTagsSettings Settings/ElevationTagsSettings.cs:21-56 Settings model with default values ElevationTagsSettingsPackContext Settings/ElevationTagsSettingsPackContext.cs:18-242 MVVM context for settings UI with validation Source: csharp/src/Tools/Common/ElevationTags/ElevationTagsToolModule.cs:14-92 Alignment Algorithm The ElevationTagsAutoUpdater.TryUpdateSpot() method performs the alignment calculation: Extract Tag Properties Origin position, leader end position, current text position Tag type parameters (text height, width scale, font name) Elevation base setting (Project Base Point, Survey Point, Relative) Format Elevation Value Apply elevation indicator prefix/suffix Format using document unit settings Measure Text Use GDI+ to measure formatted text string Account for font size scaled to view Calculate New Position Horizontal offset based on text width and leader direction Vertical offset based on text height and position setting (Above/Below) Apply user-configured offset adjustments Update Position Only update if position changed (rounded to 2 decimal places) Set SpotDimension.TextPosition to new XYZ Source: csharp/src/Tools/Common/ElevationTags/Features/ElevationTagsAutoUpdater.cs:145-231 View Activation Hook The ElevationTagsViewActivatedTask implements ViewActivatedTaskBase<ElevationTagsSettings>: protected override Task<bool> ShouldRunInternalAsync( UIApplication uiapp, ViewActivatedEventArgs args, ElevationTagsSettings settings, CancellationToken ct) { var view = app.ActiveUIDocument?.Document?.ActiveView; if (view == null) return Task.FromResult(false); return Task.FromResult( view.ViewType == ViewType.FloorPlan || view.ViewType == ViewType.CeilingPlan); } The task only runs when: Auto-update is enabled in settings No active warning is set The activated view is a floor plan or ceiling plan Source: csharp/src/Tools/Common/ElevationTags/Hooks/ElevationTagsViewActivatedTask.cs:40-52 Settings Settings Model public sealed class ElevationTagsSettings : IAutoUpdateSettings { /// <summary>Whether auto-update on view activation is enabled.</summary> public bool AutoUpdateEnabled { get; set; } = true; /// <summary>Whether a warning has been set (disables auto-update).</summary> public bool HasWarning { get; set; } /// <summary> /// Regex patterns to match tag names. Tags matching any pattern will be aligned. /// Default pattern matches tags starting with \"DB Elevation Tag\". /// Maximum of 3 patterns. /// </summary> public List<string> TagNamePatterns { get; set; } = new() { \"^DB Elevation Tag\" }; /// <summary>Horizontal offset factor applied during text positioning (model units).</summary> public double HorizontalOffset { get; set; } /// <summary>Vertical offset factor applied during text positioning (model units).</summary> public double VerticalOffset { get; set; } /// <summary>Position of aligned text relative to the tag origin.</summary> public ElevationTextPosition TextPosition { get; set; } = ElevationTextPosition.Above; } Source: csharp/src/Tools/Common/ElevationTags/Settings/ElevationTagsSettings.cs:21-56 Text Position Enum public enum ElevationTextPosition { /// <summary>Text is positioned above the tag origin.</summary> Above = 0, /// <summary>Text is positioned below the tag origin.</summary> Below = 1 } Source: csharp/src/Tools/Common/ElevationTags/Settings/ElevationTagsSettings.cs:9-16 Default Values Setting Default Value Description AutoUpdateEnabled true Auto-update is enabled by default HasWarning false No warning set initially TagNamePatterns [\"^DB Elevation Tag\"] Matches tags starting with \"DB Elevation Tag\" HorizontalOffset 0.0 No additional horizontal offset VerticalOffset 0.0 No additional vertical offset TextPosition Above Text positioned above the tag origin Configuration Section Settings are stored under the Tools.ElevationTags configuration section. Source: csharp/src/Tools/Common/ElevationTags/manifest.yml:7 Manifest id: DBTools.ElevationTags assembly: DBTools moduleType: DBTools.ElevationTags.ElevationTagsToolModule order: 0 tool: settings: configSection: Tools.ElevationTags settingsPacks: - key: common.elevation_tags title: \"Elevation Tags\" warnings: - id: core.structural.elevation_tags title: \"Elevation Tags Disabled\" message: \"Elevation tag alignment is disabled due to a warning. Clear the warning to re-enable.\" disableTools: - DBTools.AlignElevationTagsInView ribbonTools: - internalName: DBTools.AlignElevationTagsInView commandType: DBTools.ElevationTags.AlignElevationTagsInViewCommand availabilityType: DBTools.App.Tools.Availability.DbtActiveViewAvailability runProfile: InlineUi displayText: \"Align Elevation\\nTags\" iconBaseKey: align_elevation_tags tooltip: \"Align elevation tags in the active view\" controlKind: PushButton order: 20 Source: csharp/src/Tools/Common/ElevationTags/manifest.yml:1-27 Manifest Properties Property Value Description id DBTools.ElevationTags Unique tool identifier assembly DBTools Target assembly name moduleType DBTools.ElevationTags.ElevationTagsToolModule Entry point class order 0 Load order priority configSection Tools.ElevationTags Settings configuration key runProfile InlineUi Runs on UI thread with inline modal gate availabilityType DbtActiveViewAvailability Command available when active view exists Warning System The tool defines a single warning that can disable functionality: Warning ID: core.structural.elevation_tags Title: \"Elevation Tags Disabled\" Effect: When active, disables the AlignElevationTagsInView command and auto-update When the warning is set: HasWarning becomes true AutoUpdateEnabled is forced to false The toggle in settings is disabled Source: csharp/src/Tools/Common/ElevationTags/ElevationTagsToolModule.cs:47-68 API Reference ElevationTagsAutoUpdater The main alignment class that processes spot elevation tags: public sealed class ElevationTagsAutoUpdater { public ElevationTagsAutoUpdater( ITransactionRunner tx, Document doc, View activeView, ILogger<ElevationTagsAutoUpdater> logger, ElevationTagsSettings? settings = null); /// <summary> /// Runs the alignment process and returns the count of updated tags. /// Only processes floor plan and ceiling plan views. /// </summary> public int Run(); } Source: csharp/src/Tools/Common/ElevationTags/Features/ElevationTagsAutoUpdater.cs:27-91 Filtering Logic Tags are collected using a FilteredElementCollector scoped to the active view: var tags = new FilteredElementCollector(_doc, _view.Id) .OfCategory(BuiltInCategory.OST_SpotElevations) .WhereElementIsNotElementType() .ToElements(); Each tag's name is tested against all configured regex patterns. Tags matching any pattern are included. Source: csharp/src/Tools/Common/ElevationTags/Features/ElevationTagsAutoUpdater.cs:96-122 Elevation Base Handling The tool respects the elevation base setting on tag types: Base Setting Behavior Survey Point Uses raw elevation value Project Base Point Subtracts project base point Z from elevation Relative Tag is skipped (not aligned) Source: csharp/src/Tools/Common/ElevationTags/Features/ElevationTagsAutoUpdater.cs:166-170 Troubleshooting Common Issues Issue Cause Resolution Tags not aligning No patterns match tag names Add regex pattern matching your tag family names Auto-update not running Warning is active Clear the warning in settings panel Auto-update not running Disabled in settings Enable auto-update toggle No tags in view View type not supported Only floor and ceiling plans are processed Invalid regex pattern Syntax error in pattern Check regex syntax; patterns are validated Tags with Relative base skipped By design Tags with Relative elevation base cannot be aligned Logging The tool logs diagnostic information via ILogger<ElevationTagsAutoUpdater>: Invalid regex patterns are logged as warnings Tags that fail to filter or update are logged (first occurrence only) Units format option errors are logged _logger.LogWarning(ex, \"[ElevationTags] Invalid regex pattern '{Pattern}'; skipping.\", pattern); _logger.LogWarning(\"[ElevationTags] No valid tag name patterns are configured; auto-update will be skipped.\"); _logger.LogWarning(ex, \"[ElevationTags] Some elevation tags could not be updated; continuing.\"); Source: csharp/src/Tools/Common/ElevationTags/Features/ElevationTagsAutoUpdater.cs:51-189 Related Documentation Architecture Overview - DBTools architecture fundamentals Theme System - UI theming for settings panels Source Files Reviewed File Purpose manifest.yml Tool declaration and ribbon configuration ElevationTagsToolModule.cs Module registration and DI setup AlignElevationTagsInViewCommand.cs Ribbon command entry point ElevationTagsAutoUpdater.cs Core alignment algorithm ElevationTagsViewActivatedTask.cs View activation hook ElevationTagsSettings.cs Settings model definition ElevationTagsSettingsPackContext.cs Settings UI view model ElevationTagsSettingsPackView.xaml Settings UI layout DBTools.ElevationTags.csproj Project configuration"
  },
  "articles/tools/common/gm.html": {
    "href": "articles/tools/common/gm.html",
    "title": "Global Mapper (GM) | DBTools Developer Documentation",
    "summary": "Global Mapper (GM) Global Mapper is a comprehensive Revit type-mapping tool that enables users to detect, plan, and apply bulk element replacements across families, types, materials, line styles, object styles, and shared parameters. Overview Global Mapper provides a unified interface for: Family/Type Mapping: Replace family instances with equivalent types from other families Duplicate Detection: Identify potential duplicate elements using similarity analysis Usage Analysis: Understand material, line style, and object style usage across families Deep Scan: Analyze family document contents to extract parameter names, style refs, and material refs Shared Parameter Authoring: Bind and embed shared parameters to families/categories Source: csharp/src/Tools/Common/GM/manifest.yml:1-26 Features Feature Description Duplicates Tab Detects potential duplicate families, materials, styles, and shared parameters using weighted similarity scoring Families Tab Browse families by category, select target mappings, and configure type replacements Line Styles Tab View and map line style usage with visual preview Object Styles Tab View and map object style usage with visual preview Materials Tab View and map material usage with color preview Shared Parameters Tab Manage shared parameter bindings across categories and families Deep Scan Analyze family documents to extract embedded parameter names, style references, and material references Mapping Persistence Save and restore mapping preferences per-project Conflict Detection Identify conflicting mappings before applying changes Source: csharp/src/Tools/Common/GM/Shell/UI/Views/GmWindow.xaml:293-361 (Ribbon tab definitions) User Interface The GM window uses a Fluent Ribbon with six main tabs: Duplicates (Index 0) - Duplicate detection and resolution Families (Index 1) - Family/type mapping with category filtering Line Styles (Index 2) - Line style replacement with preview Object Styles (Index 3) - Object style replacement with preview Materials (Index 4) - Material replacement with color preview Shared Parameters (Index 5) - Parameter binding and authoring Each tab provides: A main DataGrid with source items and target selection dropdowns Row expansion for nested details (types within families, pairs within duplicate groups) Visual previews where applicable (color swatches, style weights) Action buttons for applying changes Source: csharp/src/Tools/Common/GM/Shell/UI/Views/GmWindow.xaml:365-576 Global Header Controls The header bar provides cross-tab controls: Search: Filter visible items by name Threshold Slider: Adjust similarity scoring threshold (0-100%) Sort Mode: Toggle between Similarity and Alphabetical ordering Filters: Hide Unused, Hide Unscanned, Applied Only Source: csharp/src/Tools/Common/GM/Shell/UI/Views/GmWindow.xaml:179-288 Architecture Module Structure csharp/src/Tools/Common/GM/ +-- GmToolModule.cs # DI registration entry point +-- Bootstrap/ | +-- GmServiceExtensions.cs # Services.AddGmServices() wrapper +-- Features/ | +-- GmCommand.cs # Ribbon command entry point | +-- Duplicates/ # Duplicate detection feature | +-- Families/ # Family/type mapping feature | +-- Mapping/ # Apply/verify mapping logic | +-- SavedMappings/ # Persistence layer | +-- SharedParameters/ # SP authoring feature | +-- Similarity/ # Name and parameter similarity | +-- Usage/ # Usage index building | +-- DeepScan/ # Family document analysis +-- Shell/ | +-- GmShellLauncher.cs # Window construction | +-- DI/Services.cs # Full DI registration | +-- UI/Views/ # WPF windows and XAML | +-- UI/ViewModels/ # MVVM view models | +-- DesignTime/ # Design-time view models +-- Shared/ | +-- Kernel/ # Domain state (GmProjectState) | +-- Planning/ # Mapping plan generation | +-- Contracts/ # Service interfaces | +-- Caching/ # Cache strategies | +-- Context/ # Planning context | +-- Project/ # Project lifecycle +-- Tests/ # Unit and integration tests Source: Directory structure of csharp/src/Tools/Common/GM/ Data Flow +------------------+ | GmCommand | +--------+---------+ | Resolves services via DI v +------------------+ | GmShellLauncher | +--------+---------+ | Creates window + ViewModel v +-------------------+ | GmShellViewModel | +--------+----------+ | +------------+------------+------------+------------+ | | | | | v v v v v +----------+ +----------+ +---------+ +----------+ +---------+ | Families | | Usage | | Mapping | | Planning | | Kernel | | Pane VM | | Pane VM | | Service | | Service | | State | +----------+ +----------+ +---------+ +----------+ +---------+ Kernel Architecture The GmProjectState is the Single Source of Truth (SSOT) for GM domain state. It holds IDs only - no Revit types leak into the kernel. public sealed class GmProjectState { public long Version { get; set; } public GmSourceSnapshot? SourceSnapshot { get; set; } public Dictionary<int, GmFamilyRecord> Families { get; set; } public GmUsageIndex Usage { get; set; } public GmSharedParameterLedger SharedParameters { get; set; } public GmTabStateSet Tabs { get; set; } public Dictionary<int, string> FamilyNames { get; set; } public Dictionary<int, string> SymbolNames { get; set; } public Dictionary<int, IReadOnlyCollection<(string, string, int)>> NestedOwnerNameIndex { get; set; } } Source: csharp/src/Tools/Common/GM/Shared/Kernel/State/GmProjectState.cs:1-32 The GmKernelMapper provides read-only projections of kernel data for UI consumption: GetLineStyleFamilyCounts() - Style usage counts GetDeepScanStyleRefsByFamily() - DS style references GetDeepScanMaterialRefsByFamily() - DS material references GetDeepScanParamNamesByFamily() - DS parameter names Source: csharp/src/Tools/Common/GM/Shared/Kernel/State/GmKernelMapper.cs:53-264 Key Classes Entry Points Class File Purpose GmToolModule GmToolModule.cs:10-18 Tool module registration; calls AddGmServices() GmCommand Features/GmCommand.cs:31-145 Ribbon command entry point; resolves all services and launches UI GmShellLauncher Shell/GmShellLauncher.cs:35-117 Static launcher creating GmWindow and GmShellViewModel Source: csharp/src/Tools/Common/GM/GmToolModule.cs:10-18 View Models Class File Purpose GmShellViewModel Shell/UI/ViewModels/GmShellViewModel.*.cs Main shell view model (split across partials) FamiliesPaneViewModel Features/Families/FamiliesPaneViewModel.cs:9-36 Families tab state UsagePaneViewModel Features/Usage/UsagePaneViewModel.cs Usage tabs (styles, materials) state DuplicatesPaneViewModel Features/Duplicates/DuplicatesPaneViewModel.cs Duplicates tab state SharedParametersPaneViewModel Features/SharedParameters/SharedParametersPaneViewModel.cs SP tab state Source: csharp/src/Tools/Common/GM/Features/Families/FamiliesPaneViewModel.cs:9-36 Core Services Interface Implementation Purpose IProjectLifecycleService ProjectLifecycleService Build kernel from Revit document IGmPlanningService GmPlanningService Generate normalized mapping plans IGmMappingService GmMappingService Apply plans to Revit document IDuplicateDetectionService DuplicateDetectionService Detect duplicate elements INamingSimilarityService NamingSimilarityService Name-based similarity scoring IParameterSimilarityService ParameterSimilarityService Parameter overlap scoring Source: csharp/src/Tools/Common/GM/Shell/DI/Services.cs:33-106 Revit Adapters Interface Implementation Purpose ITypeChangeService TypeChangeService Replace type on instances IStyleChangeService StyleChangeService Replace line style on curves IMaterialChangeService MaterialChangeServiceWriter Replace material parameters IParameterChangeService ParameterChangeService Copy type parameters IHostChangeService HostChangeService Handle host/placement changes INestingChangeService NestingChangeService Replace nested families by name ITypeCreationService TypeCreationService Create new type symbols IDeepScanService DeepScanServiceAdapter Deep scan family documents Source: csharp/src/Tools/Common/GM/Shell/DI/Services.cs:66-86 Configuration Manifest id: DBTools.GM assembly: DBTools moduleType: DBTools.GM.GmToolModule order: 0 sandboxWindows: - id: DBTools.GM.Main displayName: \"Global Mapper\" group: \"Common\" windowType: \"DBTools.GM.Shell.UI.Views.GmWindow\" designTimeViewModelType: \"DBTools.GM.Shell.DesignTime.GmShellDesignTimeViewModel\" - id: DBTools.GM.MappingReport displayName: \"Global Mapper - Mapping Report\" group: \"Common\" windowType: \"DBTools.GM.Features.Mapping.UI.Views.GmMappingReportWindow\" tool: ribbonTools: - internalName: DBTools.GM commandType: DBTools.GM.Features.GmCommand availabilityType: DBTools.App.Tools.Availability.DbtDocumentAvailability runProfile: InlineUi displayText: \"Global Mapper\" iconBaseKey: gm tooltip: \"Open Global Mapper\" controlKind: PushButton order: 30 Source: csharp/src/Tools/Common/GM/manifest.yml:1-27 Caching GM uses project-scoped caching strategies: Cache Strategy Purpose Deep Scan DeepScanCacheStrategy Cache family document scan results UI State UiStateStrategy Persist UI selections between sessions Saved Mappings SavedMappingService Store user mapping preferences Cache files are stored under %LocalAppData%/DBTools/GM/. Source: csharp/src/Tools/Common/GM/Shell/DI/Services.cs:97-105 API Reference Planning Service The IGmPlanningService generates normalized mapping plans: public interface IGmPlanningService { Task<GmPlanningResult> BuildPlanAsync( IReadOnlyDictionary<int, int> typeMappings, IReadOnlyDictionary<int, int> materialMappings, IReadOnlyDictionary<int, int> styleMappings, CancellationToken ct = default); Task<GmPlanningResult> BuildPlanAsync( IReadOnlyDictionary<int, int> typeMappings, IReadOnlyDictionary<int, int> materialMappings, IReadOnlyDictionary<int, int> styleMappings, IReadOnlyDictionary<int, int> paramMappings, IReadOnlyCollection<(int sourceId, string? newName)> createType, IGmContext? context, CancellationToken ct = default); } Source: csharp/src/Tools/Common/GM/Shared/Planning/IGmPlanningService.cs:8-28 Operation Kinds Plans contain operations of these types: public enum GmOperationKind { ReplaceType, // Replace type on family instances ReplaceMaterial, // Replace material parameters ReplaceStyle, // Replace line/object styles MapParameter, // Copy parameter values between types AddNestedFamily, // Add nested family replacement (by name) ReplaceHost, // Handle host/placement mismatches CreateType, // Create new type symbol BindSharedParameter, // Bind SP at host level EmbedSharedParameter // Embed SP in family document } Source: csharp/src/Tools/Common/GM/Shared/Planning/GmOperationKind.cs:3-14 Mapping Service The IGmMappingService applies plans to the Revit document: public interface IGmMappingService { Task ImportAsync(string path, CancellationToken ct = default); Task ExportAsync(string path, CancellationToken ct = default); Task ImportSimpleAsync(string path, CancellationToken ct = default); Task ExportSimpleAsync(string path, CancellationToken ct = default); Task<GmMappingValidationResult> ValidateAsync(CancellationToken ct = default); Task<GmMappingApplyResult> ApplyAsync(CancellationToken ct = default); Task<GmMappingApplyResult> ApplyPlanAsync(GmPlanningResult plan, IProgress<string>? progress = null, CancellationToken ct = default); Task<GmMappingVerifyResult> VerifyAsync(GmPlanningResult plan, CancellationToken ct = default); Task AddDuplicateMappingsAsync(GmDuplicateApplyBatch batch, CancellationToken ct = default); } Source: csharp/src/Tools/Common/GM/Features/Mapping/IGmMappingService.cs:12-27 Duplicate Detection The IDuplicateDetectionService analyzes the kernel for potential duplicates: public interface IDuplicateDetectionService { Task<DuplicateDetectionResult> DetectAsync(GmProjectState kernel, CancellationToken ct = default); } Detection uses: Families: 70% name similarity + 30% parameter overlap (when DS data available) Styles: Preview signature matching (color, weight, pattern) Materials: Preview + name similarity Shared Parameters: Type display + normalized name Source: csharp/src/Tools/Common/GM/Features/Duplicates/Logic/DuplicateDetectionService.cs:43-98 Testing GM tests use a shared fixture that opens a dedicated test model: [NonParallelizable] public abstract class GmTestFixture { protected const string GmModelFileName = \"gm_test_model.rvt\"; protected UIApplication UiApp { get; private set; } protected Document? Doc { get; private set; } protected IRevitCallGate? Gate { get; private set; } protected ITransactionRunner? TxRunner { get; private set; } } Source: csharp/src/Tools/Common/GM/Tests/GMTestFixture.cs:20-53 Test Categories Test Class Purpose GM_PlanningServiceTests Planning result validation GM_MappingServiceTests Apply/verify cycle testing GM_MappingApplyPlanTests End-to-end plan application DuplicateDetectionServiceTests Duplicate detection accuracy GmKernelMapperTests Kernel projection correctness GmWindowViewModel_*Tests ViewModel behavior tests Running Tests # Build test assemblies bash csharp/build.sh BuildTests # Run via Revit test runner bash csharp/invoke-revit-tests.sh --smart --tool GM -y 2025 Troubleshooting Common Issues Issue Cause Resolution \"No families found\" Category filter too restrictive Select a different category or clear filters Empty duplicate groups Similarity threshold too high Lower the threshold slider Deep scan incomplete Family document errors Check Revit error log; try manual deep scan Mapping not applied Target type not available Verify target family is loaded in project Conflict panel showing Multiple sources map to same target Resolve conflicts in conflict panel Logging GM logs diagnostic information via ILogger. Enable debug logging to see: Kernel build timing Cache hit/miss statistics Plan operation details Apply stage progress _logger.LogDebug(\"GM: scanned {Count} families for categoryId={CategoryId}\", families.Count, SelectedCategory?.Id); Source: csharp/src/Tools/Common/GM/Shell/UI/ViewModels/GmShellViewModel.CoreAndCommands.cs:1043-1045 Related Documentation Architecture Overview - DBTools architecture DBTools.Core - Core infrastructure Test Pipeline - Test infrastructure Verification Status Check Status Source anchors for all claims Yes UNVERIFIED markers where needed No (all verified) Cross-references added Yes Examples tested N/A No assumptions without evidence Yes Verified by: docs-run-20260124-020412 Date: 2026-01-24"
  },
  "articles/tools/common/tdv.html": {
    "href": "articles/tools/common/tdv.html",
    "title": "TDV - Transfer Drafting Views | DBTools Developer Documentation",
    "summary": "TDV - Transfer Drafting Views TDV (Transfer Drafting Views) is a tool for importing and exporting drafting views between Revit documents and a central library. It enables teams to maintain a shared collection of standard drafting views that can be distributed across projects. Source: csharp/src/Tools/Common/TDV/manifest.yml:1-45 Overview TDV provides two primary operations: Export to Library - Copy drafting views from the active document to a central library file Import from Library - Copy drafting views from a library file to the active document The tool handles worksharing, creates local copies for edits, and synchronizes changes back to the central library file after export operations. Source: csharp/src/Tools/Common/TDV/Features/TdvExportCommand.cs:18-27 Features Core Capabilities Bi-directional transfer - Import and export drafting views between documents View type mapping - Map source view types to destination view types, or retain original type Conflict detection - Real-time detection of naming conflicts with existing views Replace mode - Option to replace existing views with the same name Preview panel - Live preview of selected drafting views with pan/zoom support Batch transfer - Transfer multiple views in a single operation Transaction grouping - All transfers wrapped in a transaction group for atomicity Progress tracking - Per-view progress feedback during transfer operations Source: csharp/src/Tools/Common/TDV/Revit/Services/TdvService.cs:106-291 Library Management Multiple library files - Configure multiple library files with fallback paths Path validation - Automatic validation of library file accessibility Local copy workflow - Creates local copies from central files for worksharing Automatic sync - Syncs changes back to central after export with detailed comments Source: csharp/src/Tools/Common/TDV/Revit/Services/TdvDocumentService.cs:26-126 View Transfer Details When transferring views, TDV: Creates or prepares the destination view with the selected view type Copies the view scale and description parameters Copies all elements from the source view (excluding viewports, title blocks, schedules, etc.) Copies element graphic overrides from source to destination Source: csharp/src/Tools/Common/TDV/Revit/Services/TdvOps.cs:145-189 Architecture TDV follows the MVVM pattern with a clean separation between UI, business logic, and Revit API operations. Project Structure csharp/src/Tools/Common/TDV/ ├── Bootstrap/ # DI registration ├── Contracts/ # Interfaces and DTOs ├── DesignTime/ # Design-time view models ├── Features/ # Command implementations ├── Properties/ # Design-time resources ├── Revit/Services/ # Revit API operations ├── Settings/ # Configuration models ├── Tests/ # Unit tests └── UI/ ├── ViewModels/ # MVVM view models └── Views/ # WPF views Service Registration Services are registered as scoped to properly handle Revit's run-scope dependencies: Source: csharp/src/Tools/Common/TDV/Bootstrap/TdvServiceExtensions.cs:11-33 services.AddScoped<ITdvTransferService>(sp => new TdvService(gate, tx, groups, logger)); services.AddScoped<ITdvLibraryService, TdvLibraryService>(); services.AddScoped<ITdvDocumentService, TdvDocumentService>(); Key Interfaces Interface Implementation Purpose ITdvTransferService TdvService Core transfer operations ITdvLibraryService TdvLibraryService Library path management ITdvDocumentService TdvDocumentService Document open/close/sync ITdvContext TdvService.RevitTdvContext Abstraction over Revit Document Source: csharp/src/Tools/Common/TDV/Contracts/ITdvTransferService.cs:1-23 Transfer Service Operations The ITdvTransferService interface defines: Method Description BuildViewItemsAsync Collects drafting views from source document ApplySelectionAsync Executes the transfer operation WouldConflictAsync Checks for naming conflicts ExportPreviewAsync Generates preview image for a view Source: csharp/src/Tools/Common/TDV/Contracts/ITdvTransferService.cs:6-22 UI Components Main Window (TdvWindow) The main transfer window provides: Filter controls - Filter by view type and search by name Data grid - Lists all drafting views with transfer options Preview panel - Shows selected view with pan/zoom Status bar - Displays selection counts and transfer results Source: csharp/src/Tools/Common/TDV/UI/Views/TdvWindow.xaml:1-537 ViewModel (TdvWindowViewModel) Key properties and commands: Property Type Description Items ObservableCollection<TdvViewItem> Filtered list of views Search string Search filter text SelectedViewTypeFilter string View type filter SelectedItem TdvViewItem Currently selected view PreviewSource ImageSource Preview image HasAnyConflict bool Indicates naming conflicts Status string Status bar text Command Description ApplySelectionCommand Executes the transfer ClearSelectedCommand Clears all selections ClearSearchCommand Clears search filter Source: csharp/src/Tools/Common/TDV/UI/ViewModels/TdvWindowViewModel.cs:22-409 View Item (TdvViewItem) Represents a single drafting view in the UI: Property Type Description SourceViewId int Revit element ID ViewName string Editable view name ViewType string Selected destination type ViewTypeName string Original source type name Checked bool Selected for transfer Replace bool Replace if exists HasConflict bool Has naming conflict HasTypeWarning bool Source type unavailable RowState string Transfer status (pending/success/failure) Source: csharp/src/Tools/Common/TDV/UI/ViewModels/TdvViewItem.cs:9-106 Preview Features The preview panel supports: Debounced loading - 200ms debounce prevents excessive exports LRU cache - Caches up to 32 preview images Pan and zoom - Interactive image manipulation via ImagePanZoomBehavior Dark theme background - Consistent preview appearance (RGB: 43, 44, 61) Source: csharp/src/Tools/Common/TDV/UI/ViewModels/TdvWindowViewModel.cs:74-81 Source: csharp/src/Tools/Common/TDV/Revit/Services/TdvOps.cs:19-28 Settings Configuration Library Settings TDV uses the MasterLibrarySettings class to store library file configurations: public sealed class MasterLibrarySettings { public IList<LibraryFileEntry> Files { get; set; } public bool HasWarnings { get; set; } } public sealed class LibraryFileEntry { public string? MainPath { get; set; } public string? FallbackPath { get; set; } } Source: csharp/src/Tools/Common/TDV/Settings/MasterLibrarySettings.cs:1-8 Source: csharp/src/Tools/Common/TDV/Settings/LibraryFileEntry.cs:1-8 Each library entry supports: Main path - Primary path to the library RVT file Fallback path - Alternative path (e.g., for different network locations) Settings Pack The LibrarySettingsPackContext provides the settings UI with: Tree-based library file management Add/remove library files Add/remove fallback paths Real-time path validation Pending changes tracking Source: csharp/src/Tools/Common/TDV/Settings/LibrarySettingsPackContext.cs:19-352 Path Validation Library paths are validated for: File existence .rvt extension Accessibility Invalid paths trigger a settings warning that disables the import/export commands. Source: csharp/src/Tools/Common/TDV/Revit/Services/TdvLibraryService.cs:100-141 Manifest Configuration The tool is configured via manifest.yml: id: DBTools.TDV assembly: DBTools moduleType: DBTools.TDV.TdvToolModule order: 0 sandboxWindows: - id: DBTools.TDV.Main displayName: \"Transfer Drafting Views\" group: \"Common\" windowType: \"DBTools.TDV.UI.Views.TdvWindow\" tool: settings: configSection: Core.MasterLibrary settingsPacks: - key: core.library title: \"Library Files\" warnings: - id: core.library.invalid title: \"Library Paths Invalid\" message: \"One or more library file paths are invalid...\" disableTools: - DBTools.ExportToLibrary - DBTools.ImportFromLibrary ribbonTools: - internalName: DBTools.ExportToLibrary commandType: DBTools.TDV.Features.TdvExportCommand availabilityType: DBTools.App.Tools.Availability.DbtDocumentAvailability runProfile: InlineUi displayText: \"Export\\nTo Library\" iconBaseKey: export tooltip: \"Export drafting views to the library\" controlKind: StackedButtonItem splitGroup: library_transfer - internalName: DBTools.ImportFromLibrary commandType: DBTools.TDV.Features.TdvImportCommand availabilityType: DBTools.App.Tools.Availability.DbtDocumentAvailability runProfile: InlineUi displayText: \"Import\\nFrom Library\" iconBaseKey: import tooltip: \"Import drafting views from the library\" controlKind: StackedButtonItem splitGroup: library_transfer Source: csharp/src/Tools/Common/TDV/manifest.yml:1-45 Ribbon Configuration Property Export Import Internal Name DBTools.ExportToLibrary DBTools.ImportFromLibrary Command TdvExportCommand TdvImportCommand Run Profile InlineUi InlineUi Icon export import Control Kind StackedButtonItem StackedButtonItem Split Group library_transfer library_transfer Error Handling Per-View Error Codes Transfer failures are categorized by error code: Code Description Unknown Unspecified error DestinationTypeMissing Target view type not found SourceTypeNameUnavailable Cannot read source view type CreateViewFailed Failed to create destination view CopyElementsFailed Failed to copy view elements OverridesFailed Failed to copy graphic overrides Source: csharp/src/Tools/Common/TDV/Contracts/TdvPerViewErrorCode.cs:1-12 Error Reporting After transfer, errors are displayed in a detailed alert dialog with: Summary counts (added, replaced, skipped) Error details table with source info and error messages Copy to clipboard functionality Source: csharp/src/Tools/Common/TDV/UI/Views/TdvWindow.xaml.cs:111-186 Revit API Operations Getting Drafting Views new FilteredElementCollector(doc) .OfClass(typeof(View)) .WhereElementIsNotElementType() .Cast<View>() .Where(v => v.ViewType == ViewType.DraftingView && !v.IsTemplate) Source: csharp/src/Tools/Common/TDV/Revit/Services/TdvOps.cs:30-39 Copying View Contents Elements are copied using ElementTransformUtils.CopyElements with a custom IDuplicateTypeNamesHandler that uses destination types when duplicates are found. Source: csharp/src/Tools/Common/TDV/Revit/Services/TdvOps.cs:145-162 Skipped Categories The following categories are excluded from copy operations: Title Blocks Viewports Views Schedules Guide Grids Source: csharp/src/Tools/Common/TDV/Revit/Services/TdvOps.cs:13-16 Command Reference Export Command Flow Validate library paths are configured Prompt user to select a library file Create local copy of central library file Open library document Show TdvWindow for view selection Execute transfer to library Sync changes to central with comment Close library and reactivate original document Source: csharp/src/Tools/Common/TDV/Features/TdvExportCommand.cs:31-137 Import Command Flow Validate library paths are configured Prompt user to select a library file Create local copy of central library file Open library document Show TdvWindow for view selection Execute transfer to active document Close library (no sync needed) Source: csharp/src/Tools/Common/TDV/Features/TdvImportCommand.cs:27-107 Cross-References Architecture Overview - Application architecture patterns App Project - Main application and tool hosting Testing TDV includes unit tests for: TdvViewItem - View model behavior TdvLibraryService - Path validation and library management TdvAdapter - Service adapter tests Source: csharp/src/Tools/Common/TDV/Tests/ Last updated: January 2026"
  },
  "articles/tools/structural/analytical-snap.html": {
    "href": "articles/tools/structural/analytical-snap.html",
    "title": "Analytical Snap To Level | DBTools Developer Documentation",
    "summary": "Analytical Snap To Level Analytical Snap To Level is a Revit tool that snaps selected analytical model elements (beams and columns) to a user-specified level elevation. Overview This tool provides a streamlined workflow for aligning analytical model geometry to structural levels. It supports two structural roles with role-specific snapping behavior: Beams: Both endpoints are moved to the target level elevation Columns: Only the endpoint closest to the target level is moved, preserving the other endpoint's position Source: csharp/src/Tools/Structural/AnalyticalSnapToLevel/Features/AnalyticalLevelSnapper.cs:88-119 Features Feature Description Selection-Based Operates on pre-selected analytical elements Level Picker Interactive dialog to choose target level Role-Aware Snapping Different snap behavior for beams vs columns Batch Processing Processes multiple elements in a single transaction Summary Report Displays processed/skipped counts after execution Source: csharp/src/Tools/Structural/AnalyticalSnapToLevel/Features/AnalyticalSnapToLevelCommand.cs:19-70 Workflow Select Elements: Pre-select analytical members in the Revit view Launch Tool: Click \"Analytical Snap To Level\" button on the ribbon Pick Level: Select target level from the level picker dialog Review Results: View summary showing processed and skipped element counts Supported Elements The tool only processes elements that meet these criteria: Category: OST_AnalyticalMember Type: Must be castable to AnalyticalMember Structural Role: \"Beam\" or \"Column\" (other roles are skipped) Geometry: Must have a valid curve Source: csharp/src/Tools/Structural/AnalyticalSnapToLevel/Features/AnalyticalLevelSnapper.cs:55-81 Snapping Behavior Beams Beams are horizontal members. Both endpoints are moved to the target elevation while preserving X and Y coordinates: Original: Start(X1, Y1, Z1) ---- End(X2, Y2, Z2) Snapped: Start(X1, Y1, TargetElev) ---- End(X2, Y2, TargetElev) Source: csharp/src/Tools/Structural/AnalyticalSnapToLevel/Features/AnalyticalLevelSnapper.cs:88-93 Columns Columns are vertical members. Only the endpoint closest to the target level is moved: Original: Top(X, Y, 20) | Bottom(X, Y, 10) Target at 12: Top(X, Y, 20) | Bottom(X, Y, 12) [bottom was closer] Source: csharp/src/Tools/Structural/AnalyticalSnapToLevel/Features/AnalyticalLevelSnapper.cs:95-112 Architecture Module Structure csharp/src/Tools/Structural/AnalyticalSnapToLevel/ +-- manifest.yml # Tool declaration +-- AnalyticalSnapToLevelToolModule.cs # DI module registration +-- DBTools.Structural.AnalyticalSnapToLevel.csproj # Project file +-- Features/ | +-- AnalyticalSnapToLevelCommand.cs # Ribbon command entry point | +-- AnalyticalLevelSnapper.cs # Core snapping logic +-- Assets/ +-- analytical_snap_icon.png # Ribbon icon Source: Directory structure of csharp/src/Tools/Structural/AnalyticalSnapToLevel/ Key Classes Class File Purpose AnalyticalSnapToLevelToolModule AnalyticalSnapToLevelToolModule.cs:5-7 Empty tool module for registration AnalyticalSnapToLevelCommand Features/AnalyticalSnapToLevelCommand.cs:17-71 Command entry point; orchestrates workflow AnalyticalLevelSnapper Features/AnalyticalLevelSnapper.cs:16-135 Core snapping service Source: csharp/src/Tools/Structural/AnalyticalSnapToLevel/AnalyticalSnapToLevelToolModule.cs:5-7 Data Flow +----------------------------+ | AnalyticalSnapToLevelCommand| +-------------+--------------+ | | 1. Get selected element IDs | 2. Show level picker v +-------------------+ | LevelPickerHelper | (from DBTools.Core) +-------------------+ | | Returns selected Level v +----------------------------+ | AnalyticalLevelSnapper | +-------------+--------------+ | | 3. Iterate selected IDs | 4. Filter to AnalyticalMember | 5. Check structural role | 6. Compute new curve | 7. SetCurve on member v +----------------------------+ | Summary Alert | +----------------------------+ Dependencies The tool depends on these core services: Service Source Purpose IAlertService DBTools.Core Show level picker and summary dialogs LevelPickerHelper DBTools.Core Utility for level selection UI ITransactionRunner DBTools.Core Transaction execution via call gate ILogger Microsoft.Extensions.Logging Debug logging Source: csharp/src/Tools/Structural/AnalyticalSnapToLevel/Features/AnalyticalSnapToLevelCommand.cs:35-46 Settings This tool has no persistent settings. All configuration is provided at runtime via: Element Selection: User pre-selects elements before invoking the command Target Level: User picks from level dialog at runtime Manifest id: DBTools.Structural.AnalyticalSnapToLevel assembly: DBTools moduleType: DBTools.Structural.AnalyticalSnapToLevel.AnalyticalSnapToLevelToolModule order: 0 tool: ribbonTools: - internalName: DBTools.AnalyticalSnapToLevel commandType: DBTools.Structural.AnalyticalSnapToLevel.AnalyticalSnapToLevelCommand availabilityType: DBTools.App.Tools.Availability.DbtSelectionAvailability runProfile: InlineUi displayText: \"Analytical Snap\\nTo Level\" iconBaseKey: analytical_snap tooltip: \"Snap analytical model elements to specified level\" controlKind: PushButton order: 20 Source: csharp/src/Tools/Structural/AnalyticalSnapToLevel/manifest.yml:1-15 Manifest Properties Property Value Description id DBTools.Structural.AnalyticalSnapToLevel Unique tool identifier availabilityType DbtSelectionAvailability Button enabled when elements are selected runProfile InlineUi Runs with inline UI support controlKind PushButton Standard push button control order 20 Position in ribbon panel Availability The command uses DbtSelectionAvailability, which enables the ribbon button when at least one element is selected: public class DbtSelectionAvailability : IExternalCommandAvailability { public bool IsCommandAvailable(UIApplication applicationData, CategorySet selectedCategories) { var selection = uidoc.Selection?.GetElementIds(); if (selection == null || selection.Count == 0) return false; // ... return selection.Any(id => /* element matches */); } } Source: csharp/src/DBTools.App/Tools/Availability/DbtSelectionAvailability.cs:13-51 Error Handling The tool handles errors at multiple levels: Command Level Throws InvalidOperationException if no elements are selected Throws InvalidOperationException if no target level is selected Source: csharp/src/Tools/Structural/AnalyticalSnapToLevel/Features/AnalyticalSnapToLevelCommand.cs:29-40 Snapper Level Elements are silently skipped (with debug logging) when: Element is null Element category is not OST_AnalyticalMember Element cannot be cast to AnalyticalMember Element has no curve geometry Structural role is not \"Beam\" or \"Column\" Any exception occurs during curve modification Source: csharp/src/Tools/Structural/AnalyticalSnapToLevel/Features/AnalyticalLevelSnapper.cs:46-129 Logging The tool logs debug information via ILogger: // Target level selection logger.LogDebug(\"[AnalyticalSnap] Target level: {LevelName} (Elev: {Elevation})\", targetLevel.Name, targetLevel.Elevation); // Skip reasons _logger.LogDebug(\"[AnalyticalSnap] Skipping element {ElementId} - not an analytical member.\", RevitId.ToInt(elementId)); // Success _logger.LogDebug(\"[AnalyticalSnap] Snapped {Role} {ElementId} to level {LevelName}.\", role, RevitId.ToInt(elementId), level.Name); // Summary logger.LogDebug(\"[AnalyticalSnap] Processed {Processed}; skipped {Skipped}.\", processed, skipped); Source: csharp/src/Tools/Structural/AnalyticalSnapToLevel/Features/AnalyticalSnapToLevelCommand.cs:42-52 API Reference AnalyticalLevelSnapper The core snapping service: public sealed class AnalyticalLevelSnapper { public AnalyticalLevelSnapper(ITransactionRunner tx, Document doc, ILogger logger); public (int ProcessedCount, int SkippedCount) Run( ICollection<ElementId> selectedIds, Level targetLevel); } Parameters Parameter Type Description tx ITransactionRunner Transaction runner for Revit operations doc Document Active Revit document logger ILogger Logger for debug output Return Value Returns a tuple with: ProcessedCount: Number of elements successfully snapped SkippedCount: Number of elements skipped (invalid category, role, or errors) Source: csharp/src/Tools/Structural/AnalyticalSnapToLevel/Features/AnalyticalLevelSnapper.cs:22-29 Troubleshooting Issue Cause Resolution Button disabled No elements selected Select analytical elements before clicking \"No elements selected\" error Selection cleared before command ran Re-select elements and try again High skip count Non-analytical elements in selection Select only analytical members Elements not moving Role is not \"Beam\" or \"Column\" Check element's Structural Role parameter Partial success Some elements have errors Check debug log for skip reasons Related Documentation SGT Tool - Structural Grid Tool (uses similar snapping concepts) Framing Joins - Related structural framing tool Source Files Reviewed File Purpose manifest.yml Tool declaration AnalyticalSnapToLevelToolModule.cs Module registration AnalyticalSnapToLevelCommand.cs Command entry point AnalyticalLevelSnapper.cs Core snapping logic DBTools.Structural.AnalyticalSnapToLevel.csproj Project configuration DbtSelectionAvailability.cs Availability predicate LevelPickerHelper.cs Level picker utility"
  },
  "articles/tools/structural/foundation-tags.html": {
    "href": "articles/tools/structural/foundation-tags.html",
    "title": "Foundation Tags | DBTools Developer Documentation",
    "summary": "Foundation Tags Overview The Foundation Tags tool automates the management and positioning of combined foundation tags in Revit structural documentation. It provides two main capabilities: updating parameter values on foundation elements based on pier associations, and moving tags to consistent corner positions on their tagged footings. Source: csharp/src/Tools/Structural/FoundationTags/manifest.yml:1-4 Location: csharp/src/Tools/Structural/FoundationTags/ Tool ID: DBTools.Structural.FoundationTags Ribbon Location: Structural group, split button foundation_tags Features Core Functionality Feature Description Update Combined Tags Updates pier-footing associations and elevation parameters Move Combined Tags Moves tags to corner positions on footings Auto-Update on View Automatically updates tags when activating floor/ceiling plans Linked Element Support Processes tags on footings in linked Revit models Selection Sets Creates timestamped selection sets for modified/skipped elements Source: csharp/src/Tools/Structural/FoundationTags/manifest.yml:19-39 Ribbon Commands Update Combined Foundation Tags Updates parameter values on piers and footings in the current view: Pier Processing: Calculates Foundation Pier Top elevation from Top Level + Top Offset Footing Processing: Associates each footing with its nearest pier (within 2-foot threshold) Parameter Updates: Sets Associated Pier (type mark) and Associated Pier Elevation on footings Source: csharp/src/Tools/Structural/FoundationTags/Features/CombinedFoundationTagsUpdater.cs:68-267 Command: DBTools.UpdateCombinedFoundationTags Display Text: \"Update Combined Foundation Tags\" Run Profile: InlineUi Source: csharp/src/Tools/Structural/FoundationTags/manifest.yml:20-29 Move Combined Foundation Tags Repositions foundation tags to specific corners of their tagged footings: Tag Collection: Finds structural foundation tags matching configured family patterns Footing Resolution: Retrieves tagged footing (host or linked) Corner Calculation: Computes footing corners using geometry tessellation Position Assignment: Moves tag to the corner specified by the tag name/type Source: csharp/src/Tools/Structural/FoundationTags/Features/CombinedFoundationTagsMover.cs:58-116 Command: DBTools.MoveCombinedFoundationTags Display Text: \"Move Combined Tags\" Run Profile: InlineUi Source: csharp/src/Tools/Structural/FoundationTags/manifest.yml:30-39 View-Activated Auto-Update When enabled, the tool automatically runs the Update Combined Tags operation when activating floor or ceiling plan views. Source: csharp/src/Tools/Structural/FoundationTags/Hooks/CombinedTagsViewActivatedTask.cs:37-49 Supported View Types: FloorPlan CeilingPlan Source: csharp/src/Tools/Structural/FoundationTags/Hooks/CombinedTagsViewActivatedTask.cs:48 Architecture Directory Structure csharp/src/Tools/Structural/FoundationTags/ +-- Features/ # Core feature implementations | +-- CombinedFoundationTagsUpdater.cs # Update logic | +-- CombinedFoundationTagsMover.cs # Move logic | +-- FoundationTagsGeometry.cs # Pure geometry calculations | +-- UpdateCombinedFoundationTagsCommand.cs | +-- MoveCombinedFoundationTagsCommand.cs +-- Hooks/ # Event handlers | +-- CombinedTagsViewActivatedTask.cs # Auto-update on view activation +-- Settings/ # Configuration | +-- FoundationTagsSettings.cs | +-- FoundationTagsSettingsPackContext.cs | +-- FoundationTagsSettingsPackView.xaml +-- Tests/ # Unit tests | +-- FoundationTagsGeometryTests.cs +-- FoundationTagsToolModule.cs # DI registration +-- manifest.yml # Tool manifest Key Components FoundationTagsToolModule The module class registers settings, services, and settings packs with the dependency injection container. Source: csharp/src/Tools/Structural/FoundationTags/FoundationTagsToolModule.cs:14-91 Registration Points: RegisterSettings: Binds FoundationTagsSettings to configuration section Tools.FoundationTags RegisterServices: Registers CombinedTagsViewActivatedTask as IViewActivatedTask RegisterSettingsPacks: Creates settings UI with warning definitions Source: csharp/src/Tools/Structural/FoundationTags/FoundationTagsToolModule.cs:16-81 CombinedFoundationTagsUpdater The core service that updates pier and footing parameters. Source: csharp/src/Tools/Structural/FoundationTags/Features/CombinedFoundationTagsUpdater.cs:16-275 Processing Flow: Collect piers matching configured family patterns Collect footings matching configured family patterns For each pier: calculate and set Foundation Pier Top For each footing: find nearest pier and set association parameters Create selection sets for modified and skipped elements Pier-Footing Association: Uses 2D distance (X, Y only) to find nearest pier Maximum distance threshold: 2 feet (squared distance = 4.0) Clears association if no pier found within threshold Source: csharp/src/Tools/Structural/FoundationTags/Features/CombinedFoundationTagsUpdater.cs:167 CombinedFoundationTagsMover The service that repositions tags to footing corners. Source: csharp/src/Tools/Structural/FoundationTags/Features/CombinedFoundationTagsMover.cs:18-376 Corner Selection Algorithm: Extract footing geometry points via tessellation Project corners onto view coordinate system (right/up axes) Select corner based on tag name using dot product projection Supported Corner Names: \"Top Right\" \"Top Left\" \"Bottom Right\" \"Bottom Left\" Source: csharp/src/Tools/Structural/FoundationTags/Features/FoundationTagsGeometry.cs:142-149 FoundationTagsGeometry A pure, testable geometry module with no Revit dependencies. Source: csharp/src/Tools/Structural/FoundationTags/Features/FoundationTagsGeometry.cs:112-250 Functions: Function Purpose SelectCornerByViewOrientation Selects corner based on view direction vectors FindNearestPoint2D Finds nearest candidate point within threshold IsValidCornerName Validates corner name strings Source: csharp/src/Tools/Structural/FoundationTags/Features/FoundationTagsGeometry.cs:123-249 Data Types: Type Description Point2D 2D point for distance calculations Point3D 3D point/vector for projections FootingCornerPoints Four corners of a rectangular footing NearestPointResult Result of nearest point search Source: csharp/src/Tools/Structural/FoundationTags/Features/FoundationTagsGeometry.cs:11-106 Settings Configuration Section Path: Tools.FoundationTags Source: csharp/src/Tools/Structural/FoundationTags/manifest.yml:7 FoundationTagsSettings Settings class implementing IAutoUpdateSettings. Source: csharp/src/Tools/Structural/FoundationTags/Settings/FoundationTagsSettings.cs:9-50 Property Type Default Description AutoUpdateEnabled bool true Enable auto-update on view activation HasWarning bool false Warning state (disables auto-update) TagFamilyPatterns List<string> See below Regex patterns for tag families PierFamilyPatterns List<string> See below Regex patterns for pier families FootingFamilyPatterns List<string> See below Regex patterns for footing families Source: csharp/src/Tools/Structural/FoundationTags/Settings/FoundationTagsSettings.cs:14-49 Default Patterns Tag Family Patterns (Move Combined Tags): ^Combined Foundation Tag ^DB Foundation Tag Source: csharp/src/Tools/Structural/FoundationTags/Settings/FoundationTagsSettings.cs:26-30 Pier Family Patterns (Update Combined Tags): ^Foundation Pier Source: csharp/src/Tools/Structural/FoundationTags/Settings/FoundationTagsSettings.cs:36-39 Footing Family Patterns (Update Combined Tags): ^Footing-Rectangular$ ^Pile Cap-Rectangular$ Source: csharp/src/Tools/Structural/FoundationTags/Settings/FoundationTagsSettings.cs:45-49 Settings UI The settings pack provides a configuration panel with: Auto-Update Toggle: Enable/disable automatic tag updates Tag Family Patterns: Up to 3 regex patterns for matching tag families Pier Family Patterns: Up to 3 regex patterns for matching pier families Footing Family Patterns: Up to 3 regex patterns for matching footing families Source: csharp/src/Tools/Structural/FoundationTags/Settings/FoundationTagsSettingsPackContext.cs:35-48 UI Features: Pattern validation with regex syntax checking Add/remove pattern buttons (max 3 per group) Warning state management with clear action Pending changes detection Source: csharp/src/Tools/Structural/FoundationTags/Settings/FoundationTagsSettingsPackContext.cs:132-166 Warning System The tool uses a warning system to disable functionality when issues occur. Warning Definition: ID: core.structural.combined_tags Title: \"Combined Foundation Tags Disabled\" Message: \"Combined foundation tag updates are disabled due to a warning. Clear the warning to re-enable.\" Source: csharp/src/Tools/Structural/FoundationTags/manifest.yml:12-18 Disabled Tools When Warning Active: DBTools.UpdateCombinedFoundationTags DBTools.MoveCombinedFoundationTags DBTools.OrganizeFoundationTypes Source: csharp/src/Tools/Structural/FoundationTags/manifest.yml:15-18 Manifest id: DBTools.Structural.FoundationTags assembly: DBTools moduleType: DBTools.Structural.FoundationTags.FoundationTagsToolModule order: 0 tool: settings: configSection: Tools.FoundationTags settingsPacks: - key: structural.foundation_tags title: \"Combined Foundation Tags\" warnings: - id: core.structural.combined_tags title: \"Combined Foundation Tags Disabled\" message: \"Combined foundation tag updates are disabled due to a warning. Clear the warning to re-enable.\" disableTools: - DBTools.UpdateCombinedFoundationTags - DBTools.MoveCombinedFoundationTags - DBTools.OrganizeFoundationTypes ribbonTools: - internalName: DBTools.UpdateCombinedFoundationTags commandType: DBTools.Structural.FoundationTags.UpdateCombinedFoundationTagsCommand availabilityType: DBTools.App.Tools.Availability.DbtActiveViewAvailability runProfile: InlineUi displayText: \"Update Combined\\nFoundation Tags\" iconBaseKey: update_combined tooltip: \"Update combined foundation tag instances\" controlKind: SplitButtonItem splitGroup: foundation_tags order: 0 - internalName: DBTools.MoveCombinedFoundationTags commandType: DBTools.Structural.FoundationTags.MoveCombinedFoundationTagsCommand availabilityType: DBTools.App.Tools.Availability.DbtActiveViewAvailability runProfile: InlineUi displayText: \"Move Combined Tags\" iconBaseKey: move_combined tooltip: \"Move combined foundation tags to corner positions\" controlKind: SplitButtonItem splitGroup: foundation_tags order: 1 Source: csharp/src/Tools/Structural/FoundationTags/manifest.yml:1-39 Integration Points Revit API Integration The tool interacts with Revit through standard API patterns: FilteredElementCollector: Queries piers, footings, and tags FamilyInstance.Location: Extracts element positions Parameter.Set/ClearValue: Updates element parameters IndependentTag.TagHeadPosition: Repositions tags SelectionFilterElement: Creates selection sets for results RevitLinkInstance: Supports linked model elements Source: csharp/src/Tools/Structural/FoundationTags/Features/CombinedFoundationTagsMover.cs:67-189 Transaction Management Operations use the ITransactionRunner interface for transaction management: _tx.RunAsync(_doc, \"DB Tools - Update Combined Foundation Tags...\", doc => { // Parameter updates }); Source: csharp/src/Tools/Structural/FoundationTags/Features/CombinedFoundationTagsUpdater.cs:96-222 Related Documentation System Architecture - Overall system design Organize Foundation Types - Related foundation tool Testing The tool includes unit tests for the geometry module: Test File: FoundationTagsGeometryTests.cs Source: csharp/src/Tools/Structural/FoundationTags/Tests/FoundationTagsGeometryTests.cs:12 Test Categories: Corner selection by view orientation Rotated view handling Case-insensitive corner name matching Invalid input handling Nearest point 2D search Corner name validation Source: csharp/src/Tools/Structural/FoundationTags/Tests/FoundationTagsGeometryTests.cs:24-432 Run headless tests: dotnet test csharp/src/Tools/Structural/FoundationTags/Tests/DBTools.Structural.FoundationTags.Tests.csproj -c Release Documentation Status: Complete Last Updated: 2026-01-24 Source Review: Verified against source files in csharp/src/Tools/Structural/FoundationTags/"
  },
  "articles/tools/structural/framing-joins.html": {
    "href": "articles/tools/structural/framing-joins.html",
    "title": "Framing Joins | DBTools Developer Documentation",
    "summary": "Framing Joins Control structural framing join behavior at beam endpoints with bulk operations on selected elements. Overview The Framing Joins tool provides two commands for managing structural framing joins in Revit: Allow Join - Enables joins at both ends of selected structural framing elements Disallow Join - Disables joins at both ends of selected structural framing elements These commands operate on the current selection and modify the join behavior using Revit's StructuralFramingUtils API. Source: csharp/src/Tools/Structural/FramingJoins/manifest.yml:1-26 Features Allow Join Selected Allows structural framing joins at both endpoints (index 0 and 1) of all selected framing elements. Source: csharp/src/Tools/Structural/FramingJoins/Features/AllowJoinSelectedCommand.cs:16-18 Behavior: Retrieves the current selection from the active document Filters to only FamilyInstance elements in the OST_StructuralFraming category For each valid element, calls StructuralFramingUtils.AllowJoinAtEnd() for both endpoints Displays a summary alert showing the number of modified elements Source: csharp/src/Tools/Structural/FramingJoins/Features/AllowJoinSelectedCommand.cs:29-84 Disallow Join Selected Disallows structural framing joins at both endpoints (index 0 and 1) of all selected framing elements. Source: csharp/src/Tools/Structural/FramingJoins/Features/DisallowJoinSelectedCommand.cs:16-18 Behavior: Retrieves the current selection from the active document Filters to only FamilyInstance elements in the OST_StructuralFraming category For each valid element, calls StructuralFramingUtils.DisallowJoinAtEnd() for both endpoints Displays a summary alert showing the number of modified elements Source: csharp/src/Tools/Structural/FramingJoins/Features/DisallowJoinSelectedCommand.cs:29-84 Architecture Project Structure FramingJoins/ ├── DBTools.Structural.FramingJoins.csproj ├── FramingJoinsToolModule.cs ├── manifest.yml ├── Assets/ │ ├── allow_join_icon.png │ └── disallow_join_icon.png └── Features/ ├── AllowJoinSelectedCommand.cs └── DisallowJoinSelectedCommand.cs Module Registration The tool module is a simple marker class that inherits from DbtToolModule: public sealed class FramingJoinsToolModule : DbtToolModule { } Source: csharp/src/Tools/Structural/FramingJoins/FramingJoinsToolModule.cs:1-8 Command Availability Both commands use the DbtStructuralFramingSelectionAvailability predicate, which requires at least one element from the OST_StructuralFraming category to be selected: public sealed class DbtStructuralFramingSelectionAvailability : DbtSelectionAvailability { protected override BuiltInCategory[]? RequiredCategories => new[] { BuiltInCategory.OST_StructuralFraming }; } Source: csharp/src/DBTools.App/Tools/Availability/DbtSelectionAvailability.cs:57-60 Transaction Handling Both commands use CallGateTransactionRunner with ModalInlineCallGate for transaction execution: var gate = new ModalInlineCallGate(context.UIApplication); var tx = new DBTools.Core.Revit.Transactions.CallGateTransactionRunner(gate); await tx.RunAsync(doc, \"DB Tools - Allow Join Selected\", d => { ... }); Source: csharp/src/Tools/Structural/FramingJoins/Features/AllowJoinSelectedCommand.cs:48-67 Error Handling Individual element failures are caught and logged without stopping the batch operation: catch (Exception ex) { logger.LogDebug(\"[AllowJoin] Failed for element {ElementId}: {Message}\", RevitId.ToInt(elem.Id), ex.Message); } Source: csharp/src/Tools/Structural/FramingJoins/Features/AllowJoinSelectedCommand.cs:62-65 Settings This tool has no configurable settings. It operates directly on the current selection. Manifest id: DBTools.Structural.FramingJoins assembly: DBTools moduleType: DBTools.Structural.FramingJoins.FramingJoinsToolModule order: 0 tool: ribbonTools: - internalName: DBTools.AllowJoinSelected commandType: DBTools.Structural.FramingJoins.AllowJoinSelectedCommand availabilityType: DBTools.App.Tools.Availability.DbtStructuralFramingSelectionAvailability runProfile: InlineUi displayText: \"Allow Join\" iconBaseKey: allow_join tooltip: \"Allow structural framing joins for selected elements\" controlKind: SplitButtonItem splitGroup: framing_joins order: 0 - internalName: DBTools.DisallowJoinSelected commandType: DBTools.Structural.FramingJoins.DisallowJoinSelectedCommand availabilityType: DBTools.App.Tools.Availability.DbtStructuralFramingSelectionAvailability runProfile: InlineUi displayText: \"Disallow Join\" iconBaseKey: disallow_join tooltip: \"Disallow structural framing joins for selected elements\" controlKind: SplitButtonItem splitGroup: framing_joins order: 1 Source: csharp/src/Tools/Structural/FramingJoins/manifest.yml:1-26 Manifest Properties Property Value Description id DBTools.Structural.FramingJoins Unique tool identifier assembly DBTools Target assembly (merged into main DBTools assembly) moduleType FramingJoinsToolModule DI module registration class runProfile InlineUi Runs inline with UI context controlKind SplitButtonItem Ribbon control type splitGroup framing_joins Groups both commands under a single split button Usage Select one or more structural framing elements (beams, braces, etc.) Click Allow Join or Disallow Join from the ribbon Review the summary dialog showing the number of modified elements Dependencies DBTools.Core - Core infrastructure, transactions, and UI services ricaun.Revit.UI.Tasks - Async task execution in Revit context Revit API (RevitAPI.dll, RevitAPIUI.dll) Source: csharp/src/Tools/Structural/FramingJoins/DBTools.Structural.FramingJoins.csproj:35-44"
  },
  "articles/tools/structural/joist-girder-weight.html": {
    "href": "articles/tools/structural/joist-girder-weight.html",
    "title": "Joist Girder Weight Tool | DBTools Developer Documentation",
    "summary": "Joist Girder Weight Tool Automatically estimates and updates weight parameters for joist girder elements in Revit structural models. Overview The Joist Girder Weight tool provides automated weight estimation for steel joist girders using moment-based structural engineering calculations. It calculates weight per linear foot based on the number of joists, point loads, span length, and girder depth, then writes the result to the element's Wt parameter. Source: csharp/src/Tools/Structural/JoistGirderWeight/Features/JoistGirderWeightCalculator.cs:9-74 The tool operates in two modes: Manual - User-initiated command via ribbon button Automatic - Triggered on view activation when auto-update is enabled Features Weight Calculation The calculator uses moment-based weight estimation derived from structural engineering principles: Panel Spacing Calculation - Girder length divided by number of joists Maximum Moment Calculation - Based on total reaction and span, with adjustments for even/odd panel counts Section Modulus Estimation - Uses engineering constants for chord and web member sizing Weight Aggregation - Combines top chord, bottom chord, and web weights Source: csharp/src/Tools/Structural/JoistGirderWeight/Features/JoistGirderWeightCalculator.cs:20-74 Engineering Constants The calculation employs the following constants: Constant Value Description Allowable Stress 50.0 ksi Design stress limit Section Modulus Factor 0.28356 Geometric section factor Depth Efficiency Factor 0.95 Effective depth ratio Top Chord Factor 1.06 Top chord sizing multiplier Bottom Chord Factor 1.13 Bottom chord sizing multiplier Web Member Factor 0.7 Web element sizing multiplier Connection Factor 0.6 Joint efficiency factor Source: csharp/src/Tools/Structural/JoistGirderWeight/Features/JoistGirderWeightCalculator.cs:51-58 Multi-Parameter Support The estimator supports multiple parameter naming conventions to handle legacy family definitions: Input Group Supported Parameter Names Number of Joists Number of Joists, SpaceNum, Number of Equal Spaces Point Load Panel Point Load, Point Load - User Defined, Point Load, Total Load - User Defined, Total Load, Joist Load Length Length Depth Depth Output Wt (required, writable) Parameters are resolved in priority order - the first match in each list wins. Both instance and type parameters are checked. Source: csharp/src/Tools/Structural/JoistGirderWeight/Features/JoistGirderWeightEstimator.cs:19-25 Element Filtering The tool targets structural framing elements where the family name or type name contains \"joist girder\" (case-insensitive): girders = collector .OfCategory(BuiltInCategory.OST_StructuralFraming) .WhereElementIsNotElementType() .Where(e => familyName.Contains(\"joist girder\", StringComparison.OrdinalIgnoreCase) || typeName.Contains(\"joist girder\", StringComparison.OrdinalIgnoreCase)); Source: csharp/src/Tools/Structural/JoistGirderWeight/Features/JoistGirderWeightEstimator.cs:36-48 Auto-Update on View Activation When enabled, the tool automatically updates joist girder weights whenever a view is activated. This is controlled by the AutoUpdateEnabled setting. Source: csharp/src/Tools/Structural/JoistGirderWeight/Hooks/JoistGirderViewActivatedTask.cs:19-44 Architecture Component Structure JoistGirderWeight/ ├── Features/ │ ├── JoistGirderWeightCalculator.cs # Pure calculation logic (no Revit dependencies) │ ├── JoistGirderWeightEstimator.cs # Revit integration and parameter handling │ └── UpdateJoistGirderWeightsCommand.cs # Ribbon command implementation ├── Hooks/ │ └── JoistGirderViewActivatedTask.cs # Auto-update on view change ├── Settings/ │ └── JoistGirderWeightSettings.cs # Configuration model ├── Assets/ │ └── joist_girder_icon.png # Ribbon button icon ├── JoistGirderWeightToolModule.cs # DI and module registration └── manifest.yml # Tool manifest Key Classes JoistGirderWeightCalculator Pure static calculation class with no Revit dependencies, enabling unit testing without Revit runtime. public static class JoistGirderWeightCalculator { public static double EstimateWeight( double numberOfJoists, double pointLoad, double lengthFeet, double depthFeet); public static bool ValidateInputs( double numberOfJoists, double pointLoad, double lengthFeet, double depthFeet); } Source: csharp/src/Tools/Structural/JoistGirderWeight/Features/JoistGirderWeightCalculator.cs:9-92 JoistGirderWeightEstimator Orchestrates the update process: Collects joist girder elements from the document Validates parameters and computes weights (outside transaction) Applies updates within a single transaction Reports success/failure counts Source: csharp/src/Tools/Structural/JoistGirderWeight/Features/JoistGirderWeightEstimator.cs:13-111 UpdateJoistGirderWeightsCommand The ribbon command entry point. Displays an alert with the update count upon completion. Source: csharp/src/Tools/Structural/JoistGirderWeight/Features/UpdateJoistGirderWeightsCommand.cs:15-42 Error Handling The tool follows the no-fallback, no-silent-failure principle: Pre-validation: All elements are validated before the transaction starts Partial updates: If some elements fail validation, valid ones are updated and a warning is logged Complete failure: If no elements can be updated, an InvalidOperationException is thrown with a sample error Source: csharp/src/Tools/Structural/JoistGirderWeight/Features/JoistGirderWeightEstimator.cs:84-97 Settings Configuration Schema # tools.json or per-user settings Tools: JoistGirderWeight: AutoUpdateEnabled: true # Enable/disable auto-update on view activation HasWarning: false # Warning state flag Source: csharp/src/Tools/Structural/JoistGirderWeight/Settings/JoistGirderWeightSettings.cs:5-10 Settings Properties Property Type Default Description AutoUpdateEnabled bool true Whether to auto-update weights on view activation HasWarning bool false Warning state - when true, disables auto-update Warning System When a warning is active: HasWarning is set to true AutoUpdateEnabled is forced to false The UpdateJoistGirderWeights command is disabled in the ribbon Source: csharp/src/Tools/Structural/JoistGirderWeight/JoistGirderWeightToolModule.cs:49-68 Manifest id: DBTools.Structural.JoistGirderWeight assembly: DBTools moduleType: DBTools.Structural.JoistGirderWeight.JoistGirderWeightToolModule order: 0 tool: settings: configSection: Tools.JoistGirderWeight settingsPacks: - key: structural.joist_girder_weight title: \"Joist Girder Weights\" warnings: - id: core.structural.joist_girder title: \"Joist Girder Weights Disabled\" message: \"Joist girder weight updates are disabled due to a warning...\" disableTools: - DBTools.UpdateJoistGirderWeights ribbonTools: - internalName: DBTools.UpdateJoistGirderWeights commandType: DBTools.Structural.JoistGirderWeight.UpdateJoistGirderWeightsCommand availabilityType: DBTools.App.Tools.Availability.DbtDocumentAvailability runProfile: InlineUi displayText: \"Update Joist\\nGirder Weights\" iconBaseKey: joist_girder tooltip: \"Update joist girder weights\" controlKind: PushButton order: 30 Source: csharp/src/Tools/Structural/JoistGirderWeight/manifest.yml:1-27 Ribbon Configuration Property Value Display Text \"Update Joist\\nGirder Weights\" Icon Key joist_girder Availability Document-dependent Run Profile InlineUi Order 30 Input Validation Required Constraints Parameter Constraint Rationale Number of Joists > 1 At least 2 joists required to create panel points Point Load >= 0 Negative loads are physically invalid Length > 0 Zero/negative span is invalid Depth > 0 Zero/negative depth is invalid Source: csharp/src/Tools/Structural/JoistGirderWeight/Features/JoistGirderWeightCalculator.cs:84-91 Validation Methods // Throws ArgumentOutOfRangeException for invalid inputs double weight = JoistGirderWeightCalculator.EstimateWeight(n, load, length, depth); // Returns bool for pre-validation bool isValid = JoistGirderWeightCalculator.ValidateInputs(n, load, length, depth); Testing The calculator has comprehensive unit test coverage (56 tests) covering: Valid input scenarios Scaling behavior (load, length, depth relationships) Invalid input handling Edge cases (overflow, underflow, fractional values) Input validation Determinism/consistency Source: csharp/src/Tools/Structural/JoistGirderWeight/Tests/JoistGirderWeightCalculatorTests.cs Running Tests # Build tests bash csharp/build.sh BuildTests # Run calculator tests (headless, no Revit required) dotnet test csharp/testing/DBTools.BuildArtifacts.Tests \\ --filter \"FullyQualifiedName~JoistGirderWeightCalculator\" Usage Notes Family Requirements For the tool to work correctly, joist girder families must: Belong to the Structural Framing category Have \"joist girder\" in the family name or type name Include at least one parameter from each input group Have a writable Wt parameter (Double storage type) Known Limitations Estimation only: Results are engineering estimates, not certified designs Single formula: Uses one calculation method regardless of manufacturer specifications No SJI validation: Does not validate against Steel Joist Institute load tables"
  },
  "articles/tools/structural/organize-foundation.html": {
    "href": "articles/tools/structural/organize-foundation.html",
    "title": "Organize Foundation Types | DBTools Developer Documentation",
    "summary": "Organize Foundation Types The Organize Foundation Types tool standardizes naming conventions and type marks for structural foundation elements. It processes pier and footing family types to ensure consistent naming patterns and eliminates duplicate types by merging instances. Source: csharp/src/Tools/Structural/OrganizeFoundationTypes/Features/OrganizeFoundationTypesCommand.cs:12-57 Overview This tool automates the tedious process of organizing foundation type names and type marks in Revit models. It: Renames types using standardized dimension-based naming (e.g., 3'-0\"x3'-0\" (P-1)) Assigns type marks with prefixes specific to each foundation category Merges duplicate types that have identical dimensions, consolidating instances Source: csharp/src/Tools/Structural/OrganizeFoundationTypes/Features/FoundationTypeOrganizer.cs:12-14 Supported Foundation Categories The tool processes four categories of foundation elements: Category Family Name Revit Category Type Mark Prefix Sort Criteria Foundation Piers Foundation Pier Structural Columns P Section area (b x h) Round Piers Foundation Pier - Round Structural Columns RP Diameter (d) Rectangular Footings Footing-Rectangular Structural Foundation F Width, Length, Thickness Pile Caps Pile Cap-Rectangular Structural Foundation CAP Width, Length, Thickness Source: csharp/src/Tools/Structural/OrganizeFoundationTypes/Features/FoundationTypeOrganizer.cs:39-42 Features Type Mark Generation Type marks are generated with predictable formats that support efficient scheduling and tagging: Pier/Round Pier Format: {PREFIX}-{counter} Examples: P-1, P-2, RP-1, RP-2 Footing/Pile Cap Format: {PREFIX}-{widthFeet}.{counter} Examples: F-3.0, F-3.1, CAP-4.0, CAP-4.1 The generator automatically finds the next available mark, filling gaps in sequences when possible. Source: csharp/src/Tools/Structural/OrganizeFoundationTypes/Features/TypeMarkGenerator.cs:22-64 Type Naming Conventions After processing, types are renamed to include dimensions and type mark: Foundation Type Naming Pattern Example Foundation Pier {b}x{h} ({mark}) 2'-6\"x2'-6\" (P-1) Round Pier {d} DIA. ({mark}) 2'-0\" DIA. (RP-1) Footing / Pile Cap {width}x{length}x{thickness} ({mark}) 3'-0\"x3'-0\"x1'-0\" (F-3.0) Source: csharp/src/Tools/Structural/OrganizeFoundationTypes/Features/FoundationTypeOrganizer.cs:127-129,197-198,276 Duplicate Type Merging When multiple types share identical dimensions, the tool: Identifies duplicate types based on dimension parameters Moves all instances from duplicate types to the primary type Deletes the now-empty duplicate types This reduces model clutter and ensures consistent type usage. Source: csharp/src/Tools/Structural/OrganizeFoundationTypes/Features/FoundationTypeOrganizer.cs:96-107,170-179,243-254 Overwrite Protection On execution, users are prompted whether to overwrite existing type marks: Yes: All type marks are regenerated, ensuring consistent sequential numbering No: Existing type marks are preserved; only types without marks receive new ones Source: csharp/src/Tools/Structural/OrganizeFoundationTypes/Features/OrganizeFoundationTypesCommand.cs:26-29 Architecture Component Structure OrganizeFoundationTypes/ Features/ OrganizeFoundationTypesCommand.cs -- Revit external command entry point FoundationTypeOrganizer.cs -- Core processing logic TypeMarkGenerator.cs -- Type mark generation (pure logic, testable) OrganizeFoundationTypesToolModule.cs -- DI module registration manifest.yml -- Ribbon and command configuration Class Responsibilities Class Responsibility OrganizeFoundationTypesCommand Entry point; prompts user, invokes organizer, displays results FoundationTypeOrganizer Collects types, processes each category, merges duplicates TypeMarkGenerator Pure static logic for generating unique type marks Source: csharp/src/Tools/Structural/OrganizeFoundationTypes/Features/OrganizeFoundationTypesCommand.cs:16, csharp/src/Tools/Structural/OrganizeFoundationTypes/Features/FoundationTypeOrganizer.cs:15, csharp/src/Tools/Structural/OrganizeFoundationTypes/Features/TypeMarkGenerator.cs:11 Transaction Strategy The organizer runs multiple transactions to isolate changes by category: DB Tools - Organize Foundation Pier Types (rectangular piers) DB Tools - Organize Round Pier Types (round piers) DB Tools - Organize Footing Types (footings and pile caps) Source: csharp/src/Tools/Structural/OrganizeFoundationTypes/Features/FoundationTypeOrganizer.cs:48-62 Dependencies DBTools.Core - Base infrastructure, transactions, logging, alerts ricaun.Revit.UI.Tasks - Async UI task handling Source: csharp/src/Tools/Structural/OrganizeFoundationTypes/DBTools.Structural.OrganizeFoundationTypes.csproj:35-44 Manifest Configuration id: DBTools.Structural.OrganizeFoundationTypes assembly: DBTools moduleType: DBTools.Structural.OrganizeFoundationTypes.OrganizeFoundationTypesToolModule order: 0 tool: ribbonTools: - internalName: DBTools.OrganizeFoundationTypes commandType: DBTools.Structural.OrganizeFoundationTypes.OrganizeFoundationTypesCommand availabilityType: DBTools.App.Tools.Availability.DbtDocumentAvailability runProfile: InlineUi displayText: \"Organize Foundation\\nTypes\" iconBaseKey: organize_types tooltip: \"Organize foundation types for tagging\" controlKind: SplitButtonItem splitGroup: foundation_tags order: 2 Source: csharp/src/Tools/Structural/OrganizeFoundationTypes/manifest.yml:1-16 Ribbon Placement The tool appears in the Foundation Tags split button group alongside: Order Tool Description 0 Update Combined Foundation Tags Updates tag instances 1 Move Combined Foundation Tags Repositions tags 2 Organize Foundation Types This tool Source: csharp/src/Tools/Structural/FoundationTags/manifest.yml:20-39, csharp/src/Tools/Structural/OrganizeFoundationTypes/manifest.yml:14-16 Availability Availability Class: DbtDocumentAvailability Requirement: An open Revit document (no active view requirement) Settings This tool has no configurable settings. All behavior is determined by the dimension parameters of the foundation types in the model. Parameter Requirements The tool reads specific parameters from each family type: Foundation Pier (Foundation Pier) Parameter Type Description b Length Pier width dimension h Length Pier depth dimension Type Mark Text Assigned type mark Round Pier (Foundation Pier - Round) Parameter Type Description d Length Pier diameter Type Mark Text Assigned type mark Footing / Pile Cap Parameter Type Description Width Length Footing width Length Length Footing length Foundation Thickness Length Footing depth Type Mark Text Assigned type mark Source: csharp/src/Tools/Structural/OrganizeFoundationTypes/Features/FoundationTypeOrganizer.cs:92-93,167,238-240 Processing Logic Pier Types (Rectangular) Collect all FamilySymbol instances from OST_StructuralColumns where family name is Foundation Pier Sort by section area (ascending) For each type: Check for duplicate (same b and h values) If duplicate found: merge instances to existing type, mark for deletion Otherwise: assign type mark (respecting overwrite setting), rename type Delete merged duplicate types Source: csharp/src/Tools/Structural/OrganizeFoundationTypes/Features/FoundationTypeOrganizer.cs:79-151 Round Pier Types Collect all FamilySymbol instances from OST_StructuralColumns where family name is Foundation Pier - Round Sort by diameter (ascending) For each type: Check for duplicate (same d value) If duplicate found: merge instances, mark for deletion Otherwise: assign type mark, rename with {d} DIA. ({mark}) format Delete merged duplicate types Source: csharp/src/Tools/Structural/OrganizeFoundationTypes/Features/FoundationTypeOrganizer.cs:154-218 Footing and Pile Cap Types Collect all FamilySymbol instances from OST_StructuralFoundation where family name matches Sort by Width, then Length, then Foundation Thickness (ascending) For each type: Check for duplicate (same Width, Length, and Foundation Thickness) If duplicate found: merge instances, mark for deletion Otherwise: assign footing-format type mark, rename with dimensions Delete merged duplicate types (best-effort, silently continues on failure) Source: csharp/src/Tools/Structural/OrganizeFoundationTypes/Features/FoundationTypeOrganizer.cs:221-293 Error Handling Individual type processing failures are logged at DEBUG level and skipped Type deletion failures are logged at WARNING or ERROR level Footing type deletions use best-effort (silently continue if deletion fails, as type may be in use elsewhere) The command displays a summary dialog showing counts of renamed and merged types Source: csharp/src/Tools/Structural/OrganizeFoundationTypes/Features/FoundationTypeOrganizer.cs:132-136,146-150,203-205,214-217,279-282,289-291 Testing Unit tests for the TypeMarkGenerator class verify: Sequential mark generation (P-1, P-2, P-3...) Gap filling in mark sequences Width-based footing mark format (F-3.0, F-3.1...) Null/invalid input handling Multiple prefix independence Source: csharp/src/Tools/Structural/OrganizeFoundationTypes/Tests/TypeMarkGeneratorTests.cs:1-346 Integration with Foundation Tags This tool is designed to work with the Combined Foundation Tags workflow: Run Organize Foundation Types to standardize type names and marks Use Update Combined Foundation Tags to update tag values Use Move Combined Foundation Tags to position tags The tools share a common warning system - if a warning is active on the structural.foundation_tags settings pack, all three tools are disabled until the warning is cleared. Source: csharp/src/Tools/Structural/FoundationTags/manifest.yml:12-18"
  },
  "articles/tools/structural/sgt.html": {
    "href": "articles/tools/structural/sgt.html",
    "title": "SGT (Super Girt Tool) | DBTools Developer Documentation",
    "summary": "SGT (Super Girt Tool) Overview The Super Girt Tool (SGT) is a Revit add-in for placing and managing structural steel girts and opening framing members (jambs, headers, sills) on foundation walls. It supports both host document walls and walls in linked Revit models. Source: csharp/src/Tools/Structural/SGT/manifest.yml:7-8 Location: csharp/src/Tools/Structural/SGT/ Tool ID: DBTools.SGT Ribbon Location: Structural group, order 40 Features Core Functionality Feature Description Wall Selection Select linked walls or host foundation walls for girt placement Girt Placement Auto-seed girts at configurable elevations with smart spacing Opening Framing Automatic detection and framing of openings (jambs, headers, sills) Live Preview Real-time 2D elevation and 3D preview of proposed framing Extent Control Configure girt extents by wall length, grids, openings, or manual distances Edit Mode Modify previously placed SGT systems with host-change reconciliation Source: csharp/src/Tools/Structural/SGT/Features/Commands/SgtNewCommand.cs:36-39 Supported Wall Types Linked Walls: Walls from Revit link instances (any function) Host Foundation Walls: Foundation walls in the host document (WallFunction.Foundation) Source: csharp/src/Tools/Structural/SGT/Features/Commands/SgtNewCommand.cs:96-99 Supported Framing Types The tool supports structural framing families filtered by shape: Shape Category Girts Opening Members Notes C Shapes Yes Yes Default: C10X15.3 MC Shapes Yes Yes Miscellaneous channels Z Shapes Yes No Intentionally excluded for openings HSS (Tube) Yes Yes Hollow structural sections Source: csharp/src/Tools/Structural/SGT/Common/Domain/SgtPlan.cs:137-144 Architecture SGT follows a domain-driven MVVM architecture with clear separation between UI, domain logic, and Revit API interactions. csharp/src/Tools/Structural/SGT/ +-- Common/ # Shared utilities, models, domain objects | +-- Domain/ # Core domain entities (SgtPlan, SgtWall, etc.) | +-- Models/ # UI-bound row items (SgtGirtRowItem, etc.) | +-- Units/ # Unit conversion service +-- Features/ # Feature-specific code | +-- Commands/ # Revit external commands | +-- Girts/ # Girt management services | +-- Openings/ # Opening detection | +-- Orientation/ # Family orientation analysis | +-- Place/ # Placement orchestration | +-- Preview/ # 2D/3D preview rendering | +-- Reconcile/ # Host-change reconciliation +-- Shell/ # UI layer | +-- Composition/ # DI registration | +-- DesignTime/ # Design-time ViewModels | +-- UI/ # Views and ViewModels +-- Shared/ # Cross-feature services +-- Contracts/ # Interfaces and DTOs +-- Extents/ # Extent resolution +-- Hydration/ # Domain hydration +-- Kernel/ # Validation, logging Key Design Patterns Single Source of Truth (SSOT) The SgtPlan object serves as the single source of truth for all SGT operations. It contains: Wall geometry and context (host/linked) Girt row configurations Opening row configurations Eligible framing types Pre-computed orientation data Grid positions Source: csharp/src/Tools/Structural/SGT/Common/Domain/SgtPlan.cs:12-17 Plan Store Pattern The ISgtPlanStore interface provides centralized plan state management with change notifications: public interface ISgtPlanStore { SgtPlan? Plan { get; } event EventHandler<PlanChangedEventArgs>? PlanChanged; void SetPlan(SgtPlan plan); void Clear(); } Source: csharp/src/Tools/Structural/SGT/Shared/Contracts/ISgtPlanStore.cs Orchestrator Pattern The SgtOrchestrator coordinates validation, domain object creation, and placement/update operations: Validate - Check plan integrity and extent resolution Build Domain - Create SgtWall with SgtMember and SgtOpening aggregates Hydrate - Resolve segments and connectivity Persist - Write to Revit document via ISgtDomainWriter Source: csharp/src/Tools/Structural/SGT/Features/Place/Logic/SgtOrchestrator.cs:17-40 UI Components Main Window Class: SgtWindow (WPF Window) ViewModel: SgtWindowViewModel Source: csharp/src/Tools/Structural/SGT/Shell/UI/Views/SgtWindow.xaml:2 The main window is a 1600x850 modal dialog with three main regions: Left Panel: Configuration Scope controls (wall offset, layer selection) Girts expander with DataGrid Openings expander with DataGrid Bulk edit flyout Center Splitter: Resizable divider Right Panel: Preview 2D elevation view 3D view (using HelixToolkit) Preview mode toggle Source: csharp/src/Tools/Structural/SGT/Shell/UI/Views/SgtWindow.xaml:243-255 Girt Grid Columns Column Property Description Elevation ElevationText Vertical position (feet-inches format) Girt Type GirtTypeId Family type selection Rotation Rotation Cross-section rotation (0/90/180/270) Y Justification YJustification Lateral positioning Z Justification ZJustification Vertical positioning Flip FlipHand Mirror orientation Source: csharp/src/Tools/Structural/SGT/Shell/UI/Views/SgtWindow.xaml:402-517 Opening Grid Columns Each opening row supports four framing roles with independent configuration: Left Jamb: Vertical member at opening left edge Right Jamb: Vertical member at opening right edge Header: Horizontal member at opening top Sill: Horizontal member at opening bottom (optional) Source: csharp/src/Tools/Structural/SGT/Common/Domain/OpeningRoleRules.cs Preview Modes Mode Description Elevation 2D front elevation view with girts and openings 3D Interactive 3D view with wall layers and framing Source: csharp/src/Tools/Structural/SGT/Features/Preview/Logic/Models/PreviewMode.cs:4-9 Services Dependency Injection All SGT services are registered via SgtServiceCollectionExtensions.AddSgt(): Source: csharp/src/Tools/Structural/SGT/Shell/Composition/SgtServiceCollectionExtensions.cs:29-83 Core Services Service Lifetime Purpose ISgtPlanStore Singleton Plan state management IUnitService Singleton Unit conversion SgtValidationService Singleton Plan validation ISgtSystemRepository Scoped Extensible storage access SgtPersistenceService Scoped Plan persistence Feature Services Service Lifetime Purpose RevitOpeningQuery Scoped Opening detection from walls FamilyCalibrationService Scoped Family profile extraction WallGeometryService Scoped Wall geometry analysis SgtOrientationAdapter Scoped Family orientation computation IExtentResolver Singleton Extent position resolution SegmentResolutionService Singleton Girt segment computation SgtAutoSeedingService Singleton Initial girt elevation seeding Placement Services Service Lifetime Purpose ISgtPlanBuilder Transient Build plan from wall context ISgtDomainWriter Transient Write domain objects to Revit SgtOrchestrator Transient Coordinate placement flow Smart Defaults Service The SgtSmartDefaultsService applies automatic orientation defaults based on family analysis: // For girts SgtSmartDefaultsService.ApplySmartDefaultsForGirt(row, plan); // For opening roles SgtSmartDefaultsService.TryApplySmartDefaultsForOpeningRole(row, role, plan); Source: csharp/src/Tools/Structural/SGT/Features/Girts/Services/SgtSmartDefaultsService.cs:43-70 Host Change Reconciliation When editing an existing SGT system, the tool detects changes to the host wall: Diff Detection: Compare stored vs current wall geometry Missing Wall Handling: Options for re-link or delete Geometry Mismatch: Options for scale, shift, or ignore Opening Changes: Sync manual openings to real elements Source: csharp/src/Tools/Structural/SGT/Features/Reconcile/SgtHostChangeReconciliationService.cs Configuration Manifest id: DBTools.SGT assembly: DBTools moduleType: DBTools.SGT.SgtToolModule order: 0 sandboxWindows: - id: DBTools.SGT.Main displayName: \"Super Girt Tool\" group: \"Structural\" windowType: \"DBTools.SGT.Shell.UI.Views.SgtWindow\" designTimeViewModelType: \"DBTools.SGT.Shell.DesignTime.SgtWindowDesignTimeViewModel\" tool: ribbonTools: - internalName: DBTools.SGT commandType: DBTools.SGT.Features.Commands.SgtNewCommand availabilityType: DBTools.App.Tools.Availability.DbtDocumentAvailability runProfile: InlineUi displayText: \"Super Girt Tool\" iconBaseKey: sgt tooltip: \"Launch Super Girt Tool\" controlKind: PushButton order: 40 Source: csharp/src/Tools/Structural/SGT/manifest.yml:1-21 UI State Persistence The ISgtUiStateStore persists user preferences: Expander states (Girts, Openings) Preview mode selection Column visibility Source: csharp/src/Tools/Structural/SGT/Shell/UI/Settings/ISgtUiStateStore.cs Domain Model Key Domain Entities SgtPlan The central data structure containing all configuration: public sealed class SgtPlan { // Wall context public int? HostWallId { get; init; } public int? LinkedWallId { get; init; } public int? LinkInstanceId { get; init; } public WallGeometry? WallGeometry { get; set; } // Girt configuration public List<SgtGirtRow> GirtRows { get; init; } public int SelectedGirtTypeId { get; set; } // Opening configuration public List<SgtOpeningRow> OpeningRows { get; set; } public IReadOnlyList<OpeningDetectionData> DetectedOpenings { get; set; } // Options public int DepthPlaneLayerIndex { get; set; } public double WallOffsetFeet { get; set; } public bool FoundationMode { get; set; } } Source: csharp/src/Tools/Structural/SGT/Common/Domain/SgtPlan.cs:16-193 Extent Types Girts support multiple extent modes: Extent Type Description FullLengthExtent Wall start to wall end AlongExtent Fixed distances from wall start GridExtent Between named grid lines with offsets OpeningEdgeExtent Relative to opening edges DualOpeningEdgeExtent Between two opening edges Source: csharp/src/Tools/Structural/SGT/Common/Domain/ (multiple files) Integration Points Revit API Integration SGT interacts with Revit through adapter services: WallGeometryService: Extract wall curves, layers, dimensions RevitOpeningQuery: Detect doors, windows, and openings in walls SgtDomainWriter: Create structural framing instances SgtSystemRepository: Store/retrieve SGT configurations in extensible storage Related Documentation System Architecture - Overall system design Application Host - How tools are loaded and hosted Tool Manifest Format - Manifest schema reference Testing SGT includes comprehensive tests: csharp/src/Tools/Structural/SGT/Tests/ +-- SgtAdapterTests.cs +-- SgtFrameBuilderTests.cs +-- SgtConfigHydratorTests.cs +-- SgtValidationServiceTests.cs +-- SgtOrchestratorExtentTests.cs +-- SgtHostChangeDiffServiceTests.cs +-- ... (additional test files) Source: csharp/src/Tools/Structural/SGT/Tests/DBTools.SGT.Tests.csproj Run tests via the Revit test runner: bash csharp/invoke-revit-tests.sh --smart --tool SGT Documentation Status: Complete Last Updated: 2026-01-24 Source Review: Verified against source files in csharp/src/Tools/Structural/SGT/"
  },
  "articles/tools/testing/vtc.html": {
    "href": "articles/tools/testing/vtc.html",
    "title": "View Template Comparer (VTC) | DBTools Developer Documentation",
    "summary": "View Template Comparer (VTC) The View Template Comparer (VTC) is a Testing category tool that enables side-by-side comparison of Revit view templates, allowing users to identify differences, selectively merge settings, and create new templates from combined configurations. Source: csharp/src/Tools/Testing/VTC/manifest.yml:1-21 Overview VTC provides a comprehensive solution for managing view template settings across Revit projects. The tool extracts complete template configurations including display settings, template parameter includes, category overrides, and filter overrides, presenting them in a hierarchical diff view for easy comparison and selective merging. Key Capabilities Side-by-side comparison of two view templates with visual diff highlighting Selective merging - choose individual settings from either template Apply to existing - update Template A or B with selected settings Create merged template - generate a new template combining selections from both sources JSON export/import - serialize template settings for cross-document transfer Template library - save and load configurations to local cache Text dump - export human-readable settings reports Source: csharp/src/Tools/Testing/VTC/Features/VtcCommand.cs:24-28 Features Template Selection The tool automatically loads all view templates from the active document, sorted alphabetically. Users select two templates for comparison: Template A (blue indicator) - the left/source template Template B (gold indicator) - the right/target template Templates can be swapped using the swap button for quick side-reversal. Source: csharp/src/Tools/Testing/VTC/Features/VtcCommand.cs:37-43 Settings Comparison VTC compares four categories of template settings: Category Description Display Properties Detail Level, Display Style, Parts Visibility, Discipline, Show Hidden Lines Template Parameters Which parameters are included/controlled by the template Category Overrides Visibility and graphics overrides per category and subcategory Filter Overrides Applied filters with visibility and graphics settings Source: csharp/src/Tools/Testing/VTC/Contracts/VtcEnums.cs:13-21 Each setting shows one of four difference states: State Meaning Same Values match in both templates Different Values differ between templates LeftMissing Setting exists only in Template B RightMissing Setting exists only in Template A Source: csharp/src/Tools/Testing/VTC/Contracts/VtcEnums.cs:38-44 Merge Operations Apply to Template A/B Applies selected settings to an existing template. The tool: Collects all user-selected settings from the diff tree Opens a Revit transaction Applies each selected value to the target template Updates non-controlled parameter list as needed Source: csharp/src/Tools/Testing/VTC/UI/ViewModels/VtcWindowViewModel.cs:198-226 Create Merged Template Creates a new view template combining settings from both sources: Duplicates the base template (user-selectable: Template A or B) Renames to user-specified name Applies all user-selected settings Commits the new template to the document Source: csharp/src/Tools/Testing/VTC/UI/ViewModels/VtcWindowViewModel.cs:228-275 Export/Import JSON Export Exports complete template settings to a JSON file containing: Template ID and name Display settings (detail level, discipline, etc.) Template parameter includes list Category graphics data (visibility, line colors, patterns, weights) Filter graphics data Source: csharp/src/Tools/Testing/VTC/Revit/Services/VtcSerializationService.cs:34-44 JSON Import Imports settings from a JSON file and applies them to the selected template. The import supports cross-document transfer by resolving elements by name when IDs don't match. Source: csharp/src/Tools/Testing/VTC/Revit/Services/VtcComparisonService.cs:236-270 Template Library VTC maintains a local cache of saved template configurations in %APPDATA%/DBTools/Cache/VTC/. Features include: Save - Store current template configuration with custom name Load - Apply saved configuration to Template A or B Delete - Remove saved configurations Refresh - Update the saved templates list Source: csharp/src/Tools/Testing/VTC/Services/VtcTemplateStorageService.cs:14-15 Text Dump Exports a human-readable text report of template settings including: Template name and view type All included parameters Display settings with current values Category visibility and graphics overrides Filter visibility and graphics overrides Output is written to a user-selected folder as {TemplateName}_template_dump.txt. Source: csharp/src/Tools/Testing/VTC/Revit/Services/VtcDumpService.cs:52-179 Architecture Module Structure DBTools.VTC/ +-- Bootstrap/ | +-- VtcServiceExtensions.cs # DI registration +-- Contracts/ | +-- IVtcComparisonService.cs # Comparison/merge interface | +-- IVtcDumpService.cs # Text export interface | +-- IVtcSerializationService.cs # JSON serialization interface | +-- VtcDataModels.cs # Data transfer objects | +-- VtcEnums.cs # Enumerations +-- Features/ | +-- VtcCommand.cs # Main command entry point +-- Revit/ | +-- Compat/ | | +-- ElementIdCompat.cs # ElementId compatibility layer | +-- Services/ | +-- VtcComparisonService.cs # Revit comparison implementation | +-- VtcDumpService.cs # Revit dump implementation | +-- VtcSerializationService.cs # Revit serialization implementation +-- Services/ | +-- VtcTemplateStorageService.cs # Local cache storage +-- UI/ | +-- Behaviors/ | | +-- ScrollSyncBehavior.cs # Synchronized scrolling | +-- Converters/ | | +-- VtcDiffBackgroundConverter.cs # Diff color converter | +-- ViewModels/ | | +-- VtcDiffNodeType.cs # Tree node types | | +-- VtcDiffTreeBuilder.cs # Tree construction | | +-- VtcDiffTreeNode.cs # Tree node model | | +-- VtcTemplateOption.cs # Dropdown item model | | +-- VtcWindowViewModel.cs # Main window ViewModel | +-- Views/ | +-- VtcWindow.xaml(.cs) # Main window +-- DesignTime/ | +-- VtcWindowDesignTimeViewModel.cs # XAML designer support +-- VtcToolModule.cs # Tool module registration +-- manifest.yml # Tool manifest Source: csharp/src/Tools/Testing/VTC/ Service Contracts IVtcComparisonService Core comparison and merge operations: public interface IVtcComparisonService { VtcTemplateSettingsModel Extract(object templateObject); VtcComparisonResult Compare(VtcTemplateSettingsModel left, VtcTemplateSettingsModel right); void ApplySelections(object target, VtcComparisonResult comparison, IReadOnlyCollection<VtcSelection> selections); void ApplySnapshot(object target, VtcTemplateSettingsModel source); } Source: csharp/src/Tools/Testing/VTC/Contracts/IVtcComparisonService.cs:8-29 IVtcSerializationService JSON import/export and template creation: public interface IVtcSerializationService { string Export(object templateObject, string path); VtcTemplateSettingsModel Import(string path); object CreateTemplateFromModel(object baseTemplate, VtcTemplateSettingsModel model, string newName); void ApplyModel(object targetTemplate, VtcTemplateSettingsModel model); } Source: csharp/src/Tools/Testing/VTC/Contracts/IVtcSerializationService.cs:6-27 IVtcDumpService Text report generation: public interface IVtcDumpService { (bool Success, string OutputPath) Run(object templateObject, string outputFolder); } Source: csharp/src/Tools/Testing/VTC/Contracts/IVtcDumpService.cs:6-12 Data Models VtcTemplateSettingsModel Complete template configuration for serialization: public sealed record VtcTemplateSettingsModel { public long TemplateId { get; init; } public string Name { get; init; } public VtcDisplaySettings Display { get; init; } public IReadOnlyList<VtcTemplateIncludeData> Includes { get; init; } public IReadOnlyList<VtcCategoryGraphicsData> Categories { get; init; } public IReadOnlyList<VtcFilterGraphicsData> Filters { get; init; } } Source: csharp/src/Tools/Testing/VTC/Contracts/VtcDataModels.cs:64-72 VtcSettingChange Represents a single difference between templates: public sealed record VtcSettingChange { public string Key { get; init; } public string DisplayName { get; init; } public VtcSettingType SettingType { get; init; } public VtcDisplayPropertyKind? DisplayProperty { get; init; } public VtcDifferenceKind DifferenceKind { get; init; } public string LeftDisplay { get; init; } public string RightDisplay { get; init; } public object? LeftValue { get; init; } public object? RightValue { get; init; } } Source: csharp/src/Tools/Testing/VTC/Contracts/VtcDataModels.cs:77-88 UI Components Hierarchical Diff Tree The comparison view uses a hierarchical TreeView with synchronized scrolling between left and right panels. The tree structure groups settings by type: Display Settings +-- Detail Level +-- Display Style +-- ... Template Parameters +-- Parameter 1 +-- Parameter 2 +-- ... Category Overrides +-- Walls | +-- Hidden Lines | +-- Surface Pattern +-- Structural Framing +-- ... Filter Overrides +-- Filter 1 +-- Filter 2 Source: csharp/src/Tools/Testing/VTC/UI/ViewModels/VtcDiffTreeBuilder.cs:17-43 Node types in the tree: Type Purpose Root Top-level category (Display Settings, Categories, etc.) CategoryGroup Parent category containing subcategories Setting Leaf node with actual values and selection checkboxes Source: csharp/src/Tools/Testing/VTC/UI/ViewModels/VtcDiffNodeType.cs:6-22 Settings VTC currently has no persistent user settings. All configuration is session-based through the UI. Cache Location Saved templates are stored in the user's local application data: %APPDATA%/DBTools/Cache/VTC/ Each saved template is stored as a JSON file with sanitized filename. Source: csharp/src/Tools/Testing/VTC/Services/VtcTemplateStorageService.cs:34 Manifest id: DBTools.VTC assembly: DBTools moduleType: DBTools.VTC.VtcToolModule order: 0 sandboxWindows: - id: DBTools.VTC.Main displayName: \"View Template Comparer\" group: \"Testing\" windowType: \"DBTools.VTC.UI.Views.VtcWindow\" designTimeViewModelType: \"DBTools.VTC.DesignTime.VtcWindowDesignTimeViewModel\" tool: ribbonTools: - internalName: DBTools.ViewTemplateComparer commandType: DBTools.VTC.Features.VtcCommand availabilityType: DBTools.App.Tools.Availability.DbtDocumentAvailability runProfile: InlineUi displayText: \"View Template\\nComparer\" iconBaseKey: vtc tooltip: \"Compare and merge view template settings\" controlKind: PushButton order: 50 Source: csharp/src/Tools/Testing/VTC/manifest.yml:1-21 Manifest Properties Property Value Description id DBTools.VTC Unique tool identifier moduleType DBTools.VTC.VtcToolModule Tool module class group Testing Ribbon panel group runProfile InlineUi Shows modeless window within Revit availabilityType DbtDocumentAvailability Requires active document controlKind PushButton Standard ribbon button Cross-Document Import VTC supports importing template settings from JSON files created in different Revit documents. When element IDs don't match (common across documents), the service falls back to name-based resolution: Parameters Searches ParameterElement and GlobalParameter types by name. Source: csharp/src/Tools/Testing/VTC/Revit/Services/VtcComparisonService.cs:239-270 Categories Handles both top-level and subcategories using \"Parent : Subcategory\" naming convention. Source: csharp/src/Tools/Testing/VTC/Revit/Services/VtcComparisonService.cs:296-340 Filters Searches ParameterFilterElement instances by name. Source: csharp/src/Tools/Testing/VTC/Revit/Services/VtcComparisonService.cs:398-415 Graphics Override Data VTC captures comprehensive graphics override settings for categories and filters: public sealed record VtcOverrideGraphicsData { public VtcColorData? ProjectionLineColor { get; init; } public long? ProjectionLinePatternId { get; init; } public int? ProjectionLineWeight { get; init; } public int? Transparency { get; init; } public int? CutLineWeight { get; init; } public VtcColorData? CutLineColor { get; init; } public long? CutLinePatternId { get; init; } public long? CutForegroundPatternId { get; init; } public VtcColorData? CutForegroundPatternColor { get; init; } } Source: csharp/src/Tools/Testing/VTC/Contracts/VtcDataModels.cs:17-28 Error Handling VTC uses the standard DBTools alert service for user notifications. The ViewModel provides centralized error and success messaging: No templates found - Warning shown if document contains no view templates Template not found - Error if selected template cannot be resolved No selections - Error if merge attempted without any settings selected Duplicate name - Error if new template name already exists Source: csharp/src/Tools/Testing/VTC/UI/ViewModels/VtcWindowViewModel.cs:472-488 Testing VTC includes unit tests for core logic that doesn't require Revit: VtcTemplateStorageServiceTests.cs - File I/O operations VtcDiffTreeNodeTests.cs - Tree node behavior VtcDiffTreeBuilderTests.cs - Tree construction from change lists Source: csharp/src/Tools/Testing/VTC/Tests/ Tests are located in csharp/src/Tools/Testing/VTC/Tests/ and run via the standard test runner without requiring Revit."
  },
  "articles/troubleshooting.html": {
    "href": "articles/troubleshooting.html",
    "title": "Troubleshooting Guide | DBTools Developer Documentation",
    "summary": "Troubleshooting Guide This guide covers common issues encountered when building, running, and debugging DBTools. Build Issues MSBuild Errors Error: DBT0001 - Build must be run through build.sh Symptom: error DBT0001: Raw 'dotnet build' from CLI is not supported. Use bash csharp/build.sh instead. Cause: The build system enforces that all builds go through the repository's build entrypoint to ensure proper configuration, vendored dependency staging, and multi-year target handling. Solution: Always use the build script: # Standard incremental build bash csharp/build.sh # Clean and rebuild bash csharp/build.sh --clean # Build specific Revit year bash csharp/build.sh -y 2025 BuildAll # Build only the app bash csharp/build.sh BuildApp Error: Windows dotnet.exe not found Symptom: Windows dotnet.exe not found at: /mnt/c/Program Files/dotnet/dotnet.exe Cause: The build script runs Windows dotnet.exe from WSL. The .NET SDK must be installed on the Windows host. Solution: Install .NET 8 SDK on Windows from dotnet.microsoft.com Verify installation: \"/mnt/c/Program Files/dotnet/dotnet.exe\" --version If installed to a non-default location, set the path in build.sh Missing Dependencies Vendored UI Assemblies Missing Symptom: Vendored UI assemblies missing under csharp/.artifacts/vendor; building them now... Or build failures referencing DBTools.HandyControl, DBTools.ControlzEx, or DBTools.Fluent.Ribbon. Cause: The vendored UI libraries (HandyControl, ControlzEx, FluentRibbon) must be built with custom namespaces before the main build. Solution: # Automatic (build.sh runs this if needed) bash csharp/build.sh # Manual rebuild of vendored deps bash csharp/build-vendored-deps.sh Expected output location: csharp/.artifacts/vendor/ handycontrol/net48/DBTools.HandyControl.dll handycontrol/net8.0-windows/DBTools.HandyControl.dll controlzex/net48/DBTools.ControlzEx.dll fluentribbon/net48/DBTools.Fluent.Ribbon.dll Assembly Load Failures Symptom: InvalidOperationException: Failed to load tool assembly 'DBTools.GM'. Cause: With file-linking architecture, tool assemblies (GM, TDV, SGT, VTC) are compiled into DBTools.dll. This error indicates the main assembly wasn't built correctly. Solution: Run a clean build: bash csharp/build.sh --clean Verify build output exists in csharp/.artifacts/bin/ Check that the Revit add-in is loading the correct version Source: DbtToolAssemblyLoader.cs:10 Runtime Issues Theme Validation Failures Theme validation runs at startup to catch XAML resource issues early. Failures here indicate broken theme dictionaries or missing resources. Theme Dictionary Merge Failed Symptom: InvalidOperationException: Theme dictionary merge failed at 'pack://application:,,,/DBTools.Themes;component/Themes/App.Brushes.xaml'. Cause: A XAML resource dictionary failed to load. Common causes: Missing assembly reference Broken StaticResource chain Syntax error in XAML Solution: Verify DBTools.Themes.dll exists alongside DBTools.dll Check build output for XAML compilation errors If modifying themes, validate XAML syntax in Visual Studio Source: DbtThemeValidator.cs:69 Theme Resource Freeze Failed Symptom: InvalidOperationException: Theme resource freeze failed for key 'PrimaryBrush' in 'App.Brushes.xaml'. Cause: A Freezable resource (brush, geometry) could not be frozen. This typically indicates the resource has unresolved bindings or dynamic references. Solution: Check the resource definition in the XAML file Ensure all referenced colors/values are static Remove any bindings from Freezable resources Source: DbtThemeValidator.cs:161 Theme Contract Mismatch Symptom: InvalidOperationException: Theme merged dictionary contract mismatch: expected 11 dictionaries but found 10 in 'App.Theme.xaml'. Cause: The theme root dictionary doesn't match the expected structure. This catches accidental removal or reordering of theme dictionaries. Expected merged dictionaries (in order): DBTools.HandyControl/Themes/SkinDark.xaml DBTools.HandyControl/Themes/Theme.xaml DBTools.Fluent.Ribbon/Themes/Generic.xaml DBTools.Themes/Themes/App.Tokens.xaml DBTools.Themes/Themes/App.Brushes.xaml DBTools.Themes/Themes/App.Converters.xaml DBTools.Themes/Themes/App.Controls.Base.xaml DBTools.Themes/Themes/App.DataGrid.xaml DBTools.Themes/Themes/App.Menus.xaml DBTools.Themes/Themes/App.Components.xaml DBTools.Themes/Themes/App.FluentRibbon.xaml Solution: Ensure App.Theme.xaml contains all dictionaries in the correct order. Source: DbtThemeValidator.cs:191 Revit API Errors RevitContextUnavailableException Symptom: RevitContextUnavailableException: No UIApplication in current gate scope. Or: RevitContextUnavailableException: ActiveUIDocument is required but was not available. Cause: Code attempted to access Revit API objects outside of a valid Revit context. This happens when: A modeless window tries to access Revit without using the call gate An async operation continues after the document was closed Code runs during Revit shutdown Solution: Ensure Revit API calls are wrapped in IRevitCallGate.RunAsync() Check for document availability before operations Handle cancellation when documents close Source: RevitContextUnavailableException.cs:6 WPF Dispatcher Issues Symptom: InvalidOperationException: No WPF Dispatcher is available (Application.Current is null and no Revit window dispatcher could be resolved). Or: InvalidOperationException: WPF Dispatcher is shutting down. Cause: WPF UI operations attempted when no dispatcher is available, typically during early startup or late shutdown. Solution: Use WpfUiThread.TryGetDispatcher() and check for null Check dispatcher.HasShutdownStarted before operations Use BeginInvoke instead of Invoke for non-blocking operations Source: WpfUiThread.cs:21 Tool-Specific Issues Generic Model Tool (GM) GmKernelBuildException Error Code Message Solution 1001 Failed to resolve family or type names Check that all referenced families exist in the project 1002 Failed to build nesting index Verify nested family relationships are valid 1003 Shared parameter deserialization failed Check shared parameter file integrity 1004 Usage data collection failed Ensure document is fully loaded before scanning Source: GmKernelExceptions.cs:6 GmInvalidMappingException Error Code Message Solution 2001 Operation metadata missing Ensure mapping configuration is complete 2002 Target type creation failed Check family loading and type creation permissions 2003 Shared parameter bind failed Verify parameter definitions exist 2004 Shared parameter embed failed Check parameter embedding permissions 2005 Replacement operation failed Validate replacement targets exist GmSnapshotLoadException Error Code Message Solution 4001 Snapshot deserialization failed Re-export snapshot; file may be corrupt 4002 Snapshot checksum mismatch Re-export snapshot; data integrity issue Transfer Drafting Views Tool (TDV) Error Code Message Solution DestinationTypeMissing Destination view type not found Create matching view type in destination SourceTypeNameUnavailable Source view type name not available Check source view is a valid drafting view CreateViewFailed Failed to create destination view Verify write permissions and view limits CopyElementsFailed Failed to copy view elements Check element validity and target view OverridesFailed Failed to copy view overrides Some overrides may not be transferable Source: TdvPerViewErrorCode.cs:3 Debugging Enabling Debug Mode Debug mode provides detailed logging and surfaces the logger window on errors. Methods to enable: Programmatically: debugModeService.SetEnabled(true) On error: Debug mode auto-enables when ISafeExecutor catches an exception Via Logger Window: Toggle the debug checkbox in the logger window toolbar Effects of debug mode: Log level changes from Information to Debug Logger window becomes visible More detailed stack traces in logs Faster log buffer flush (120ms vs 600ms) Log File Locations Log files are written to the user's local app data directory: %LOCALAPPDATA%\\DBTools\\Logs\\ Log file naming pattern: dbtools-{RevitYear}-{InstanceId}-{Timestamp}-{Nonce}.log Example: dbtools-2025-ABC123-20260124-143022345-a1b2c3d4.log Log retention policy: Maximum 50 files across all instances Maximum 14 days retention Maximum 100 MB total size Automatic cleanup on startup Source: LoggingConstants.cs:119 Using the Logger Window The logger window provides real-time log viewing with filtering capabilities. Features: Level filtering: Toggle INFO, WARN, ERROR, DEBUG visibility Search: Filter logs by text content Export: Save filtered logs to a file Auto-scroll: Automatically scroll to new entries Correlation IDs: Track related log entries across operations Window title format: DB Tools Log - Revit {Year} [{InstanceId}] Opening the logger window: Automatically opens when debug mode is enabled Automatically opens when an unhandled error occurs Can be opened via tools menu (if available) Understanding Correlation IDs Every operation executed through ISafeExecutor is assigned a correlation ID (GUID). This ID appears in all related log entries: [Start] GM Apply starting (CorrelationId=abc123...) ... operation logs ... [Complete] GM Apply completed in 1234ms (CorrelationId=abc123...) Use the correlation ID to: Filter related log entries Track operation duration Correlate errors with their triggering operations Common Error Messages Quick Reference Table Error Message Category Solution DBT0001: Raw 'dotnet build' not supported Build Use bash csharp/build.sh Theme dictionary merge failed Theme Rebuild themes, check XAML syntax Theme resource freeze failed Theme Remove bindings from Freezable resources Failed to load tool assembly Assembly Clean rebuild: build.sh --clean No UIApplication in current gate scope Revit API Wrap calls in IRevitCallGate.RunAsync() ActiveUIDocument is required Revit API Check document is open before operations WPF Dispatcher is shutting down UI Check dispatcher state before UI operations AppRuntime not initialized Runtime Ensure add-in is fully loaded Manifest missing required field Manifest Check tool manifest YAML syntax Tool module type not found Assembly Verify assembly name in manifest ISafeExecutor Error Phases All tool entrypoints run through ISafeExecutor, which logs structured execution phases: Phase Log Level Meaning [Start] Info Operation beginning [Complete] Info Operation finished successfully [Cancel] Warning Operation was cancelled [Error] Error Operation failed with exception Source: SafeExecutor.cs:12 Getting Help Diagnostic Information to Collect When reporting issues, gather: Log file from %LOCALAPPDATA%\\DBTools\\Logs\\ Revit version (year and build number) DBTools version (from add-in manifest) Correlation ID from the error log Steps to reproduce the issue Screenshot of any error dialogs Log Export Use the logger window's export feature to save filtered logs: Open logger window (enable debug mode if needed) Apply any relevant filters Click Export button Save to file with timestamp Export filename pattern: DBToolsLog_{Timestamp}.txt"
  },
  "index.html": {
    "href": "index.html",
    "title": "DBTools Documentation | DBTools Developer Documentation",
    "summary": "DBTools Documentation Welcome to the DBTools documentation. DBTools is a comprehensive toolkit of productivity tools for Autodesk Revit, designed to streamline structural engineering workflows. Choose Your Path User Guide For Revit users who want to learn how to use DBTools effectively. Installation Getting Started Tool Guides Developer Guide For developers working on the DBTools codebase or building integrations. Architecture Creating New Tools API Reference What is DBTools? DBTools provides automation for common Revit tasks: Tool Description Global Mapper Batch parameter mapping between elements Super Girt Tool Automated girt placement and management Foundation Tags Smart tagging for foundation elements Transfer Drafting Views Import/export drafting views between projects View Template Comparer Compare and merge view templates And more... See the full tool list Quick Links Resource Description Installation How to install DBTools Troubleshooting Common issues and solutions API Reference Auto-generated API documentation Documentation Roadmap Planned documentation work System Requirements Revit: 2024, 2025, or 2026 Windows: 10 or 11 (64-bit) Permissions: Standard user (admin not required for most features) Architecture at a Glance ┌─────────────────────────────────────────────────────────────┐ │ Revit │ ├─────────────────────────────────────────────────────────────┤ │ DBTools.Loader │ │ (Revit Add-in Entry Point) │ ├─────────────────────────────────────────────────────────────┤ │ DBTools.App │ │ (Application Shell, Ribbon UI) │ ├──────────────┬──────────────┬──────────────┬────────────────┤ │ GM Tool │ SGT Tool │ Other Tools │ Settings │ ├──────────────┴──────────────┴──────────────┴────────────────┤ │ DBTools.Core │ │ (Shared Infrastructure, Transactions, UI) │ ├─────────────────────────────────────────────────────────────┤ │ DBTools.Themes │ │ (UI Theming System) │ └─────────────────────────────────────────────────────────────┘ Documentation Status Area Documents Status User Guide 13 In Progress Developer Guide 26 Complete API Reference Auto-generated Partial See DOCUMENTATION_ROADMAP.md for the full roadmap. Get Started Install DBTools First Steps Learn More Architecture Tool Development Get Help Troubleshooting GitHub Issues"
  }
}