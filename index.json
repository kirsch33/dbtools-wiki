{
  "DOCUMENTATION_MANIFEST.html": {
    "href": "DOCUMENTATION_MANIFEST.html",
    "title": "Documentation Manifest | DB Tools",
    "summary": "Documentation Manifest Last Updated: 2026-01-24 Total Units: 25 Completed: 25 In Progress: 0 Status Legend Status Meaning pending Not started in_progress Currently being documented draft Written but not verified verified Reviewed and source-anchored deferred Blocked by external factor Architecture Documentation Document Status Assignee Notes architecture/overview.md draft docs-run-20260124-020412 Complete (301 lines) architecture/build-pipeline.md draft initial-session Complete (462 lines) architecture/test-pipeline.md draft docs-run-20260124-020412 Complete (596 lines) architecture/project-references.md draft docs-run-20260124-020412 Complete (534 lines) architecture/ilrepack-embedding.md draft docs-run-20260124-020412 Complete (601 lines) architecture/sandbox-validator.md draft docs-run-20260124-020412 Complete (376 lines) architecture/theme-system.md draft docs-run-20260124-020412 Complete (697 lines) Project Documentation Document Status Assignee Notes projects/core.md draft docs-run-20260124-020412 Complete (745 lines) projects/app.md draft docs-run-20260124-020412 Complete (849 lines) projects/loader.md draft docs-run-20260124-020412 Complete (515 lines) projects/sandbox.md draft docs-run-20260124-020412 Complete (486 lines) projects/themes.md draft docs-run-20260124-020412 Complete (509 lines) Tool Documentation Common Tools Document Status Assignee Notes tools/common/elements-from-list-3d.md draft docs-run-20260124-020412 Complete (430 lines) tools/common/elevation-tags.md draft docs-run-20260124-020412 Complete (401 lines) tools/common/tdv.md draft docs-run-20260124-020412 Complete (393 lines) tools/common/gm.md draft docs-run-20260124-020412 Complete (433 lines) Structural Tools Document Status Assignee Notes tools/structural/analytical-snap.md draft docs-run-20260124-020412 Complete (299 lines) tools/structural/foundation-tags.md draft docs-run-20260124-020412 Complete (376 lines) tools/structural/framing-joins.md draft docs-run-20260124-020412 Complete (175 lines) tools/structural/joist-girder-weight.md draft docs-run-20260124-020412 Complete (287 lines) tools/structural/organize-foundation.md draft docs-run-20260124-020412 Complete (282 lines) tools/structural/sgt.md draft docs-run-20260124-020412 Complete (377 lines) Testing Tools Document Status Assignee Notes tools/testing/vtc.md draft docs-run-20260124-020412 Complete (411 lines) Developer Guides Document Status Assignee Notes developing/new-tool-guide.md draft docs-run-20260124-020412 Complete (1060 lines) developing/modularity.md draft docs-run-20260124-020412 Complete (738 lines) Summary Statistics Category Documents Total Lines Architecture 7 ~3,567 Projects 5 ~3,104 Tools - Common 4 ~1,657 Tools - Structural 6 ~1,796 Tools - Testing 1 ~411 Developer Guides 2 ~1,798 Total 25 ~12,333 Verification Checklist Template Each completed document must have: [x] All code references include file:line source anchors [x] No assumptions without evidence [x] Cross-references to related documents [ ] Examples tested where applicable [x] UNVERIFIED markers for uncertain claims [ ] Reviewed by human or verified AI session Session Log Date Session Documents Touched Notes 2026-01-16 initial-setup All stubs created Infrastructure setup 2026-01-16 initial-session build-pipeline.md Proof-of-concept complete 2026-01-24 docs-run-20260124-020412 Batch 1: overview.md, test-pipeline.md, project-references.md, core.md, loader.md, gm.md 6 docs completed 2026-01-24 docs-run-20260124-020412 Batch 2: ilrepack-embedding.md, theme-system.md, app.md 3 docs completed 2026-01-24 docs-run-20260124-020412 Batch 3: themes.md, sandbox.md, sandbox-validator.md, sgt.md 4 docs completed 2026-01-24 docs-run-20260124-020412 Batch 4: tdv.md, elevation-tags.md, foundation-tags.md, elements-from-list-3d.md 4 docs completed 2026-01-24 docs-run-20260124-020412 Batch 5: analytical-snap.md, framing-joins.md, joist-girder-weight.md, organize-foundation.md, vtc.md 5 docs completed 2026-01-24 docs-run-20260124-020412 Batch 6: new-tool-guide.md, modularity.md 2 developer guides completed How to Update This Manifest Before starting work, mark document as in_progress Add your session ID to Assignee column After completing, change status to draft After verification, change to verified Add entry to Session Log"
  },
  "DOCUMENTATION_ROADMAP.html": {
    "href": "DOCUMENTATION_ROADMAP.html",
    "title": "Documentation Roadmap | DB Tools",
    "summary": "Documentation Roadmap Created: 2026-01-24 Last Updated: 2026-01-24 (Session 2) Status: Active This document tracks all planned documentation work for the DBTools wiki. It serves as a feature/issue tracker for documentation efforts. Quick Status Phase Status Progress Phase 1: Infrastructure Complete 2/2 Phase 2: Theming Complete 3/3 Phase 3: Developer Guides Complete 5/5 Phase 4: User Documentation Complete 13/13 Phase 5: Diagrams Complete 4/4 Phase 6: XML Audit Not Started 0/10 Phase 1: Documentation Infrastructure 1.1 Documentation Roadmap Status: Complete File: DOCUMENTATION_ROADMAP.md (this file) Description: Create feature/issue tracker for documentation work 1.2 Website Structure Redesign Status: Complete Priority: High Description: Split site into user-facing and developer-facing sections Implemented Structure: wiki/ ├── user-guide/ # END-USER facing (non-developers) │ ├── index.md # User guide home │ ├── installation.md # Install/uninstall, admin reqs │ ├── getting-started.md # Quick start for users │ ├── toc.yml │ └── tools/ # HOW TO USE each tool (11 guides) │ ├── gm.md │ ├── sgt.md │ ├── tdv.md │ ├── foundation-tags.md │ ├── elevation-tags.md │ ├── elements-from-list-3d.md │ ├── analytical-snap.md │ ├── framing-joins.md │ ├── joist-girder-weight.md │ ├── organize-foundation.md │ └── vtc.md ├── developer-guide/ # DEVELOPER facing │ ├── index.md # Developer guide home │ ├── architecture/ # Architecture docs │ ├── projects/ # Project docs │ ├── tools/ # Technical tool docs │ ├── developing/ # Tool development guides │ └── troubleshooting.md ├── templates/modern/styles/main.css # Custom theming ├── images/ # Logo, favicon └── index.md # Site home Tasks: [x] Create user-guide/ directory structure [x] Move existing docs to developer-guide/ [x] Update root toc.yml with new navigation [x] Create section index pages [x] Update cross-references in existing docs Phase 2: Website Theming 2.1 Custom CSS Status: Complete Priority: High File: templates/modern/styles/main.css Token Color Usage Primary #1946B9 Links, headers, accents Primary Light #3D6AD4 Hover states Secondary #FEC425 Highlights, call-to-action Secondary Light #FFD54F Secondary hover Paper #181820 Dark theme background Surface #222228 Cards, panels Body #E6E6E6 Body text Tasks: [x] Create templates/modern/styles/main.css [x] Override DocFX default colors with brand palette [x] Style code blocks, tables, blockquotes [x] Ensure accessibility (contrast ratios) [x] Test dark/light theme toggle 2.2 Logo & Favicon Status: Complete Priority: High Tasks: [x] Copy db_tools_icon.png to images/logo.png [x] Create favicon.ico [x] Update docfx.json with logo/favicon paths 2.3 DocFX Configuration Status: Complete Priority: High File: docfx.json Tasks: [x] Fix _gitContribute.repo URL [x] Add custom template reference [x] Configure _appLogoPath and _appFaviconPath [x] Set default theme preference Phase 3: Advanced Developer Guides All guides created under developer-guide/developing/ with cross-links. 3.1 Settings Packs Guide Status: Complete Priority: High File: developer-guide/developing/settings-packs.md Content: [x] What are settings packs? [x] Defining in manifest.yml [x] Settings model with Options pattern [x] SettingsPack UI integration [x] Configuration section naming conventions [x] Real examples from GM, SGT, FoundationTags 3.2 Feature Warnings Guide Status: Complete Priority: High File: developer-guide/developing/feature-warnings.md Content: [x] Warning system architecture [x] Defining warnings in manifest.yml [x] Warning lifecycle (trigger, display, dismiss) [x] disableTools mechanism [x] Warning UI in Settings window [x] IWarningPublisher usage [x] Real examples with code 3.3 Hooks Guide Status: Complete Priority: High File: developer-guide/developing/hooks.md Content: [x] Hook system architecture [x] DbtHookHost internals [x] Available hook types: [x] IViewActivatedHookHandler [x] IContextualRibbonHookHandler [x] Registering hooks in ToolModule [x] Writing custom hook handlers [x] Hook execution order and lifecycle [x] Real examples from existing tools [x] Creating new hook types (extension guide) 3.4 Sandbox Integration Guide Status: Complete Priority: High File: developer-guide/developing/sandbox-integration.md Content: [x] What is the Sandbox? [x] Why validation matters [x] Registering sandbox windows in manifest [x] Design-time ViewModels [x] SandboxMode detection [x] DistValidator checks [x] Running sandbox validation locally [x] Troubleshooting validation failures 3.5 Testing Tools Guide Status: Complete Priority: High File: developer-guide/developing/testing-tools.md Content: [x] Test project structure [x] Test categories (headless vs Revit integration) [x] TestSupport library usage [x] Writing headless tests [x] Writing Revit integration tests [x] Test doubles and stubs (legitimate vs illegitimate) [x] Running tests locally [x] CI integration [x] Debugging test failures [x] Real examples from GM.Tests, SGT.Tests 3.6 Update new-tool-guide.md Status: Complete (existing doc maintained) Priority: Medium File: developer-guide/developing/new-tool-guide.md Phase 4: User-Facing Documentation 4.1 Installation Guide Status: Complete Priority: High File: user-guide/installation.md Content: [x] System requirements (Revit versions, Windows version) [x] Download location [x] Installer workflow (what it does step-by-step) [x] Installation directory structure [x] Where settings are stored (%APPDATA%/DBTools/) [x] Admin requirements (if any) [x] Silent install options (if applicable) [x] Uninstallation process [x] Troubleshooting installation issues 4.2 Getting Started Guide Status: Complete Priority: High File: user-guide/getting-started.md Content: [x] First launch experience [x] Finding the DB Tools ribbon tab [x] Overview of available tools [x] Quick example: running a simple tool [x] Where to find help 4.3 Tool User Guides Status: Complete Priority: Medium Each tool has a user-facing guide at user-guide/tools/<tool>.md: Tool Status File GM (Global Mapper) Complete gm.md SGT (Super Girt Tool) Complete sgt.md TDV (Transfer Drafting Views) Complete tdv.md Foundation Tags Complete foundation-tags.md Elevation Tags Complete elevation-tags.md Elements From List 3D Complete elements-from-list-3d.md Analytical Snap Complete analytical-snap.md Framing Joins Complete framing-joins.md Joist Girder Weight Complete joist-girder-weight.md Organize Foundation Complete organize-foundation.md VTC Complete vtc.md Each guide includes: What the tool does (non-technical) When to use it (scenario table) Quick Start steps UI description Settings explanation (if applicable) Workflows (step-by-step) Tips and tricks Troubleshooting FAQ Phase 5: Diagrams & Visuals Mermaid diagrams added to key documents. 5.1 Architecture Diagram Status: Complete File: developer-guide/architecture/overview.md Added: Component diagram showing project relationships, discovery flow sequence diagram 5.2 Build Pipeline Diagram Status: Complete File: developer-guide/architecture/build-pipeline.md Added: Build targets flowchart showing Preflight → Build → Package phases 5.3 Tool Module Lifecycle Diagram Status: Complete File: developer-guide/developing/new-tool-guide.md Added: State diagram showing Discovered → Instantiated → Registered → Active lifecycle 5.4 Hook Execution Diagram Status: Complete (already existed) File: developer-guide/developing/hooks.md Existing: Component overview flowchart, registration sequence, execution flow sequence diagrams Phase 6: XML Comment Audit Systematic review of XML documentation comments in source code. Priority Order Project Status Est. Files Priority DBTools.Core Not Started ~50 1 (Highest) DBTools.App Not Started ~30 2 DBTools.Themes Not Started ~5 3 DBTools.Loader Not Started ~5 4 DBTools.Sandbox Not Started ~10 5 Tools/Common/GM Not Started ~40 6 Tools/Structural/SGT Not Started ~30 7 Tools/Common/TDV Not Started ~15 8 Tools/Structural/* Not Started ~40 9 Tools/Common/* Not Started ~20 10 Audit Checklist (per project) [ ] Public classes have <summary> [ ] Public methods have <summary>, <param>, <returns> [ ] Public properties have <summary> [ ] Complex logic has <remarks> [ ] Obsolete items have migration notes [ ] Stale/misleading comments removed [ ] IntelliSense reads naturally [ ] Consistency with naming conventions Execution Notes Parallel Work These can be worked on in parallel: Phase 2 (Theming) - independent of content Phase 5 (Diagrams) - can be added anytime Phase 6 (XML Audit) - separate from wiki Dependencies Phase 1.2 (Structure) ├── Phase 3 (Dev Guides) - need new paths └── Phase 4 (User Docs) - need new paths Phase 2 (Theming) - independent Phase 3 + 4 complete → Phase 5 (Diagrams) - add to final docs All content complete → Phase 6 (XML Audit) Session Continuity When picking up work: Check this roadmap for current status Update status as you work Commit changes frequently Update \"Last Updated\" date Completed Work 2026-01-24: Session 2 - Website Restructure, User Guides & Diagrams PR: https://github.com/kirsch33/dbtools/pull/198 (continued) Completed: Website restructured into user-guide / developer-guide split Custom CSS theming with DBTools brand colors Logo and favicon added 5 advanced developer guides (settings-packs, feature-warnings, hooks, sandbox-integration, testing-tools) 11 user-facing tool guides (all tools) Installation and Getting Started guides Updated navigation and index pages Mermaid diagrams added to architecture overview, build pipeline, and new-tool-guide Commits: 52da0ffc - docs: restructure site (user/developer split), add theming, add advanced dev guides 25fed669 - docs: add user guides for GM, SGT, TDV, Foundation Tags 6d000f73 - docs: add user guides for remaining 7 tools 4657b14a - docs: update roadmap - phases 1-4 complete e7c015b0 - docs: add Mermaid diagrams to architecture and developer guides 2026-01-24: Session 1 - Initial Documentation Completed: 26 documentation files (~12,700 lines) All architecture docs All project docs All tool technical docs (developer-facing) Developer guides (new-tool-guide, modularity) Troubleshooting guide Updated manifest and index Branch: docs-run-20260124-020412"
  },
  "api/index.html": {
    "href": "api/index.html",
    "title": "API Reference | DB Tools",
    "summary": "API Reference This section contains auto-generated API documentation from XML doc comments in the source code. Coverage Status Current XML doc comment coverage is approximately 33%. Areas with gaps will show minimal documentation. Project Coverage Notes DBTools.Core ~22% Needs improvement DBTools.App ~37% Moderate DBTools.Themes ~1% Critical gap SGT ~50% Best documented GM ~23% Large codebase Improving Coverage To improve API documentation: Add /// XML doc comments to public members Include at minimum: <summary>, <param>, <returns> Run docfx build to regenerate Example: /// <summary> /// Executes a transaction with the specified action. /// </summary> /// <param name=\"action\">The action to execute within the transaction.</param> /// <returns>True if the transaction succeeded; otherwise, false.</returns> /// <exception cref=\"InvalidOperationException\">Thrown when no document is active.</exception> public bool Execute(Action action) { // ... } Namespaces Once API metadata is generated via docfx metadata, namespace links will appear here: DBTools.Core DBTools.App DBTools.Themes DBTools.GM DBTools.SGT Note: Run docfx docfx.json (not docfx-conceptual.json) to generate API documentation from XML comments."
  },
  "articles/architecture/build-pipeline.html": {
    "href": "articles/architecture/build-pipeline.html",
    "title": "Build Pipeline | DB Tools",
    "summary": "Build Pipeline Overview DBTools uses a sophisticated build pipeline designed for: Multi-year Revit support (2024, 2025, 2026) Multi-framework targeting (net48 for Revit 2024, net8.0-windows for 2025+) WSL/Windows interoperability (development in WSL, builds via Windows dotnet.exe) Assembly merging (ILRepack for net48, AssemblyLoadContext for net8) Centralized artifacts (all outputs to .artifacts/, no per-project bin/obj) Source: csharp/build.sh:1-162, csharp/build/Build.cs:1-200 Quick Reference # Fast incremental build (default) bash csharp/build.sh # Clean + full rebuild bash csharp/build.sh --clean # Build specific Revit year bash csharp/build.sh -y 2025 BuildAll # Debug configuration bash csharp/build.sh --debug # Build only the app (skip tests) bash csharp/build.sh BuildApp # Clean outputs only bash csharp/build.sh Clean Source: csharp/build.sh:33-61 Architecture Build System Stack ┌─────────────────────────────────────────────────────────────┐ │ build.sh │ │ (Bash wrapper - WSL/Git Bash compatible) │ ├─────────────────────────────────────────────────────────────┤ │ Windows dotnet.exe │ │ (via wslpath/cygpath conversion) │ ├─────────────────────────────────────────────────────────────┤ │ NUKE Build │ │ (Build.cs, BuildTargets.cs, etc.) │ ├─────────────────────────────────────────────────────────────┤ │ MSBuild + .NET SDK │ │ (Directory.Build.props/targets, *.csproj) │ └─────────────────────────────────────────────────────────────┘ Key Files File Purpose build.sh Entry point - WSL/Git Bash wrapper build/Build.cs NUKE orchestration, parameters, cleanup build/BuildTargets.cs Build targets, Revit path resolution build/BuildMerging.cs ILRepack assembly merging (net48) build/BuildHelpers.cs Path conversion utilities build/ArtifactManagement.cs Metadata, fingerprinting, promotion Directory.Build.props Centralized project properties Directory.Build.targets Build targets, NUKE enforcement Version.props Product version build/Revit.props Revit-specific TFM definitions Source: csharp/build/Build.cs:17-24 Entry Point: build.sh The build script (build.sh) is the required entry point for all builds. Direct dotnet build is blocked by MSBuild. WSL Detection The script auto-detects the environment and configures appropriate path conversion: if [[ -f /proc/version ]] && grep -qi microsoft /proc/version 2>/dev/null; then # WSL environment WIN_DOTNET_EXE=\"/mnt/c/Program Files/dotnet/dotnet.exe\" to_win_path() { wslpath -w \"$1\"; } else # Git Bash or other WIN_DOTNET_EXE=\"/c/Program Files/dotnet/dotnet.exe\" to_win_path() { cygpath -w \"$1\"; } fi Source: csharp/build.sh:6-15 Build Server Cleanup The script ensures MSBuild daemon processes are terminated on exit to prevent file locks: cleanup_build_servers() { \"$WIN_DOTNET_EXE\" build-server shutdown 2>/dev/null || true } trap cleanup_build_servers EXIT INT TERM Source: csharp/build.sh:17-20 Vendored Dependencies Before non-Clean targets, the script checks for vendored UI assemblies and builds them if missing: ensure_vendored_deps() { local vendor_root=\"$SCRIPT_DIR/.artifacts/vendor\" local missing=false for tfm in net48 net8.0-windows; do [[ -f \"$vendor_root/handycontrol/$tfm/DBTools.HandyControl.dll\" ]] || missing=true [[ -f \"$vendor_root/controlzex/$tfm/DBTools.ControlzEx.dll\" ]] || missing=true [[ -f \"$vendor_root/fluentribbon/$tfm/DBTools.Fluent.Ribbon.dll\" ]] || missing=true done if $missing; then echo \"Vendored UI assemblies missing; building them now...\" bash \"$SCRIPT_DIR/build-vendored-deps.sh\" fi } Source: csharp/build.sh:116-130 NUKE Build System Parameters Parameter Default Description --Configuration Release Build configuration --Years 2024 2025 2026 Revit years to target --SkipClean true Skip clean for fast incremental builds --DryRun false Simulate actions without executing --ValidateManifests true Validate embedded manifests --ValidateTools true Validate tool UIs Source: csharp/build/Build.cs:36-51 Key Targets BuildAll ├── PreflightRevitInstalls ├── BuildCore ├── BuildApp ├── VendoredStageUiToYearOutputs ├── BuildTests ├── FlattenYearOutputs ├── PromoteToDist ├── WriteMetadata └── ValidateDist Target Description BuildAll Full build with validation BuildOnly Build without validation (CI use) BuildApp Build DBTools.App only BuildCore Build DBTools.Core only BuildTests Build all test projects Clean Delete staging/intermediate outputs PromoteToDist Copy validated outputs to dist/ Source: csharp/build/Build.cs:165-177 Revit Path Resolution NUKE auto-detects Revit installations using ricaun.Nuke: var installs = RevitInstallationUtils.InstalledRevit ?? Array.Empty<RevitInstallation>(); foreach (var inst in installs) Serilog.Log.Information(\" - Version={Version}, Location={Location}\", inst.Version, inst.InstallLocation); Override with parameters if needed: --Revit2024Dir --Revit2025Dir --Revit2026Dir Source: csharp/build/BuildTargets.cs:35-78 MSBuild Configuration Directory.Build.props The centralized props file establishes: Artifact paths - All outputs to .artifacts/ Year-based organization - bin/{Config}/{Year}/{TFM}/ Design-time support - XAML designer compatibility Code analysis - Warnings as errors, nullable enabled Centralized Artifacts <PropertyGroup> <BaseArtifactsDir>$(MSBuildThisFileDirectory).artifacts\\</BaseArtifactsDir> <BaseIntermediateOutputPath>$(BaseArtifactsDir)obj\\</BaseIntermediateOutputPath> <BaseOutputPath>$(BaseArtifactsDir)bin\\</BaseOutputPath> </PropertyGroup> Source: csharp/Directory.Build.props:12-14 Year-Based Output <PropertyGroup Condition=\"'$(DesignTimeBuild)'!='true'\"> <DBT_OutputYear Condition=\"'$(RevitYear)'!=''\">$(RevitYear)</DBT_OutputYear> <DBT_OutputYear Condition=\"'$(RevitYear)'==''\">shared</DBT_OutputYear> <OutputPath>$(BaseOutputPath)$(Configuration)\\$(DBT_OutputYear)\\</OutputPath> </PropertyGroup> This produces: .artifacts/ ├── bin/ │ ├── Release/ │ │ ├── 2024/ │ │ │ └── net48/ │ │ ├── 2025/ │ │ │ └── net8.0-windows/ │ │ └── 2026/ │ │ └── net8.0-windows/ │ └── Debug/ │ └── ... └── obj/ └── ... Source: csharp/Directory.Build.props:105-121 Code Quality Settings <PropertyGroup> <TreatWarningsAsErrors>true</TreatWarningsAsErrors> <LangVersion>latest</LangVersion> <Nullable>enable</Nullable> <EnableNETAnalyzers>true</EnableNETAnalyzers> <AnalysisLevel>latest-recommended</AnalysisLevel> </PropertyGroup> Source: csharp/Directory.Build.props:142-150 Directory.Build.targets NUKE Entry Point Enforcement Direct dotnet build from CLI is blocked to ensure consistent builds: <Target Name=\"DBT_EnforceEntryPoint\" BeforeTargets=\"CoreCompile\" Condition=\"'$(DesignTimeBuild)'!='true' and '$(DBT_Entry)'!='true'\"> <Error Code=\"DBT0001\" Text=\"Direct builds are blocked. Use ./csharp/build.sh\" /> </Target> Only builds via build.sh (which sets DBT_Entry=true) are allowed. Source: csharp/Directory.Build.targets:32-37 WPF Designer Fixes The targets file includes several fixes for WPF/XAML designer compatibility: Platform target override for designer (AnyCPU instead of x64) Intermediate path fixes for wpftmp projects Reference resolution before XAML compilation Duplicate file removal for generated code Source: csharp/Directory.Build.targets:8-63 Multi-Year Targeting Target Framework Matrix Revit Year .NET Version TFM 2024 .NET Framework 4.8 net48 2025 .NET 8 net8.0-windows 2026 .NET 8 net8.0-windows Revit.props Defines canonical TFMs for Revit-facing projects: <PropertyGroup> <RevitTargetFrameworks>net48;net8.0-windows</RevitTargetFrameworks> </PropertyGroup> Source: csharp/build/Revit.props Conditional Compilation Projects use conditional compilation for version-specific code: #if REVIT2024 // net48-specific code #elif REVIT2025 || REVIT2026 // net8-specific code #endif Assembly Merging ILRepack (net48 / Revit 2024) For Revit 2024 (net48), dependencies are merged into DBTools.dll using ILRepack: // Merge ALL DLLs except whitelist: var keepSeparate = new HashSet<string> { \"DBTools.dll\", // Primary assembly \"DBTools.Loader.dll\", // Entry point \"DBTools.HandyControl.dll\", \"DBTools.Fluent.Ribbon.dll\", \"DBTools.ControlzEx.dll\", \"DBTools.Themes.dll\", // Revit API (shouldn't be in output) \"RevitAPI.dll\", \"RevitAPIUI.dll\", }; Why merge? Revit add-ins share the AppDomain Without merging, different add-ins with same dependency versions can conflict ILRepack internalizes types to prevent conflicts What stays separate? WPF theme assemblies (need file Location for pack:// URIs) Loader assembly (Revit's entry point) Logging abstractions (shared type identity) Source: csharp/build/BuildMerging.cs:17-65 AssemblyLoadContext (net8 / Revit 2025+) For Revit 2025+ (net8), isolation is achieved via AssemblyLoadContext: Each add-in gets its own load context Dependencies are isolated without merging No ILRepack needed Source: csharp/build/BuildMerging.cs:11-14 Artifact Structure Build Outputs .artifacts/ ├── bin/ │ └── Release/ │ ├── 2024/ │ │ └── net48/ │ │ ├── DBTools.dll (merged) │ │ ├── DBTools.Loader.dll │ │ ├── DBTools.Themes.dll │ │ └── DBTools.*.dll (UI assemblies) │ ├── 2025/ │ │ └── net8.0-windows/ │ │ ├── DBTools.dll │ │ ├── DBTools.Loader.dll │ │ └── *.dll (dependencies) │ └── 2026/ │ └── net8.0-windows/ │ └── ... ├── tests/ │ └── Release/ │ ├── 2024/ │ ├── 2025/ │ └── 2026/ ├── vendor/ │ ├── handycontrol/ │ ├── controlzex/ │ └── fluentribbon/ └── .staging/ └── {BuildId}/ ├── bundle/ ├── installer/ └── logs/ Distribution After PromoteToDist, production payloads are in: .artifacts/dist/ ├── 2024/ ├── 2025/ └── 2026/ Troubleshooting Common Issues Problem Solution \"Direct builds are blocked\" (DBT0001) Use build.sh instead of dotnet build \"Windows dotnet.exe not found\" Ensure .NET SDK installed on Windows side \"Vendored UI assemblies missing\" Run build-vendored-deps.sh XAML designer errors Build once via build.sh to populate artifacts MSBuild daemon file locks Script auto-cleans; or run dotnet build-server shutdown Verbose Logging # Add --Verbose for detailed NUKE output bash csharp/build.sh --Verbose BuildAll Clean Rebuild # Full clean + rebuild bash csharp/build.sh --clean BuildAll Related Documentation Project References - Dependency relationships ILRepack & Embedding - Assembly merging details Test Pipeline - Testing infrastructure Verification Status Check Status Source anchors for all claims Yes UNVERIFIED markers where needed No (all verified) Cross-references added Yes Examples tested N/A (documentation) No assumptions without evidence Yes Verified by: initial-wiki-session Date: 2026-01-16"
  },
  "articles/architecture/ilrepack-embedding.html": {
    "href": "articles/architecture/ilrepack-embedding.html",
    "title": "ILRepack and Assembly Embedding | DB Tools",
    "summary": "ILRepack and Assembly Embedding This document describes how DBTools merges and embeds assemblies to achieve a minimal deployment footprint while avoiding conflicts with other Revit add-ins. Overview DBTools uses two complementary strategies to manage dependencies: Strategy Framework Purpose ILRepack net48 only Merges most dependencies INTO DBTools.dll Embedding Both TFMs Embeds assemblies as resources, loaded on-demand Both strategies aim to: Minimize deployment files (ideally just DBTools.dll + DBTools.Loader.dll + WPF theme DLLs) Avoid conflicts with other Revit add-ins that may load different versions of shared libraries Prevent GAC/Revit-provided assemblies from being used instead of our versions Source: csharp/build/BuildMerging.cs:11-22 Why ILRepack? The Revit Add-in Conflict Problem Revit add-ins share a single AppDomain (net48) or AssemblyLoadContext (net8). When multiple add-ins depend on the same library (e.g., Serilog, Newtonsoft.Json), the first-loaded version wins. Problems this causes: Type identity mismatches (your code expects Serilog 4.0, but Serilog 2.0 was loaded first) Missing method exceptions (newer API called on older assembly) Mysterious crashes when reflection fails ILRepack's solution: Merge dependencies INTO DBTools.dll with internalized types Types become internal to your assembly, invisible to other add-ins No conflict possible because types aren't shared Source: csharp/build/BuildMerging.cs:17-21 net48 vs net8.0-windows Strategy Differences net48 (Revit 2024) Uses both ILRepack merging AND embedding: +-------------------+ | DBTools.dll | | (ILRepack'd) | <-- Contains merged types from Serilog, M.E.*, etc. +-------------------+ | +-- Embedded resources: ricaun.Revit.UI.*.dll (loaded from bytes) | +-- Separate files: DBTools.Fluent.Ribbon.dll, DBTools.Themes.dll, etc. net8.0-windows (Revit 2025/2026) Uses embedding only (no ILRepack): +-------------------+ | DBTools.dll | | (standard) | +-------------------+ | +-- Embedded resources: ALL dependencies (DBTools.Core, Serilog, M.E.*, etc.) | +-- Separate files: DBTools.Fluent.Ribbon.dll, DBTools.Themes.dll, etc. Why no ILRepack for net8? .NET 8's AssemblyLoadContext provides natural isolation Each add-in can have its own isolated context ILRepack has compatibility issues with some .NET 8 assemblies Source: csharp/build/BuildMerging.cs:13-14, csharp/src/DBTools.Loader/AssemblyResolution/EmbeddedAssemblyResolver.cs:32-37 ILRepack Merging (net48) Target: MergeNet48Assemblies The build target MergeNet48Assemblies performs the merge: Target MergeNet48Assemblies => _ => _ .Description(\"Merge ALL dependencies into DBTools.dll for net48 via ILRepack (except WPF themes)\") .DependsOn(FlattenYearOutputs) .After(BuildApp, BuildTests) .Before(PromoteToDist) Source: csharp/build/BuildMerging.cs:23-28 What Gets Merged (Everything Except Whitelist) The strategy is \"merge everything EXCEPT a small whitelist\": var keepSeparate = new HashSet<string>(StringComparer.OrdinalIgnoreCase) { \"DBTools.dll\", // Primary assembly (merging INTO this) \"DBTools.Loader.dll\", // Entry point loaded by Revit \"DBTools.HandyControl.dll\", // WPF theme - needs file Location \"DBTools.Fluent.Ribbon.dll\", // WPF theme - needs file Location \"DBTools.ControlzEx.dll\", // WPF theme - needs file Location \"DBTools.Themes.dll\", // WPF theme - needs file Location \"Microsoft.Extensions.Logging.Abstractions.dll\", // Shared with sandbox // Revit API (shouldn't be in output) \"RevitAPI.dll\", \"RevitAPIUI.dll\", \"AdWindows.dll\", \"UIFramework.dll\" }; Source: csharp/build/BuildMerging.cs:50-65 Prefix-Based Exclusions Some assemblies are excluded by prefix (because NuGet adds version numbers): var keepSeparatePrefixes = new[] { \"ricaun.Revit.UI\" }; Why ricaun assemblies aren't merged: ILRepack corrupts ricaun IL, causing runtime crashes Instead, ricaun assemblies are EMBEDDED as resources Source: csharp/build/BuildMerging.cs:68-70 Internalization with Exclusions ILRepack internalizes merged types, but some namespaces must stay public: var excludeFile = yearDir / \"ilrepack-exclude.txt\"; File.WriteAllText(excludeFile, \"^DBTools\\\\.Core\\\\.\\n^Serilog\\\\.\\n^Microsoft\\\\.Extensions\\\\.\\n^Microsoft\\\\.Bcl\\\\.\\n^System\\\\.\\n^ricaun\\\\.Revit\\\\.\"); Namespace Why Public DBTools.Core.* Base classes used by tools Serilog.* Reflection-based sink discovery Microsoft.Extensions.* DI and configuration Microsoft.Bcl.* Polyfill interfaces (IAsyncDisposable) System.* Polyfill types Source: csharp/build/BuildMerging.cs:115-127 ILRepack Command The actual merge command: args.Append($\"/internalize:\\\"{excludeFile}\\\" \"); // Internalize with exclusions args.Append(\"/allowdup \"); // Handle duplicate polyfill types args.Append(\"/ndebug \"); // Skip debug info args.Append($\"/lib:\\\"{revitPath}\\\" \"); // Resolve Revit API references args.Append($\"/out:\\\"{dbToolsDll}\\\" \"); // Output to DBTools.dll args.Append($\"\\\"{backupOriginal}\\\" \"); // Primary assembly // + all assemblies to merge Source: csharp/build/BuildMerging.cs:129-144 Assembly Embedding Strategy Build Target: DBT_EmbedCopyLocalAssemblies The embedding happens during MSBuild via a custom target: <Target Name=\"DBT_EmbedCopyLocalAssemblies\" AfterTargets=\"ResolveReferences\" Condition=\"'$(DesignTimeBuild)'!='true'\"> Source: csharp/src/DBTools.App/DBTools.App.csproj:234-236 Resource Naming Convention Embedded assemblies use a logical name pattern: DBTools.EmbeddedAssemblies.{AssemblyName}.dll For example: DBTools.EmbeddedAssemblies.Serilog.dll DBTools.EmbeddedAssemblies.DBTools.Core.dll <ItemGroup> <_EmbedLogical Include=\"@(_EmbedIdentity->'DBTools.EmbeddedAssemblies.%(Name).dll')\"> <SourcePath>%(OriginalItemSpec)</SourcePath> </_EmbedLogical> <EmbeddedResource Include=\"%(_EmbedLogicalDistinct.SourcePath)\" LogicalName=\"%(_EmbedLogicalDistinct.Identity)\" /> </ItemGroup> Source: csharp/src/DBTools.App/DBTools.App.csproj:262-268 Exclusions from Embedding Revit-provided assemblies (never copy/embed): <_EmbedCandidate Remove=\"@(_EmbedCandidate)\" Condition=\"'%(Filename)%(Extension)' == 'RevitAPI.dll'\" /> <_EmbedCandidate Remove=\"@(_EmbedCandidate)\" Condition=\"'%(Filename)%(Extension)' == 'Newtonsoft.Json.dll'\" /> WPF theme assemblies (need file Location): <_EmbedCandidate Remove=\"@(_EmbedCandidate)\" Condition=\"$([System.String]::Copy('%(Filename)').StartsWith('DBTools.Fluent.Ribbon'))\" /> <_EmbedCandidate Remove=\"@(_EmbedCandidate)\" Condition=\"$([System.String]::Copy('%(Filename)').StartsWith('DBTools.ControlzEx'))\" /> <_EmbedCandidate Remove=\"@(_EmbedCandidate)\" Condition=\"$([System.String]::Copy('%(Filename)').StartsWith('DBTools.Themes'))\" /> Source: csharp/src/DBTools.App/DBTools.App.csproj:241-251 Runtime Assembly Resolution EmbeddedAssemblyResolver The resolver is installed early during add-in startup: public static void Install(Assembly mainAssembly, string? deployedDir = null) { // ... #if NET8_0_OR_GREATER var alc = AssemblyLoadContext.GetLoadContext(mainAssembly) ?? AssemblyLoadContext.Default; alc.Resolving += (context, name) => ResolveNet8(context, mainAssembly, name); #else AppDomain.CurrentDomain.AssemblyResolve += (_, args) => Resolve(mainAssembly, args.Name); #endif } Source: csharp/src/DBTools.Loader/AssemblyResolution/EmbeddedAssemblyResolver.cs:24-38 Resolution Flow (net48) Assembly requested (e.g., \"Serilog\") | v 1. Already loaded in AppDomain? YES -> Return existing (prevents duplicates) | v 2. Try embedded resource: \"DBTools.EmbeddedAssemblies.Serilog.dll\" FOUND -> Assembly.Load(bytes) | v 3. Check if merged via ILRepack (TryGetMergedAssembly) MERGED -> Return mainAssembly | v 4. DBTools.* namespace? Try file-based fallbacks FOUND -> Assembly.LoadFrom(path) | v 5. Return null (let CLR handle) Source: csharp/src/DBTools.Loader/AssemblyResolution/EmbeddedAssemblyResolver.cs:40-95 Merged Assembly Detection (net48) For ILRepack'd assemblies, the resolver returns the main assembly: private static Assembly? TryGetMergedAssembly(Assembly mainAssembly, string requestedName) { // WPF themes NOT merged if (requestedName.Equals(\"DBTools.Fluent.Ribbon\", ...) || requestedName.Equals(\"DBTools.ControlzEx\", ...) || requestedName.Equals(\"DBTools.Themes\", ...) || requestedName.Equals(\"DBTools.Loader\", ...)) return null; // DBTools.Core is merged if (requestedName.Equals(\"DBTools.Core\", ...)) return mainAssembly; // Other merged deps if (requestedName.StartsWith(\"Serilog\", ...) || requestedName.StartsWith(\"Microsoft.Extensions\", ...) || requestedName.Equals(\"YamlDotNet\", ...)) return mainAssembly; return null; } Source: csharp/src/DBTools.Loader/AssemblyResolution/EmbeddedAssemblyResolver.cs:223-263 Resolution Flow (net8) private static Assembly? ResolveNet8(AssemblyLoadContext alc, Assembly mainAssembly, AssemblyName requested) { // 1. Already loaded? Return it var alreadyLoaded = alc.Assemblies.FirstOrDefault(...); if (alreadyLoaded != null) return alreadyLoaded; // 2. Try embedded resource var resourceName = ResourcePrefix + requestedName + \".dll\"; using var stream = mainAssembly.GetManifestResourceStream(resourceName); if (stream != null) { return alc.LoadFromStream(ms); // Load into same ALC } // 3. File-based fallbacks for WPF assemblies return TryLoadFromFileFallbacksNet8(alc, mainAssembly, requestedName); } Source: csharp/src/DBTools.Loader/AssemblyResolution/EmbeddedAssemblyResolver.cs:146-189 WPF Theme Assemblies: Why They Stay Separate The pack:// URI Problem WPF's XAML parser uses pack:// URIs to locate resources within assemblies: <ResourceDictionary Source=\"pack://application:,,,/DBTools.Fluent.Ribbon;component/Themes/Generic.xaml\" /> The parser uses Assembly.Location to resolve these URIs. Assemblies loaded from byte arrays have Location = \"\", breaking resource lookup. Source: csharp/src/DBTools.Loader/AssemblyResolution/EmbeddedAssemblyResolver.cs:93-94, csharp/src/DBTools.App/DBTools.App.csproj:244-251 Which Assemblies Need File Location Assembly Reason DBTools.Fluent.Ribbon Contains BAML for ribbon controls DBTools.ControlzEx Contains BAML for window behaviors DBTools.HandyControl Contains BAML for HandyControl widgets DBTools.Themes Contains merged theme dictionaries Source: csharp/build/BuildMerging.cs:53-57 File-Based Resolution Fallbacks For WPF assemblies, the resolver tries file-based loading: private static Assembly? TryLoadFromFileFallbacks(Assembly mainAssembly, string requestedName) { // 1. Check %APPDATA%/DBTools/vendor/<type>/<tfm>/ var appDataPath = Path.Combine( Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData), \"DBTools\", \"vendor\", vendorType, vendorTfm, dllName); if (File.Exists(appDataPath)) return Assembly.LoadFrom(appDataPath); // 2. Check deployed directory (next to DBTools.Loader.dll) return TryLoadFromDeployedDir(deployedDir, dllName); } Source: csharp/src/DBTools.Loader/AssemblyResolution/EmbeddedAssemblyResolver.cs:101-129 Preloading Critical Assemblies (net48) The GAC Problem On net48, AssemblyResolve only fires when an assembly CAN'T be found. If an older version exists in the GAC or was loaded by another add-in, the CLR uses it instead of asking our resolver. Solution: Preload During Startup Before any code uses these assemblies, DBTools.Loader preloads them from embedded resources: #if !NET8_0_OR_GREATER PreloadEmbeddedConfigurationAssemblies(assembly); PreloadEmbeddedSerilogAssemblies(assembly); #endif Source: csharp/src/DBTools.Loader/Addin/AddinEntry.cs:25-28 Configuration Assembly Preload private static void PreloadEmbeddedConfigurationAssemblies(Assembly mainAssembly) { var configAssemblies = new[] { \"Microsoft.Extensions.Primitives\", \"Microsoft.Extensions.FileProviders.Abstractions\", \"Microsoft.Extensions.FileProviders.Physical\", \"Microsoft.Extensions.Configuration.Abstractions\", \"Microsoft.Extensions.Configuration\", \"Microsoft.Extensions.Configuration.FileExtensions\", \"Microsoft.Extensions.Configuration.Json\", \"Microsoft.Extensions.Configuration.Binder\" }; foreach (var name in configAssemblies) { var alreadyLoaded = GetLoadedAssemblyBySimpleName(name); if (alreadyLoaded != null) continue; var resourceName = \"DBTools.EmbeddedAssemblies.\" + name + \".dll\"; using (var stream = mainAssembly.GetManifestResourceStream(resourceName)) { if (stream == null) continue; using (var ms = new MemoryStream()) { stream.CopyTo(ms); Assembly.Load(ms.ToArray()); } } } } Source: csharp/src/DBTools.Loader/Addin/AddinEntry.cs:109-143 Serilog Assembly Preload Critical: Dependencies must be loaded BEFORE dependents: var serilogAssemblies = new[] { // 1. Base abstractions first \"Microsoft.Extensions.Logging.Abstractions\", \"Microsoft.Extensions.DependencyInjection.Abstractions\", // 2. M.E.Logging (depends on Abstractions) \"Microsoft.Extensions.Logging\", // 3. Serilog core \"Serilog\", // 4. Serilog extensions (depend on above) \"Serilog.Extensions.Logging\", \"Serilog.Enrichers.Thread\", \"Serilog.Sinks.File\" }; Source: csharp/src/DBTools.Loader/Addin/AddinEntry.cs:150-170 Forbidden Host Assemblies Build-Time Guardrails The build prevents certain assemblies from landing in output: <ItemGroup> <ForbiddenHostAssembly Include=\"RevitAPI.dll\" /> <ForbiddenHostAssembly Include=\"RevitAPIUI.dll\" /> <ForbiddenHostAssembly Include=\"AdWindows.dll\" /> <ForbiddenHostAssembly Include=\"UIFramework.dll\" /> <ForbiddenHostAssembly Include=\"Newtonsoft.Json.dll\" /> <ForbiddenHostAssembly Include=\"System.Runtime.dll\" /> <ForbiddenHostAssembly Include=\"System.ObjectModel.dll\" /> </ItemGroup> Source: csharp/src/DBTools.App/DBTools.App.csproj:169-177 Automatic Cleanup A build target removes forbidden assemblies if transitive dependencies copied them: <Target Name=\"DBT_RemoveForbiddenAfterCopy\" AfterTargets=\"CopyFilesToOutputDirectory\" BeforeTargets=\"FailIfHostAssembliesInOutput\"> <Delete Files=\"@(_DBT_ForbiddenToClear)\" /> </Target> Source: csharp/src/DBTools.App/DBTools.App.csproj:181-196 Build Failure on Violation If any forbidden assemblies remain after cleanup, the build fails: <Target Name=\"FailIfHostAssembliesInOutput\"> <Error Text=\"Forbidden host assemblies detected in output: @(_ForbiddenInOutput).\" Condition=\"'@(_ForbiddenInOutput)' != ''\" /> </Target> Source: csharp/src/DBTools.App/DBTools.App.csproj:198-211 Summary: What Goes Where Assembly Type net48 net8.0-windows Location DBTools.Core ILRepack merged Embedded resource Inside DBTools.dll Serilog.* ILRepack merged Embedded resource Inside DBTools.dll M.E.DI/Config ILRepack merged Embedded resource Inside DBTools.dll YamlDotNet ILRepack merged Embedded resource Inside DBTools.dll ricaun.Revit.* Embedded resource Embedded resource Inside DBTools.dll DBTools.Themes Separate file Separate file Next to DBTools.dll DBTools.Fluent.Ribbon Separate file Separate file Next to DBTools.dll DBTools.ControlzEx Separate file Separate file Next to DBTools.dll DBTools.HandyControl Separate file Separate file Next to DBTools.dll DBTools.Loader Separate file Separate file Next to DBTools.dll RevitAPI/UI Never copied Never copied Revit provides Troubleshooting Issue: \"Type X not found\" or \"Method Y not found\" Cause: Assembly version mismatch - another add-in loaded a different version first. Solutions: Ensure dependencies are embedded or merged Check if the assembly is in keepSeparate whitelist unnecessarily Preload the assembly during startup Issue: WPF resource not found (pack:// URI failure) Cause: WPF assembly loaded from bytes instead of file. Solutions: Ensure WPF assemblies are in keepSeparate whitelist Verify DLLs are deployed next to DBTools.Loader.dll Check EmbeddedAssemblyResolver file fallback paths Issue: ILRepack crash or corrupted IL Cause: Some assemblies have IL that ILRepack can't process. Solutions: Add to keepSeparatePrefixes to exclude from merge Embed as resource instead of merging Check ILRepack version compatibility Issue: Duplicate type definitions after merge Cause: Multiple assemblies define the same polyfill type. Solution: ILRepack /allowdup flag handles this: args.Append(\"/allowdup \"); // Handle duplicate polyfill types Source: csharp/build/BuildMerging.cs:131 Related Documentation Architecture Overview - High-level system architecture Project References - How projects reference each other Build Pipeline - Build system details DBTools.Loader - Assembly loading at runtime Verification Status Check Status Source anchors for all claims Yes UNVERIFIED markers where needed No (all verified) Cross-references added Yes Examples tested N/A No assumptions without evidence Yes Verified by: docs-run-20260124-020412 Date: 2026-01-24"
  },
  "articles/architecture/overview.html": {
    "href": "articles/architecture/overview.html",
    "title": "Architecture Overview | DB Tools",
    "summary": "Architecture Overview DBTools is a modular Revit add-in suite built with modern C#/.NET practices. It provides a collection of productivity tools for structural engineers working in Autodesk Revit. High-Level Architecture +-----------------------------------------------------------------------------------+ | Revit Host | +-----------------------------------------------------------------------------------+ | | v v +-------------------+ +----------------------+ | DBTools.Loader | <-- Revit .addin manifest | Revit API | | (Entry Point) | points here | (RevitAPI.dll, | +-------------------+ | RevitAPIUI.dll) | | +----------------------+ | Loads DBTools.dll, installs ^ | EmbeddedAssemblyResolver | v | +-------------------+ References +----------------------+ | | DBTools.App | -----------------> | DBTools.Core |-+ | (DBTools.dll) | | (Core Library) | | | +----------------------+ | - AddinEntry | ^ | - Tool Modules | | | - Ribbon UI | References | | - Commands | -----------------> +----------------------+ +-------------------+ | DBTools.Themes | | | (WPF Resources) | | Discovers via manifest.yml +----------------------+ v +-------------------+ | Tool Modules | | (File-linked) | | - GM, SGT, TDV | | - Settings | | - Structural/* | +-------------------+ Source: csharp/src/DBTools.Loader/Addin/AddinEntry.cs:12-38 Project Organization The solution follows a layered architecture with clear separation of concerns: Core Projects Project Purpose Target Frameworks DBTools.Loader Revit entry point; loads DBTools.dll and resolves embedded assemblies net48, net8.0-windows DBTools.App Main application assembly (outputs as DBTools.dll); contains ribbon UI and tool registration net48, net8.0-windows DBTools.Core Core library with shared infrastructure (DI, logging, settings, Revit abstractions) net48, net8.0-windows DBTools.Themes WPF theme resources and styling (HandyControl, Fluent.Ribbon) net48, net8.0-windows DBTools.Sandbox Standalone WPF app for UI development without Revit net48, net8.0-windows Source: csharp/src/ directory structure Tool Projects (File-Linked into DBTools.App) Tools are organized under csharp/src/Tools/ and compiled into the main DBTools.dll assembly via MSBuild file linking: Tools/ +-- Common/ | +-- GM/ # Global Mapper | +-- TDV/ # Type Data Viewer | +-- ElevationTags/ | +-- 3DElementsFromList/ +-- Structural/ | +-- SGT/ # Structural Grid Tool | +-- FoundationTags/ | +-- FramingJoins/ | +-- JoistGirderWeight/ | +-- OrganizeFoundationTypes/ | +-- AnalyticalSnapToLevel/ +-- Settings/ # Settings management tool +-- Testing/ +-- VTC/ # View Test Coordinator Source: csharp/src/DBTools.App/DBTools.App.csproj:62-78 (file linking configuration) Tool source files are linked (not copied) into the DBTools.App project: <Compile Include=\"..\\Tools\\**\\*.cs\" Exclude=\"..\\Tools\\**\\Tests\\**\\*.cs;..\\Tools\\**\\obj\\**\\*.cs\" Link=\"Tools\\%(RecursiveDir)%(Filename)%(Extension)\" /> Source: csharp/src/DBTools.App/DBTools.App.csproj:64-66 Multi-Year Revit Support DBTools supports multiple Revit versions through dual target frameworks: Revit Version Target Framework Runtime Revit 2024 net48 .NET Framework 4.8 Revit 2025+ net8.0-windows .NET 8 Source: csharp/build/Revit.props:2-6 The build system auto-detects installed Revit versions and builds for all available years: <DBT_RevitLegacyTFM>net48</DBT_RevitLegacyTFM> <DBT_RevitModernTFM>net8.0-windows</DBT_RevitModernTFM> <DBT_RevitTargetFrameworks>$(DBT_RevitLegacyTFM);$(DBT_RevitModernTFM)</DBT_RevitTargetFrameworks> Source: csharp/build/Revit.props:3-5 Tool Discovery and Registration DBTools uses a YAML manifest-driven tool discovery system. Each tool declares its module, commands, and UI configuration in a manifest.yml file. Manifest Structure id: DBTools.GM assembly: DBTools moduleType: DBTools.GM.GmToolModule order: 0 sandboxWindows: - id: DBTools.GM.Main displayName: \"Global Mapper\" windowType: \"DBTools.GM.Shell.UI.Views.GmWindow\" tool: ribbonTools: - internalName: DBTools.GM commandType: DBTools.GM.Features.GmCommand availabilityType: DBTools.App.Tools.Availability.DbtDocumentAvailability displayText: \"Global Mapper\" iconBaseKey: gm controlKind: PushButton Source: csharp/src/Tools/Common/GM/manifest.yml:1-26 Discovery Flow Manifest Loading: DbtToolManifestLoader scans embedded resources for manifest.yml files Module Instantiation: DbtToolModuleCatalog creates DbtToolModule instances via reflection Service Registration: Each module's RegisterServices(), RegisterSettings(), and RegisterHooks() are called Ribbon Tool Registration: RegisterRibbonToolsFromManifest() parses ribbon definitions and registers commands Source: csharp/src/DBTools.Core/Tools/DbtToolModuleCatalog.cs:11-64 Tool Module Base Class All tools inherit from DbtToolModule, which provides hooks for: RegisterSettings() - Bind configuration sections to strongly-typed options RegisterServices() - Register tool-specific DI services RegisterSettingsPacks() - Register settings UI definitions RegisterHooks() - Register event handlers (e.g., DocumentOpened, ViewActivated) Source: csharp/src/DBTools.Core/Tools/DbtToolModule.cs:9-49 Dependency Injection Architecture DBTools uses Microsoft.Extensions.DependencyInjection with a two-tier service scope pattern: Singleton Services (Application Lifetime) IDbtLoggingHost - Serilog-based logging infrastructure IConfiguration - Settings from settings.json DbtToolRegistry - Discovered tool registrations ISafeExecutor - Centralized error handling ISettingsProvider - Settings read/write access Scoped Services (Per-Command Lifetime) IRevitRunScope - Active command execution context IRevitCallGate - Thread-safe Revit API access ITransactionRunner - Transaction management ITransactionGroupService - Transaction grouping Source: csharp/src/DBTools.App/Bootstrap/DbtServiceBootstrapper.cs:68-130 Assembly Loading Strategy Loader Bootstrap The DBTools.Loader assembly is the Revit entry point. It: Locates DBTools.dll in the same directory Installs EmbeddedAssemblyResolver for runtime dependency resolution Pre-loads critical assemblies (Configuration, Serilog) on net48 Reflectively creates and invokes DBTools.App.AddinEntry Source: csharp/src/DBTools.Loader/Addin/AddinEntry.cs:17-47 Embedded Dependencies Dependencies are embedded as resources in DBTools.dll to minimize deployment complexity: <EmbeddedResource Include=\"%(_EmbedLogicalDistinct.SourcePath)\" LogicalName=\"%(_EmbedLogicalDistinct.Identity)\" /> Source: csharp/src/DBTools.App/DBTools.App.csproj:267-268 The resolver uses different strategies per framework: Framework Strategy net48 ILRepack merges most assemblies; ricaun.* embedded as resources net8.0 All dependencies embedded as resources, loaded via AssemblyLoadContext Source: csharp/src/DBTools.Loader/AssemblyResolution/EmbeddedAssemblyResolver.cs:14-96 WPF Theme Assemblies WPF assemblies (Fluent.Ribbon, ControlzEx, HandyControl) cannot be embedded because they require Assembly.Location for pack:// URI resolution. These are: Vendored/renamed to avoid conflicts with pyRevit (e.g., DBTools.Fluent.Ribbon) Deployed as files alongside DBTools.dll Source: csharp/src/DBTools.Loader/AssemblyResolution/EmbeddedAssemblyResolver.cs:134-143 Build System Overview The build uses NUKE (C# build automation) invoked via build.sh: # Fast incremental build (default) bash csharp/build.sh # Clean rebuild bash csharp/build.sh --clean # Build specific Revit year bash csharp/build.sh -y 2025 BuildAll # Common targets bash csharp/build.sh BuildAll # Build everything bash csharp/build.sh BuildApp # Build DBTools.dll only bash csharp/build.sh BuildSandbox # Build UI sandbox bash csharp/build.sh PromoteToDist # Stage for deployment Source: csharp/build.sh:33-60 Key build features: Centralized Artifacts: All outputs go to csharp/.artifacts/ (not per-project bin/obj) Vendored Dependencies: UI assemblies built via build-vendored-deps.sh Strict Analysis: TreatWarningsAsErrors=true, Roslyn analyzers enabled Multi-Year: Builds for all detected Revit installations Source: csharp/Directory.Build.props:8-28 For detailed build pipeline documentation, see Build Pipeline. Error Handling Philosophy All entrypoints execute within ISafeExecutor, which: Catches and logs all exceptions Displays user-friendly error dialogs Prevents silent failures Centralizes error reporting Source: csharp/src/DBTools.App/Bootstrap/DbtServiceBootstrapper.cs:435-436 Non-Negotiable Rules: No fallbacks that hide failures No silent exception swallowing No returning defaults as if nothing failed Related Documentation Build Pipeline - Detailed build system reference Test Pipeline - Testing infrastructure Project References - Dependency relationships DBTools.Core - Core library documentation DBTools.Loader - Revit entry point Verification Status Check Status Source anchors for all claims Yes UNVERIFIED markers where needed No (all verified) Cross-references added Yes Examples tested N/A No assumptions without evidence Yes Verified by: docs-run-20260124-020412 Date: 2026-01-24"
  },
  "articles/architecture/project-references.html": {
    "href": "articles/architecture/project-references.html",
    "title": "Project References and Dependency Management | DB Tools",
    "summary": "Project References and Dependency Management This document describes how DBTools projects reference each other, manage dependencies, and use file linking patterns. Project Dependency Graph +-----------------------+ | DBTools.Themes | | (WPF theme resources)| +-----------+-----------+ | +------------------------+------------------------+ | | +---------v---------+ +---------v---------+ | DBTools.Core |<----------------------------+ DBTools.App | | (shared services, | | (assembly output: | | UI, Revit infra) | | DBTools.dll) | +---------+---------+ +---------+---------+ ^ ^ | | +-----------+-----------+ +-----------+-----------+ | | | | +-------+-------+ +-------+-------+ +-------+-------+ +-------+-------+ | DBTools.GM | | DBTools.SGT | | File-linked | | File-linked | | (XAML design) | | (XAML design) | | tool sources | | tool assets | +---------------+ +---------------+ +---------------+ +---------------+ ^ ^ | | +-------+-------+ +-------+-------+ |DBTools.GM.Tests| |DBTools.SGT.Tests| +---------------+ +---------------+ +-------------------+ +-------------------+ | DBTools.Loader | | DBTools.Sandbox | | (Revit entrypoint)| | (standalone exe) | +-------------------+ +-------------------+ Source: csharp/src/DBTools.App/DBTools.App.csproj:56-59 Key Relationships From To Reference Type Purpose DBTools.App DBTools.Core ProjectReference Core services, UI infrastructure DBTools.App DBTools.Themes ProjectReference WPF theme resources DBTools.Core DBTools.Themes ProjectReference ComponentResourceKey definitions Tool projects DBTools.Core ProjectReference Shared infrastructure Test projects DBTools.App + DBTools.Core ProjectReference Test compilation DBTools.Sandbox DBTools.Core + DBTools.Themes ProjectReference Standalone preview File Linking vs Project References DBTools uses two distinct patterns for code sharing: Pattern 1: Project References (Standard) Used when the referenced assembly should be included as a separate DLL in output. <!-- From DBTools.Core.csproj:165 --> <ProjectReference Include=\"..\\DBTools.Themes\\DBTools.Themes.csproj\" /> Source: csharp/src/DBTools.Core/DBTools.Core.csproj:165 When to use: Shared infrastructure code (Core, Themes) Code that defines types needed at runtime via reflection WPF resources that use pack:// URIs Pattern 2: File Linking (Compile-time inclusion) Used when source files should be compiled directly into another assembly. <!-- From DBTools.App.csproj:64-67 --> <Compile Include=\"..\\Tools\\**\\*.cs\" Exclude=\"..\\Tools\\**\\Tests\\**\\*.cs;..\\Tools\\**\\obj\\**\\*.cs\" Link=\"Tools\\%(RecursiveDir)%(Filename)%(Extension)\" /> Source: csharp/src/DBTools.App/DBTools.App.csproj:64-67 When to use: Tool source code compiled into DBTools.dll Shared test utilities across test projects Polyfill files for net48 compatibility File Linking Patterns in Detail Tool Source Files into DBTools.App All tool code from src/Tools/ is file-linked into DBTools.App: <!-- C# source files --> <Compile Include=\"..\\Tools\\**\\*.cs\" Exclude=\"..\\Tools\\**\\Tests\\**\\*.cs;..\\Tools\\**\\obj\\**\\*.cs\" Link=\"Tools\\%(RecursiveDir)%(Filename)%(Extension)\" /> <!-- XAML files --> <Page Include=\"..\\Tools\\**\\*.xaml\" Exclude=\"..\\Tools\\**\\obj\\**\\*.xaml;..\\Tools\\**\\Properties\\DesignTimeResources.xaml\" Link=\"Tools\\%(RecursiveDir)%(Filename)%(Extension)\" /> <!-- Icon assets --> <EmbeddedResource Include=\"..\\Tools\\**\\Assets\\*.png\" Link=\"Resources\\Icons\\%(RecursiveDir)%(Filename)%(Extension)\" /> Source: csharp/src/DBTools.App/DBTools.App.csproj:63-78 Why file linking for tools? Single deployable assembly (DBTools.dll) Eliminates plugin DLL proliferation Tool projects exist primarily for XAML designer support Shared Test Utilities Test projects link shared test infrastructure: <!-- From DBTools.GM.Tests.csproj:62-79 --> <Compile Include=\"..\\..\\..\\..\\..\\testing\\TestSupport\\ApsEnv.cs\" Link=\"TestSupport\\ApsEnv.cs\" /> <Compile Include=\"..\\..\\..\\..\\..\\testing\\TestSupport\\CommonTestDoubles.cs\" Link=\"TestSupport\\CommonTestDoubles.cs\" /> <Compile Include=\"..\\..\\..\\..\\..\\testing\\TestSupport\\TestHost\\RevitHost.cs\" Link=\"TestSupport\\TestHost\\RevitHost.cs\" /> <!-- ... more linked files ... --> Source: csharp/src/Tools/Common/GM/Tests/DBTools.GM.Tests.csproj:62-79 BCL Polyfills for net48 Polyfill files enable C# 10+ features on .NET Framework: <!-- From Directory.Build.props:215-219 --> <Compile Include=\"$(MSBuildThisFileDirectory)build/BuildSupport/Polyfills/IsExternalInit.cs\" Condition=\"'$(TargetFramework)'=='net48'\" /> <Compile Include=\"$(MSBuildThisFileDirectory)build/BuildSupport/Polyfills/StringExtensions.cs\" Condition=\"'$(TargetFramework)'=='net48'\" /> Source: csharp/Directory.Build.props:215-219 Centralized Package Management Directory.Packages.props All NuGet package versions are centralized: <Project> <PropertyGroup> <ManagePackageVersionsCentrally>true</ManagePackageVersionsCentrally> <CentralPackageTransitivePinningEnabled>true</CentralPackageTransitivePinningEnabled> </PropertyGroup> <ItemGroup> <!-- Package versions defined once --> <PackageVersion Include=\"CommunityToolkit.Mvvm\" Version=\"8.2.2\" /> <PackageVersion Include=\"Microsoft.Extensions.DependencyInjection\" Version=\"8.0.1\" /> <!-- ... --> </ItemGroup> </Project> Source: csharp/Directory.Packages.props:1-5 Consuming Packages Projects reference packages without specifying versions: <!-- From DBTools.Core.csproj:107-127 --> <PackageReference Include=\"CSharpFunctionalExtensions\" /> <PackageReference Include=\"Ardalis.GuardClauses\" /> <PackageReference Include=\"AutoMapper\" /> <PackageReference Include=\"Serilog\" /> Source: csharp/src/DBTools.Core/DBTools.Core.csproj:107-127 Version Pinning Strategy Package Category Version Strategy Rationale M.E.* (DI, Config, Logging) 8.x Match Revit 2026 .NET 8 runtime Serilog 4.x/6.x/8.x Compatible with both TFMs BCL packages (System.Memory) Pinned Align with vendored Fluent.Ribbon Source: csharp/Directory.Packages.props:73-95 Multi-Targeting Configuration Target Framework Definitions All Revit-facing projects target both frameworks: <!-- From Revit.props:2-6 --> <PropertyGroup Label=\"Revit TFMs\"> <DBT_RevitLegacyTFM>net48</DBT_RevitLegacyTFM> <DBT_RevitModernTFM>net8.0-windows</DBT_RevitModernTFM> <DBT_RevitTargetFrameworks>$(DBT_RevitLegacyTFM);$(DBT_RevitModernTFM)</DBT_RevitTargetFrameworks> </PropertyGroup> Source: csharp/build/Revit.props:2-6 Consuming in Projects <!-- Standard pattern in all Revit projects --> <TargetFrameworks>$(DBT_RevitTargetFrameworks)</TargetFrameworks> Source: csharp/src/DBTools.Core/DBTools.Core.csproj:3 Revit API Reference Patterns References are conditional on TFM and build type: <!-- net48 references Revit 2024 --> <ItemGroup Condition=\"'$(TargetFramework)'=='net48'\"> <Reference Include=\"RevitAPI\"> <HintPath>$(REVIT2024_DIR)\\RevitAPI.dll</HintPath> <Private>false</Private> </Reference> </ItemGroup> <!-- net8 references Revit 2025/2026 --> <ItemGroup Condition=\"'$(TargetFramework)'=='net8.0-windows'\"> <Reference Include=\"RevitAPI\" Condition=\"'$(REVIT_NET8_DIR)'!=''\"> <HintPath>$(REVIT_NET8_DIR)\\RevitAPI.dll</HintPath> <Private>false</Private> </Reference> </ItemGroup> Source: csharp/src/DBTools.App/DBTools.App.csproj:110-165 Vendored Dependencies Why Vendored? Some UI libraries are vendored (renamed) to avoid conflicts with other Revit add-ins: <!-- From DBTools.Core.csproj:144-152 --> <Reference Include=\"DBTools.Fluent.Ribbon\"> <HintPath>$(DBT_VendorArtifactsRoot)fluentribbon\\$(TargetFramework)\\DBTools.Fluent.Ribbon.dll</HintPath> <Private>true</Private> </Reference> <Reference Include=\"DBTools.ControlzEx\"> <HintPath>$(DBT_VendorArtifactsRoot)controlzex\\$(TargetFramework)\\DBTools.ControlzEx.dll</HintPath> <Private>true</Private> </Reference> Source: csharp/src/DBTools.Core/DBTools.Core.csproj:144-152 Vendored Libraries Original Vendored As Reason Fluent.Ribbon DBTools.Fluent.Ribbon Avoid pyRevit conflicts ControlzEx DBTools.ControlzEx Avoid pyRevit conflicts HandyControl DBTools.HandyControl Avoid host conflicts Source: csharp/src/DBTools.Themes/DBTools.Themes.csproj:53-70 Assembly Embedding (DBTools.App) Embedded Assembly Strategy DBTools.App embeds most dependencies into the main DLL: <!-- From DBTools.App.csproj:234-270 --> <Target Name=\"DBT_EmbedCopyLocalAssemblies\" AfterTargets=\"ResolveReferences\" Condition=\"'$(DesignTimeBuild)'!='true'\"> <ItemGroup> <_EmbedCandidate Include=\"@(ReferenceCopyLocalPaths)\" Condition=\"...\" /> <!-- Exclude host-provided assemblies --> <_EmbedCandidate Remove=\"@(_EmbedCandidate)\" Condition=\"'%(Filename)%(Extension)' == 'RevitAPI.dll'\" /> </ItemGroup> <ItemGroup> <EmbeddedResource Include=\"%(_EmbedLogicalDistinct.SourcePath)\" LogicalName=\"%(_EmbedLogicalDistinct.Identity)\" /> </ItemGroup> </Target> Source: csharp/src/DBTools.App/DBTools.App.csproj:234-270 What Gets Embedded Embedded Not Embedded Reason DBTools.Core RevitAPI/RevitAPIUI Revit provides at runtime Serilog.* Newtonsoft.Json Revit provides M.E.DependencyInjection DBTools.Fluent.Ribbon WPF needs file-based Location AutoMapper DBTools.ControlzEx WPF needs file-based Location Test Project References Reference Strategy Test projects reference both App and Core: <!-- From DBTools.GM.Tests.csproj:83-86 --> <ItemGroup> <ProjectReference Include=\"..\\..\\..\\..\\DBTools.App\\DBTools.App.csproj\" /> <ProjectReference Include=\"..\\..\\..\\..\\DBTools.Core\\DBTools.Core.csproj\" /> </ItemGroup> Source: csharp/src/Tools/Common/GM/Tests/DBTools.GM.Tests.csproj:83-86 Why reference both? Tool code is file-linked into App (need App for tool types) Core exposes internal types via InternalsVisibleTo Tests need access to both layers InternalsVisibleTo Declarations <!-- From DBTools.Core.csproj:27-32 --> <ItemGroup> <InternalsVisibleTo Include=\"DBTools.App\" /> <InternalsVisibleTo Include=\"DBTools.GM.Tests\" /> <InternalsVisibleTo Include=\"DBTools.SGT.Tests\" /> <InternalsVisibleTo Include=\"DBTools.TDV.Tests\" /> </ItemGroup> Source: csharp/src/DBTools.Core/DBTools.Core.csproj:27-32 Common Pitfalls and Solutions Pitfall 1: Circular Reference Between Themes and Core Problem: DBTools.Core needs theme resources; themes might need Core types. Solution: Theme dictionaries that need Core types are kept as raw Resource XAML (not compiled BAML): <!-- From DBTools.Themes.csproj:38-46 --> <ItemGroup> <Page Remove=\"Themes\\App.Converters.xaml\" /> <Resource Include=\"Themes\\App.Converters.xaml\" /> </ItemGroup> Source: csharp/src/DBTools.Themes/DBTools.Themes.csproj:38-46 Pitfall 2: Forbidden Host Assemblies in Output Problem: Transitive dependencies may copy Revit-provided DLLs to output. Solution: Build targets explicitly remove forbidden assemblies: <!-- From DBTools.App.csproj:169-177 --> <ItemGroup> <ForbiddenHostAssembly Include=\"RevitAPI.dll\" /> <ForbiddenHostAssembly Include=\"Newtonsoft.Json.dll\" /> <!-- ... --> </ItemGroup> <Target Name=\"DBT_RemoveForbiddenAfterCopy\" AfterTargets=\"CopyFilesToOutputDirectory\"> <Delete Files=\"@(_DBT_ForbiddenToClear)\" /> </Target> Source: csharp/src/DBTools.App/DBTools.App.csproj:169-196 Pitfall 3: XAML Designer Cannot Load x64 Assemblies Problem: XDesProc.exe is 32-bit; DBTools.App is x64 for Revit. Solution: Override PlatformTarget during design-time builds: <!-- From Directory.Build.targets:27-30 --> <PropertyGroup Condition=\"'$(DBT_IsDesignerBuild)'=='true' and '$(TargetFramework)'=='net48'\"> <PlatformTarget>AnyCPU</PlatformTarget> <Prefer32Bit>false</Prefer32Bit> </PropertyGroup> Source: csharp/Directory.Build.targets:27-30 Pitfall 4: Test Projects Missing Revit API Types Problem: Revit API references aren't transitive. Solution: Test projects explicitly reference Revit APIs: <!-- From DBTools.GM.Tests.csproj:95-109 --> <ItemGroup Condition=\"'$(TargetFramework)'=='net48'\"> <Reference Include=\"RevitAPI\"> <HintPath>$(REVIT2024_DIR)\\RevitAPI.dll</HintPath> <Private>false</Private> </Reference> </ItemGroup> Source: csharp/src/Tools/Common/GM/Tests/DBTools.GM.Tests.csproj:95-109 Pitfall 5: DBTools.Themes Polyfill Conflicts Problem: Themes is referenced by other net48 projects; polyfill types could conflict. Solution: Themes explicitly removes polyfill files: <!-- From DBTools.Themes.csproj:24-29 --> <ItemGroup Condition=\"'$(TargetFramework)'=='net48'\"> <Compile Remove=\"$(MSBuildThisFileDirectory)../../build/BuildSupport/Polyfills/IsExternalInit.cs\" /> <Compile Remove=\"$(MSBuildThisFileDirectory)../../build/BuildSupport/Polyfills/StringExtensions.cs\" /> </ItemGroup> Source: csharp/src/DBTools.Themes/DBTools.Themes.csproj:24-29 Build Configuration Inheritance Directory.Build.props Flow csharp/Directory.Build.props | +-- Imports Version.props (version numbers) +-- Imports build/Revit.props (TFM definitions) +-- Sets artifact paths (.artifacts/) +-- Configures analyzers, warnings +-- Defines shared package references Source: csharp/Directory.Build.props:1-6 Directory.Build.targets Flow csharp/Directory.Build.targets | +-- Enforces NUKE entrypoint (DBT_Entry) +-- Handles WPF temp project intermediates +-- Copies vendored DLLs for XAML designer +-- Cleans up wpftmp artifacts Source: csharp/Directory.Build.targets:1-312 Quick Reference: Adding a New Project Tool Project Checklist Create project in src/Tools/{Category}/{ToolName}/ Use standard template: <TargetFrameworks>$(DBT_RevitTargetFrameworks)</TargetFrameworks> <ProjectReference Include=\"..\\..\\..\\DBTools.Core\\DBTools.Core.csproj\" /> Add conditional Revit API references (copy from existing tool) Tool sources are automatically file-linked into DBTools.App via wildcard Test Project Checklist Create in src/Tools/{Category}/{ToolName}/Tests/ Reference both App and Core: <ProjectReference Include=\"..\\..\\..\\..\\DBTools.App\\DBTools.App.csproj\" /> <ProjectReference Include=\"..\\..\\..\\..\\DBTools.Core\\DBTools.Core.csproj\" /> Link shared test utilities from testing/TestSupport/ Add explicit Revit API references (not transitive) Related Documentation Build Pipeline - How projects are built ILRepack & Embedding - Assembly merging details Architecture Overview - High-level system architecture Verification Status Check Status Source anchors for all claims Yes UNVERIFIED markers where needed No (all verified) Cross-references added Yes Examples tested N/A No assumptions without evidence Yes Verified by: docs-run-20260124-020412 Date: 2026-01-24"
  },
  "articles/architecture/sandbox-validator.html": {
    "href": "articles/architecture/sandbox-validator.html",
    "title": "Sandbox Validator Architecture | DB Tools",
    "summary": "Sandbox Validator Architecture Overview The Sandbox Validator is a critical build-time validation system that verifies the integrity of DBTools dist outputs before deployment. It runs as part of the BuildAll target and catches XAML errors, manifest misconfigurations, binding failures, and assembly merge issues that would otherwise only manifest at runtime inside Revit. The validator operates in two modes: Headless mode (--headless): Used by the build pipeline for automated validation Interactive mode: A UI gallery for manual testing and development Source: csharp/src/DBTools.Sandbox/App.xaml.cs:21-77 Architecture Diagram NUKE BuildAll | v +-------------------+ | ValidateDist | | (BuildTargets) | +-------------------+ | | --headless --dist-dir <path> v +-------------------+ | DBTools.Sandbox | | (net48/net8) | +-------------------+ | +-----------------------------+-----------------------------+ | | | v v v +---------------+ +------------------+ +------------------+ | DistValidator | | ManifestValidator| | ToolWindowValidator| +---------------+ +------------------+ +------------------+ | | | | - Theme validation | - Manifest parsing | - Window instantiation | - Core window tests | - ModuleType checks | - Design-time VM binding | - Merge validation | - RibbonTool validation | - Tab interaction tests | - Binding error capture | - Assembly resolution | - Row expansion tests v v v +---------------+ +------------------+ +------------------+ | WindowGhost | | Assembly | | DbtSandboxCatalog| | Validator | | MetadataInspector| | (Discovery) | +---------------+ +------------------+ +------------------+ Source: csharp/build/BuildTargets.cs:1151-1259 Key Components DistValidator The main orchestrator that coordinates all validation steps. It: Resolves and validates the dist directory structure Ensures the validator runtime matches the dist target (net48 for Revit 2024, net8 for 2025+) Installs assembly resolvers for dist and Revit dependencies Activates sandbox mode to enable design-time ViewModels Runs theme, core window, manifest, and tool validations Source: csharp/src/DBTools.Sandbox/Validation/DistValidator.cs:15-327 Required Dist Layout The validator expects these files in the dist directory: File Purpose DBTools.Loader.dll Add-in entry point loader DBTools.dll Main merged assembly DBTools.Themes.dll Theme resource dictionaries DBTools.HandyControl.dll UI control library DBTools.ControlzEx.dll Window chrome library DBTools.Fluent.Ribbon.dll Ribbon UI library Source: csharp/src/DBTools.Sandbox/Validation/DistValidator.cs:149-167 ManifestValidator Validates that all tool manifests are correctly formed and that their referenced types exist: Loads manifest entries via DbtToolManifestLoader Verifies moduleType derives from DbtToolModule Validates commandType implements IExternalCommand Validates availabilityType implements IExternalCommandAvailability Uses metadata inspection (not runtime loading) to avoid Revit API dependencies Source: csharp/src/DBTools.Sandbox/Validation/ManifestValidator.cs:10-178 ToolWindowValidator Validates tool UI by instantiating windows with design-time ViewModels: Discovers sandbox windows via DbtSandboxCatalog Instantiates each window type and its design-time ViewModel Validates window layout via WindowGhostValidator Tests interactive behaviors: Tab cycling: Switches through all tabs in TabControl and Fluent.RibbonTabControl Row expansion: Toggles DataGrid row details visibility Preview modes: Cycles through preview modes for tools like SGT Source: csharp/src/DBTools.Sandbox/Validation/ToolWindowValidator.cs:13-412 WindowGhostValidator Performs \"ghost\" window validation by forcing layout passes without showing the window: Fixed size pass: Measures/arranges at 800x600 (typical window size) Infinite size pass: Catches controls that crash calculating \"desired\" size Content validation: Separately validates the window's content element Error localization: Walks visual tree to identify the failing element Source: csharp/src/DBTools.Sandbox/Validation/WindowGhostValidator.cs:9-129 BindingErrorListener Captures WPF data binding errors that normally fail silently: // Listens to WPF's binding trace source PresentationTraceSources.DataBindingSource.Listeners.Add(listener); PresentationTraceSources.DataBindingSource.Switch.Level = SourceLevels.Error; These silent failures are a major source of \"ghost UI\" issues - buttons that don't work, missing text, broken controls. The listener converts them into hard build failures. Source: csharp/src/DBTools.Sandbox/Validation/BindingErrorListener.cs:13-118 MergeValidator Validates the assembly merge/embedding strategy differs by target framework: net48 (ILRepack merge): Verifies sentinel types from merged assemblies exist in DBTools.dll Checks that assemblies like DynamicData.dll don't exist separately Validates internalization exclusions preserved required public types net8 (Embedded payloads): Verifies DBTools.EmbeddedAssemblies.DBTools.Core.dll resource exists Checks resource streams are loadable and have reasonable size Source: csharp/src/DBTools.Sandbox/Validation/MergeValidator.cs:17-222 Sandbox Window Configuration Tools opt into sandbox validation by adding sandboxWindows entries to their manifest.yml: # Example: csharp/src/Tools/Common/GM/manifest.yml id: DBTools.GM assembly: DBTools moduleType: DBTools.GM.GmToolModule order: 0 sandboxWindows: - id: DBTools.GM.Main displayName: \"Global Mapper\" group: \"Common\" windowType: \"DBTools.GM.Shell.UI.Views.GmWindow\" designTimeViewModelType: \"DBTools.GM.Shell.DesignTime.GmShellDesignTimeViewModel\" - id: DBTools.GM.MappingReport displayName: \"Global Mapper - Mapping Report\" group: \"Common\" windowType: \"DBTools.GM.Features.Mapping.UI.Views.GmMappingReportWindow\" designTimeViewModelType: \"DBTools.GM.Features.Mapping.DesignTime.GmMappingReportDesignTimeViewModel\" Source: csharp/src/Tools/Common/GM/manifest.yml:1-27 Required Fields Field Description id Unique identifier for the sandbox entry displayName Human-readable name shown in the sandbox gallery group Category for grouping related windows windowType Fully-qualified type name of the WPF Window designTimeViewModelType ViewModel providing mock data for validation assembly (Optional) Assembly containing the types; defaults to manifest's assembly Source: csharp/src/DBTools.Core/Tools/DbtSandboxCatalog.cs:24-46 Discovery Mechanism The DbtSandboxCatalog discovers sandbox windows by: Loading manifests embedded as resources in DBTools.dll Parsing sandboxWindows entries from each manifest Validating required fields and uniqueness of IDs Building DbtSandboxWindowSpec objects for runtime use public static IReadOnlyList<DbtSandboxWindowSpec> Discover(Assembly rootAssembly) { var entries = DbtToolManifestLoader.LoadEntries(rootAssembly); var specs = new List<DbtSandboxWindowSpec>(); foreach (var entry in entries) { foreach (var window in entry.Manifest.SandboxWindows ?? new List<>()) { // Validate and create spec... specs.Add(new DbtSandboxWindowSpec(...)); } } return specs; } Source: csharp/src/DBTools.Core/Tools/DbtSandboxCatalog.cs:8-59 SandboxMode Activation SandboxMode is a global flag that tells tool windows they're running outside Revit: namespace DBTools.Core.Compat; public static class SandboxMode { private static bool _isActive; public static bool IsActive => _isActive; public static void Activate() => _isActive = true; } Windows check this flag to: Skip Revit API calls Use design-time ViewModels Disable features requiring document context Skip UIErrorProtection.Attach in Loaded handlers Source: csharp/src/DBTools.Core/Compat/SandboxMode.cs:1-24 The SandboxModeActivator ensures the flag is set in all loaded assembly copies (handles ILMerge scenarios where multiple SandboxMode types exist): Source: csharp/src/DBTools.Sandbox/Validation/SandboxModeActivator.cs:9-119 Build Pipeline Integration The ValidateDist target in NUKE runs the validator: Target ValidateDist => _ => _ .Description(\"Validate dist outputs via DBTools.Sandbox headless runner\") .DependsOn(BuildSandbox) .After(PromoteToDist) .OnlyWhenDynamic(() => Configuration == \"Release\") .OnlyWhenDynamic(() => !SkipValidation) .Executes(() => { foreach (var year in RevitYears) { var tfm = year == 2024 ? \"net48\" : \"net8.0-windows\"; var validatorExe = ArtifactsDir / \"sandbox\" / Configuration / tfm / \"DBTools.Sandbox.exe\"; var args = new List<string> { \"--headless\", \"--dist-dir\", distDir, ValidateManifests ? \"--validate-manifests\" : \"--skip-validate-manifests\", ValidateTools ? \"--validate-tools\" : \"--skip-validate-tools\" }; // Execute with 3-minute timeout... } }); Source: csharp/build/BuildTargets.cs:1151-1259 Command-Line Options Flag Description --headless Run in validation mode (no UI) --dist-dir <path> Path to dist year folder (e.g., .artifacts/dist/Release/2026) --validate-manifests / --skip-validate-manifests Toggle manifest validation --validate-tools / --skip-validate-tools Toggle tool UI validation --screenshot --tool-id <id> --output <path> Capture tool window screenshot --list List available tool IDs for screenshot mode Source: csharp/src/DBTools.Sandbox/Validation/SandboxValidateOptions.cs:7-113 Validation Checks Summary Always Run (No Skip Flags) Check Description Dist layout Required files exist Runtime match net48 validator for 2024, net8 for 2025+ Theme validation DbtThemeValidator.ValidateOrThrow() Core windows AlertWindow, SettingsWindow, LoggerWindow Binding errors Silent WPF binding failures Merge/embed ILRepack (net48) or embedded payload (net8) With --validate-manifests Check Description Manifest parsing YAML structure, required keys ModuleType Derives from DbtToolModule RibbonTool commandType Implements IExternalCommand RibbonTool availabilityType Implements IExternalCommandAvailability With --validate-tools Check Description Window instantiation Parameterless constructor works ViewModel binding DataContext assignment succeeds Layout passes Fixed and infinite size measure/arrange Tab cycling All tabs can be selected Row expansion DataGrid row details toggle Preview modes Mode switching (e.g., SGT elevation/section/3D) Troubleshooting Validation Failures \"Window layout validation failed\" The window crashed during Measure, Arrange, or UpdateLayout. Common causes: Missing StaticResource: A resource key referenced in XAML doesn't exist in the merged resource dictionaries Constructor throws: The window constructor requires Revit context Binding converter crash: A value converter throws when given design-time data Solution: Check the exception message for the failing element name. Look for XAML bindings or resources that assume runtime context. \"WPF binding errors detected\" Silent binding failures were captured. The error message lists each failure: System.Windows.Data Error: 40 : BindingExpression path error: 'PropertyName' property not found on 'object' 'DesignTimeViewModel' Solution: Ensure design-time ViewModels expose all properties the XAML binds to. \"ILRepack merge validation failed\" Types that should have been merged exist as separate DLLs, or expected types are missing. Solution: Check csharp/build/ilrepack.txt for the merge whitelist configuration. \"Sandbox window ' ' failed to instantiate\" The window or ViewModel couldn't be created. Check: Does the window have a parameterless constructor? Does the ViewModel have a parameterless constructor? Is SandboxMode.IsActive checked before Revit API calls? Orphaned Validator Processes The build system kills orphaned DBTools.Sandbox.exe processes before validation to prevent stale state: Source: csharp/build/BuildTargets.cs:1292-1314 If validation hangs, check Task Manager for zombie sandbox processes. Related Documentation Test Pipeline - How tests use sandbox infrastructure Build Pipeline - Overall build and validation flow ILRepack & Embedding - Assembly merge strategy validated here Documentation Status: Complete Last Updated: January 2026"
  },
  "articles/architecture/test-pipeline.html": {
    "href": "articles/architecture/test-pipeline.html",
    "title": "Test Pipeline | DB Tools",
    "summary": "Test Pipeline This document describes the DBTools testing infrastructure, including test categories, execution methods, and shared test utilities. Overview DBTools uses a dual-tier testing strategy: Headless Tests - Run via dotnet test without Revit, validating build artifacts and cloud integrations Revit Integration Tests - Run inside a live Revit process using the ricaun.RevitTest adapter Source: csharp/invoke-revit-tests.sh:1-6 Test Categories Category System Tests are categorized using NUnit's [Category] attribute to enable selective execution: Category Description DA-Compatible RequiresRevitUI Needs UIApplication, UIDocument, TaskDialog, or STA thread No RequiresActiveDocument Needs an open Revit document with elements No Local Runs only in local Revit environment No Slow Takes >5 seconds, may be excluded from quick runs Yes Integration Requires external dependencies (network, cloud) Yes Source: csharp/testing/TestSupport/TestCategories.cs:14-42 DA vs Local Execution DA (Design Automation): Filter out UI-dependent tests: dotnet test --filter \"Category!=RequiresRevitUI&Category!=RequiresActiveDocument\" Local: Run all tests inside Revit Source: csharp/testing/TestSupport/TestCategories.cs:10-12 Test Project Organization Directory Structure csharp/testing/ DBTools.BuildArtifacts.Tests/ # Headless artifact validation DBTools.DA.Tests/ # Design Automation tests (cloud/headless) TestSupport/ # Shared test infrastructure GM/ # GM-specific test doubles SGT/ # SGT-specific test doubles TestHost/ # Revit host integration RevitTestModels/ # Test .rvt files by year 2024/GM/, 2024/SGT/ 2025/GM/, 2025/SGT/ 2026/GM/, 2026/SGT/ csharp/src/Tools/ Common/GM/Tests/ # GM integration tests Structural/SGT/Tests/ # SGT integration tests Testing/VTC/Tests/ # VTC tests Common/TDV/Tests/ # TDV tests Headless Test Projects DBTools.BuildArtifacts.Tests Validates build output without Revit: Assembly existence and validity per Revit year Target framework correctness (net48 for 2024, net8.0 for 2025+) Forbidden reference detection (RevitAPI, AdWindows) Namespace presence verification Embedded XAML resource validation Source: csharp/testing/DBTools.BuildArtifacts.Tests/AssemblyManifestTests.cs:14-20 Run command: dotnet test csharp/testing/DBTools.BuildArtifacts.Tests/DBTools.BuildArtifacts.Tests.csproj -c Release DBTools.DA.Tests Design Automation and APS integration tests: Links APS test files from tool directories (e.g., GM/Tests/APS/) Uses shared test utilities via <Compile Include> links Runs against Autodesk cloud services Source: csharp/testing/DBTools.DA.Tests/DBTools.DA.Tests.csproj:43-48 Run command: dotnet test csharp/testing/DBTools.DA.Tests/DBTools.DA.Tests.csproj -c Release Configuration: Uses da.runsettings for APS bucket configuration: <TestRunParameters> <Parameter name=\"APS_BUCKET\" value=\"dbtools-tests\" /> <Parameter name=\"APS_REGION\" value=\"US\" /> </TestRunParameters> Source: csharp/testing/da.runsettings:1-8 Tool-Specific Test Projects Each tool has its own test project under csharp/src/Tools/*/Tests/: Project Target Frameworks Revit Years DBTools.GM.Tests net48, net8.0-windows 2024, 2025, 2026 DBTools.SGT.Tests net48, net8.0-windows 2024, 2025, 2026 DBTools.TDV.Tests net48, net8.0-windows 2024, 2025, 2026 DBTools.VTC.Tests net48, net8.0-windows 2024, 2025, 2026 Source: csharp/src/Tools/Common/GM/Tests/DBTools.GM.Tests.csproj:4, csharp/src/Tools/Structural/SGT/Tests/DBTools.SGT.Tests.csproj:4 Key dependencies: ricaun.RevitTest.TestAdapter - Revit test execution ricaun.Revit.UI.Tasks - UI task scheduling NUnit 3 with test adapter Source: csharp/src/Tools/Common/GM/Tests/DBTools.GM.Tests.csproj:35-44 Test Runner: invoke-revit-tests.sh The primary test runner script for Revit integration tests. Prerequisites Required: gum (interactive terminal UI tool) # Install via Homebrew (macOS/Linux) brew install gum # Or Debian/Ubuntu sudo apt install gum # Or Go go install github.com/charmbracelet/gum@latest Source: csharp/invoke-revit-tests.sh:8-17 Basic Usage # Run all GM tests with smart mode (recommended) bash csharp/invoke-revit-tests.sh --smart --tool GM # Run SGT tests for Revit 2025 bash csharp/invoke-revit-tests.sh --smart --tool SGT -y 2025 # Run specific test by filter bash csharp/invoke-revit-tests.sh -f \"FullyQualifiedName~SomeTestName\" # Run specific fixture bash csharp/invoke-revit-tests.sh --smart --fixture GmAdapterTests Source: csharp/invoke-revit-tests.sh:202-204 Command-Line Options Test Execution Flag Description Default -y, --year YEAR Revit year: 2024, 2025, or 2026 2026 --debug, -d Use Debug configuration Auto-detect --release, -r Use Release configuration Auto-detect -f, --filter \"...\" VSTest filter (must include FullyQualifiedName) None -v, --verbosity N 0=quiet, 1=normal, 2=verbose 1 --timeout-minutes N Revit test timeout 4 --show-log Display DBTools log file path after completion Off Source: csharp/invoke-revit-tests.sh:130-140 Revit Instance Modes Flag Behavior --reuse Use existing Revit; fail if none running --persist Open new Revit and leave running after tests --close Open new Revit and close after tests (default) Source: csharp/invoke-revit-tests.sh:142-146 Smart Mode (Recommended) bash csharp/invoke-revit-tests.sh --smart --tool GM Smart mode auto-detects: If build changed since last test: opens fresh Revit (--persist) If build unchanged and session has Revit: reuses existing (--reuse) Source: csharp/invoke-revit-tests.sh:148-150 Tool/Fixture Shortcuts Flag Description --tool TOOL Run tests for GM, SGT, TDV, or VTC --fixture FIXTURE Run tests for specific fixture class Source: csharp/invoke-revit-tests.sh:149-150 Running Single Tests Recommended (via test runner): # Exact match bash csharp/invoke-revit-tests.sh --smart -y 2026 -f \"FullyQualifiedName=DBTools.GM.Tests.GmAdapterTests.SomeTest\" # Partial match (contains) bash csharp/invoke-revit-tests.sh --smart -f \"FullyQualifiedName~SomeTestName\" Headless projects only: dotnet test csharp/testing/DBTools.BuildArtifacts.Tests/DBTools.BuildArtifacts.Tests.csproj \\ -c Release --filter \"FullyQualifiedName~Metadata\" Source: csharp/invoke-revit-tests.sh:204, AGENTS.md Test Discovery The runner includes built-in test discovery: # List all available tests bash csharp/invoke-revit-tests.sh --discover # Rebuild test registry from source bash csharp/invoke-revit-tests.sh --discover --generate # Show test count summary bash csharp/invoke-revit-tests.sh --discover --summary # Filter by tool bash csharp/invoke-revit-tests.sh --discover --tool GM # Show only DA-compatible tests bash csharp/invoke-revit-tests.sh --discover --da-only # Show only local-only tests bash csharp/invoke-revit-tests.sh --discover --local-only Source: csharp/invoke-revit-tests.sh:171-180 Registry is stored at: .artifacts/metadata/test-registry.json Source: csharp/invoke-revit-tests.sh:647 Test History The runner tracks test execution history: # Show test run history bash csharp/invoke-revit-tests.sh --history # Show tests not run in last N days bash csharp/invoke-revit-tests.sh --show-stale 7 # Show tests that failed on last run bash csharp/invoke-revit-tests.sh --show-failed # Show error details for failed tests bash csharp/invoke-revit-tests.sh --get-errors \"GM\" Source: csharp/invoke-revit-tests.sh:183-189 History is stored at: .artifacts/test-history.json Source: csharp/invoke-revit-tests.sh:60 Parallel AI Agent Support For parallel test execution by multiple AI agents: # Agent 1 bash csharp/invoke-revit-tests.sh --smart --session agent-001 --tool GM # Agent 2 bash csharp/invoke-revit-tests.sh --smart --session agent-002 --tool SGT Each --session ID gets its own Revit instance for isolation. Source: csharp/invoke-revit-tests.sh:153-168 Session Management # List active sessions bash csharp/invoke-revit-tests.sh --sessions # Clean up stale sessions (dead Revit PIDs) bash csharp/invoke-revit-tests.sh --kill-orphans Source: csharp/invoke-revit-tests.sh:193-196 TestSupport Infrastructure Shared test utilities in csharp/testing/TestSupport/: Common Test Doubles Located in CommonTestDoubles.cs: Class Purpose RecordingNotifier Records error/success banner invocations RecordingOverlay Records progress overlay method calls InlineExecutor Runs actions inline (no async dispatch) InlineTransactionRunner Executes without Revit transactions InlineTransactionGroupService Executes without transaction groups Source: csharp/testing/TestSupport/CommonTestDoubles.cs:15-339 Test Host Integration RevitHost (TestHost/RevitHost.cs): Manages Revit context for async test execution Handles inline vs queued execution modes Integrates with RevitTestTaskBinder Source: csharp/testing/TestSupport/TestHost/RevitHost.cs:12-109 RevitAmbientScope (TestHost/RevitAmbientScope.cs): Provides ambient UIApplication access during tests Test Path Resolution TestPathResolver (TestPathResolver.cs): Resolves test model paths from dbtools.testparams.json Located at %APPDATA%/DBTools/dbtools.testparams.json Written by invoke-revit-tests.sh before test execution // Get model path var path = TestPathResolver.ResolveTestModelPath(\"2026\", \"GM\", \"gm_test_model.rvt\"); Source: csharp/testing/TestSupport/TestPathResolver.cs:10-65 Test Logging TestLoggingBridge (TestLoggingBridge.cs): Centralizes test logging setup Bridges to production logging when Revit is running Falls back to console mirroring in standalone mode [OneTimeSetUp] public void GlobalSetup() { TestLoggingBridge.Initialize(); } [OneTimeTearDown] public void GlobalTeardown() { TestLoggingBridge.Shutdown(); } Source: csharp/testing/TestSupport/TestLoggingBridge.cs:14-143 Tool-Specific Test Doubles GM (TestSupport/GM/): GmTestDataBuilder - Builds test data for GM GmRealisticTestDoubles - Production-like test doubles GmShellViewModelTestFactory - Creates shell ViewModels for testing SGT (TestSupport/SGT/): SgtTestDataBuilder - Builds test data for SGT SgtRealisticTestDoubles - Production-like test doubles InMemorySgtUiStateStore - In-memory UI state store Test Fixture Base Classes GmTestFixture Base class for GM integration tests: [NonParallelizable] public abstract class GmTestFixture { protected UIApplication UiApp { get; private set; } protected Document? Doc { get; private set; } protected IRevitCallGate? Gate { get; private set; } protected ITransactionRunner? TxRunner { get; private set; } [OneTimeSetUp] public virtual void GlobalSetup(UIApplication app) { // Opens gm_test_model.rvt // Initializes call gate and transaction runner } } Features: Opens tool-specific test model automatically Provides ResolveTypeIds(), ResolveStyleIds(), ResolveMaterialIds() helpers Manages document lifecycle Source: csharp/src/Tools/Common/GM/Tests/GMTestFixture.cs:14-128 Test Models Located in csharp/testing/RevitTestModels/: RevitTestModels/ model_info.txt 2024/ GM/gm_test_model.rvt SGT/sgt_test_model.rvt SGT/_LinkedModels/sgt_test_linked_model.rvt 2025/ GM/gm_test_model.rvt SGT/sgt_test_model.rvt SGT/_LinkedModels/sgt_test_linked_model.rvt 2026/ GM/gm_test_model.rvt SGT/sgt_test_model.rvt SGT/_LinkedModels/sgt_test_linked_model.rvt Each year has its own model versions for forward compatibility testing. Configuration Files .runsettings Revit Tests: Generated at runtime by invoke-revit-tests.sh: <RunSettings> <NUnit> <Version>2026</Version> <Language>ENU</Language> <Open>true</Open> <Close>false</Close> <Verbosity>2</Verbosity> <Timeout>4</Timeout> </NUnit> </RunSettings> Source: csharp/invoke-revit-tests.sh:1425-1442 DA Tests: csharp/testing/da.runsettings for APS configuration. Source: csharp/testing/da.runsettings:1-8 Test Parameters (dbtools.testparams.json) Written to %APPDATA%/DBTools/instances/<worktree-id>/dbtools.testparams.json: { \"ModelsDirectory\": \"C:\\\\...\\\\csharp\\\\testing\\\\RevitTestModels\", \"Year\": 2026 } Source: csharp/invoke-revit-tests.sh:1446-1451 Build Integration Tests depend on artifacts from build.sh: # Build all (required before running tests) bash csharp/build.sh BuildAll # Build tests specifically bash csharp/build.sh BuildTests The test runner validates artifact freshness: Checks .artifacts/metadata/build.json for source fingerprint Fails if artifacts are stale relative to source Source: csharp/invoke-revit-tests.sh:1201-1363 Guardrails (from AGENTS.md) Prime Directive When a test fails, investigate and fix PRODUCTION CODE first. Do not change tests or infrastructure to simulate missing production behavior. Forbidden Test Patterns Use test doubles only for TRUE externals (Revit API, filesystem, network) Never mock your own services/orchestrators Never assert only that mocks were called Every test must assert at least one real outcome Legitimate vs Illegitimate Stubbing Legitimate (external): Revit API File system Network Time/Random Illegitimate (your code): Your own services Orchestrators/handlers Anything in src/ you wrote Quick Reference Task Command Run GM tests (smart mode) bash csharp/invoke-revit-tests.sh --smart --tool GM Run SGT tests for 2025 bash csharp/invoke-revit-tests.sh --smart --tool SGT -y 2025 Run single test bash csharp/invoke-revit-tests.sh --smart -f \"FullyQualifiedName~TestName\" Run headless artifact tests dotnet test csharp/testing/DBTools.BuildArtifacts.Tests/ -c Release Run DA tests dotnet test csharp/testing/DBTools.DA.Tests/ -c Release List all tests bash csharp/invoke-revit-tests.sh --discover Show failed tests bash csharp/invoke-revit-tests.sh --show-failed Build before tests bash csharp/build.sh BuildAll Related Documentation Build Pipeline - Build system and artifact generation Architecture Overview - High-level system architecture Project References - Project structure and dependencies Verification Status Check Status Source anchors for all claims Yes UNVERIFIED markers where needed No (all verified) Cross-references added Yes Examples tested N/A No assumptions without evidence Yes Verified by: docs-run-20260124-020412 Date: 2026-01-24"
  },
  "articles/architecture/theme-system.html": {
    "href": "articles/architecture/theme-system.html",
    "title": "Theme System | DB Tools",
    "summary": "Theme System DBTools implements a comprehensive WPF theming system that provides a cohesive dark theme across all windows and controls. The system is designed to work within Revit's add-in environment while avoiding conflicts with other add-ins. Architecture Overview +-----------------------------------------------------------------------------------+ | DBTools Theme Stack | +-----------------------------------------------------------------------------------+ | | | +-------------------+ +--------------------+ +------------------------+ | | | DBTools.Themes | | Vendored Libraries | | DBTools.Core | | | | (Resources) | | (UI Frameworks) | | (Theme Loading) | | | +-------------------+ +--------------------+ +------------------------+ | | | | | | | v v v | | +----------------+ +---------------------+ +------------------------+ | | | App.Theme.xaml | --> | DBTools.HandyControl| --> | DbtWindowInitHelper | | | | (Root Dict) | | DBTools.Fluent.Ribbon| | DbtThemeValidator | | | +----------------+ | DBTools.ControlzEx | +------------------------+ | | | +---------------------+ | | v | | +---------------------------+ | | | Merged Dictionaries | | | | - App.Tokens.xaml | | | | - App.Brushes.xaml | | | | - App.Controls.Base.xaml | | | | - App.DataGrid.xaml | | | | - App.Menus.xaml | | | | - App.Components.xaml | | | | - App.FluentRibbon.xaml | | | +---------------------------+ | +-----------------------------------------------------------------------------------+ Source: csharp/src/DBTools.Themes/Themes/App.Theme.xaml:1-21 Project Structure The DBTools.Themes project contains all theme resources and references vendored UI libraries: DBTools.Themes/ +-- DBTools.Themes.csproj # Project configuration with vendored refs +-- BrushKeys.cs # ComponentResourceKey definitions +-- Assets/ | +-- db_tools_icon.png # Window icon +-- Themes/ +-- App.Theme.xaml # Root theme dictionary +-- App.Tokens.xaml # Spacing, sizing, typography tokens +-- App.Brushes.xaml # Color/brush definitions +-- App.Converters.xaml # Value converters +-- App.Controls.Base.xaml # Basic control styles +-- App.DataGrid.xaml # DataGrid-specific styles +-- App.Menus.xaml # Menu/ContextMenu styles +-- App.Components.xaml # Composite component styles +-- App.FluentRibbon.xaml # Fluent.Ribbon theme bridge Source: csharp/src/DBTools.Themes/DBTools.Themes.csproj:1-72 Vendored UI Libraries DBTools uses renamed/vendored copies of third-party UI libraries to avoid assembly conflicts with other Revit add-ins (especially pyRevit): Library Vendored Name Purpose HandyControl DBTools.HandyControl Base theme framework Fluent.Ribbon DBTools.Fluent.Ribbon Ribbon window/controls ControlzEx DBTools.ControlzEx Window chrome behaviors Source: csharp/src/DBTools.Themes/DBTools.Themes.csproj:54-71 Why Vendored Libraries? WPF theme assemblies cannot be ILRepack-merged or embedded as resources because they require Assembly.Location for pack:// URI resolution. The vendoring process: Clones upstream repos to vendor/ Renames assembly names and updates pack URIs Builds renamed assemblies to csharp/.artifacts/vendor/ Deploys alongside DBTools.dll Source: csharp/build-vendored-deps.sh:1-446 Theme Loading Mechanism Window-Scoped Theming DBTools applies themes at the window level (not application level) because Revit's Application.Resources are shared across all add-ins. This prevents theme pollution between add-ins. public static void EnsureWindowScopedTheme(Window window) { WpfUiThread.EnsurePackUriSupport(); if (!ResourceDictionaryHelper.HasSource(window.Resources, ThemeSource)) { window.Resources.MergedDictionaries.Add(new ResourceDictionary { Source = new Uri(ThemeSource, UriKind.Absolute) }); } DbtThemeValidator.FreezeFreezablesOrThrow(window.Resources); } Source: csharp/src/DBTools.Core/UI/Windows/DbtWindowInitHelper.cs:91-108 Theme Initialization Flow Window Constructor: DbtWindowInitHelper.Initialize() is called Pack URI Support: WpfUiThread.EnsurePackUriSupport() ensures pack:// scheme is registered Dictionary Merge: App.Theme.xaml is merged into Window.Resources Resource Freeze: All freezable resources are frozen to prevent runtime leaks Validation: Theme contract is validated (dictionary order, completeness) Source: csharp/src/DBTools.Core/UI/Windows/DbtWindowInitHelper.cs:44-78 Theme Opt-Out Windows can opt out of DBTools theming via IThemeOptOut: public interface IThemeOptOut { bool UseDefaultTheme { get; set; } } Source: csharp/src/DBTools.Core/UI/Windows/DbtWindowBase.cs:13-21 ResourceDictionary Structure Root Theme Dictionary App.Theme.xaml is the root dictionary that merges all theme components: <ResourceDictionary xmlns=\"http://schemas.microsoft.com/winfx/2006/xaml/presentation\"> <ResourceDictionary.MergedDictionaries> <!-- HandyControl Foundation --> <ResourceDictionary Source=\"pack://application:,,,/DBTools.HandyControl;component/Themes/SkinDark.xaml\"/> <ResourceDictionary Source=\"pack://application:,,,/DBTools.HandyControl;component/Themes/Theme.xaml\"/> <!-- Fluent.Ribbon for ribbon windows --> <ResourceDictionary Source=\"pack://application:,,,/DBTools.Fluent.Ribbon;component/Themes/Generic.xaml\"/> <!-- DBTools Custom Themes --> <ResourceDictionary Source=\"App.Tokens.xaml\"/> <ResourceDictionary Source=\"App.Brushes.xaml\"/> <ResourceDictionary Source=\"App.Converters.xaml\"/> <ResourceDictionary Source=\"App.Controls.Base.xaml\"/> <ResourceDictionary Source=\"App.DataGrid.xaml\"/> <ResourceDictionary Source=\"App.Menus.xaml\"/> <ResourceDictionary Source=\"App.Components.xaml\"/> <ResourceDictionary Source=\"App.FluentRibbon.xaml\"/> </ResourceDictionary.MergedDictionaries> </ResourceDictionary> Source: csharp/src/DBTools.Themes/Themes/App.Theme.xaml:1-21 Dictionary Order Contract The merged dictionary order is locked and validated at runtime: private static readonly IReadOnlyList<string> ExpectedMergedDictionarySources = new[] { \"pack://application:,,,/DBTools.HandyControl;component/Themes/SkinDark.xaml\", \"pack://application:,,,/DBTools.HandyControl;component/Themes/Theme.xaml\", \"pack://application:,,,/DBTools.Fluent.Ribbon;component/Themes/Generic.xaml\", \"pack://application:,,,/DBTools.Themes;component/Themes/App.Tokens.xaml\", \"pack://application:,,,/DBTools.Themes;component/Themes/App.Brushes.xaml\", // ... additional dictionaries }; Source: csharp/src/DBTools.Core/UI/Theming/DbtThemeValidator.cs:20-33 Design Tokens Spacing Tokens Standard spacing values for consistent layouts: <Thickness x:Key=\"Spacing4\">4</Thickness> <Thickness x:Key=\"Spacing8\">8</Thickness> <Thickness x:Key=\"Spacing12\">12</Thickness> <Thickness x:Key=\"Spacing16\">16</Thickness> <Thickness x:Key=\"Spacing32\">32</Thickness> <!-- Scalar variants for non-Thickness contexts --> <sys:Double x:Key=\"Spacing8.Value\">8</sys:Double> Source: csharp/src/DBTools.Themes/Themes/App.Tokens.xaml:5-18 Typography Tokens <sys:Double x:Key=\"FontSize.Caption\">11</sys:Double> <sys:Double x:Key=\"FontSize.Body.Small\">12</sys:Double> <sys:Double x:Key=\"FontSize.Body\">13</sys:Double> <sys:Double x:Key=\"FontSize.Subtitle\">14</sys:Double> <sys:Double x:Key=\"FontSize.Title\">16</sys:Double> <sys:Double x:Key=\"FontSize.Header\">20</sys:Double> Source: csharp/src/DBTools.Themes/Themes/App.Tokens.xaml:66-72 Corner Radius Tokens <CornerRadius x:Key=\"Radius4\">4</CornerRadius> <CornerRadius x:Key=\"Radius6\">6</CornerRadius> <CornerRadius x:Key=\"Radius8\">8</CornerRadius> <CornerRadius x:Key=\"Radius12\">12</CornerRadius> Source: csharp/src/DBTools.Themes/Themes/App.Tokens.xaml:43-46 Color System BrushKeys (ComponentResourceKeys) All brushes are defined using ComponentResourceKey to enable reliable cross-template resolution: public static class BrushKeys { public static ComponentResourceKey Primary => new(typeof(BrushKeys), \"Brush.Primary\"); public static ComponentResourceKey PrimaryLight => new(typeof(BrushKeys), \"Brush.PrimaryLight\"); public static ComponentResourceKey Paper => new(typeof(BrushKeys), \"Brush.Paper\"); public static ComponentResourceKey Surface => new(typeof(BrushKeys), \"Brush.Surface\"); public static ComponentResourceKey Body => new(typeof(BrushKeys), \"Brush.Body\"); // ... 130+ additional keys } Source: csharp/src/DBTools.Themes/BrushKeys.cs:1-139 Brand Colors DBTools uses a blue/gold brand palette: <!-- Core Brand Colors --> <SolidColorBrush x:Key=\"{x:Static theme:BrushKeys.Primary}\" Color=\"#FF1946B9\"/> <SolidColorBrush x:Key=\"{x:Static theme:BrushKeys.PrimaryLight}\" Color=\"#FF3D6AD4\"/> <SolidColorBrush x:Key=\"{x:Static theme:BrushKeys.Secondary}\" Color=\"#FFFEC425\"/> <SolidColorBrush x:Key=\"{x:Static theme:BrushKeys.SecondaryLight}\" Color=\"#FFFFD54F\"/> Source: csharp/src/DBTools.Themes/Themes/App.Brushes.xaml:14-19 Surface Colors Dark theme surfaces with subtle differentiation: <SolidColorBrush x:Key=\"{x:Static theme:BrushKeys.Paper}\" Color=\"#FF181820\"/> <SolidColorBrush x:Key=\"{x:Static theme:BrushKeys.Surface}\" Color=\"#FF222228\"/> <SolidColorBrush x:Key=\"{x:Static theme:BrushKeys.SurfaceAlt}\" Color=\"#FF1C1C22\"/> <SolidColorBrush x:Key=\"{x:Static theme:BrushKeys.CardSurface}\" Color=\"#FF1E1E24\"/> Source: csharp/src/DBTools.Themes/Themes/App.Brushes.xaml:24-30 Text Colors (WCAG Compliant) Text colors maintain minimum 4.5:1 contrast ratio for accessibility: <!-- WCAG AA compliant - min 4.5:1 contrast ratio on dark backgrounds --> <SolidColorBrush x:Key=\"{x:Static theme:BrushKeys.Body}\" Color=\"#FFE6E6E6\"/> <SolidColorBrush x:Key=\"{x:Static theme:BrushKeys.BodyLight}\" Color=\"#FFBDBDBD\"/> <SolidColorBrush x:Key=\"{x:Static theme:BrushKeys.TextMuted}\" Color=\"#FF999999\"/> Source: csharp/src/DBTools.Themes/Themes/App.Brushes.xaml:35-40 Status Colors Semantic colors for success, warning, error, and info states: <SolidColorBrush x:Key=\"{x:Static theme:BrushKeys.Success}\" Color=\"#FF4CAF50\"/> <SolidColorBrush x:Key=\"{x:Static theme:BrushKeys.Warning}\" Color=\"#FFFFA000\"/> <SolidColorBrush x:Key=\"{x:Static theme:BrushKeys.Error}\" Color=\"#FFCF6679\"/> <SolidColorBrush x:Key=\"{x:Static theme:BrushKeys.Info}\" Color=\"#FF1946B9\"/> Source: csharp/src/DBTools.Themes/Themes/App.Brushes.xaml:84-95 Window Base Classes DbtWindowBase Standard modal window with theme and progress overlay support: public class DbtWindowBase : Window, IWindowWithOwnerProvider, IThemeOptOut { public DbtWindowBase() { DbtWindowInitHelper.Initialize(this, nameof(DbtWindowBase)); } } Source: csharp/src/DBTools.Core/UI/Windows/DbtWindowBase.cs:27-32 The XAML style applies default theme properties and progress overlay: <Style TargetType=\"{x:Type core:DbtWindowBase}\" BasedOn=\"{StaticResource {x:Type Window}}\"> <Setter Property=\"Icon\" Value=\"pack://application:,,,/DBTools.Themes;component/Assets/db_tools_icon.png\"/> <Setter Property=\"Background\" Value=\"{DynamicResource {x:Static theme:BrushKeys.Paper}}\"/> <Setter Property=\"Foreground\" Value=\"{DynamicResource {x:Static theme:BrushKeys.Body}}\"/> <Setter Property=\"ContentTemplate\"> <Setter.Value> <DataTemplate> <Grid> <ContentPresenter/> <Border Panel.ZIndex=\"1000\" ...> <progress:ProgressOverlayControl .../> </Border> </Grid> </DataTemplate> </Setter.Value> </Setter> </Style> Source: csharp/src/DBTools.Themes/Themes/App.Controls.Base.xaml:13-33 DbtRibbonWindowBase Ribbon window for tool UIs with tab-based navigation: public class DbtRibbonWindowBase : RibbonWindow, IWindowWithOwnerProvider, IThemeOptOut { public DbtRibbonWindowBase() { DbtWindowInitHelper.Initialize(this, nameof(DbtRibbonWindowBase)); } } Source: csharp/src/DBTools.Core/UI/Windows/DbtRibbonWindowBase.cs:15-19 Fluent.Ribbon Theme Bridge App.FluentRibbon.xaml maps all 196+ Fluent.Ribbon internal brush keys to DBTools theme colors: <!-- Window Chrome --> <SolidColorBrush x:Key=\"Fluent.Ribbon.Brushes.RibbonWindow.Background\" Color=\"{Binding Source={StaticResource {x:Static theme:BrushKeys.Paper}}, Path=Color}\"/> <!-- Tab Control --> <SolidColorBrush x:Key=\"Fluent.Ribbon.Brushes.RibbonTabItem.Selected.Background\" Color=\"{Binding Source={StaticResource {x:Static theme:BrushKeys.SelectionGoldStrong}}, Path=Color}\"/> <!-- Buttons --> <SolidColorBrush x:Key=\"Fluent.Ribbon.Brushes.Button.MouseOver.Background\" Color=\"{Binding Source={StaticResource {x:Static theme:BrushKeys.Hover}}, Path=Color}\"/> Source: csharp/src/DBTools.Themes/Themes/App.FluentRibbon.xaml:24-211 TransitioningControl Hotfix A style override prevents animation failures during tab switching: <Style TargetType=\"{x:Type fluent:TransitioningControl}\"> <Setter Property=\"Template\"> <Setter.Value> <ControlTemplate TargetType=\"{x:Type fluent:TransitioningControl}\"> <Border ...> <Grid> <ContentPresenter x:Name=\"PART_CurrentContent\" .../> <ContentPresenter x:Name=\"PART_PreviousContent\" .../> </Grid> </Border> </ControlTemplate> </Setter.Value> </Setter> </Style> Source: csharp/src/DBTools.Themes/Themes/App.FluentRibbon.xaml:53-97 Control Styles Standard Controls Implicit styles override WPF defaults with theme colors: <Style TargetType=\"Button\" BasedOn=\"{StaticResource {x:Type Button}}\"> <Setter Property=\"MinWidth\" Value=\"88\"/> <Setter Property=\"MinHeight\" Value=\"36\"/> <Setter Property=\"Background\" Value=\"{DynamicResource {x:Static theme:BrushKeys.Surface}}\"/> <Setter Property=\"Foreground\" Value=\"{DynamicResource {x:Static theme:BrushKeys.Body}}\"/> <Setter Property=\"BorderBrush\" Value=\"{DynamicResource {x:Static theme:BrushKeys.Divider}}\"/> <Style.Triggers> <Trigger Property=\"IsMouseOver\" Value=\"True\"> <Setter Property=\"Background\" Value=\"{DynamicResource {x:Static theme:BrushKeys.SecondaryHover}}\"/> </Trigger> </Style.Triggers> </Style> Source: csharp/src/DBTools.Themes/Themes/App.Controls.Base.xaml:73-92 DataGrid Styles Custom DataGrid with accent stripe and enhanced selection: <Style TargetType=\"DataGridRow\" BasedOn=\"{StaticResource {x:Type DataGridRow}}\"> <Setter Property=\"Template\"> <Setter.Value> <ControlTemplate TargetType=\"DataGridRow\"> <Border x:Name=\"DGR_Border\" ...> <Grid> <Grid.ColumnDefinitions> <ColumnDefinition Width=\"3\"/> <!-- Accent stripe --> <ColumnDefinition Width=\"*\"/> </Grid.ColumnDefinitions> <Border x:Name=\"AccentStripe\" Grid.Column=\"0\" Background=\"Transparent\"/> <SelectiveScrollingGrid Grid.Column=\"1\"> <!-- Row content --> </SelectiveScrollingGrid> </Grid> </Border> <ControlTemplate.Triggers> <Trigger Property=\"IsSelected\" Value=\"True\"> <Setter TargetName=\"AccentStripe\" Property=\"Background\" Value=\"{DynamicResource {x:Static theme:BrushKeys.DataGridAccentStripe}}\"/> </Trigger> </ControlTemplate.Triggers> </ControlTemplate> </Setter.Value> </Setter> </Style> Source: csharp/src/DBTools.Themes/Themes/App.DataGrid.xaml:24-101 Menu Styles Full custom templates avoid Revit add-in styling conflicts: <Style x:Key=\"ContextMenu\" TargetType=\"ContextMenu\"> <Setter Property=\"Background\" Value=\"{DynamicResource {x:Static theme:BrushKeys.Surface}}\"/> <Setter Property=\"BorderBrush\" Value=\"{DynamicResource {x:Static theme:BrushKeys.Divider}}\"/> <Setter Property=\"Template\"> <Setter.Value> <ControlTemplate TargetType=\"ContextMenu\"> <Border Background=\"{TemplateBinding Background}\" CornerRadius=\"4\" SnapsToDevicePixels=\"True\"> <Border.Effect> <DropShadowEffect BlurRadius=\"8\" ShadowDepth=\"2\" Opacity=\"0.35\"/> </Border.Effect> <ScrollViewer> <ItemsPresenter/> </ScrollViewer> </Border> </ControlTemplate> </Setter.Value> </Setter> </Style> Source: csharp/src/DBTools.Themes/Themes/App.Menus.xaml:9-42 Component Styles Cards Elevated card surfaces with shadows: <Style x:Key=\"Card\" TargetType=\"Border\"> <Setter Property=\"Background\" Value=\"{DynamicResource {x:Static theme:BrushKeys.CardSurface}}\"/> <Setter Property=\"BorderBrush\" Value=\"{DynamicResource {x:Static theme:BrushKeys.CardBorder}}\"/> <Setter Property=\"CornerRadius\" Value=\"{DynamicResource Radius8}\"/> <Setter Property=\"Padding\" Value=\"{DynamicResource Card.Padding}\"/> </Style> <Style x:Key=\"Card.Elevated\" TargetType=\"Border\" BasedOn=\"{StaticResource Card}\"> <Setter Property=\"Effect\"> <Setter.Value> <DropShadowEffect BlurRadius=\"18\" ShadowDepth=\"4\" Opacity=\"0.35\"/> </Setter.Value> </Setter> </Style> Source: csharp/src/DBTools.Themes/Themes/App.Components.xaml:205-225 Toolbar Chips Toggle buttons styled as filter chips: <Style x:Key=\"ToolbarChip\" TargetType=\"ToggleButton\"> <Setter Property=\"Background\" Value=\"{DynamicResource {x:Static theme:BrushKeys.ToolbarChipBackground}}\"/> <Setter Property=\"Template\"> <Setter.Value> <ControlTemplate TargetType=\"ToggleButton\"> <Border x:Name=\"Chip\" CornerRadius=\"{DynamicResource Radius6}\" ...> <ContentPresenter/> </Border> <ControlTemplate.Triggers> <Trigger Property=\"IsChecked\" Value=\"True\"> <Setter TargetName=\"Chip\" Property=\"Background\" Value=\"{DynamicResource {x:Static theme:BrushKeys.ToolbarChipSelected}}\"/> </Trigger> </ControlTemplate.Triggers> </ControlTemplate> </Setter.Value> </Setter> </Style> Source: csharp/src/DBTools.Themes/Themes/App.Components.xaml:29-91 Theme Validation Startup Validation DbtThemeValidator.ValidateOrThrow() performs comprehensive theme validation: Incremental Merge Test: Merges each dictionary one-by-one to pinpoint failures Freezable Freeze: Freezes all brushes to prevent runtime leaks Contract Assertion: Validates merged dictionary order matches expected Ghost Validation: Creates invisible control tree to force template evaluation public static void ValidateOrThrow() { WpfUiThread.EnsurePackUriSupport(); // Incremental merge to pinpoint first broken dictionary var scratch = new ResourceDictionary(); foreach (var source in ExpectedMergedDictionarySources) { scratch.MergedDictionaries.Add(new ResourceDictionary { Source = new Uri(source, UriKind.Absolute) }); } FreezeFreezablesOrThrow(scratch); AssertMergedDictionariesContract(themeRoot); GhostValidate(themeRoot); } Source: csharp/src/DBTools.Core/UI/Theming/DbtThemeValidator.cs:52-92 Ghost Validation Creates an invisible visual tree to force template instantiation and catch deferred failures: private static void GhostValidate(ResourceDictionary themeRoot) { var root = new Grid { Width = 800, Height = 600 }; root.Resources.MergedDictionaries.Add(themeRoot); root.Children.Add(BuildProbeContent(root)); root.Measure(new Size(root.Width, root.Height)); root.Arrange(new Rect(0, 0, root.Width, root.Height)); root.UpdateLayout(); } Source: csharp/src/DBTools.Core/UI/Theming/DbtThemeValidator.cs:229-248 Using the Theme In XAML Reference brushes via DynamicResource and BrushKeys: <Window xmlns:theme=\"clr-namespace:DBTools.Themes;assembly=DBTools.Themes\"> <Border Background=\"{DynamicResource {x:Static theme:BrushKeys.Surface}}\"> <TextBlock Text=\"Hello\" Foreground=\"{DynamicResource {x:Static theme:BrushKeys.Body}}\"/> </Border> </Window> In Code Use SetResourceReference for dynamic binding: window.SetResourceReference(Window.BackgroundProperty, BrushKeys.Paper); window.SetResourceReference(Window.ForegroundProperty, BrushKeys.Body); Source: csharp/src/DBTools.Core/UI/Windows/DbtWindowInitHelper.cs:151-155 Extending the Theme Adding New Brushes Add ComponentResourceKey property in BrushKeys.cs: public static ComponentResourceKey MyNewBrush => new(typeof(BrushKeys), \"Brush.MyNew\"); Add brush definition in App.Brushes.xaml: <SolidColorBrush x:Key=\"{x:Static theme:BrushKeys.MyNewBrush}\" Color=\"#FF123456\"/> Adding New Styles Create new keyed style in appropriate dictionary: <Style x:Key=\"MyCustomButton\" TargetType=\"Button\" BasedOn=\"{StaticResource {x:Type Button}}\"> <Setter Property=\"Background\" Value=\"{DynamicResource {x:Static theme:BrushKeys.Primary}}\"/> </Style> For implicit styles, omit the x:Key: <Style TargetType=\"MyCustomControl\"> <Setter Property=\"Background\" Value=\"{DynamicResource {x:Static theme:BrushKeys.Surface}}\"/> </Style> XAML Resource File Types Some XAML files reference DBTools.Core types and cannot be compiled as BAML: <!-- These files are raw resources, not compiled BAML --> <Page Remove=\"Themes\\App.Converters.xaml\"/> <Page Remove=\"Themes\\App.Controls.Base.xaml\"/> <Page Remove=\"Themes\\App.Components.xaml\"/> <Resource Include=\"Themes\\App.Converters.xaml\"/> <Resource Include=\"Themes\\App.Controls.Base.xaml\"/> <Resource Include=\"Themes\\App.Components.xaml\"/> Source: csharp/src/DBTools.Themes/DBTools.Themes.csproj:38-46 Related Documentation Architecture Overview - High-level system architecture Project References - Project dependency graph Files Reviewed File Purpose csharp/src/DBTools.Themes/DBTools.Themes.csproj Project configuration csharp/src/DBTools.Themes/BrushKeys.cs ComponentResourceKey definitions csharp/src/DBTools.Themes/Themes/App.Theme.xaml Root theme dictionary csharp/src/DBTools.Themes/Themes/App.Tokens.xaml Design tokens csharp/src/DBTools.Themes/Themes/App.Brushes.xaml Color definitions csharp/src/DBTools.Themes/Themes/App.Controls.Base.xaml Base control styles csharp/src/DBTools.Themes/Themes/App.DataGrid.xaml DataGrid styles csharp/src/DBTools.Themes/Themes/App.Menus.xaml Menu styles csharp/src/DBTools.Themes/Themes/App.Components.xaml Component styles csharp/src/DBTools.Themes/Themes/App.FluentRibbon.xaml Fluent.Ribbon bridge csharp/src/DBTools.Themes/Themes/App.Converters.xaml Value converters csharp/src/DBTools.Core/UI/Theming/DbtThemeValidator.cs Theme validation csharp/src/DBTools.Core/UI/Windows/DbtWindowBase.cs Window base class csharp/src/DBTools.Core/UI/Windows/DbtRibbonWindowBase.cs Ribbon window base csharp/src/DBTools.Core/UI/Windows/DbtWindowInitHelper.cs Theme loading logic csharp/src/DBTools.Core/UI/Windows/ResourceDictionaryHelper.cs Dictionary utilities csharp/build-vendored-deps.sh Vendored library build script"
  },
  "articles/developing/modularity.html": {
    "href": "articles/developing/modularity.html",
    "title": "Leveraging DBTools Modularity | DB Tools",
    "summary": "Leveraging DBTools Modularity DBTools is designed as a modular Revit add-in platform where tools share common infrastructure while maintaining clear boundaries. This guide explains how to leverage the shared services from DBTools.Core and DBTools.Themes to build tools that integrate seamlessly with the platform. Philosophy DBTools follows these modularity principles: Shared Infrastructure, Independent Tools - Core services are centralized; tools are self-contained Dependency Injection First - All services are resolved through DI, enabling testing and flexibility Contract-Driven - Interfaces define contracts; implementations can vary per context Error Handling at Boundaries - All entrypoints run inside ISafeExecutor Window-Scoped Theming - Each window owns its theme resources to avoid cross-add-in conflicts Source: csharp/src/DBTools.App/Bootstrap/DbtServiceBootstrapper.cs:69-130 Two-Tier DI Architecture DBTools uses a two-tier dependency injection model: Tier Lifetime Purpose Examples Singleton Application lifetime Infrastructure services ISafeExecutor, IAlertService, ISettingsProvider, DbtToolRegistry Scoped Per-command lifetime Revit context services ITransactionRunner, IRevitCallGate, IRevitRunScope Source: csharp/src/DBTools.App/Bootstrap/DbtServiceBootstrapper.cs:77-79 Shared Services from DBTools.Core ISafeExecutor The central error handling service. All tool entrypoints must execute within ISafeExecutor. public interface ISafeExecutor { Task RunAsync(Func<Task> action, ILogger logger, IErrorNotifier? notifier = null, CancellationToken ct = default); Task RunAsync(Func<Task> action, ILogger logger, IErrorNotifier? notifier, SafeExecutor.SafeExecuteOptions? opts, CancellationToken ct = default); } Source: csharp/src/DBTools.Core/Execution/ISafeExecutor.cs:6-16 What it provides: Correlation IDs for log tracing Execution timing Exception logging with full stack traces and inner exceptions User notification via banners Automatic debug mode activation on fatal errors Lifecycle hooks (OnSuccessAsync, OnCancelAsync, OnErrorAsync) Source: csharp/src/DBTools.Core/Execution/SafeExecutor.cs:12-467 Usage in a command: // Commands automatically use ISafeExecutor via DbtToolCommand base class public sealed class GmCommand : DbtToolCommand { protected override async Task RunAsync(IDbtToolContext context) { var exec = context.Resolve<ISafeExecutor>(); // For nested async operations that need error handling: await exec.RunAsync(async () => { // Your work here }, context.Logger, context.ErrorNotifier); } } Source: csharp/src/Tools/Common/GM/Features/GmCommand.cs:32-93 ITransactionRunner Unified API for executing Revit model modifications with automatic transaction management. public interface ITransactionRunner { Task RunAsync(string name, Action action, CancellationToken ct = default); Task<T> RunAsync<T>(string name, Func<T> action, CancellationToken ct = default); Task RunAsync(string name, Action<Document> action, CancellationToken ct = default); Task<T> RunAsync<T>(string name, Func<Document, T> action, CancellationToken ct = default); Task RunAsync(string name, Action<UIApplication, Document> action, CancellationToken ct = default); Task<T> RunAsync<T>(string name, Func<UIApplication, Document, T> action, CancellationToken ct = default); // Overloads with explicit Document parameter Task RunAsync(Document doc, string name, Action<Document> action, CancellationToken ct = default); Task<T> RunAsync<T>(Document doc, string name, Func<Document, T> action, CancellationToken ct = default); } Source: csharp/src/DBTools.Core/Revit/Transactions/ITransactionRunner.cs:6-53 Key behaviors: Auto-selects transaction type: SubTransaction if doc.IsModifiable, otherwise new Transaction Cross-document protection Failure handling with SilentFailuresPreprocessor Usage example: public class FoundationTypeOrganizer { private readonly ITransactionRunner _tx; public FoundationTypeOrganizer(ITransactionRunner tx, Document doc, ILogger logger) { _tx = tx; // ... } public async Task OrganizeAsync() { await _tx.RunAsync(\"Organize Foundation Types\", doc => { // Modify document - transaction is automatic }); } } Source: csharp/src/Tools/Structural/OrganizeFoundationTypes/Features/FoundationTypeOrganizer.cs:19-27 ITransactionGroupService Manages transaction groups for operations requiring multiple transactions to appear as a single undo item. public interface ITransactionGroupService { bool IsActive { get; } Task BeginAsync(string name, CancellationToken ct = default); Task FinalizeAsync(bool commit, CancellationToken ct = default); Task RunAsync(string name, bool commit, Func<Task> work, CancellationToken ct = default); } Source: csharp/src/DBTools.Core/Revit/Transactions/ITransactionGroupService.cs:3-14 Usage for batch operations: public class TdvService { private readonly ITransactionRunner _tx; private readonly ITransactionGroupService _group; public TdvService(IRevitCallGate gate, ITransactionRunner tx, ITransactionGroupService group, ILogger<TdvService> logger) { _tx = tx; _group = group; // ... } public async Task ApplyMultipleChangesAsync() { await _group.RunAsync(\"Batch Apply\", commit: true, async () => { // Multiple transactions appear as one undo item await _tx.RunAsync(\"Step 1\", doc => { /* ... */ }); await _tx.RunAsync(\"Step 2\", doc => { /* ... */ }); await _tx.RunAsync(\"Step 3\", doc => { /* ... */ }); }); } } Source: csharp/src/Tools/Common/TDV/Revit/Services/TdvService.cs:20-23 IAlertService Service for showing alert dialogs with various body types. public interface IAlertService { AlertResult Show(AlertRequest request); bool Confirm(string message, string title = \"DB Tools\"); T? SelectSingle<T>(IEnumerable<T> items, Func<T, string> displayFunc, string windowTitle, string header, string? message = null, AlertWindowOptions? options = null) where T : class; IReadOnlyList<T> SelectMultiple<T>(IEnumerable<T> items, Func<T, string> displayFunc, string windowTitle, string header, string? message = null, AlertWindowOptions? options = null) where T : class; } Source: csharp/src/DBTools.Core/UI/Alerts/Services/IAlertService.cs:5-26 Usage examples: // Simple confirmation var alerts = context.Resolve<IAlertService>(); if (alerts.Confirm(\"Delete 15 elements?\", \"Confirm Delete\")) { // Proceed } // Single selection var selectedLevel = alerts.SelectSingle( levels, level => level.Name, windowTitle: \"Select Level\", header: \"Target Level\", message: \"Choose the level to place elements on\"); // Multiple selection var selectedTypes = alerts.SelectMultiple( familyTypes, t => t.Name, windowTitle: \"Select Types\", header: \"Types to Process\"); Source: csharp/src/DBTools.Core/UI/Alerts/Services/AlertService.cs:51-183 ILogger DBTools uses Microsoft.Extensions.Logging with Serilog as the provider. // Resolve from DI var logger = context.Resolve<ILogger<MyService>>(); // Or use the context's logger var logger = context.Logger; // Structured logging logger.LogInformation(\"Processing {Count} elements in {Document}\", elements.Count, doc.Title); logger.LogWarning(\"[GM] Failed to compute DocumentKey: {Message}\", ex.Message); logger.LogError(ex, \"[{Command}] execution failed.\", GetType().Name); Source: csharp/src/DBTools.App/Bootstrap/DbtServiceBootstrapper.cs:381-386 Important: Always use structured logging with named placeholders, not string interpolation. IRevitRunScope Represents a single Revit run scope (command, modeless session, or test). Provides access to the current Revit context. public interface IRevitRunScope { UIApplication UIApplication { get; } IRevitCallGate CallGate { get; } ITransactionRunner TransactionRunner { get; } ITransactionGroupService TransactionGroupService { get; } UIDocument GetActiveUiDocument(); Document GetActiveDocument(); Document GetLockedDocument(Document expectedDocument, string? context = null); } Source: csharp/src/DBTools.Core/Revit/Execution/IRevitRunScope.cs:11-20 Run Scope Profiles: Profile Use Case Description InlineUi Modal commands, RevitTest Executes directly on Revit UI thread QueuedModeless Long-running/modeless tools Uses ExternalEvent/RevitTask Source: csharp/src/DBTools.Core/Revit/Execution/IRevitRunScope.cs:22-36 ISettingsProvider / IOptionsMonitor Type-safe settings access with persistence and hot-reload support. public interface ISettingsProvider { TSettings Get<TSettings>() where TSettings : class, new(); Task SaveAsync<TSettings>(string section, TSettings settings, CancellationToken ct = default) where TSettings : class; } Source: csharp/src/DBTools.Core/Settings/ISettingsProvider.cs:1-8 Usage: // Via ISettingsProvider (singleton) var settings = context.Resolve<ISettingsProvider>(); var gmSettings = settings.Get<GmSettings>(); // Via IOptionsMonitor (for reactive updates) var monitor = context.Resolve<IOptionsMonitor<GmSettings>>(); var currentSettings = monitor.CurrentValue; Source: csharp/src/DBTools.App/Bootstrap/DiAppRuntime.cs:78 Shared UI from DBTools.Themes BrushKeys All theme brushes are defined using ComponentResourceKey for reliable cross-template resolution: public static class BrushKeys { // Brand colors public static ComponentResourceKey Primary => new(typeof(BrushKeys), \"Brush.Primary\"); public static ComponentResourceKey Secondary => new(typeof(BrushKeys), \"Brush.Secondary\"); // Surface colors public static ComponentResourceKey Paper => new(typeof(BrushKeys), \"Brush.Paper\"); public static ComponentResourceKey Surface => new(typeof(BrushKeys), \"Brush.Surface\"); public static ComponentResourceKey CardSurface => new(typeof(BrushKeys), \"Brush.CardSurface\"); // Text colors (WCAG AA compliant) public static ComponentResourceKey Body => new(typeof(BrushKeys), \"Brush.Body\"); public static ComponentResourceKey TextSecondary => new(typeof(BrushKeys), \"Brush.TextSecondary\"); public static ComponentResourceKey TextMuted => new(typeof(BrushKeys), \"Brush.TextMuted\"); // Status colors public static ComponentResourceKey Success => new(typeof(BrushKeys), \"Brush.Success\"); public static ComponentResourceKey Warning => new(typeof(BrushKeys), \"Brush.Warning\"); public static ComponentResourceKey Error => new(typeof(BrushKeys), \"Brush.Error\"); // DataGrid specific public static ComponentResourceKey DataGridRowSelected => new(typeof(BrushKeys), \"Brush.DataGrid.RowSelected\"); public static ComponentResourceKey DataGridAccentStripe => new(typeof(BrushKeys), \"Brush.DataGrid.AccentStripe\"); // ... 130+ additional keys } Source: csharp/src/DBTools.Themes/BrushKeys.cs:9-139 Usage in XAML: <Window xmlns:theme=\"clr-namespace:DBTools.Themes;assembly=DBTools.Themes\"> <Border Background=\"{DynamicResource {x:Static theme:BrushKeys.Surface}}\"> <TextBlock Text=\"Hello\" Foreground=\"{DynamicResource {x:Static theme:BrushKeys.Body}}\"/> </Border> </Window> Design Tokens Standard spacing, sizing, and typography values for consistent layouts: <!-- Spacing --> <Thickness x:Key=\"Spacing4\">4</Thickness> <Thickness x:Key=\"Spacing8\">8</Thickness> <Thickness x:Key=\"Spacing16\">16</Thickness> <!-- Padding --> <Thickness x:Key=\"Pad8\">8</Thickness> <Thickness x:Key=\"Card.Padding\">16,12</Thickness> <!-- Corner radius --> <CornerRadius x:Key=\"Radius4\">4</CornerRadius> <CornerRadius x:Key=\"Radius8\">8</CornerRadius> <!-- Typography --> <sys:Double x:Key=\"FontSize.Body\">13</sys:Double> <sys:Double x:Key=\"FontSize.Title\">16</sys:Double> <sys:Double x:Key=\"FontSize.Header\">20</sys:Double> Source: csharp/src/DBTools.Themes/Themes/App.Tokens.xaml:5-72 Window Base Classes DbtWindowBase Standard modal window with automatic theme loading and progress overlay: public class DbtWindowBase : Window, IWindowWithOwnerProvider, IThemeOptOut { public DbtWindowBase() { DbtWindowInitHelper.Initialize(this, nameof(DbtWindowBase)); } public IWindowOwnerProvider? OwnerProvider { get; set; } public bool UseDefaultTheme { get; set; } } Source: csharp/src/DBTools.Core/UI/Windows/DbtWindowBase.cs:27-47 DbtRibbonWindowBase Ribbon window for tools with tab-based navigation: public class DbtRibbonWindowBase : RibbonWindow, IWindowWithOwnerProvider, IThemeOptOut { public DbtRibbonWindowBase() { DbtWindowInitHelper.Initialize(this, nameof(DbtRibbonWindowBase)); } } Source: csharp/src/DBTools.Core/UI/Windows/DbtRibbonWindowBase.cs:15-35 What window bases provide: Window-scoped theme loading (avoids cross-add-in conflicts) Revit window ownership binding Progress overlay integration UI error protection DBTools icon Source: csharp/src/DBTools.Core/UI/Windows/DbtWindowInitHelper.cs:44-78 DI Patterns Creating a Tool Module Every tool implements DbtToolModule to register its services: public sealed class GmToolModule : DbtToolModule { public override void RegisterServices(IServiceCollection services, DbtToolManifest manifest) { Guard.NotNull(services, nameof(services)); Guard.NotNull(manifest, nameof(manifest)); services.AddGmServices(); // Extension method for cleaner registration } } Source: csharp/src/Tools/Common/GM/GmToolModule.cs:10-18 DbtToolModule Base Class public abstract class DbtToolModule { /// <summary>Registers tool settings types (Options pattern).</summary> public virtual void RegisterSettings(IServiceCollection services, IConfiguration configuration, DbtToolManifest manifest) { } /// <summary>Registers services required by this tool module.</summary> public virtual void RegisterServices(IServiceCollection services, DbtToolManifest manifest) { } /// <summary>Registers settings pack definitions for the Settings UI.</summary> public virtual void RegisterSettingsPacks(IServiceCollection services, DbtToolManifest manifest) { } /// <summary>Registers hook handlers with the tool registry.</summary> public virtual void RegisterHooks(DbtToolRegistry registry, DbtToolManifest manifest) { } } Source: csharp/src/DBTools.Core/Tools/DbtToolModule.cs:9-49 Service Registration Patterns public static class GmServiceCollectionExtensions { public static IServiceCollection AddGm(this IServiceCollection services) { // === Pure/shared logic (scoped) === services.AddScoped<IProjectLifecycleService, ProjectLifecycleService>(); services.AddScoped<INamingSimilarityService, NamingSimilarityService>(); // === Services with complex initialization === services.AddScoped<IGmMappingService>(sp => { var logger = sp.GetRequiredService<ILogger<GmMappingService>>(); var usage = sp.GetRequiredService<IUsageIndexService>(); var tx = sp.GetRequiredService<ITransactionRunner>(); // ... resolve other dependencies return new GmMappingService(logger, usage, tx, writers); }); // === Revit infrastructure (scoped) === services.AddScoped<ICategoryService, CategoryService>(); services.AddScoped<IElementQuery, ElementQueryService>(); // === UI services === services.AddScoped<IReportWindowService, ReportWindowService>(); return services; } } Source: csharp/src/Tools/Common/GM/Shell/DI/Services.cs:28-108 Resolving Services in Commands protected override async Task RunAsync(IDbtToolContext context) { // Single service var alerts = context.Resolve<IAlertService>(); // Multiple services (tuple pattern) var (tx, groups, mapping, planner, lifecycle) = context.Resolve< ITransactionRunner, ITransactionGroupService, IGmMappingService, IGmPlanningService, IProjectLifecycleService>(); } Source: csharp/src/Tools/Common/GM/Features/GmCommand.cs:59-91 Best Practices 1. Always Use ISafeExecutor at Entrypoints // DO: Inherit from DbtToolCommand (uses ISafeExecutor internally) public sealed class MyCommand : DbtToolCommand { protected override async Task RunAsync(IDbtToolContext context) { // ISafeExecutor wraps this automatically } } // DON'T: Create IExternalCommand without error handling public class BadCommand : IExternalCommand { public Result Execute(...) { // No error handling - will crash Revit } } Source: csharp/src/DBTools.Core/Revit/Execution/DbtToolCommand.cs:35-126 2. Prefer Scoped Services for Revit-Dependent Code // DO: Scoped registration for services that need Revit context services.AddScoped<ICategoryService, CategoryService>(); services.AddScoped<IElementQuery, ElementQueryService>(); // DON'T: Singleton for services that capture Document references services.AddSingleton<IBadService, ServiceThatHoldsDocument>(); // Memory leak! 3. Use Transaction Services, Not Raw Transactions // DO: Use ITransactionRunner await _tx.RunAsync(\"Create Wall\", doc => { Wall.Create(doc, curve, levelId, false); }); // DON'T: Create raw Transaction objects using var tx = new Transaction(doc, \"Create Wall\"); tx.Start(); Wall.Create(doc, curve, levelId, false); tx.Commit(); // Manual error handling required 4. Reference Theme Brushes via BrushKeys <!-- DO: Use BrushKeys for reliable resolution --> <Border Background=\"{DynamicResource {x:Static theme:BrushKeys.Surface}}\"/> <!-- DON'T: Use string keys (fragile) --> <Border Background=\"{DynamicResource Brush.Surface}\"/> 5. Inherit from Window Base Classes // DO: Inherit from DbtWindowBase public partial class MyToolWindow : DbtWindowBase { // Theme, progress overlay, error protection all included } // DON'T: Use raw Window public partial class MyToolWindow : Window { // No theme, no error protection, no Revit ownership } Anti-Patterns to Avoid 1. Service Locator Pattern // DON'T: Use AppRuntime.Resolve outside of command constructors public class BadService { public void DoWork() { var alerts = AppRuntime.Resolve<IAlertService>(); // Hidden dependency } } // DO: Inject via constructor public class GoodService { private readonly IAlertService _alerts; public GoodService(IAlertService alerts) { _alerts = alerts; } } 2. Silent Failures // DON'T: Swallow exceptions try { DoWork(); } catch { /* silent failure */ } // DON'T: Return defaults pretending success catch (Exception) { return new List<Element>(); } // DO: Let ISafeExecutor handle errors await executor.RunAsync(async () => { DoWork(); // Exception propagates to error handling }, logger, notifier); 3. Capturing Document References // DON'T: Hold Document references in singleton services public class BadService { private readonly Document _doc; // Will become stale! public BadService(Document doc) => _doc = doc; } // DO: Accept Document per-call public class GoodService { public void DoWork(Document doc) { // Fresh reference each call } } 4. Raw Console/MessageBox Output // DON'T: Use Console or MessageBox Console.WriteLine(\"Debug info\"); MessageBox.Show(\"Error occurred\"); // DO: Use logging and IAlertService _logger.LogDebug(\"Debug info\"); _alerts.Show(new AlertRequest(\"Error\", new MessageBodyViewModel(\"Error occurred\"))); 5. Bypassing Theme System // DON'T: Use hard-coded colors <Border Background=\"#222228\"/> // DO: Use theme brushes <Border Background=\"{DynamicResource {x:Static theme:BrushKeys.Surface}}\"/> Related Documentation DBTools.Core Project - Complete Core API reference Theme System - Detailed theming documentation Architecture Overview - System-wide architecture Quick Reference Table Need Service Lifetime Error handling at entrypoints ISafeExecutor Singleton Model modifications ITransactionRunner Scoped Batch undo operations ITransactionGroupService Scoped User dialogs IAlertService Singleton Logging ILogger<T> Singleton Revit context IRevitRunScope Scoped Thread-safe API access IRevitCallGate Scoped Settings access ISettingsProvider Singleton Reactive settings IOptionsMonitor<T> Singleton"
  },
  "articles/developing/new-tool-guide.html": {
    "href": "articles/developing/new-tool-guide.html",
    "title": "Creating New Tools in DBTools | DB Tools",
    "summary": "Creating New Tools in DBTools This guide covers the complete process of creating a new tool for the DBTools Revit add-in platform. By the end, you'll understand the tool module system, manifest configuration, command implementation, and UI patterns. Overview DBTools uses a manifest-driven plugin architecture. Each tool: Lives in its own folder under csharp/src/Tools/ Declares metadata via manifest.yml Implements a DbtToolModule subclass for DI registration Provides one or more DbtToolCommand implementations Optionally includes WPF UI, settings, and hooks Key architectural principle: Tool source files are file-linked into DBTools.App at build time. Individual tool .csproj files exist for IDE navigation and per-tool test projects, but the final DBTools.dll assembly contains all tool code compiled together. Source: csharp/src/DBTools.App/DBTools.App.csproj:61-78 Prerequisites Before creating a new tool: Ensure you can build the solution: bash csharp/build.sh Understand the target Revit versions (net48 for 2024, net8.0-windows for 2025+) Decide on a tool category: Common, Structural, Testing, or new category Choose a unique tool ID (e.g., DBTools.MyTool) Step 1: Directory Structure Create your tool folder under the appropriate category: csharp/src/Tools/ Common/ # General-purpose tools GM/ # Global Mapper (complex example) ElevationTags/ # Simple example Structural/ # Structural engineering tools SGT/ # Super Girt Tool (complex example) FramingJoins/ # Simple example Testing/ # Testing/debug tools Minimal Tool Structure csharp/src/Tools/<Category>/<ToolName>/ Assets/ my_tool.png # 32x32 icon for ribbon (required) my_tool_16.png # 16x16 small icon (optional) Features/ MyToolCommand.cs # IExternalCommand implementation manifest.yml # Tool metadata and ribbon config <ToolName>ToolModule.cs # DI registration DBTools.<ToolName>.csproj # Project file (for IDE/tests) Complex Tool Structure (with UI) csharp/src/Tools/<Category>/<ToolName>/ Assets/ *.png # Icons Bootstrap/ ServiceExtensions.cs # DI extension methods Features/ Commands/ MyToolCommand.cs Logic/ MyService.cs IMyService.cs Shell/ DI/ Services.cs # Detailed DI registrations DesignTime/ MyWindowDesignTimeViewModel.cs UI/ Views/ MyWindow.xaml MyWindow.xaml.cs ViewModels/ MyWindowViewModel.cs Shared/ Models/ Contracts/ Tests/ # Separate test project folder DBTools.<ToolName>.Tests.csproj Properties/ DesignTimeResources.xaml # For XAML designer manifest.yml <ToolName>ToolModule.cs DBTools.<ToolName>.csproj Source: Reference structure from csharp/src/Tools/Common/GM/ and csharp/src/Tools/Structural/SGT/ Step 2: Project File (.csproj) Create a project file for IDE support and test isolation. The project file is NOT used for the main build (files are linked into DBTools.App), but it enables: IntelliSense and navigation Per-tool test projects Design-time XAML preview Minimal Project File <Project Sdk=\"Microsoft.NET.Sdk\"> <PropertyGroup> <TargetFrameworks>$(DBT_RevitTargetFrameworks)</TargetFrameworks> <LangVersion>latest</LangVersion> <Nullable>enable</Nullable> <ImplicitUsings>enable</ImplicitUsings> <RootNamespace>DBTools.MyTool</RootNamespace> </PropertyGroup> <!-- Exclude Revit-dependent code during design-time builds --> <ItemGroup Condition=\"'$(DesignTimeBuild)'=='true' or '$(DBT_IsSandboxBuild)'=='true'\"> <Compile Remove=\"**\\Revit\\**\\*.cs\" /> </ItemGroup> <ItemGroup Condition=\"'$(DBT_IsSandboxBuild)'=='true'\"> <Compile Remove=\"Features\\MyToolCommand.cs\" /> <Compile Remove=\"MyToolToolModule.cs\" /> </ItemGroup> <ItemGroup> <Compile Remove=\"Tests\\**\\*.cs\" /> </ItemGroup> <PropertyGroup Condition=\"'$(TargetFramework)'=='net48'\"> <NoWarn>$(NoWarn);CS0618;MA0038;MA0051;MA0048;MA0016;MA0098;MA0004;CA1068;CA1707;CA1725</NoWarn> <PlatformTarget>x64</PlatformTarget> <Prefer32Bit>false</Prefer32Bit> </PropertyGroup> <PropertyGroup Condition=\"'$(TargetFramework)'=='net8.0-windows'\"> <NoWarn>$(NoWarn);CS0618;MA0038;MA0048;MA0016;MA0051;MA0098;MA0004;CA1707;CA1725;CA1068;MSB3277</NoWarn> <Nullable>enable</Nullable> <SupportedOSPlatformVersion>6.1</SupportedOSPlatformVersion> </PropertyGroup> <ItemGroup> <ProjectReference Include=\"..\\..\\..\\DBTools.Core\\DBTools.Core.csproj\" /> </ItemGroup> <!-- Embed icons --> <ItemGroup> <EmbeddedResource Include=\"Assets\\\\*.png\"> <Link>Resources\\\\Icons\\\\%(Filename)%(Extension)</Link> </EmbeddedResource> </ItemGroup> <!-- Required packages --> <ItemGroup> <PackageReference Include=\"ricaun.Revit.UI.Tasks\" /> </ItemGroup> <!-- Revit API references --> <ItemGroup Condition=\"'$(DesignTimeBuild)'!='true' and '$(DBT_IsSandboxBuild)'!='true' and '$(TargetFramework)'=='net48'\"> <Reference Include=\"RevitAPI\"> <HintPath>$(REVIT2024_DIR)\\RevitAPI.dll</HintPath> <Private>false</Private> </Reference> <Reference Include=\"RevitAPIUI\"> <HintPath>$(REVIT2024_DIR)\\RevitAPIUI.dll</HintPath> <Private>false</Private> </Reference> <Reference Include=\"WindowsBase\" /> </ItemGroup> <ItemGroup Condition=\"'$(DesignTimeBuild)'!='true' and '$(DBT_IsSandboxBuild)'!='true' and '$(TargetFramework)'=='net8.0-windows'\"> <Reference Include=\"RevitAPI\" Condition=\"'$(REVIT_NET8_DIR)'!='' and Exists('$(REVIT_NET8_DIR)\\\\RevitAPI.dll')\"> <HintPath>$(REVIT_NET8_DIR)\\RevitAPI.dll</HintPath> <Private>false</Private> </Reference> <Reference Include=\"RevitAPIUI\" Condition=\"'$(REVIT_NET8_DIR)'!='' and Exists('$(REVIT_NET8_DIR)\\\\RevitAPIUI.dll')\"> <HintPath>$(REVIT_NET8_DIR)\\RevitAPIUI.dll</HintPath> <Private>false</Private> </Reference> </ItemGroup> </Project> Source: csharp/src/Tools/Structural/FramingJoins/DBTools.Structural.FramingJoins.csproj:1-69 For Tools with WPF UI Add the following to your .csproj: <PropertyGroup> <UseWPF>true</UseWPF> </PropertyGroup> <!-- Additional packages for MVVM --> <ItemGroup> <PackageReference Include=\"CommunityToolkit.Mvvm\" /> </ItemGroup> <!-- Fluent Ribbon if using ribbon-based window --> <ItemGroup> <Reference Include=\"DBTools.Fluent.Ribbon\"> <HintPath>$(DBT_VendorArtifactsRoot)fluentribbon\\$(TargetFramework)\\DBTools.Fluent.Ribbon.dll</HintPath> <Private>true</Private> </Reference> <Reference Include=\"DBTools.ControlzEx\"> <HintPath>$(DBT_VendorArtifactsRoot)controlzex\\$(TargetFramework)\\DBTools.ControlzEx.dll</HintPath> <Private>true</Private> </Reference> </ItemGroup> <!-- Design-time resources --> <ItemGroup> <Page Update=\"Properties\\DesignTimeResources.xaml\"> <SubType>Designer</SubType> <Generator>MSBuild:Compile</Generator> <ContainsDesignTimeResources>true</ContainsDesignTimeResources> </Page> </ItemGroup> Source: csharp/src/Tools/Common/GM/DBTools.GM.csproj:1-94 Step 3: manifest.yml (Complete Schema) The manifest file declares your tool's metadata, ribbon configuration, and optional settings. Complete Schema Reference # Required: Unique tool identifier id: DBTools.MyTool # Required: Assembly name (without .dll) - always \"DBTools\" for main tools assembly: DBTools # Required: Fully-qualified type name of DbtToolModule subclass moduleType: DBTools.MyTool.MyToolToolModule # Required: Load order (lower = earlier). Use 0 unless you need ordering. order: 0 # Optional: Sandbox windows for design-time preview sandboxWindows: - id: DBTools.MyTool.Main displayName: \"My Tool\" group: \"Common\" # or \"Structural\", \"Testing\" windowType: \"DBTools.MyTool.Shell.UI.Views.MyToolWindow\" designTimeViewModelType: \"DBTools.MyTool.Shell.DesignTime.MyToolDesignTimeViewModel\" # Required: Tool configuration tool: # Optional: Settings configuration settings: configSection: Tools.MyTool # Section in settings.json # Optional: Settings packs for Settings window settingsPacks: - key: common.my_tool title: \"My Tool\" warnings: - id: core.my_tool.warning title: \"My Tool Disabled\" message: \"Tool is disabled due to a configuration issue.\" disableTools: - DBTools.MyToolCommand # Required: Ribbon button definitions ribbonTools: - internalName: DBTools.MyToolCommand commandType: DBTools.MyTool.Features.MyToolCommand availabilityType: DBTools.App.Tools.Availability.DbtDocumentAvailability runProfile: InlineUi displayText: \"My Tool\" iconBaseKey: my_tool tooltip: \"Launch My Tool\" controlKind: PushButton order: 50 Manifest Properties Reference Property Required Description id Yes Unique identifier (e.g., DBTools.MyTool) assembly Yes Assembly name without .dll (always DBTools) moduleType Yes Full type name of DbtToolModule subclass order Yes Load order (0 for most tools) sandboxWindows No Design-time preview windows tool.settings.configSection No settings.json section for Options pattern tool.settingsPacks No Settings window configuration tool.ribbonTools Yes At least one ribbon button definition Ribbon Tool Properties Property Required Description internalName Yes Unique button identifier commandType Yes Full type name of command class availabilityType No IExternalCommandAvailability implementation runProfile No InlineUi (default), BackgroundWork, etc. displayText Yes Button label (use \\n for line breaks) iconBaseKey Yes Icon filename without extension tooltip Yes Button tooltip text controlKind Yes PushButton, SplitButtonItem, PulldownButtonItem, StackedButtonItem splitGroup No Group name for split/pulldown/stacked buttons order Yes Button order within panel groupDisplayText No Header text for pulldown groups groupTooltip No Tooltip for pulldown header groupIconBaseKey No Icon for pulldown header Source: csharp/src/DBTools.Core/Tools/DbtToolManifest.cs:1-68 and csharp/src/DBTools.Core/Tools/DbtToolManifestLoader.cs:287-307 Example: Simple Tool id: DBTools.Structural.FramingJoins assembly: DBTools moduleType: DBTools.Structural.FramingJoins.FramingJoinsToolModule order: 0 tool: ribbonTools: - internalName: DBTools.AllowJoinSelected commandType: DBTools.Structural.FramingJoins.AllowJoinSelectedCommand availabilityType: DBTools.App.Tools.Availability.DbtStructuralFramingSelectionAvailability runProfile: InlineUi displayText: \"Allow Join\" iconBaseKey: allow_join tooltip: \"Allow structural framing joins for selected elements\" controlKind: SplitButtonItem splitGroup: framing_joins order: 0 - internalName: DBTools.DisallowJoinSelected commandType: DBTools.Structural.FramingJoins.DisallowJoinSelectedCommand availabilityType: DBTools.App.Tools.Availability.DbtStructuralFramingSelectionAvailability runProfile: InlineUi displayText: \"Disallow Join\" iconBaseKey: disallow_join tooltip: \"Disallow structural framing joins for selected elements\" controlKind: SplitButtonItem splitGroup: framing_joins order: 1 Source: csharp/src/Tools/Structural/FramingJoins/manifest.yml:1-27 Example: Complex Tool with UI id: DBTools.GM assembly: DBTools moduleType: DBTools.GM.GmToolModule order: 0 sandboxWindows: - id: DBTools.GM.Main displayName: \"Global Mapper\" group: \"Common\" windowType: \"DBTools.GM.Shell.UI.Views.GmWindow\" designTimeViewModelType: \"DBTools.GM.Shell.DesignTime.GmShellDesignTimeViewModel\" - id: DBTools.GM.MappingReport displayName: \"Global Mapper - Mapping Report\" group: \"Common\" windowType: \"DBTools.GM.Features.Mapping.UI.Views.GmMappingReportWindow\" designTimeViewModelType: \"DBTools.GM.Features.Mapping.DesignTime.GmMappingReportDesignTimeViewModel\" tool: ribbonTools: - internalName: DBTools.GM commandType: DBTools.GM.Features.GmCommand availabilityType: DBTools.App.Tools.Availability.DbtDocumentAvailability runProfile: InlineUi displayText: \"Global Mapper\" iconBaseKey: gm tooltip: \"Open Global Mapper\" controlKind: PushButton order: 30 Source: csharp/src/Tools/Common/GM/manifest.yml:1-27 Step 4: ToolModule Class The DbtToolModule subclass registers services with the DI container. Minimal Implementation For simple tools with no custom services: using DBTools.Core.Tools; namespace DBTools.Structural.FramingJoins; public sealed class FramingJoinsToolModule : DbtToolModule { } Source: csharp/src/Tools/Structural/FramingJoins/FramingJoinsToolModule.cs:1-8 With Service Registration using DBTools.Core.Tools; using DBTools.Core.Compat; using Microsoft.Extensions.DependencyInjection; namespace DBTools.MyTool; public sealed class MyToolToolModule : DbtToolModule { public override void RegisterServices(IServiceCollection services, DbtToolManifest manifest) { Guard.NotNull(services, nameof(services)); Guard.NotNull(manifest, nameof(manifest)); // Register tool-specific services services.AddScoped<IMyService, MyService>(); services.AddScoped<MyOtherService>(); } } Source: csharp/src/Tools/Common/GM/GmToolModule.cs:1-19 With Hooks using DBTools.Core.Tools; using DBTools.Core.Compat; using Microsoft.Extensions.DependencyInjection; namespace DBTools.SGT; public sealed class SgtToolModule : DbtToolModule { public override void RegisterServices(IServiceCollection services, DbtToolManifest manifest) { Guard.NotNull(services, nameof(services)); Guard.NotNull(manifest, nameof(manifest)); services.AddSgtServices(); services.AddSingleton<SgtContextualRibbonInjector, SgtContextualRibbonInjector>(); } public override void RegisterHooks(DbtToolRegistry registry, DbtToolManifest manifest) { Guard.NotNull(registry, nameof(registry)); Guard.NotNull(manifest, nameof(manifest)); // Register contextual ribbon hook registry.RegisterHook<IContextualRibbonInjector, SgtContextualRibbonInjector>(); } } Source: csharp/src/Tools/Structural/SGT/SgtToolModule.cs:1-27 DbtToolModule Virtual Methods Method Purpose RegisterSettings Register Options pattern settings types RegisterServices Register services for DI container RegisterSettingsPacks Register settings pack definitions RegisterHooks Register event hooks (ViewActivated, ContextualRibbon) Source: csharp/src/DBTools.Core/Tools/DbtToolModule.cs:1-50 Step 5: Command Implementation Commands implement DbtToolCommand (not IExternalCommand directly) to get automatic error handling, logging, and run scope management. Basic Command Structure using System; using System.Threading.Tasks; using Autodesk.Revit.Attributes; using DBTools.Core.Compat; using DBTools.Core.Revit.Execution; using Microsoft.Extensions.Logging; namespace DBTools.MyTool.Features; [Transaction(TransactionMode.Manual)] public sealed class MyToolCommand : DbtToolCommand { protected override async Task RunAsync(IDbtToolContext context) { Guard.EnsureNotNull(context, nameof(context)); var logger = context.Logger; var doc = context.Document; var uidoc = context.UIDocument; logger.LogDebug(\"[MyTool] Starting execution\"); // Your tool logic here await Task.CompletedTask.ConfigureAwait(false); } protected override SafeExecutor.SafeExecuteOptions CreateExecuteOptions( Autodesk.Revit.UI.ExternalCommandData commandData) { return new SafeExecutor.SafeExecuteOptions { Name = \"My Tool\", ShowCompletionToUser = true, SuppressCompletionBanner = false }; } } With Transaction [Transaction(TransactionMode.Manual)] public sealed class AllowJoinSelectedCommand : DbtToolCommand { protected override async Task RunAsync(IDbtToolContext context) { Guard.EnsureNotNull(context, nameof(context)); var uidoc = context.UIDocument; var doc = context.Document; var logger = context.Logger; // Get selection var selectedIds = uidoc.Selection.GetElementIds(); if (selectedIds == null || selectedIds.Count == 0) { throw new InvalidOperationException(\"Please select elements.\"); } // Create transaction runner var gate = new ModalInlineCallGate(context.UIApplication); var tx = new DBTools.Core.Revit.Transactions.CallGateTransactionRunner(gate); int modified = 0; await tx.RunAsync(doc, \"DB Tools - Allow Join\", d => { foreach (var id in selectedIds) { var elem = doc.GetElement(id) as FamilyInstance; if (elem == null) continue; StructuralFramingUtils.AllowJoinAtEnd(elem, 0); StructuralFramingUtils.AllowJoinAtEnd(elem, 1); modified++; } }).ConfigureAwait(false); logger.LogDebug(\"[AllowJoin] Modified {Count} elements.\", modified); // Show result var alerts = context.Resolve<IAlertService>(); _ = alerts.Show(new AlertRequest( \"Allow Join\", new MessageBodyViewModel($\"Allowed joins on {modified} element(s).\")) { Buttons = new[] { new AlertButtonSpec(\"ok\", \"OK\") { IsDefault = true } } }); } } Source: csharp/src/Tools/Structural/FramingJoins/Features/AllowJoinSelectedCommand.cs:1-89 IDbtToolContext Properties Property Description UIApplication Revit UIApplication UIDocument Active UIDocument Document Active Document Logger ILogger for the command Resolve<T>() Resolve service from DI Source: csharp/src/DBTools.Core/Revit/Execution/DbtToolCommand.cs:1-239 Step 6: UI Implementation (MVVM Pattern) For tools with UI, follow the MVVM pattern with DBTools conventions. Window Base Classes Class Use Case DbtWindowBase Modal dialogs DbtRibbonWindowBase Windows with Fluent Ribbon Source: csharp/src/DBTools.Core/UI/Windows/DbtWindowBase.cs:1-48 XAML Window Template <?xml version=\"1.0\" encoding=\"utf-8\"?> <core:DbtWindowBase x:Class=\"DBTools.MyTool.Shell.UI.Views.MyToolWindow\" xmlns=\"http://schemas.microsoft.com/winfx/2006/xaml/presentation\" xmlns:x=\"http://schemas.microsoft.com/winfx/2006/xaml\" xmlns:d=\"http://schemas.microsoft.com/expression/blend/2008\" xmlns:mc=\"http://schemas.openxmlformats.org/markup-compatibility/2006\" xmlns:core=\"clr-namespace:DBTools.Core.UI.Windows;assembly=DBTools.Core\" xmlns:theme=\"clr-namespace:DBTools.Themes;assembly=DBTools.Themes\" xmlns:dt=\"clr-namespace:DBTools.MyTool.Shell.DesignTime\" d:DataContext=\"{d:DesignInstance Type=dt:MyToolDesignTimeViewModel, IsDesignTimeCreatable=True}\" Title=\"My Tool\" Width=\"800\" Height=\"600\" MinWidth=\"600\" MinHeight=\"400\" ResizeMode=\"CanResize\" mc:Ignorable=\"d\"> <Window.Resources> <ResourceDictionary> <ResourceDictionary.MergedDictionaries> <ResourceDictionary Source=\"pack://application:,,,/DBTools.Themes;component/Themes/App.Theme.xaml\" /> </ResourceDictionary.MergedDictionaries> </ResourceDictionary> </Window.Resources> <Grid> <!-- Your UI content --> </Grid> </core:DbtWindowBase> Source: csharp/src/Tools/Common/GM/Shell/UI/Views/GmWindow.xaml:1-26 ViewModel Pattern Use CommunityToolkit.Mvvm for MVVM implementation: using CommunityToolkit.Mvvm.ComponentModel; using CommunityToolkit.Mvvm.Input; namespace DBTools.MyTool.Shell.UI.ViewModels; public partial class MyToolWindowViewModel : ObservableObject { [ObservableProperty] private string _searchText = string.Empty; [ObservableProperty] private bool _isBusy; [RelayCommand] private async Task ExecuteAsync() { IsBusy = true; try { // Do work } finally { IsBusy = false; } } } Design-Time ViewModel Create a design-time ViewModel for XAML preview: using System.Windows.Input; using DBTools.Core.UI; namespace DBTools.MyTool.Shell.DesignTime; /// <summary> /// Design-time ViewModel for XAML Designer support. /// DO NOT instantiate at runtime. /// </summary> [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)] public sealed class MyToolDesignTimeViewModel { // Commands - use DesignTimeRelayCommand for all public ICommand ExecuteCommand => DesignTimeRelayCommand.Instance; public ICommand CloseCommand => DesignTimeRelayCommand.Instance; // Properties with sample data public string SearchText { get; set; } = \"Sample search\"; public bool IsBusy => false; public MyToolDesignTimeViewModel() { // Initialize sample data for designer preview } } Source: csharp/src/Tools/Common/GM/Shell/DesignTime/GmShellDesignTimeViewModel.cs:1-250 Step 7: Settings (Optional) Defining Settings Create a settings class: namespace DBTools.MyTool.Settings; public sealed class MyToolSettings { public bool EnableFeatureX { get; set; } = true; public int Threshold { get; set; } = 50; } Registering Settings In your ToolModule: public override void RegisterSettings( IServiceCollection services, IConfiguration configuration, DbtToolManifest manifest) { Guard.NotNull(services, nameof(services)); Guard.NotNull(configuration, nameof(configuration)); Guard.NotNull(manifest, nameof(manifest)); var section = manifest.Tool?.Settings?.ConfigSection ?? \"Tools.MyTool\"; services.Configure<MyToolSettings>(configuration.GetSection(section)); } Using Settings public sealed class MyService { private readonly MyToolSettings _settings; public MyService(IOptionsMonitor<MyToolSettings> options) { _settings = options.CurrentValue; } } settings.json Structure { \"Tools\": { \"MyTool\": { \"EnableFeatureX\": true, \"Threshold\": 75 } } } Step 8: Hooks (Optional) Available Hook Interfaces Interface Purpose IViewActivatedHookHandler React to view changes IContextualRibbonInjector Add contextual ribbon tabs Source: csharp/src/DBTools.Core/Tools/DbtHookHost.cs:14-23 ViewActivated Hook using DBTools.Core.Tools; using Autodesk.Revit.UI; using Autodesk.Revit.UI.Events; namespace DBTools.MyTool.Features.Hooks; public sealed class MyViewActivatedHandler : IViewActivatedHookHandler { public Task OnViewActivatedAsync( UIControlledApplication application, ViewActivatedEventArgs args, CancellationToken ct) { // React to view changes return Task.CompletedTask; } } Register in your ToolModule: public override void RegisterHooks(DbtToolRegistry registry, DbtToolManifest manifest) { registry.RegisterHook<IViewActivatedHookHandler, MyViewActivatedHandler>(); } public override void RegisterServices(IServiceCollection services, DbtToolManifest manifest) { services.AddSingleton<MyViewActivatedHandler>(); } Step 9: Availability Types Availability types control when ribbon buttons are enabled. Built-in Availability Types Type Description DbtDocumentAvailability Requires an open document DbtActiveViewAvailability Requires an active view DbtSelectionAvailability Requires selected elements Source: csharp/src/DBTools.App/Tools/Availability/DbtDocumentAvailability.cs:1-17 Custom Availability using Autodesk.Revit.DB; using Autodesk.Revit.UI; namespace DBTools.App.Tools.Availability; public sealed class MyCustomAvailability : IExternalCommandAvailability { public bool IsCommandAvailable(UIApplication applicationData, CategorySet selectedCategories) { var doc = applicationData?.ActiveUIDocument?.Document; if (doc == null) return false; // Custom logic return selectedCategories?.Contains(Category.GetCategory(doc, BuiltInCategory.OST_Walls)) == true; } } Step 10: File Linking (How It Works) Tool source files are compiled into DBTools.dll via file linking in DBTools.App.csproj: <!-- Tool Source Files --> <ItemGroup Label=\"Tool Source Files\"> <Compile Include=\"..\\Tools\\**\\*.cs\" Exclude=\"..\\Tools\\**\\Tests\\**\\*.cs;..\\Tools\\**\\obj\\**\\*.cs\" Link=\"Tools\\%(RecursiveDir)%(Filename)%(Extension)\" /> </ItemGroup> <!-- Tool XAML Files --> <ItemGroup Label=\"Tool XAML Files\"> <Page Include=\"..\\Tools\\**\\*.xaml\" Exclude=\"..\\Tools\\**\\obj\\**\\*.xaml;..\\Tools\\**\\Properties\\DesignTimeResources.xaml\" Link=\"Tools\\%(RecursiveDir)%(Filename)%(Extension)\" /> </ItemGroup> <!-- Tool Icons --> <ItemGroup Label=\"Tool Embedded Assets\"> <EmbeddedResource Include=\"..\\Tools\\**\\Assets\\*.png\" Link=\"Resources\\Icons\\%(RecursiveDir)%(Filename)%(Extension)\" /> </ItemGroup> <!-- Tool Manifests --> <ItemGroup> <EmbeddedResource Include=\"..\\Tools\\**\\manifest.yml\" LogicalName=\"DBTools.ToolManifests.%(RecursiveDir)%(Filename)%(Extension)\" /> </ItemGroup> Source: csharp/src/DBTools.App/DBTools.App.csproj:61-78, 218-222 Step 11: Testing Setup Test Project Structure csharp/src/Tools/<Category>/<ToolName>/Tests/ DBTools.<ToolName>.Tests.csproj MyToolCommandTests.cs MyServiceTests.cs Test Project File <Project Sdk=\"Microsoft.NET.Sdk\"> <PropertyGroup> <TargetFramework>net8.0-windows</TargetFramework> <IsPackable>false</IsPackable> <Nullable>enable</Nullable> <ImplicitUsings>enable</ImplicitUsings> </PropertyGroup> <ItemGroup> <PackageReference Include=\"Microsoft.NET.Test.Sdk\" /> <PackageReference Include=\"xunit\" /> <PackageReference Include=\"xunit.runner.visualstudio\" /> <PackageReference Include=\"NSubstitute\" /> </ItemGroup> <ItemGroup> <ProjectReference Include=\"..\\..\\..\\..\\DBTools.App\\DBTools.App.csproj\" /> <ProjectReference Include=\"..\\..\\..\\..\\testing\\TestSupport\\DBTools.TestSupport.csproj\" /> </ItemGroup> </Project> Running Tests # Run all tests for a tool bash csharp/invoke-revit-tests.sh --smart --tool MyTool -y 2025 # Run specific test bash csharp/invoke-revit-tests.sh --smart -f \"FullyQualifiedName~MyTestName\" Common Patterns and Best Practices 1. Service Extension Pattern Centralize DI registration in an extension method: // Bootstrap/MyToolServiceExtensions.cs namespace DBTools.MyTool.Bootstrap; public static class MyToolServiceExtensions { public static IServiceCollection AddMyToolServices(this IServiceCollection services) { Guard.NotNull(services, nameof(services)); services.AddScoped<IMyService, MyService>(); services.AddScoped<MyOtherService>(); return services; } } Then in ToolModule: services.AddMyToolServices(); Source: csharp/src/Tools/Common/GM/Bootstrap/GmServiceExtensions.cs:1-16 2. Error Handling Never swallow exceptions. Use ISafeExecutor for top-level error handling (provided by DbtToolCommand): // DON'T do this: try { DoWork(); } catch { } // Silent failure // DO this: // Exceptions propagate to DbtToolCommand's ISafeExecutor DoWork(); // Let exceptions propagate 3. Logging Use the injected logger, not Console.WriteLine: var logger = context.Logger; logger.LogDebug(\"[MyTool] Processing {Count} elements\", count); logger.LogWarning(\"[MyTool] Skipped invalid element {Id}\", elementId); logger.LogError(ex, \"[MyTool] Failed to process\"); 4. Transactions Always name transactions descriptively: await tx.RunAsync(doc, \"DB Tools - My Tool Operation\", d => { // Modifications here }).ConfigureAwait(false); 5. Icon Naming Main icon: my_tool.png (32x32) Small icon: my_tool_16.png (16x16, optional) Match the iconBaseKey in manifest (without extension) 6. Namespace Conventions DBTools.<ToolName> # Root namespace DBTools.<ToolName>.Bootstrap # DI extensions DBTools.<ToolName>.Features # Commands and feature logic DBTools.<ToolName>.Features.Commands # Revit commands DBTools.<ToolName>.Features.Logic # Business logic DBTools.<ToolName>.Shell # Application shell DBTools.<ToolName>.Shell.DI # Detailed DI registrations DBTools.<ToolName>.Shell.UI # Views and ViewModels DBTools.<ToolName>.Shell.DesignTime # Design-time ViewModels DBTools.<ToolName>.Shared # Shared types/contracts Checklist: New Tool Completion [ ] Created directory structure under csharp/src/Tools/<Category>/<ToolName>/ [ ] Added manifest.yml with unique id and valid ribbonTools [ ] Created <ToolName>ToolModule.cs extending DbtToolModule [ ] Implemented command(s) extending DbtToolCommand [ ] Added icon(s) in Assets/ folder [ ] Created .csproj file for IDE support [ ] Build passes: bash csharp/build.sh [ ] Tool appears in Revit ribbon [ ] Command executes successfully [ ] (Optional) Created test project [ ] (Optional) Added UI with design-time preview Cross-References Architecture Overview DI Container Guide UI Theming Guide Testing Guide"
  },
  "articles/projects/app.html": {
    "href": "articles/projects/app.html",
    "title": "DBTools.App | DB Tools",
    "summary": "DBTools.App Purpose: Main application assembly containing all tools and bootstrapping logic. Output: DBTools.dll Target Frameworks: net48, net8.0-windows Overview DBTools.App is the main application assembly that compiles to DBTools.dll. It is loaded by DBTools.Loader and serves as the host for all tool implementations, the dependency injection container, ribbon composition, and Revit lifecycle management. This project uses file linking to compile tool source code from src/Tools/ into the single DBTools.dll assembly. Individual tool projects exist primarily for IDE organization, isolated testing, and XAML designer support, but at runtime everything executes within this unified assembly. Source: csharp/src/DBTools.App/DBTools.App.csproj:1-13 Responsibilities Responsibility Implementation Application entry point AddinEntry implements IExternalApplication Runtime initialization AppRuntimeFactory creates DiAppRuntime DI container setup DbtServiceBootstrapper.Build() registers all services Tool discovery DbtToolModuleCatalog.Discover() scans embedded YAML manifests Ribbon composition DbtRibbonComposer creates tab, panels, and buttons Hook coordination DbtHookHost dispatches view-activated and contextual ribbon events Test API hosting TestApiHost enables API calls from test harnesses File-linked tool compilation MSBuild items compile src/Tools/**/*.cs into this assembly Source: csharp/src/DBTools.App/Addin/AddinEntry.cs:29-247 Key Components AddinEntry (Application Entry Point) The AddinEntry class is the inner application entry point, loaded by DBTools.Loader.AddinEntry after assembly resolution is configured. public class AddinEntry : IExternalApplication { public static IRevitTask? RevitTask { get; private set; } private static DbtHookHost? _hookHost; private static DbtToolRegistry? _toolRegistry; private static DbtRibbonComposer? _ribbonComposer; public Result OnStartup(UIControlledApplication application) { ... } public Result OnShutdown(UIControlledApplication application) { ... } } Source: csharp/src/DBTools.App/Addin/AddinEntry.cs:29-43 Key Static Fields: RevitTask - The IRevitTask for marshaling work to Revit's UI thread _hookHost - Coordinates view-activated and contextual ribbon hooks _toolRegistry - Registry of discovered tool commands _ribbonComposer - Manages ribbon tab/panel creation Source: csharp/src/DBTools.App/Addin/AddinEntry.cs:33-36 Bootstrap System AppRuntimeFactory Factory class that creates the application runtime: public static class AppRuntimeFactory { public static IAppRuntime Create() => new DiAppRuntime(); } Source: csharp/src/DBTools.App/Bootstrap/AppRuntimeFactory.cs:5-8 DiAppRuntime The DI-based implementation of IAppRuntime that owns the service provider: public sealed class DiAppRuntime : IAppRuntime { private readonly IServiceProvider _root; public DiAppRuntime() { var root = DbtServiceBootstrapper.Build(); _root = root.Services; _logger = _root.GetRequiredService<ILogger<DiAppRuntime>>(); _settings = _root.GetRequiredService<ISettingsProvider>(); } public IAppRunScope CreateRunScope(UIApplication uiapp, RevitRunScopeProfile profile) { var scope = _root.GetRequiredService<IServiceScopeFactory>().CreateScope(); var rsFactory = scope.ServiceProvider.GetRequiredService<IRevitRunScopeFactory>(); var accessor = scope.ServiceProvider.GetRequiredService<IRevitRunScopeAccessor>(); var rs = rsFactory.CreateScope(uiapp, profile); accessor.Current = rs; return new DiRunScope(scope); } } Source: csharp/src/DBTools.App/Bootstrap/DiAppRuntime.cs:17-62 DbtServiceBootstrapper The central DI container builder that registers all services: public static class DbtServiceBootstrapper { public static DbtServiceRoot Build(Action<IServiceCollection>? configure = null) { // 1. Create logging host // 2. Load configuration from settings.json // 3. Register core services // 4. Discover and register tool modules // 5. Start hosted services } } Source: csharp/src/DBTools.App/Bootstrap/DbtServiceBootstrapper.cs:163-248 Service Categories Registered: Logging - IDbtLoggingHost, ILoggerFactory, ILogger<T> Debug - IDebugModeService (session-only) Settings - IOptionsMonitor<T>, IOptionsWriter, ISettingsProvider Revit Scope - IRevitRunScopeFactory, IRevitRunScopeAccessor, IRevitCallGate Transactions - ITransactionRunner, ITransactionGroupService Execution - ISafeExecutor, IAlertService Hosted Services - ILoggerWindowManager, HostedServiceCoordinator Source: csharp/src/DBTools.App/Bootstrap/DbtServiceBootstrapper.cs:376-437 DbtServiceRoot Container holding all initialized services: public sealed class DbtServiceRoot { public IServiceProvider Services { get; } public IConfiguration Configuration { get; } public IDbtLoggingHost LoggingHost { get; } public DbtToolRegistry ToolRegistry { get; } public IReadOnlyList<DbtToolModule> ToolModules { get; } } Source: csharp/src/DBTools.App/Bootstrap/DbtServiceBootstrapper.cs:34-67 Ribbon Composition DbtRibbonComposer Composes the DB Tools ribbon from tool specifications: public sealed class DbtRibbonComposer : IDisposable { public void Compose(DbtToolRegistry registry, Flags flags) { // 1. Create ribbon tab // 2. Create panels in defined order // 3. Build control plans for each tool // 4. Execute plans in order (push buttons, split buttons, pulldowns, stacked) // 5. Subscribe to settings changes } } Source: csharp/src/DBTools.App/Features/Ribbon/DbtRibbonComposer.cs:19-102 Control Kind Description PushButton Standard button SplitButtonItem Primary + dropdown items PulldownButtonItem Dropdown menu StackedButtonItem 2-3 buttons in vertical stack Source: csharp/src/DBTools.App/Features/Ribbon/DbtRibbonComposer.cs:159-252 Panel Order: Settings Common Structural Testing Any additional panels (alphabetical) Source: csharp/src/DBTools.App/Features/Ribbon/DbtRibbonComposer.cs:109-121 RibbonDefinition Defines ribbon constants (tab name, panel names, command names): public static class RibbonDefinition { public const string TabName = SettingsConstants.Ribbon.TabName; public static class Panels { public const string Settings = SettingsConstants.Ribbon.Panels.Settings; public const string Structural = SettingsConstants.Ribbon.Panels.Structural; public const string Testing = SettingsConstants.Ribbon.Panels.Testing; public const string Common = SettingsConstants.Ribbon.Panels.Common; } } Source: csharp/src/DBTools.App/Features/Ribbon/RibbonDefinition.cs:5-21 Availability Predicates Located in Tools/Availability/, these classes control when ribbon buttons are enabled. DbtDocumentAvailability Requires an active document to be open: public sealed class DbtDocumentAvailability : IExternalCommandAvailability { public bool IsCommandAvailable(UIApplication applicationData, CategorySet selectedCategories) { return applicationData?.ActiveUIDocument?.Document != null; } } Source: csharp/src/DBTools.App/Tools/Availability/DbtDocumentAvailability.cs:10-16 DbtSelectionAvailability Base class requiring element selection, with optional category filtering: public class DbtSelectionAvailability : IExternalCommandAvailability { protected virtual BuiltInCategory[]? RequiredCategories => null; protected virtual bool IsElementMatch(Element element) => true; public bool IsCommandAvailable(UIApplication applicationData, CategorySet selectedCategories) { // Check for selection and optional category/element matching } } Source: csharp/src/DBTools.App/Tools/Availability/DbtSelectionAvailability.cs:13-52 DbtStructuralFramingSelectionAvailability Requires structural framing selection: public sealed class DbtStructuralFramingSelectionAvailability : DbtSelectionAvailability { protected override BuiltInCategory[]? RequiredCategories => new[] { BuiltInCategory.OST_StructuralFraming }; } Source: csharp/src/DBTools.App/Tools/Availability/DbtSelectionAvailability.cs:57-60 Hooks System AppHookModule The application-level hook module that registers view-activated handlers: public sealed class AppHookModule : DbtToolModule { public override void RegisterServices(IServiceCollection services, DbtToolManifest manifest) { services.AddSingleton<ViewActivatedHookHandler, ViewActivatedHookHandler>(); } public override void RegisterHooks(DbtToolRegistry registry, DbtToolManifest manifest) { registry.RegisterHook<IViewActivatedHookHandler, ViewActivatedHookHandler>(); } } Source: csharp/src/DBTools.App/Features/Hooks/AppHookModule.cs:7-22 TestApiHost Static host for test harness integration, providing API access outside Revit command context: public static class TestApiHost { public static bool IsInitialized { get; private set; } public static void Initialize(UIControlledApplication app) { // Create ExternalEvent handler and UIApplication.Idling subscription } public static Task<object?> RunAsync(Func<object, Task<object?>> work) { // Queue work and raise ExternalEvent } } Source: csharp/src/DBTools.App/Addin/TestApiHost.cs:9-123 OnStartup Sequence The complete startup flow with source references: 1. Set Revit year from VersionNumber (for per-instance log files) > Source: AddinEntry.cs:55-66 2. Initialize AppRuntime via AppRuntimeFactory.Create() > Source: AddinEntry.cs:72 3. Resolve ISafeExecutor, DbtToolRegistry, DbtHookHost > Source: AddinEntry.cs:74-76 4. Validate theme (mandatory - fails startup if broken) > Source: AddinEntry.cs:106-113 5. Detect RevitTest environment > Source: AddinEntry.cs:116, 573-629 6. Register deferred UI startup handlers (ApplicationInitialized, Idling) > Source: AddinEntry.cs:125-127 7. Execute startup task via ISafeExecutor.RunAsync: a. Try binding global window owner (may be deferred) b. Initialize DialogGuardianHook c. Initialize RevitTaskService (if not RevitTest) d. Attach DbtHookHost (if not RevitTest) e. Initialize TestApiHost (if not RevitTest) > Source: AddinEntry.cs:133-178 8. Create ribbon synchronously (Revit API requirement): a. Get Flags settings b. Create DbtRibbonComposer c. Call Compose() with registry and flags d. Publish warning changes > Source: AddinEntry.cs:217-244 9. Return Result.Succeeded > Source: AddinEntry.cs:246 Deferred UI Startup Certain operations run after ApplicationInitialized/Idling to ensure Revit is fully ready: private static Task RunDeferredUiStartupAsync(...) { return executor.RunAsync(async () => { // 1. Ensure global window owner is bound await EnsureGlobalWindowOwnerBoundAsync(logger); // 2. Apply ribbon special effects (visual styling) await RibbonSpecialEffects.ApplyAsync(logger); // 3. Show logger window if debug mode enabled loggerWindowManager.ShowIfDebugEnabled(); }, ...); } Source: csharp/src/DBTools.App/Addin/AddinEntry.cs:421-479 OnShutdown Sequence 1. Wait for startup task completion (5s timeout) > Source: AddinEntry.cs:265-274 2. Unregister deferred UI handlers > Source: AddinEntry.cs:276 3. Detach DbtHookHost > Source: AddinEntry.cs:278 4. Shutdown DialogGuardianHook > Source: AddinEntry.cs:281 5. Shutdown TestApiHost > Source: AddinEntry.cs:284 6. Dispose RevitTaskService > Source: AddinEntry.cs:287 7. Dispose DbtRibbonComposer > Source: AddinEntry.cs:292 8. Stop hosted services > Source: AddinEntry.cs:303 9. Dispose logging host > Source: AddinEntry.cs:306 Source: csharp/src/DBTools.App/Addin/AddinEntry.cs:250-325 File Linking Strategy DBTools.App compiles tool source code via MSBuild file linking. Source files remain in their respective src/Tools/ directories but are compiled into the single DBTools.dll assembly. Source File Linking <ItemGroup Label=\"Tool Source Files\"> <Compile Include=\"..\\Tools\\**\\*.cs\" Exclude=\"..\\Tools\\**\\Tests\\**\\*.cs;..\\Tools\\**\\obj\\**\\*.cs\" Link=\"Tools\\%(RecursiveDir)%(Filename)%(Extension)\" /> </ItemGroup> Source: csharp/src/DBTools.App/DBTools.App.csproj:63-67 XAML File Linking <ItemGroup Label=\"Tool XAML Files\"> <Page Include=\"..\\Tools\\**\\*.xaml\" Exclude=\"..\\Tools\\**\\obj\\**\\*.xaml;..\\Tools\\**\\Properties\\DesignTimeResources.xaml\" Link=\"Tools\\%(RecursiveDir)%(Filename)%(Extension)\" /> </ItemGroup> Source: csharp/src/DBTools.App/DBTools.App.csproj:69-73 Tool Assets (Embedded Icons) <ItemGroup Label=\"Tool Embedded Assets\"> <EmbeddedResource Include=\"..\\Tools\\**\\Assets\\*.png\" Link=\"Resources\\Icons\\%(RecursiveDir)%(Filename)%(Extension)\" /> </ItemGroup> Source: csharp/src/DBTools.App/DBTools.App.csproj:75-78 Tool Manifests (Embedded YAML) <ItemGroup> <EmbeddedResource Include=\"manifest.yml\" LogicalName=\"DBTools.ToolManifests.DBTools.AppHooks.yml\" /> <EmbeddedResource Include=\"..\\Tools\\**\\manifest.yml\" LogicalName=\"DBTools.ToolManifests.%(RecursiveDir)%(Filename)%(Extension)\" /> </ItemGroup> Source: csharp/src/DBTools.App/DBTools.App.csproj:218-222 Why File Linking? Single assembly deployment - Reduces complexity and potential conflicts IDE organization - Tools can have separate projects for development Isolated testing - Test projects reference tool projects directly XAML designer support - Individual projects can have design-time resources Tool Module Discovery Tools are discovered via embedded YAML manifests during DbtServiceBootstrapper.Build(): var rootAssembly = typeof(DbtServiceBootstrapper).Assembly; var discovery = DbtToolModuleCatalog.Discover(rootAssembly); foreach (var entry in discovery.Entries) { var module = entry.Module; module.RegisterSettings(services, configuration, entry.Manifest); module.RegisterServices(services, entry.Manifest); module.RegisterSettingsPacks(services, entry.Manifest); module.RegisterHooks(registry, entry.Manifest); RegisterRibbonToolsFromManifest(registry, rootAssembly, entry.Manifest); } Source: csharp/src/DBTools.App/Bootstrap/DbtServiceBootstrapper.cs:194-237 Manifest Structure Example tool manifest (manifest.yml): id: DBTools.GM assembly: DBTools moduleType: DBTools.GM.GmToolModule order: 0 sandboxWindows: - id: DBTools.GM.Main displayName: \"Global Mapper\" windowType: \"DBTools.GM.Shell.UI.Views.GmWindow\" tool: ribbonTools: - internalName: DBTools.GM commandType: DBTools.GM.Features.GmCommand availabilityType: DBTools.App.Tools.Availability.DbtDocumentAvailability runProfile: InlineUi displayText: \"Global Mapper\" iconBaseKey: gm tooltip: \"Open Global Mapper\" controlKind: PushButton order: 30 Source: csharp/src/Tools/Common/GM/manifest.yml:1-27 Dependencies Project References Project Purpose DBTools.Core Core infrastructure and abstractions DBTools.Themes WPF theme resources Source: csharp/src/DBTools.App/DBTools.App.csproj:57-59 NuGet Packages Package Purpose Microsoft.Extensions.DependencyInjection DI container Microsoft.Extensions.Options.ConfigurationExtensions Options pattern Microsoft.Extensions.Configuration.* Configuration binding ricaun.Revit.UI Ribbon utilities ricaun.Revit.UI.Tasks RevitTask for async CommunityToolkit.Mvvm MVVM for tools JsonDiffPatch.Net JSON diff (tools) AutoMapper Object mapping (tools) HelixToolkit.Wpf.SharpDX 3D visualization (tools) Source: csharp/src/DBTools.App/DBTools.App.csproj:27-87 Vendored Assemblies Assembly Purpose DBTools.Fluent.Ribbon Ribbon UI for tool windows DBTools.ControlzEx Window chrome and behaviors Source: csharp/src/DBTools.App/DBTools.App.csproj:89-98 Revit API References net48: <Reference Include=\"RevitAPI\"> <HintPath>$(REVIT2024_DIR)\\RevitAPI.dll</HintPath> <Private>false</Private> </Reference> Source: csharp/src/DBTools.App/DBTools.App.csproj:114-134 net8.0-windows: <Reference Include=\"RevitAPI\" Condition=\"'$(REVIT_NET8_DIR)'!=''\"> <HintPath>$(REVIT_NET8_DIR)\\RevitAPI.dll</HintPath> <Private>false</Private> </Reference> Source: csharp/src/DBTools.App/DBTools.App.csproj:143-165 Assembly Embedding All CopyLocal dependencies (except forbidden host assemblies) are embedded as resources for single-DLL deployment: <Target Name=\"DBT_EmbedCopyLocalAssemblies\" AfterTargets=\"ResolveReferences\"> <ItemGroup> <_EmbedCandidate Include=\"@(ReferenceCopyLocalPaths)\" ... /> <!-- Exclude Revit host assemblies --> <_EmbedCandidate Remove=\"...\" Condition=\"'%(Filename)%(Extension)' == 'RevitAPI.dll'\" /> <!-- Exclude WPF theme assemblies (need file Location for pack:// URIs) --> <_EmbedCandidate Remove=\"...\" Condition=\"StartsWith('DBTools.Fluent.Ribbon')\" /> </ItemGroup> <EmbeddedResource Include=\"%(_EmbedLogicalDistinct.SourcePath)\" LogicalName=\"DBTools.EmbeddedAssemblies.%(Name).dll\" /> </Target> Source: csharp/src/DBTools.App/DBTools.App.csproj:234-270 Forbidden Host Assemblies These assemblies must never be in the output (Revit provides them): <ItemGroup> <ForbiddenHostAssembly Include=\"RevitAPI.dll\" /> <ForbiddenHostAssembly Include=\"RevitAPIUI.dll\" /> <ForbiddenHostAssembly Include=\"AdWindows.dll\" /> <ForbiddenHostAssembly Include=\"UIFramework.dll\" /> <ForbiddenHostAssembly Include=\"Newtonsoft.Json.dll\" /> </ItemGroup> Source: csharp/src/DBTools.App/DBTools.App.csproj:169-177 Build Configuration Project Properties <PropertyGroup> <TargetFrameworks>$(DBT_RevitTargetFrameworks)</TargetFrameworks> <AssemblyName>DBTools</AssemblyName> <RootNamespace>DBTools.App</RootNamespace> <UseWPF>true</UseWPF> <ILRepackEnabled>false</ILRepackEnabled> </PropertyGroup> Source: csharp/src/DBTools.App/DBTools.App.csproj:2-13 InternalsVisibleTo Test assemblies can access internal types: <ItemGroup> <InternalsVisibleTo Include=\"DBTools.GM.Tests\" /> <InternalsVisibleTo Include=\"DBTools.SGT.Tests\" /> <InternalsVisibleTo Include=\"DBTools.TDV.Tests\" /> <InternalsVisibleTo Include=\"DBTools.Testing.Tests\" /> </ItemGroup> Source: csharp/src/DBTools.App/DBTools.App.csproj:15-20 Warning Suppressions Tool code suppressions consolidated from individual tool projects: <NoWarn>$(NoWarn);CS0618;CS0649;CS8600;CS8602;CS8603;CS8604;CS8619;CS8620; MA0038;MA0051;MA0048;MA0016;MA0098;MA0004;MA0008;MA0015; CA1068;CA1707;CA1716;CA1720;CA1722;CA1725;CA1822</NoWarn> Source: csharp/src/DBTools.App/DBTools.App.csproj:136-138 File Structure csharp/src/DBTools.App/ +-- DBTools.App.csproj +-- manifest.yml # AppHooks module manifest +-- GlobalUsings.cs +-- GlobalSuppressions.cs +-- AssemblyInfo.cs +-- Addin/ | +-- AddinEntry.cs # IExternalApplication entry point | +-- TestApiHost.cs # Test harness API host +-- Bootstrap/ | +-- AppRuntimeFactory.cs # Creates DiAppRuntime | +-- DiAppRuntime.cs # IAppRuntime implementation | +-- DbtServiceBootstrapper.cs # DI container builder | +-- Startup.cs # Legacy startup helper +-- Features/ | +-- Hooks/ | | +-- AppHookModule.cs # Application-level hooks | | +-- ViewActivatedHookHandler.cs | | +-- DialogGuardianHook.cs | +-- Ribbon/ | +-- DbtRibbonComposer.cs # Ribbon composition | +-- RibbonDefinition.cs # Tab/panel constants | +-- RibbonRegistry.cs # Runtime button registry | +-- RibbonSettingsListener.cs | +-- RibbonSpecialEffects.cs | +-- RevitRibbonBuilder.cs +-- Tools/ | +-- Availability/ | +-- DbtDocumentAvailability.cs | +-- DbtSelectionAvailability.cs | +-- DbtActiveViewAvailability.cs +-- Resources/ +-- (Ribbon icons - embedded resources) RevitTest Environment Detection AddinEntry detects when running under ricaun.RevitTest and adjusts behavior: private static bool DetectRevitTestEnvironment(UIControlledApplication application, ILogger logger) { bool hostBoundToRevitTest = RevitTaskAccessor.RevitTask != null; bool hasRevitTestAssembly = AppDomain.CurrentDomain.GetAssemblies() .Any(a => a.GetName().Name == \"ricaun.RevitTest.Application\" || a.GetName().Name == \"ricaun.RevitTest\"); bool isRevitTestFlag = RevitExecutionContext.IsRevitTest; return hostBoundToRevitTest || hasRevitTestAssembly || isRevitTestFlag; } Source: csharp/src/DBTools.App/Addin/AddinEntry.cs:573-629 Skipped in RevitTest: RevitTaskService initialization (test host provides its own) DbtHookHost attachment TestApiHost initialization Error Handling Startup Errors Fatal errors during startup show a message box and return Result.Failed: private static void TryShowStartupError(string message) { // Try WPF MessageBox first MessageBox.Show(message, \"DB Tools\", MessageBoxButton.OK, MessageBoxImage.Error, ...); // Fall back to Win32 MessageBoxW if WPF fails MessageBoxW(IntPtr.Zero, text, caption, MB_OK | MB_ICONERROR); } Source: csharp/src/DBTools.App/Addin/AddinEntry.cs:481-535 Theme Validation Theme validation is mandatory - if it fails, startup aborts: try { DbtThemeValidator.ValidateOrThrow(); } catch (Exception ex) { logger.LogError(ex, \"[AddinEntry] Theme validation failed; aborting add-in startup.\"); TryShowStartupError($\"DB Tools theme failed to load:\\n\\n{ex.GetBaseException().Message}\"); return Result.Failed; } Source: csharp/src/DBTools.App/Addin/AddinEntry.cs:104-113 Troubleshooting \"Theme validation failed\" Error Cause: WPF theme assemblies (Fluent.Ribbon, ControlzEx) not found. Solution: Ensure %APPDATA%/DBTools/vendor/ contains theme assemblies Or rebuild with bash csharp/build.sh --clean BuildAll Ribbon Not Appearing Possible Causes: Tool manifests not embedded (check build output) Tool command type not found (check namespace/assembly in manifest) Availability type resolution failed (check availabilityType in manifest) Diagnosis: Enable debug mode and check log file for errors during Compose(). Tools Disabled Unexpectedly Check: Availability predicate in manifest.yml Flags settings (some tools check flags.EnableTesting) IExternalCommandAvailability implementation returning false Related Documentation Architecture Overview - High-level system architecture Project References - How projects relate DBTools.Loader - Bootstrap assembly that loads DBTools.App DBTools.Core - Core infrastructure library Source Files Reviewed File Purpose csharp/src/DBTools.App/DBTools.App.csproj Project configuration csharp/src/DBTools.App/Addin/AddinEntry.cs Application entry point csharp/src/DBTools.App/Addin/TestApiHost.cs Test harness API csharp/src/DBTools.App/Bootstrap/AppRuntimeFactory.cs Runtime factory csharp/src/DBTools.App/Bootstrap/DiAppRuntime.cs DI-based runtime csharp/src/DBTools.App/Bootstrap/DbtServiceBootstrapper.cs DI container builder csharp/src/DBTools.App/Bootstrap/Startup.cs Legacy startup helper csharp/src/DBTools.App/Features/Ribbon/DbtRibbonComposer.cs Ribbon composition csharp/src/DBTools.App/Features/Ribbon/RibbonDefinition.cs Ribbon constants csharp/src/DBTools.App/Features/Hooks/AppHookModule.cs Application hooks csharp/src/DBTools.App/Tools/Availability/DbtDocumentAvailability.cs Document availability csharp/src/DBTools.App/Tools/Availability/DbtSelectionAvailability.cs Selection availability csharp/src/DBTools.App/manifest.yml AppHooks manifest csharp/src/Tools/Common/GM/manifest.yml Example tool manifest csharp/src/DBTools.Core/Tools/DbtHookHost.cs Hook coordination (Core) UNVERIFIED Items"
  },
  "articles/projects/core.html": {
    "href": "articles/projects/core.html",
    "title": "DBTools.Core | DB Tools",
    "summary": "DBTools.Core DBTools.Core is the foundational library providing shared infrastructure for all DBTools components. It contains Revit execution abstractions, transaction management, safe execution patterns, logging infrastructure, settings management, tool module system, and shared UI components. Overview DBTools.Core serves as the central infrastructure layer, abstracting away Revit API complexities while providing consistent patterns for error handling, logging, and dependency injection across all tools. Property Value Assembly Name DBTools.Core.dll Target Frameworks net48, net8.0-windows WPF Support Yes (UseWPF=true) Nullable Enabled Source: csharp/src/DBTools.Core/DBTools.Core.csproj:1-10 Responsibilities Revit Execution Abstraction - Thread-safe API access via call gates and run scopes Transaction Management - Unified transaction/subtransaction handling with automatic rollback Safe Execution - Centralized error handling with user notification and logging Logging Infrastructure - Serilog-based structured logging with UI sink Settings System - Type-safe options pattern with persistence and validation Tool Module System - Discovery, registration, and lifecycle management for tools Shared UI Components - Window bases, alert dialogs, progress overlays, and behaviors Key Components Revit Execution Layer IRevitCallGate The unified entry point for executing Revit API callbacks, supporting both inline (modal) and queued (modeless) execution modes. public interface IRevitCallGate { bool InGate { get; } Task<T> RunAsync<T>(Func<UIApplication, T> work, CancellationToken ct = default, RevitCallMode mode = RevitCallMode.Auto); Task RunAsync(Action<UIApplication> work, CancellationToken ct = default, RevitCallMode mode = RevitCallMode.Auto); } Source: csharp/src/DBTools.Core/Revit/Execution/IRevitCallGate.cs:8-28 Mode Description Auto Execute inline if valid context exists; otherwise queue InlineOnly Execute inline only; throw if context unavailable ForceQueue Always queue via ExternalEvent/RevitTask RequiresActiveView Require an active UIDocument before executing Source: csharp/src/DBTools.Core/Revit/Execution/IRevitCallGate.cs:30-51 IRevitRunScope Represents a single Revit run scope (command, modeless session, or test). Owns UI/document context plus call gate and transaction services. public interface IRevitRunScope { UIApplication UIApplication { get; } IRevitCallGate CallGate { get; } ITransactionRunner TransactionRunner { get; } ITransactionGroupService TransactionGroupService { get; } UIDocument GetActiveUiDocument(); Document GetActiveDocument(); Document GetLockedDocument(Document expectedDocument, string? context = null); } Source: csharp/src/DBTools.Core/Revit/Execution/IRevitRunScope.cs:11-20 Profile Use Case Implementation InlineUi Modal commands and RevitTest ModalInlineCallGate + CallGateTransactionRunner QueuedModeless Long-running/modeless tools ModelessQueuedCallGate + RevitTaskService Source: csharp/src/DBTools.Core/Revit/Execution/IRevitRunScope.cs:22-36 ModalInlineCallGate Call-gate implementation that executes delegates inline on the Revit UI thread using a supplied UIApplication. Used for modal command execution. public sealed class ModalInlineCallGate : IRevitCallGate { public ModalInlineCallGate(UIApplication uiapp) { ... } public bool InGate => _inGate.Value; public Task<T> RunAsync<T>(Func<UIApplication, T> work, ...) { ... } } Source: csharp/src/DBTools.Core/Revit/Execution/ModalInlineCallGate.cs:10-74 Transaction Management ITransactionRunner Provides a unified API for executing Revit model modifications with automatic transaction management. public interface ITransactionRunner { Task RunAsync(string name, Action action, CancellationToken ct = default); Task<T> RunAsync<T>(string name, Func<T> action, CancellationToken ct = default); Task RunAsync(string name, Action<Document> action, CancellationToken ct = default); Task<T> RunAsync<T>(string name, Func<Document, T> action, CancellationToken ct = default); // Additional overloads with UIApplication access and explicit Document } Source: csharp/src/DBTools.Core/Revit/Transactions/ITransactionRunner.cs:6-53 CallGateTransactionRunner The primary implementation that wraps all Revit API calls in properly managed transactions: Auto-selects transaction type: Uses SubTransaction if doc.IsModifiable (already in transaction), otherwise creates new Transaction Cross-document protection: Prevents starting transactions on Document B while Document A is modifiable Failure handling: Attaches SilentFailuresPreprocessor to suppress non-critical Revit warnings Source: csharp/src/DBTools.Core/Revit/Transactions/CallGateTransactionRunner.cs:9-390 Usage Example: // Basic modification with automatic transaction await _transactionRunner.RunAsync(\"Create Wall\", doc => { Wall.Create(doc, curve, levelId, false); }); // Get a result from a transaction var wallId = await _transactionRunner.RunAsync(\"Create Wall\", doc => { var wall = Wall.Create(doc, curve, levelId, false); return wall.Id; }); Source: csharp/src/DBTools.Core/Revit/Transactions/CallGateTransactionRunner.cs:64-79 ITransactionGroupService Manages transaction groups for operations requiring multiple undoable transactions to appear as a single undo item. public interface ITransactionGroupService { bool IsActive { get; } Task BeginAsync(string name, CancellationToken ct = default); Task FinalizeAsync(bool commit, CancellationToken ct = default); Task RunAsync(string name, bool commit, Func<Task> work, CancellationToken ct = default); } Source: csharp/src/DBTools.Core/Revit/Transactions/ITransactionGroupService.cs:1-14 Safe Execution ISafeExecutor The central error handling service. All tool entrypoints must execute within ISafeExecutor. public interface ISafeExecutor { Task RunAsync(Func<Task> action, ILogger logger, IErrorNotifier? notifier = null, CancellationToken ct = default); Task RunAsync(Func<Task> action, ILogger logger, IErrorNotifier? notifier, SafeExecutor.SafeExecuteOptions? opts, CancellationToken ct = default); } Source: csharp/src/DBTools.Core/Execution/ISafeExecutor.cs:6-16 SafeExecutor Implementation Provides comprehensive error handling: Correlation IDs: Each execution gets a unique GUID for log correlation Timing: Tracks elapsed milliseconds for performance analysis Exception logging: Logs full exception details including inner exceptions and XAML parse context User notification: Shows error banners via IErrorNotifier Debug mode: Automatically enables debug mode and shows logger window on fatal errors Lifecycle hooks: Optional OnSuccessAsync, OnCancelAsync, OnErrorAsync callbacks Source: csharp/src/DBTools.Core/Execution/SafeExecutor.cs:12-467 SafeExecuteOptions: public sealed class SafeExecuteOptions { public string? Name { get; set; } public bool LogStart { get; set; } = true; public bool ShowCompletionToUser { get; set; } public Guid? CorrelationId { get; set; } public Func<Task>? OnSuccessAsync { get; set; } public Func<Task>? OnCancelAsync { get; set; } public Func<Exception, Task>? OnErrorAsync { get; set; } public NotifyKindKind NotifyKind { get; set; } = NotifyKindKind.Success; } Source: csharp/src/DBTools.Core/Execution/SafeExecutor.cs:451-466 DbtToolCommand Base Class Abstract base class for Revit commands that enforces ISafeExecutor usage, run-scope creation, and centralized error notification. public abstract class DbtToolCommand : IExternalCommand { public Result Execute(ExternalCommandData commandData, ref string message, ElementSet elements) { // Wraps execution in ISafeExecutor, creates run scope } protected abstract Task RunAsync(IDbtToolContext context); // Convenience methods protected static T GetService<T>(IDbtToolContext context) where T : notnull; protected static Task<T> RunInRevitAsync<T>(IDbtToolContext context, Func<UIApplication, T> work, ...); protected static bool? ShowToolWindow<TWindow>(Func<TWindow> windowFactory) where TWindow : Window; } Source: csharp/src/DBTools.Core/Revit/Execution/DbtToolCommand.cs:35-238 Tool Context IDbtToolContext Ambient context provided to DBT tool commands, wrapping the current Revit run scope, DI scope, and shared services. public interface IDbtToolContext { ExternalCommandData CommandData { get; } UIApplication UIApplication { get; } UIDocument UIDocument { get; } Document Document { get; } IAppRunScope RunScope { get; } IRevitRunScope RevitRunScope { get; } ILogger Logger { get; } IErrorNotifier ErrorNotifier { get; } RevitRunScopeProfile RunProfile { get; } T Resolve<T>() where T : notnull; } Source: csharp/src/DBTools.Core/Revit/Execution/IDbtToolContext.cs:14-27 Runtime AppRuntime Static accessor for the application runtime. Provides global access to services when DI is not available (e.g., Revit's parameterless constructor requirement). public static class AppRuntime { public static bool IsInitialized { get; } public static void Initialize(IAppRuntime runtime); public static void InitializeIfNeeded(Func<IAppRuntime> factory); public static ILogger Logger { get; } public static ISettingsProvider Settings { get; } public static IAppRunScope CreateRunScope(UIApplication uiapp, RevitRunScopeProfile profile); public static T Resolve<T>() where T : notnull; } Source: csharp/src/DBTools.Core/Runtime/AppRuntime.cs:8-155 IAppRuntime Interface for the application runtime container. public interface IAppRuntime { ILogger Logger { get; } ISettingsProvider Settings { get; } IAppRunScope CreateRunScope(UIApplication uiapp, RevitRunScopeProfile profile); T Resolve<T>() where T : notnull; } Source: csharp/src/DBTools.Core/Runtime/IAppRuntime.cs:8-16 IAppRunScope Scoped DI container for per-command lifetimes. public interface IAppRunScope : IDisposable { T Resolve<T>() where T : notnull; } Source: csharp/src/DBTools.Core/Runtime/IAppRunScope.cs:5-8 Logging Infrastructure IDbtLoggingHost Central logging host that implements ILoggerFactory directly. public interface IDbtLoggingHost : ILoggerFactory, IDisposable { SerilogUiSink UiSink { get; } bool IsDebugMode { get; } void SetDebugMode(bool enabled); ILoggerFactory LoggerFactory { get; } string InstanceId { get; } int? RevitYear { get; } string? LogFilePath { get; } } Source: csharp/src/DBTools.Core/Logging/DbtLoggingHost.cs:21-33 DbtLoggingHost Implementation Features: Serilog integration: Uses Serilog with structured logging UI sink: Feeds log entries to the Logger Window File sink: Custom DbtTextFileSink avoids version conflicts with Serilog.Sinks.File Thread enrichment: Adds thread ID to all log entries Instance identification: Unique instance ID per Revit process Log rotation: Automatic cleanup of old log files by age, count, and total size Source: csharp/src/DBTools.Core/Logging/DbtLoggingHost.cs:35-226 Log File Naming: dbtools-{revitYear}-{instanceId}-{timestamp}-{nonce}.log Source: csharp/src/DBTools.Core/Logging/DbtLoggingHost.cs:88-100 Settings System ISettingsProvider Interface for reading and persisting settings. public interface ISettingsProvider { TSettings Get<TSettings>() where TSettings : class, new(); Task SaveAsync<TSettings>(string section, TSettings settings, CancellationToken ct = default) where TSettings : class; } Source: csharp/src/DBTools.Core/Settings/ISettingsProvider.cs:1-8 DbtSettingsRegistry Registry for settings pack definitions, enabling the Settings Window to discover and display tool-specific settings. public sealed class DbtSettingsRegistry { public IReadOnlyCollection<IDbtSettingsPackDefinition> Definitions { get; } public void Register(IDbtSettingsPackDefinition definition); public bool Unregister(string key); public IEnumerable<IDbtSettingsPackDefinition> ForPanel(string ribbonPanel); public IEnumerable<IDbtSettingsWarningDefinition> WarningDefinitions(); } Source: csharp/src/DBTools.Core/Settings/DbtSettingsRegistry.cs:8-62 DbtToolSettingsPack Generic container for tool settings with validation support. public sealed class DbtToolSettingsPack<TOptions> : IDbtToolSettingsPack { public string Key { get; } public string Title { get; } public string RibbonPanel { get; } public Type OptionsType { get; } public object Context { get; } public object CreateDefaultOptions(); public object BuildOptionsSnapshot(); public Task<DbtSettingsValidationResult> ValidateAsync(CancellationToken ct = default); public FrameworkElement View { get; } } Source: csharp/src/DBTools.Core/Settings/DbtToolSettingsPack.cs:37-85 Tool Module System DbtToolModule Base class for tool modules to contribute DI services and tool registrations. public abstract class DbtToolModule { public virtual void RegisterSettings(IServiceCollection services, IConfiguration configuration, DbtToolManifest manifest) { } public virtual void RegisterServices(IServiceCollection services, DbtToolManifest manifest) { } public virtual void RegisterSettingsPacks(IServiceCollection services, DbtToolManifest manifest) { } public virtual void RegisterHooks(DbtToolRegistry registry, DbtToolManifest manifest) { } } Source: csharp/src/DBTools.Core/Tools/DbtToolModule.cs:9-49 DbtToolRegistry Central registry for tool registrations and hook handlers. public sealed class DbtToolRegistry { public ReadOnlyCollection<DbtToolRegistration> Tools { get; } public IReadOnlyDictionary<Type, IReadOnlyCollection<Type>> HookRegistrations { get; } public void RegisterTool(DbtToolRegistration registration); public void RegisterHook<THook, TImplementation>() where THook : class where TImplementation : class, THook; public Type[] GetHookImplementations<THook>() where THook : class; } Source: csharp/src/DBTools.Core/Tools/DbtToolRegistry.cs:9-83 DbtToolRegistration Encapsulates a tool command registration with ribbon configuration. public sealed class DbtToolRegistration { public Type CommandType { get; } public Type? AvailabilityType { get; } public RevitRunScopeProfile RunProfile { get; } public DbtToolRibbonSpec Ribbon { get; } public Func<Flags, bool>? AvailabilityPredicate { get; init; } } Source: csharp/src/DBTools.Core/Tools/DbtToolRegistration.cs:8-38 DbtToolManifest YAML manifest structure for tool discovery. public sealed class DbtToolManifest { public string Id { get; set; } public string Assembly { get; set; } public string ModuleType { get; set; } public int? Order { get; set; } public List<DbtSandboxWindowManifest>? SandboxWindows { get; set; } public DbtToolMetadataManifest? Tool { get; set; } } Source: csharp/src/DBTools.Core/Tools/DbtToolManifest.cs:5-13 DbtHookHost Coordinates application-level hooks, dispatching events to registered handlers. Supported Hook Interfaces: IViewActivatedHookHandler - Called when views are activated IContextualRibbonInjector - For contextual ribbon panel initialization public sealed class DbtHookHost { public void Attach(UIControlledApplication application); public Task AttachAsync(UIControlledApplication application, CancellationToken ct); public void Detach(UIControlledApplication application); } Source: csharp/src/DBTools.Core/Tools/DbtHookHost.cs:28-244 UI Components DbtWindowBase Modal-first base window for DBT. Hosts the progress overlay and central UI error boundary. public class DbtWindowBase : Window, IWindowWithOwnerProvider, IThemeOptOut { public IWindowOwnerProvider? OwnerProvider { get; set; } public bool UseDefaultTheme { get; set; } } Source: csharp/src/DBTools.Core/UI/Windows/DbtWindowBase.cs:27-47 IAlertService Service for showing alert dialogs with various body types. public interface IAlertService { AlertResult Show(AlertRequest request); bool Confirm(string message, string title = \"DB Tools\"); T? SelectSingle<T>(IEnumerable<T> items, Func<T, string> displayFunc, ...); IReadOnlyList<T> SelectMultiple<T>(IEnumerable<T> items, Func<T, string> displayFunc, ...); } Source: csharp/src/DBTools.Core/UI/Alerts/Services/IAlertService.cs:5-26 IErrorNotifier Interface for displaying error/success banners to users. public interface IErrorNotifier { void ShowBanner(string title, string message); // Error (red) void ShowSuccessBanner(string title, string message); // Success (green) } Source: csharp/src/DBTools.Core/Execution/IErrorNotifier.cs:1-10 Dependencies NuGet Packages Package Purpose Newtonsoft.Json JSON serialization CSharpFunctionalExtensions Result types and functional patterns Ardalis.GuardClauses Argument validation AutoMapper Object mapping UnitsNet Units and measurements Serilog + extensions Structured logging Microsoft.Extensions.DependencyInjection Dependency injection Microsoft.Extensions.Configuration.* Configuration binding CommunityToolkit.Mvvm MVVM base classes DynamicData Reactive collections System.Reactive Reactive extensions Ookii.Dialogs.Wpf Native file dialogs ricaun.Revit.UI.Tasks Revit async task support Source: csharp/src/DBTools.Core/DBTools.Core.csproj:102-161 Vendored Assemblies Assembly Purpose DBTools.Fluent.Ribbon Ribbon UI for tool windows DBTools.ControlzEx Window chrome and behaviors Source: csharp/src/DBTools.Core/DBTools.Core.csproj:144-152 Project References Project Purpose DBTools.Themes WPF theme resources Source: csharp/src/DBTools.Core/DBTools.Core.csproj:165 Directory Structure DBTools.Core/ +-- Assets/ # Shared resources (icons) +-- Compat/ # Cross-framework compatibility utilities +-- Constants/ # Application-wide constants +-- Execution/ # Safe execution, error handling +-- Hosting/ # Service hosting infrastructure +-- IO/ # File system utilities +-- Logging/ # Serilog infrastructure, UI sink +-- Notifications/ # Banner notifications +-- Revit/ | +-- Context/ # Revit context accessors | +-- Execution/ # Call gates, run scopes, tool context | +-- Transactions/ # Transaction runners and groups | +-- Utilities/ # Revit helpers (RevitId, Failures, etc.) +-- Runtime/ # AppRuntime, IAppRunScope +-- Sandbox/ # Sandbox mode stubs +-- Settings/ # Settings infrastructure +-- Tools/ # Tool module system +-- UI/ +-- Alerts/ # Alert dialog system +-- Behaviors/ # WPF attached behaviors +-- Converters/ # Value converters +-- Icons/ # Icon loading +-- Progress/ # Progress overlay +-- Theming/ # Theme validation +-- Windows/ # Window base classes Public API Summary Revit Execution IRevitCallGate - Thread-safe Revit API execution IRevitRunScope - Command execution scope IRevitRunScopeFactory - Factory for run scopes DbtToolCommand - Base class for Revit commands IDbtToolContext - Command context interface Transaction Management ITransactionRunner - Transaction execution ITransactionGroupService - Transaction grouping Safe Execution ISafeExecutor - Centralized error handling IErrorNotifier - User notification Logging IDbtLoggingHost - Logging host interface ILogSink - Custom sink interface Settings ISettingsProvider - Settings access DbtSettingsRegistry - Settings pack registry IDbtToolSettingsPack - Settings pack interface Tool System DbtToolModule - Tool module base class DbtToolRegistry - Tool registration DbtToolManifest - Manifest structure DbtHookHost - Hook coordination UI DbtWindowBase - Window base class IAlertService - Alert dialogs IWindowOwnerProvider - Window ownership Usage Examples Creating a Tool Command public class MyToolCommand : DbtToolCommand { protected override async Task RunAsync(IDbtToolContext context) { var myService = context.Resolve<IMyService>(); // Execute Revit API work await context.RevitRunScope.TransactionRunner.RunAsync(\"My Operation\", doc => { // Modify document }); } } Using the Call Gate // Get element data from Revit (thread-safe) var result = await callGate.RunAsync(uiapp => { var doc = uiapp.ActiveUIDocument.Document; return doc.GetElement(elementId); }, ct, RevitCallMode.RequiresActiveView); Registering a Tool Module public class MyToolModule : DbtToolModule { public override void RegisterServices(IServiceCollection services, DbtToolManifest manifest) { services.AddSingleton<IMyService, MyService>(); } public override void RegisterHooks(DbtToolRegistry registry, DbtToolManifest manifest) { registry.RegisterHook<IViewActivatedHookHandler, MyViewHandler>(); } } Extension Points Custom Call Gates - Implement IRevitCallGate for specialized execution modes Hook Handlers - Register implementations of IViewActivatedHookHandler or IContextualRibbonInjector Settings Packs - Create DbtToolSettingsPack<T> instances for tool-specific settings UI Alert Bodies - Implement IAlertBody for custom alert dialog content Build Considerations Conditional Compilation Sandbox builds (DBT_IsSandboxBuild): Revit-dependent files excluded, sandbox stubs used Designer builds (DBT_IsDesignerBuild): Revit sources excluded for XAML designer wpftmp builds: Special handling for temporary projects during BAML compilation Source: csharp/src/DBTools.Core/DBTools.Core.csproj:12-99 InternalsVisibleTo Test projects and DBTools.App have access to internal types: DBTools.App DBTools.GM.Tests DBTools.SGT.Tests DBTools.TDV.Tests Source: csharp/src/DBTools.Core/DBTools.Core.csproj:27-32 Related Documentation Architecture Overview - System-wide architecture Project References - Inter-project dependencies DBTools.Loader - Revit entry point Verification Status Check Status Source anchors for all claims Yes UNVERIFIED markers where needed No (all verified) Cross-references added Yes Examples tested N/A No assumptions without evidence Yes Verified by: docs-run-20260124-020412 Date: 2026-01-24"
  },
  "articles/projects/loader.html": {
    "href": "articles/projects/loader.html",
    "title": "DBTools.Loader | DB Tools",
    "summary": "DBTools.Loader Purpose: Revit entry point assembly that bootstraps DBTools. Output: DBTools.Loader.dll Target Frameworks: net48, net8.0-windows Overview DBTools.Loader is the critical bootstrap component that Revit loads directly via the .addin manifest. Its sole responsibility is to load DBTools.dll (the main application assembly) and install the assembly resolver infrastructure that handles embedded dependencies. This project is intentionally minimal to reduce startup failure risk. All application logic lives in DBTools.App; the loader exists only to: Find and load DBTools.dll Install the EmbeddedAssemblyResolver Forward Revit lifecycle calls to DBTools.App.AddinEntry Source: csharp/src/DBTools.Loader/Addin/AddinEntry.cs:13-47 Responsibilities Responsibility Implementation Revit entry point IExternalApplication implementation with [AppLoader] attribute Load main assembly LoadMainAssembly() loads DBTools.dll from deployed directory Install assembly resolver EmbeddedAssemblyResolver.Install() handles runtime resolution Pre-load critical assemblies net48 only: Configuration and Serilog assemblies pre-loaded to beat GAC Forward lifecycle OnStartup/OnShutdown delegated to inner DBTools.App.AddinEntry Source: csharp/src/DBTools.Loader/Addin/AddinEntry.cs:17-47 Key Components AddinEntry (Revit Entry Point) The AddinEntry class is the Revit-facing entry point. It implements IExternalApplication and is decorated with [AppLoader] from ricaun.Revit.UI for enhanced loading behavior. [AppLoader] public sealed class AddinEntry : IExternalApplication { private IExternalApplication? _inner; public Result OnStartup(UIControlledApplication application) { // Bootstrap sequence here... } } Source: csharp/src/DBTools.Loader/Addin/AddinEntry.cs:12-14 Key Fields: _inner: Stores the instantiated DBTools.App.AddinEntry for forwarding lifecycle calls Source: csharp/src/DBTools.Loader/Addin/AddinEntry.cs:15 EmbeddedAssemblyResolver Static class that installs hooks into the CLR's assembly resolution mechanism. Handles loading dependencies from embedded resources within DBTools.dll. internal static class EmbeddedAssemblyResolver { private const string ResourcePrefix = \"DBTools.EmbeddedAssemblies.\"; private static int _installed; private static string? _deployedDir; public static void Install(Assembly mainAssembly, string? deployedDir = null) { // Installs AssemblyResolve (net48) or ALC.Resolving (net8) handler } } Source: csharp/src/DBTools.Loader/AssemblyResolution/EmbeddedAssemblyResolver.cs:14-38 LoaderCompat Provides cross-TFM compatibility utilities for the loader. Abstracts differences between .NET Framework and .NET 8. internal static class LoaderCompat { internal static string VendorTfm => #if NET8_0_OR_GREATER \"net8.0-windows\"; #else \"net48\"; #endif internal static Assembly LoadAssemblyFromPath(string path) { #if NET8_0_OR_GREATER return AssemblyLoadContext.Default.LoadFromAssemblyPath(path); #else return Assembly.LoadFrom(path); #endif } } Source: csharp/src/DBTools.Loader/Compat/LoaderCompat.cs:10-35 Bootstrap Sequence OnStartup Flow The complete startup sequence with line numbers: 1. Validate application parameter > Source: AddinEntry.cs:19 2. Get deployed directory (where DBTools.Loader.dll lives) > Source: AddinEntry.cs:21 3. Load DBTools.dll from deployed directory > Source: AddinEntry.cs:22 4. Verify embedded payload is present > Source: AddinEntry.cs:23 5. Install EmbeddedAssemblyResolver > Source: AddinEntry.cs:24 6. [net48 only] Pre-load Configuration assemblies > Source: AddinEntry.cs:26 7. [net48 only] Pre-load Serilog assemblies > Source: AddinEntry.cs:27 8. Resolve DBTools.App.AddinEntry type via reflection > Source: AddinEntry.cs:30-31 9. Create instance of DBTools.App.AddinEntry > Source: AddinEntry.cs:33-34 10. Store instance and forward OnStartup call > Source: AddinEntry.cs:36-37 Source: csharp/src/DBTools.Loader/Addin/AddinEntry.cs:17-38 Sequence Diagram Revit DBTools.Loader DBTools.dll (DBTools.App) | | | |--OnStartup(app)----------->| | | | | | GetDeployedDirectory() | | LoadMainAssembly() | | |--------load-------------->| | | | | EnsureEmbeddedPayloadPresent() | | EmbeddedAssemblyResolver.Install()| | | | | [net48: PreloadEmbedded*()] | | | | | Activator.CreateInstance()------->| | | | | |------OnStartup(app)------>| | | | |<-------Result.Succeeded----|<-------Result-------------| Assembly Loading Strategy net48 Strategy (ILRepack + Embedded) On .NET Framework 4.8, dependencies are handled via two mechanisms: 1. ILRepack (Merged into DBTools.dll): DBTools.Core Serilog, Microsoft.Extensions., YamlDotNet, System. polyfills These types exist directly in DBTools.dll; no resolution needed 2. Embedded Resources (for ricaun.Revit.*): Stored as DBTools.EmbeddedAssemblies.<name>.dll Loaded via Assembly.Load(byte[]) at runtime ILRepack corrupts some IL, so these stay as resources Source: csharp/src/DBTools.Loader/AssemblyResolution/EmbeddedAssemblyResolver.cs:223-263 3. Pre-loaded Assemblies: Configuration assemblies are pre-loaded before any code uses them to ensure DBTools' versions load before GAC/Revit's conflicting versions: var configAssemblies = new[] { \"Microsoft.Extensions.Primitives\", \"Microsoft.Extensions.FileProviders.Abstractions\", \"Microsoft.Extensions.FileProviders.Physical\", \"Microsoft.Extensions.Configuration.Abstractions\", \"Microsoft.Extensions.Configuration\", \"Microsoft.Extensions.Configuration.FileExtensions\", \"Microsoft.Extensions.Configuration.Json\", \"Microsoft.Extensions.Configuration.Binder\" }; Source: csharp/src/DBTools.Loader/Addin/AddinEntry.cs:111-121 Serilog assemblies are also pre-loaded in dependency order: var serilogAssemblies = new[] { \"Microsoft.Extensions.Logging.Abstractions\", \"Microsoft.Extensions.DependencyInjection.Abstractions\", \"Microsoft.Extensions.Logging\", \"Serilog\", \"Serilog.Extensions.Logging\", \"Serilog.Enrichers.Thread\", \"Serilog.Sinks.File\" }; Source: csharp/src/DBTools.Loader/Addin/AddinEntry.cs:154-170 Why Pre-load? On net48, AssemblyResolve only fires when an assembly cannot be found. If the GAC or another add-in already loaded a different version, our resolver never runs. Pre-loading ensures our versions are loaded first. Source: csharp/src/DBTools.Loader/Addin/AddinEntry.cs:104-108 net8.0-windows Strategy (All Embedded) On .NET 8, all dependencies are embedded as resources and loaded via AssemblyLoadContext: alc.Resolving += (context, name) => ResolveNet8(context, mainAssembly, name); Source: csharp/src/DBTools.Loader/AssemblyResolution/EmbeddedAssemblyResolver.cs:33-34 Resolution loads from embedded resources via stream: using var stream = mainAssembly.GetManifestResourceStream(resourceName); if (stream != null) { using var ms = new MemoryStream(); stream.CopyTo(ms); ms.Position = 0; return alc.LoadFromStream(ms); } Source: csharp/src/DBTools.Loader/AssemblyResolution/EmbeddedAssemblyResolver.cs:168-176 WPF Assembly Fallback WPF assemblies (Fluent.Ribbon, ControlzEx, HandyControl) cannot be embedded because they require Assembly.Location for pack:// URI resolution. These are loaded from files: Search Order: %APPDATA%/DBTools/vendor/<type>/<tfm>/ (traditional install) Deployed directory (next to DBTools.Loader.dll) Source: csharp/src/DBTools.Loader/AssemblyResolution/EmbeddedAssemblyResolver.cs:101-129 Vendor Type Detection: private static string? GetVendorTypeForAssembly(string requestedName) { if (requestedName.StartsWith(\"DBTools.Fluent.Ribbon\", ...)) return \"fluentribbon\"; if (requestedName.Equals(\"DBTools.ControlzEx\", ...)) return \"controlzex\"; if (requestedName.Equals(\"DBTools.HandyControl\", ...)) return \"handycontrol\"; return null; } Source: csharp/src/DBTools.Loader/AssemblyResolution/EmbeddedAssemblyResolver.cs:134-143 Duplicate Load Prevention Both resolution paths check for already-loaded assemblies first to prevent type identity mismatches: // Critical for ricaun.Revit.* which AppLoader may have already loaded var alreadyLoaded = AppDomain.CurrentDomain.GetAssemblies() .FirstOrDefault(a => string.Equals(a.GetName().Name, requestedName, ...)); if (alreadyLoaded != null) return alreadyLoaded; Source: csharp/src/DBTools.Loader/AssemblyResolution/EmbeddedAssemblyResolver.cs:50-61 Dependencies NuGet Packages Package Purpose ricaun.Revit.UI Provides [AppLoader] attribute for enhanced Revit loading Source: csharp/src/DBTools.Loader/DBTools.Loader.csproj:20 Note: ricaun.Revit.UI is a compile-time dependency that ensures ricaun is loaded EARLY when Revit loads DBTools.Loader.dll. This is required for RevitTaskService to work correctly in DBTools.App. Source: csharp/src/DBTools.Loader/DBTools.Loader.csproj:16-18 Revit API References Conditional based on target framework: net48: <Reference Include=\"RevitAPI\"> <HintPath>$(REVIT2024_DIR)\\RevitAPI.dll</HintPath> <Private>false</Private> </Reference> Source: csharp/src/DBTools.Loader/DBTools.Loader.csproj:23-34 net8.0-windows: <Reference Include=\"RevitAPI\" Condition=\"'$(REVIT_NET8_DIR)'!=''\"> <HintPath>$(REVIT_NET8_DIR)\\RevitAPI.dll</HintPath> <Private>false</Private> </Reference> Source: csharp/src/DBTools.Loader/DBTools.Loader.csproj:36-47 Runtime Dependencies DBTools.dll - Must be present in same directory as DBTools.Loader.dll Source: csharp/src/DBTools.Loader/Addin/AddinEntry.cs:67-69 Error Handling Startup Errors The loader has minimal error handling - it must either succeed or fail fast: Missing DBTools.dll: if (!File.Exists(mainPath)) throw new FileNotFoundException(\"DBTools.dll not found next to DBTools.Loader.dll.\", mainPath); Source: csharp/src/DBTools.Loader/Addin/AddinEntry.cs:68-69 Missing Embedded Payload (net8 only): var hasCore = Array.Exists(resources, r => string.Equals(r, \"DBTools.EmbeddedAssemblies.DBTools.Core.dll\", ...)); if (!hasCore) { throw new InvalidOperationException( \"DBTools.dll is missing embedded dependencies...\"); } Source: csharp/src/DBTools.Loader/Addin/AddinEntry.cs:89-96 Type Resolution Failure: var type = assembly.GetType(\"DBTools.App.AddinEntry\", throwOnError: true) ?? throw new InvalidOperationException(\"DBTools.App.AddinEntry type not found.\"); Source: csharp/src/DBTools.Loader/Addin/AddinEntry.cs:30-31 Silent Failures (Intentional) Pre-load failures during net48 startup are logged to Debug output but don't fail startup: catch (Exception ex) { // Silent continue - the EmbeddedAssemblyResolver will handle on-demand loading System.Diagnostics.Debug.WriteLine($\"[DBTools.Loader] Preload failed for {name}: {ex.Message}\"); } Source: csharp/src/DBTools.Loader/Addin/AddinEntry.cs:192-196 This is acceptable because the EmbeddedAssemblyResolver can still load these assemblies on-demand if pre-loading fails. Build Configuration Project Properties <TargetFrameworks>$(DBT_RevitTargetFrameworks)</TargetFrameworks> <AssemblyName>DBTools.Loader</AssemblyName> <RootNamespace>DBTools.Loader</RootNamespace> <CopyLocalLockFileAssemblies>true</CopyLocalLockFileAssemblies> Source: csharp/src/DBTools.Loader/DBTools.Loader.csproj:3-13 CopyLocalLockFileAssemblies: Set to true to copy NuGet dependencies (ricaun) to output for AppLoader/Debug scenarios. Source: csharp/src/DBTools.Loader/DBTools.Loader.csproj:13 Suppressed Warnings <NoWarn>$(NoWarn);MSB3277</NoWarn> MSB3277 (assembly version conflicts) is suppressed because Revit host references surface unavoidable conflicts. Source: csharp/src/DBTools.Loader/DBTools.Loader.csproj:10-11 File Structure csharp/src/DBTools.Loader/ +-- DBTools.Loader.csproj +-- Addin/ | +-- AddinEntry.cs # IExternalApplication entry point +-- AssemblyResolution/ | +-- EmbeddedAssemblyResolver.cs # Runtime assembly loading +-- Compat/ +-- LoaderCompat.cs # Cross-TFM utilities Integration with AppLoader DBTools.Loader uses ricaun's [AppLoader] attribute which provides: Automatic Revit version detection Enhanced error reporting Integration with ricaun.RevitTest for automated testing The AppLoader may have already loaded shared assemblies (like ricaun.Revit.*). The resolver explicitly checks for already-loaded assemblies to prevent duplicate loading which would cause type identity mismatches. Source: csharp/src/DBTools.Loader/AssemblyResolution/EmbeddedAssemblyResolver.cs:51-53 Troubleshooting \"DBTools.dll not found\" Error Cause: DBTools.dll is not in the same directory as DBTools.Loader.dll. Solution: Ensure the deployment copies both files together. \"Missing embedded dependencies\" Error (net8) Cause: DBTools.dll was built without the embedded assembly step. Solution: Rebuild using bash csharp/build.sh BuildAll. Source: csharp/src/DBTools.Loader/Addin/AddinEntry.cs:93-96 Assembly Resolution Failures Symptoms: FileNotFoundException or TypeLoadException for dependency types. Diagnosis: Check if the assembly is in embedded resources (DBTools.EmbeddedAssemblies.<name>.dll) For WPF assemblies, check %APPDATA%/DBTools/vendor/ or deployed directory Enable assembly binding logging (FUSLOGVW.exe) on net48 Related Documentation Architecture Overview - High-level system architecture Project References - How projects relate DBTools.Core - Core library documentation Verification Status Check Status Source anchors for all claims Yes UNVERIFIED markers where needed Yes (addin manifest) Cross-references added Yes Examples tested N/A No assumptions without evidence Yes Verified by: docs-run-20260124-020412 Date: 2026-01-24"
  },
  "articles/projects/sandbox.html": {
    "href": "articles/projects/sandbox.html",
    "title": "DBTools.Sandbox | DB Tools",
    "summary": "DBTools.Sandbox The DBTools.Sandbox project is a standalone WPF application that enables development, testing, and validation of DBTools UI windows without running Revit. It provides both an interactive gallery for browsing tool windows and a headless validation mode used during CI builds. Source: csharp/src/DBTools.Sandbox/DBTools.Sandbox.csproj:1-54 Overview Purpose Sandbox exists to solve a fundamental Revit development challenge: tool UI windows normally require Revit to be running, which makes iterative UI development slow and makes CI validation difficult. Sandbox provides: Interactive Development: Launch tool windows with design-time ViewModels to preview UI without Revit Build-Time Validation: Catch XAML errors, missing resources, and binding failures during CI Screenshot Capture: Generate UI screenshots for documentation or visual regression testing Key Concepts Design-Time ViewModels: Each sandbox-enabled window must provide a ViewModel that works without Revit services Sandbox Mode: A global flag (SandboxMode.IsActive) that windows check to avoid calling Revit-dependent code Dist-Driven Discovery: Sandbox loads windows from the built dist/ payload, validating the actual shipped assemblies Project Structure csharp/src/DBTools.Sandbox/ ├── App.xaml.cs # Application entry, mode switching ├── MainWindow.xaml.cs # Interactive gallery window ├── SandboxAppRuntime.cs # IAppRuntime implementation for sandbox ├── SandboxDiagnostics.cs # Logging utilities ├── SandboxSettingsProvider.cs # Settings stub for sandbox mode ├── HeadlessUiSuppression.cs # Suppresses OS dialogs in CI └── Validation/ ├── DistValidator.cs # Main validation orchestrator ├── ToolWindowValidator.cs # Tool window instantiation/layout ├── ManifestValidator.cs # Manifest schema validation ├── WindowGhostValidator.cs # WPF layout pass validation ├── MergeValidator.cs # ILRepack/embedded payload checks ├── BindingErrorListener.cs # WPF binding error capture ├── SandboxValidateOptions.cs # CLI argument parsing ├── SandboxModeActivator.cs # Cross-assembly mode activation ├── SandboxScreenshotHandler.cs # Screenshot capture mode ├── DistDirLocator.cs # Dist directory resolution ├── DistAssemblyResolver.cs # Assembly loading for dist payload ├── RevitDirLocator.cs # Revit installation discovery ├── DistValidationReflection.cs # Reflection helpers ├── AssemblyMetadataInspector.cs # PE metadata inspection └── XamlExceptionDiagnostics.cs # XAML error formatting Operating Modes Interactive Mode (Default) Launch the sandbox gallery to browse and open tool windows: # From csharp/.artifacts/sandbox/Release/net8.0-windows/ DBTools.Sandbox.exe Source: csharp/src/DBTools.Sandbox/App.xaml.cs:109-137 The interactive mode: Initializes SandboxAppRuntime for service resolution Loads DBTools.dll from the dist payload Discovers all sandboxWindows from tool manifests Displays a grouped gallery of launchable windows Headless Validation Mode Used by the build system to validate dist output: DBTools.Sandbox.exe --headless --dist-dir \"path/to/dist/Release/2026\" Source: csharp/src/DBTools.Sandbox/App.xaml.cs:45-57 Headless mode performs comprehensive validation without showing any UI: Theme resource validation Core window instantiation Tool manifest validation Tool window XAML validation WPF binding error detection Screenshot Mode Capture window screenshots for documentation: # List available tools DBTools.Sandbox.exe --screenshot --list # Capture specific tool DBTools.Sandbox.exe --screenshot --tool-id DBTools.GM.Main --output gm.png Source: csharp/src/DBTools.Sandbox/Validation/SandboxScreenshotHandler.cs:24-49 Key Components SandboxAppRuntime Minimal IAppRuntime implementation that provides essential services without Revit: internal sealed class SandboxAppRuntime : IAppRuntime, IDisposable { // Provides: ILogger, ISettingsProvider, ILoggerFactory, IAlertService public T Resolve<T>() where T : notnull { ... } } Source: csharp/src/DBTools.Sandbox/SandboxAppRuntime.cs:17-90 Services provided: IDbtLoggingHost - Real logging to %APPDATA%/DBTools/Logs/dbtools-SANDBOX-*.log ISettingsProvider - Stub implementation returning defaults ILoggerFactory - Creates category-scoped loggers IAlertService - Real alert service for error display SandboxMode Global flag that windows check to avoid Revit-dependent code paths: public static class SandboxMode { public static bool IsActive => _isActive; public static void Activate() { _isActive = true; } } Source: csharp/src/DBTools.Core/Compat/SandboxMode.cs:1-24 Windows should check this before calling Revit services: if (!SandboxMode.IsActive) { // Call Revit-dependent code } DbtSandboxCatalog Discovers sandbox windows from tool manifests: public static IReadOnlyList<DbtSandboxWindowSpec> Discover(Assembly rootAssembly) { var entries = DbtToolManifestLoader.LoadEntries(rootAssembly); // Extract sandboxWindows from each manifest } Source: csharp/src/DBTools.Core/Tools/DbtSandboxCatalog.cs:8-60 Validates that each sandbox window entry has: id - Unique identifier displayName - Human-readable name group - Category for gallery grouping windowType - Fully-qualified Window class name designTimeViewModelType - ViewModel for sandbox mode Tool Manifest Integration Tools register sandbox windows via manifest.yml: id: DBTools.GM assembly: DBTools moduleType: DBTools.GM.GmToolModule sandboxWindows: - id: DBTools.GM.Main displayName: \"Global Mapper\" group: \"Common\" windowType: \"DBTools.GM.Shell.UI.Views.GmWindow\" designTimeViewModelType: \"DBTools.GM.Shell.DesignTime.GmShellDesignTimeViewModel\" Source: csharp/src/Tools/Common/GM/manifest.yml:1-15 Schema Fields Field Required Description id Yes Unique window identifier (e.g., DBTools.GM.Main) displayName Yes Gallery display name group Yes Gallery category grouping windowType Yes Fully-qualified Window type name designTimeViewModelType Yes Design-time ViewModel type assembly No Assembly name (defaults to manifest's assembly) Source: csharp/src/DBTools.Core/Tools/DbtToolManifestLoader.cs:121-153 Validation System The validation system runs during BuildAll to catch UI issues before deployment. DistValidator (Orchestrator) Main validation entry point that coordinates all validators: internal static class DistValidator { public static int Run(SandboxValidateOptions options, ILogger? logger = null) { // 1. Validate dist layout // 2. Install assembly resolver // 3. Validate theme resources // 4. Validate core windows // 5. Validate manifests (optional) // 6. Validate tool windows (optional) } } Source: csharp/src/DBTools.Sandbox/Validation/DistValidator.cs:15-118 ToolWindowValidator Instantiates each sandbox window with its design-time ViewModel: internal static class ToolWindowValidator { public static void ValidateOrThrow(Assembly dbtoolsAssembly, ILogger? logger = null) { var specs = DiscoverSpecs(dbtoolsAssembly); foreach (var spec in specs) { // 1. Load window type from assembly // 2. Create window instance // 3. Create design-time ViewModel // 4. Set DataContext // 5. Run WindowGhostValidator // 6. Validate tab interactions // 7. Validate row expansion } } } Source: csharp/src/DBTools.Sandbox/Validation/ToolWindowValidator.cs:13-173 Additional validations performed: Tab cycling - Switches through all tabs to catch transition errors DataGrid row expansion - Toggles row details visibility Preview mode switching - Tests mode transitions (e.g., SGT preview modes) Source: csharp/src/DBTools.Sandbox/Validation/ToolWindowValidator.cs:201-368 WindowGhostValidator Forces WPF layout passes to catch XAML errors: internal static class WindowGhostValidator { public static void Validate(Window window) { // Pass 1: Fixed 800x600 size ValidateLayoutPass(window, new Size(800, 600), \"fixed size\"); // Pass 2: Infinite size (catches DesiredSize calculation errors) ValidateLayoutPass(window, new Size(PositiveInfinity, PositiveInfinity), \"infinite size\"); } } Source: csharp/src/DBTools.Sandbox/Validation/WindowGhostValidator.cs:9-129 BindingErrorListener Captures WPF binding errors that normally fail silently: internal sealed class BindingErrorListener : TraceListener { // Hooks into PresentationTraceSources.DataBindingSource // Collects \"System.Windows.Data Error:\" messages // ThrowIfErrors() fails validation if any binding errors occurred } Source: csharp/src/DBTools.Sandbox/Validation/BindingErrorListener.cs:13-118 This catches issues like: Missing StaticResource references Broken binding paths Type conversion failures MergeValidator Validates assembly merge/embedding is correct: For net48 (ILRepack): Verifies expected types exist inside DBTools.dll Ensures merged assemblies don't exist as separate files For net8 (Embedded Payload): Verifies DBTools.EmbeddedAssemblies.DBTools.Core.dll resource exists Checks resource isn't corrupted (minimum size validation) Source: csharp/src/DBTools.Sandbox/Validation/MergeValidator.cs:17-222 CLI Arguments Argument Description --headless Run validation only, no UI --screenshot Run screenshot capture mode --dist-dir <path> Path to dist directory or year folder --revit-dir <path> Override Revit installation path --validate-manifests Enable manifest validation (default: true) --skip-validate-manifests Disable manifest validation --validate-tools Enable tool window validation (default: true) --skip-validate-tools Disable tool window validation --list List available tools (screenshot mode) --tool-id <id> Tool to capture (screenshot mode) --output <path> Screenshot output path Source: csharp/src/DBTools.Sandbox/Validation/SandboxValidateOptions.cs:7-113 Build Integration The sandbox validator is invoked automatically during BuildAll: bash csharp/build.sh BuildAll # Internally runs: DBTools.Sandbox.exe --headless --dist-dir ... The build system also handles orphaned processes: static void KillOrphanedSandboxValidatorProcesses() { // Kills any lingering DBTools.Sandbox processes from previous builds } Source: csharp/build/BuildTargets.cs:1292 Creating a Sandbox-Enabled Window 1. Create Design-Time ViewModel public class MyWindowDesignTimeViewModel : INotifyPropertyChanged { public MyWindowDesignTimeViewModel() { // Initialize with sample data Items = new ObservableCollection<ItemModel> { new ItemModel { Name = \"Sample 1\" }, new ItemModel { Name = \"Sample 2\" } }; } public ObservableCollection<ItemModel> Items { get; } } 2. Add Parameterless Constructor to Window public partial class MyWindow : Window { // Required for sandbox mode public MyWindow() { InitializeComponent(); if (SandboxMode.IsActive) { // Skip Revit-dependent initialization return; } // Normal initialization... } } 3. Register in manifest.yml sandboxWindows: - id: MyTool.Main displayName: \"My Tool Window\" group: \"Common\" windowType: \"MyNamespace.UI.Views.MyWindow\" designTimeViewModelType: \"MyNamespace.DesignTime.MyWindowDesignTimeViewModel\" 4. Test Locally # Build bash csharp/build.sh BuildAll # Launch interactive sandbox csharp/.artifacts/sandbox/Release/net8.0-windows/DBTools.Sandbox.exe Multi-Framework Support Sandbox targets both net48 and net8.0-windows to validate both Revit 2024 (net48) and Revit 2025+ (net8) distributions: <TargetFrameworks>$(DBT_RevitTargetFrameworks)</TargetFrameworks> Source: csharp/src/DBTools.Sandbox/DBTools.Sandbox.csproj:3 The validator automatically selects the compatible year folder: net48 sandbox validates Revit 2024 (year <= 2024) net8 sandbox validates Revit 2025+ (year >= 2025) Source: csharp/src/DBTools.Sandbox/Validation/DistDirLocator.cs:75-80 Headless UI Suppression In CI environments, the sandbox suppresses all OS-level dialogs: SetErrorMode - Suppresses Win32 critical error dialogs WerSetFlags - Suppresses Windows Error Reporting UI Trace listeners - Disables Debug.Assert popups Source: csharp/src/DBTools.Sandbox/HeadlessUiSuppression.cs:17-120 This prevents CI builds from hanging on modal dialogs. Troubleshooting \"Dist payload not found\" The sandbox requires a built dist payload: bash csharp/build.sh BuildAll Window crashes in sandbox but works in Revit Check for Revit-dependent code not guarded by SandboxMode.IsActive: // Wrong - crashes in sandbox var doc = AppRuntime.Resolve<IRevitService>().Document; // Right - sandbox-safe if (!SandboxMode.IsActive) { var doc = AppRuntime.Resolve<IRevitService>().Document; } Binding errors in validation The BindingErrorListener will report silent WPF binding failures. Check: Missing StaticResource keys in XAML Incorrect binding paths Missing value converters \"Type not found\" during validation Ensure the window and ViewModel types: Have fully-qualified names in the manifest Are public classes Have public parameterless constructors Related Documentation Architecture: Sandbox Validator - Detailed validation architecture DBTools.App - How App discovers tools via manifests Tool Manifest Schema - Complete manifest documentation See Also DbtSandboxWindowSpec - Window specification model DbtSandboxCatalog - Window discovery from manifests DbtToolManifestLoader - Manifest parsing and validation"
  },
  "articles/projects/themes.html": {
    "href": "articles/projects/themes.html",
    "title": "DBTools.Themes | DB Tools",
    "summary": "DBTools.Themes The DBTools.Themes project provides a unified dark theme system for all DBTools WPF applications. It establishes design tokens, brush definitions, and control styles that ensure visual consistency across the application while avoiding conflicts with Revit's host environment. Overview DBTools.Themes solves several key challenges: Host Isolation: Revit's UI can interfere with WPF resource dictionaries. This project uses vendored, renamed libraries (e.g., DBTools.HandyControl instead of HandyControl) to prevent conflicts with pyRevit or other add-ins. Consistent Branding: Implements the DBTools brand colors (deep blue #1946B9 and golden yellow #FEC425) across all UI controls. WCAG Accessibility: Text colors are designed to meet WCAG AA contrast requirements (min 4.5:1 ratio on dark backgrounds). Template Boundary Crossing: The BrushKeys system using ComponentResourceKey allows brushes to propagate correctly across DataTemplate and ControlTemplate boundaries. Source: csharp/src/DBTools.Themes/DBTools.Themes.csproj:1-73 Project Structure DBTools.Themes/ ├── DBTools.Themes.csproj # Project configuration ├── BrushKeys.cs # ComponentResourceKey definitions ├── Assets/ │ └── db_tools_icon.png # Application icon └── Themes/ ├── App.Theme.xaml # Root dictionary (entry point) ├── App.Tokens.xaml # Design tokens (spacing, sizing) ├── App.Brushes.xaml # Color/brush definitions ├── App.Converters.xaml # Value converters ├── App.Controls.Base.xaml # Base control styles ├── App.DataGrid.xaml # DataGrid-specific styles ├── App.Menus.xaml # Menu/ContextMenu styles ├── App.Components.xaml # Higher-level component styles └── App.FluentRibbon.xaml # Fluent.Ribbon theme bridge Source: csharp/src/DBTools.Themes/DBTools.Themes.csproj:38-51 Key Files App.Theme.xaml - Root Entry Point The root resource dictionary that merges all theme components. This is what consuming projects reference. <ResourceDictionary.MergedDictionaries> <!-- HandyControl Foundation --> <ResourceDictionary Source=\"pack://application:,,,/DBTools.HandyControl;component/Themes/SkinDark.xaml\"/> <ResourceDictionary Source=\"pack://application:,,,/DBTools.HandyControl;component/Themes/Theme.xaml\"/> <!-- Fluent.Ribbon for ribbon windows --> <ResourceDictionary Source=\"pack://application:,,,/DBTools.Fluent.Ribbon;component/Themes/Generic.xaml\" /> <!-- DBTools Custom Themes --> <ResourceDictionary Source=\"App.Tokens.xaml\" /> <ResourceDictionary Source=\"App.Brushes.xaml\" /> <!-- ... additional dictionaries ... --> </ResourceDictionary.MergedDictionaries> Source: csharp/src/DBTools.Themes/Themes/App.Theme.xaml:1-22 BrushKeys.cs - ComponentResourceKey System Defines strongly-typed keys for all theme brushes. This pattern enables brushes to work correctly inside DataTemplate and ControlTemplate boundaries where DynamicResource with string keys may fail. public static class BrushKeys { public static ComponentResourceKey Primary => new(typeof(BrushKeys), \"Brush.Primary\"); public static ComponentResourceKey Secondary => new(typeof(BrushKeys), \"Brush.Secondary\"); // ... 100+ additional keys } Usage in XAML: <Border Background=\"{DynamicResource {x:Static theme:BrushKeys.Primary}}\" /> Source: csharp/src/DBTools.Themes/BrushKeys.cs:1-140 Design Tokens Design tokens provide consistent spacing, sizing, typography, and other visual constants. Spacing Tokens Token Value Usage Spacing4 4px Tight spacing (icon margins) Spacing8 8px Standard spacing Spacing12 12px Medium spacing Spacing16 16px Large spacing Spacing32 32px Section spacing Scalar variants (Spacing8.Value, etc.) are provided for properties that require Double instead of Thickness. Source: csharp/src/DBTools.Themes/Themes/App.Tokens.xaml:5-18 Padding Tokens Token Value Usage Pad4 4px uniform Compact padding Pad8 8px uniform Standard padding Pad16 16px uniform Large padding Pad8x4 8px H, 4px V Button padding Card.Padding 16px H, 12px V Card content Source: csharp/src/DBTools.Themes/Themes/App.Tokens.xaml:24-56 Gap Tokens Directional margins for layout: Token Value Description TGap8 Top 8px Top margin BGap8 Bottom 8px Bottom margin LGap8 Left 8px Left margin RGap8 Right 8px Right margin VGap8 Top/Bottom 8px Vertical margin HGap8 Left 8px Horizontal gap Source: csharp/src/DBTools.Themes/Themes/App.Tokens.xaml:30-64 Typography Tokens Token Size Usage FontSize.Caption 11px Captions, timestamps FontSize.Body.Small 12px Secondary text FontSize.Body 13px Default body text FontSize.Subtitle 14px Subtitles FontSize.Title 16px Section titles FontSize.Header 20px Page headers Source: csharp/src/DBTools.Themes/Themes/App.Tokens.xaml:66-72 Corner Radius Tokens Token Value Usage Radius4 4px Buttons, inputs Radius6 6px Cards, chips Radius8 8px Dialogs, overlays Radius12 12px Large surfaces Source: csharp/src/DBTools.Themes/Themes/App.Tokens.xaml:43-46 Control Size Tokens Token Value Usage MinHeight.Control 32px Minimum control height Size.CheckBox.Box 18px Checkbox dimensions Size.ToggleTrack.Width 44px Toggle switch track Size.DataGridRow.MinHeight 32px Grid row height Size.ScrollBar.Width 10px Scrollbar width Source: csharp/src/DBTools.Themes/Themes/App.Tokens.xaml:98-114 Color System (App.Brushes.xaml) The color system is built around the DBTools brand colors with carefully designed semantic roles. Brand Colors Key Color Description Primary #1946B9 Deep blue - primary actions PrimaryLight #3D6AD4 Hover state PrimaryDark #0D2E7A Pressed state Secondary #FEC425 Golden yellow - accents SecondaryLight #FFD54F Hover state SecondaryDark #C79100 Pressed state Source: csharp/src/DBTools.Themes/Themes/App.Brushes.xaml:14-19 Surface Colors Neutral dark palette with reduced blue tint: Key Color Description Paper #181820 Window background Surface #222228 Card/panel background SurfaceAlt #1C1C22 Alternate surface SurfaceHover #2A2A32 Hover state CardSurface #1E1E24 Card background CardSurfaceElevated #282830 Elevated cards Source: csharp/src/DBTools.Themes/Themes/App.Brushes.xaml:24-30 Text Colors (WCAG Compliant) Key Color Contrast Description Body / Text #E6E6E6 ~12:1 Primary text BodyLight / TextSecondary #BDBDBD ~9:1 Secondary text TextMuted / Muted #999999 ~7:1 Muted text OnAccent #FFFFFF - Text on colored bg OnSecondary #181820 - Text on yellow Source: csharp/src/DBTools.Themes/Themes/App.Brushes.xaml:35-44 Selection & Highlight Colors Alpha transparency reference: #33 = 20%, #44 = 27%, #55 = 33%, #66 = 40%, #99 = 60% Key Color Description Selection #441946B9 (27%) Standard selection SelectionStrong #661946B9 (40%) Strong selection SelectionGold #33FEC425 (20%) Row highlighting SelectionGoldStrong #55FEC425 (33%) Strong gold Hover #33FEC425 (20%) Hover state Source: csharp/src/DBTools.Themes/Themes/App.Brushes.xaml:59-78 Status Colors Key Color Description Success #4CAF50 Success state Warning #FFA000 Warning state Error #CF6679 Error state Info #1946B9 Informational Each status color has Light and Background variants for subtle backgrounds. Source: csharp/src/DBTools.Themes/Themes/App.Brushes.xaml:84-95 Specialized Brush Categories The brush system includes specialized categories for: DataGrid: Header, row, cell, selection colors Input Controls: Background, border, focus states Buttons: Primary, secondary, accent, danger variants Checkbox/Toggle: Box, checked, indeterminate states Tabs: Background, indicator, hover states ScrollBar/Slider: Track, thumb, hover/pressed states VTC Diff View: Add/remove/missing background colors Source: csharp/src/DBTools.Themes/Themes/App.Brushes.xaml:100-232 BrushKeys System Why ComponentResourceKey? WPF has a limitation where DynamicResource with string keys doesn't always resolve correctly inside DataTemplate or ControlTemplate boundaries. ComponentResourceKey solves this by creating type-safe keys that the resource system can resolve across template boundaries. Key Categories The BrushKeys class defines 100+ keys organized into categories: Category Example Keys Count Brand Primary, Secondary, PrimaryLight 6 Surface Paper, Surface, CardSurface 7 Text Body, Text, TextMuted 10 Border Border, Divider, BorderSubtle 4 Selection Selection, SelectionGold, Hover 12 Status Success, Warning, Error, Info 12 DataGrid DataGridHeader, DataGridRow, etc. 14 Input InputBackground, InputBorder 5 Button ButtonPrimary, ButtonDanger 10 Checkbox CheckBox, CheckChecked 6 Toggle ToggleTrackOn, ToggleThumb 7 Tab TabBackground, TabIndicator 5 ScrollBar ScrollBarTrack, ScrollBarThumb 4 Slider SliderTrack, SliderThumb 5 Progress ProgressTrack, ProgressFill 3 Toolbar ToolbarChipBackground, etc. 6 VTC Diff VtcDiffAddBackground, etc. 4 Source: csharp/src/DBTools.Themes/BrushKeys.cs:11-139 Usage Pattern In XAML: xmlns:theme=\"clr-namespace:DBTools.Themes;assembly=DBTools.Themes\" <Border Background=\"{DynamicResource {x:Static theme:BrushKeys.CardSurface}}\" BorderBrush=\"{DynamicResource {x:Static theme:BrushKeys.CardBorder}}\" /> In Code: var brush = (Brush)FindResource(BrushKeys.Primary); Control Styles Window Styles The theme provides implicit styles for DbtWindowBase and DbtRibbonWindowBase: Sets the DBTools icon Applies Paper background and Body foreground Includes progress overlay support via ProgressOverlayService Source: csharp/src/DBTools.Themes/Themes/App.Controls.Base.xaml:13-55 Base Control Styles TextBlock Foreground: Body brush TextWrapping: Wrap TextTrimming: CharacterEllipsis Button MinWidth: 88px, MinHeight: 36px Hover: SecondaryHover background, Secondary border Pressed: PrimaryHover background, Primary border TextBox Background: InputBackground Border: InputBorder (hover: Secondary, focus: FocusBorder) Validation error: Red border with tooltip ComboBox Custom dropdown template with dark popup background Drop shadow effect on dropdown Proper dark theme item highlighting CheckBox / RadioButton Custom templates with theme-consistent colors Checked: CheckChecked background Indeterminate: CheckIndeterminate fill (yellow) Source: csharp/src/DBTools.Themes/Themes/App.Controls.Base.xaml:61-449 DataGrid Styles Comprehensive DataGrid theming with: Row Features: Yellow accent stripe on left edge Gold hover highlighting (DataGridRowHover) Blue selection with yellow accent (DataGridRowSelected) Keyboard focus indicator (DataGridRowFocus) Cell Features: Focus state with primary border Edit mode with secondary border Conflict highlighting support Column Header: Hover state Sort direction indicators (yellow arrows) Resizable column grippers Source: csharp/src/DBTools.Themes/Themes/App.DataGrid.xaml:1-476 Component Styles (App.Components.xaml) Higher-level UI component styles: Style Key Target Description ToolBar ToolBar Dark themed toolbar StatusBar StatusBar Dark themed status bar ToolbarChip ToggleButton Pill-shaped filter buttons OverlayCard Border Modal dialog container Card Border Standard card surface Card.Elevated Border Card with drop shadow Dbt.Section GroupBox Section with accent stripe Dbt.Callout Border Info callout box WarningBar Border Warning message container Typography Styles: HeaderText, SubtitleText, BodyText, DescriptionText, CaptionText Source: csharp/src/DBTools.Themes/Themes/App.Components.xaml:1-414 Menu Styles Custom templates for proper dark theme rendering in Revit: ContextMenu: Dark background, rounded corners, drop shadow MenuItem: Hover highlighting, keyboard shortcut display MenuSeparator: Subtle divider Source: csharp/src/DBTools.Themes/Themes/App.Menus.xaml:1-136 Vendored Library Integration Why Vendored Libraries? Revit hosts multiple add-ins that may use conflicting versions of UI libraries like HandyControl or Fluent.Ribbon. By vendoring and renaming these libraries, DBTools avoids: Assembly version conflicts Resource dictionary collisions pyRevit theme interference Vendored Assemblies Original Vendored Purpose HandyControl DBTools.HandyControl Control library foundation Fluent.Ribbon DBTools.Fluent.Ribbon Ribbon window support ControlzEx DBTools.ControlzEx Window chrome (dependency) <Reference Include=\"DBTools.HandyControl\"> <HintPath>$(DBT_VendorArtifactsRoot)handycontrol\\$(TargetFramework)\\DBTools.HandyControl.dll</HintPath> </Reference> Source: csharp/src/DBTools.Themes/DBTools.Themes.csproj:55-71 Fluent.Ribbon Theme Bridge App.FluentRibbon.xaml provides a complete dark theme override with 196 brush key mappings to integrate Fluent.Ribbon with the DBTools color system. Key integrations: Window chrome (title bar, caption buttons) Ribbon tabs and groups All control variants (buttons, checkboxes, textboxes) Gallery and backstage views Source: csharp/src/DBTools.Themes/Themes/App.FluentRibbon.xaml:1-575 Build Configuration Target Frameworks The project multi-targets: net48 (Revit 2024 and earlier) net8.0-windows (Revit 2025+) XAML Compilation Some XAML files are kept as raw resources (not compiled to BAML) to avoid requiring a project reference to DBTools.Core: <Page Remove=\"Themes\\App.Converters.xaml\" /> <Resource Include=\"Themes\\App.Converters.xaml\" /> Source: csharp/src/DBTools.Themes/DBTools.Themes.csproj:38-46 Dependency Rules Critical: DBTools.Themes must NOT reference DBTools.Core to avoid circular dependencies. Theme dictionaries that need Core types are defined in Core and merged via pack URIs. Source: csharp/src/DBTools.Themes/DBTools.Themes.csproj:31-34 How to Extend Adding New Brushes Add the ComponentResourceKey to BrushKeys.cs: public static ComponentResourceKey MyNewBrush => new(typeof(BrushKeys), \"Brush.MyNew\"); Define the brush in App.Brushes.xaml: <SolidColorBrush x:Key=\"{x:Static theme:BrushKeys.MyNewBrush}\" Color=\"#FF123456\" /> Adding New Tokens Add to App.Tokens.xaml following existing patterns: <sys:Double x:Key=\"Size.MyNew\">24</sys:Double> <Thickness x:Key=\"Pad.MyNew\">8,4</Thickness> Creating New Control Styles For base controls, add to App.Controls.Base.xaml For higher-level components, add to App.Components.xaml Use DynamicResource with BrushKeys for all colors Use token resources for spacing/sizing Adding Converters Implement converter in DBTools.Core.UI.Converters Add resource entry in App.Converters.xaml: <conv:MyConverter x:Key=\"Converter.MyConverter\" /> Cross-References Theme System Architecture - Detailed architecture documentation DBTools.Core - Theme loading and initialization Value Converters Available converters (defined in App.Converters.xaml): Key Type Description Converter.BoolToVisibility BooleanToVisibilityConverter Standard bool-to-visibility Converter.InverseBoolToVisibility InverseBooleanToVisibilityConverter Inverted visibility Converter.NullToVisibility NullToVisibilityConverter Collapsed when not null Converter.NullToInverseVisibility NullToInverseVisibilityConverter Collapsed when null Converter.RowKindToVisibility RowKindToVisibilityConverter DataGrid row type filtering Source: csharp/src/DBTools.Themes/Themes/App.Converters.xaml:1-12"
  },
  "articles/tools/common/elements-from-list-3d.html": {
    "href": "articles/tools/common/elements-from-list-3d.html",
    "title": "Elements From List 3D | DB Tools",
    "summary": "Elements From List 3D Elements From List 3D is a utility tool module that provides two related commands for creating and visualizing 3D elements in Revit: placing family instances from CSV coordinate data, and creating filled regions from selected wall and caisson elements. Overview The tool module contains two ribbon commands: Command Description Availability 3D Elements From List Creates family instances at coordinates specified in a CSV file Document open Filled Regions From Elements Creates filled regions from selected walls and caissons Elements selected Source: csharp/src/Tools/Common/3DElementsFromList/manifest.yml:6-24 Features 3D Elements From List Command CSV Import: Reads coordinate data from user-selected CSV files Flexible Column Ordering: Supports any column order with case-insensitive headers Optional ID Column: Maps CSV id field to element parameter Auto-Family Loading: Automatically loads the required family if not present in project Multi-Format Support: Handles integers, decimals, negative values, and scientific notation Source: csharp/src/Tools/Common/3DElementsFromList/Features/ElementsFromList3DCommand.cs:13-72 Filled Regions From Elements Command Wall Support: Creates rectangular filled regions from wall bounding boxes Caisson Support: Creates circular filled regions from caisson diameter parameters Style Matching: Uses \"solid gray\" non-masking filled region type Invisible Lines: Applies invisible line style to region boundaries Automatic Comments: Sets \"DB Tools\" comment on created regions Source: csharp/src/Tools/Common/3DElementsFromList/Features/FilledRegionsFromElementsCommand.cs:12-62 Architecture Module Structure csharp/src/Tools/Common/3DElementsFromList/ +-- ElementsFromList3DToolModule.cs # Tool module registration +-- DBTools.ElementsFromList3D.csproj # Project file +-- manifest.yml # Tool manifest +-- Features/ | +-- ElementsFromList3DCommand.cs # CSV import command | +-- FilledRegionsFromElementsCommand.cs # Filled region command | +-- CsvCoordinateParser.cs # Pure CSV parsing logic | +-- CsvElementPlacer.cs # Element placement service | +-- FilledRegionCreator.cs # Region creation service +-- Assets/ | +-- 3d_elements_icon.png # Command icon | +-- filled_regions_icon.png # Command icon +-- Tests/ +-- CsvCoordinateParserTests.cs # Parser unit tests +-- TEST_SUMMARY.md # Test documentation Source: Directory structure of csharp/src/Tools/Common/3DElementsFromList/ Data Flow +------------------------+ | ElementsFromList3DCommand | +-----------+------------+ | (User selects CSV file) | v +------------------------+ | CsvCoordinateParser | | (Pure parsing logic) | +-----------+------------+ | (CoordinateRecords) | v +------------------------+ | CsvElementPlacer | | (Revit integration) | +-----------+------------+ | +-----------------+-----------------+ | | v v +------------------+ +-------------------+ | FamilyLoader | | Transaction | | (Load/find family)| | (Create instances)| +------------------+ +-------------------+ Separation of Concerns The tool follows a clean separation pattern: Layer Class Responsibility Command ElementsFromList3DCommand Entry point, file selection, result display Parsing CsvCoordinateParser Pure CSV logic, no Revit/file dependencies Placement CsvElementPlacer Revit API integration, transaction management Source: csharp/src/Tools/Common/3DElementsFromList/Features/CsvCoordinateParser.cs:59-63 Key Classes Entry Points Class File Purpose ElementsFromList3DToolModule ElementsFromList3DToolModule.cs:5-7 Empty tool module; uses manifest-driven registration ElementsFromList3DCommand Features/ElementsFromList3DCommand.cs:17-72 CSV import command entry point FilledRegionsFromElementsCommand Features/FilledRegionsFromElementsCommand.cs:16-62 Filled region command entry point Source: csharp/src/Tools/Common/3DElementsFromList/ElementsFromList3DToolModule.cs:5-7 Domain Types Type File Purpose CoordinateRecord Features/CsvCoordinateParser.cs:12-35 Immutable struct holding X, Y, Z, and optional ID CsvParseResult Features/CsvCoordinateParser.cs:40-57 Result type with success/failure semantics Source: csharp/src/Tools/Common/3DElementsFromList/Features/CsvCoordinateParser.cs:12-35 Services Class File Purpose CsvCoordinateParser Features/CsvCoordinateParser.cs:63-153 Static parser with Parse(), ParseContent(), ParseFile() methods CsvElementPlacer Features/CsvElementPlacer.cs:17-143 Creates family instances from coordinate records FilledRegionCreator Features/FilledRegionCreator.cs:16-248 Creates filled regions from walls and caissons Source: csharp/src/Tools/Common/3DElementsFromList/Features/CsvElementPlacer.cs:17-31 CSV Format The CSV parser accepts files with the following format: Required Columns x - X coordinate (feet in Revit internal units) y - Y coordinate (feet in Revit internal units) z - Z coordinate (feet in Revit internal units) Optional Columns id - Identifier string (written to element's \"ID\" parameter if available) Format Rules Feature Behavior Header case Case-insensitive (X, x, X all valid) Column order Any order allowed Extra columns Ignored Whitespace Trimmed from headers and values Empty rows Skipped Invalid rows Skipped (row with unparseable numbers) Number format Integer, decimal, negative, scientific notation Line endings Windows (\\r\\n), Unix (\\n), Mac (\\r) Source: csharp/src/Tools/Common/3DElementsFromList/Features/CsvCoordinateParser.cs:70-114 Example CSV id,x,y,z P001,100.5,200.25,10.0 P002,150.0,250.5,10.0 P003,200.75,300.0,10.0 Source: csharp/src/Tools/Common/3DElementsFromList/Tests/CsvCoordinateParserTests.cs:453-471 Configuration Manifest id: DBTools.ElementsFromList3D assembly: DBTools moduleType: DBTools.ElementsFromList3D.ElementsFromList3DToolModule order: 0 tool: ribbonTools: - internalName: DBTools.ElementsFromList3D commandType: DBTools.ElementsFromList3D.ElementsFromList3DCommand availabilityType: DBTools.App.Tools.Availability.DbtDocumentAvailability runProfile: InlineUi displayText: \"3D Elements\\nFrom List\" iconBaseKey: 3d_elements tooltip: \"Create 3D elements from a CSV file\" controlKind: PushButton order: 10 - internalName: DBTools.FilledRegionsFromElements commandType: DBTools.ElementsFromList3D.FilledRegionsFromElementsCommand availabilityType: DBTools.App.Tools.Availability.DbtSelectionAvailability runProfile: InlineUi displayText: \"Filled Regions\\nFrom Elements\" iconBaseKey: filled_regions tooltip: \"Create filled regions from selected elements\" controlKind: PushButton order: 11 Source: csharp/src/Tools/Common/3DElementsFromList/manifest.yml:1-24 Availability Conditions Command Availability Type Condition 3D Elements From List DbtDocumentAvailability Any document open Filled Regions From Elements DbtSelectionAvailability Elements selected Source: csharp/src/Tools/Common/3DElementsFromList/manifest.yml:9,18 Family Dependency The 3D Elements command requires a specific family: Property Value File name 3D-Elements-From-List.rfa Family name 3D-Elements-From-List Category Generic Model (OST_GenericModel) Expected parameter ID (string, for CSV ID mapping) Source: csharp/src/Tools/Common/3DElementsFromList/Features/CsvElementPlacer.cs:23-24 The placer first searches for an existing family symbol in the document, then loads from the installed family library path if not found. Source: csharp/src/Tools/Common/3DElementsFromList/Features/CsvElementPlacer.cs:113-142 Filled Region Requirements The Filled Regions command requires specific project resources: Resource Requirement Filled Region Type Name contains \"solid\" AND \"gray\", non-masking Graphics Style <Invisible lines> (exact name) Caisson Family Concrete-Caisson (family name, case-insensitive) Caisson Diameter Type parameter b (double) Source: csharp/src/Tools/Common/3DElementsFromList/Features/FilledRegionCreator.cs:111-140 API Reference CsvCoordinateParser The static parser provides three entry points: public static class CsvCoordinateParser { // Parse from string array (already split lines) public static CsvParseResult Parse(IReadOnlyList<string> lines); // Parse from content string (handles line splitting) public static CsvParseResult ParseContent(string csvContent); // Parse from file path (handles file I/O) public static CsvParseResult ParseFile(string filePath); } Source: csharp/src/Tools/Common/3DElementsFromList/Features/CsvCoordinateParser.cs:72,121,135 CoordinateRecord Immutable value type for parsed coordinates: public readonly struct CoordinateRecord : IEquatable<CoordinateRecord> { public double X { get; } public double Y { get; } public double Z { get; } public string? Id { get; } } Source: csharp/src/Tools/Common/3DElementsFromList/Features/CsvCoordinateParser.cs:12-25 CsvParseResult Result type with explicit success/failure: public sealed class CsvParseResult { public IReadOnlyList<CoordinateRecord> Records { get; } public string? Error { get; } public bool IsSuccess => Error == null; public static CsvParseResult Success(IReadOnlyList<CoordinateRecord> records); public static CsvParseResult Failure(string error); } Source: csharp/src/Tools/Common/3DElementsFromList/Features/CsvCoordinateParser.cs:40-57 CsvElementPlacer Creates elements within a transaction: public sealed class CsvElementPlacer { public CsvElementPlacer(ITransactionRunner tx, Document doc, ILogger logger); public (int CreatedCount, int FailedCount, string? ErrorMessage) Run(string csvPath); } Source: csharp/src/Tools/Common/3DElementsFromList/Features/CsvElementPlacer.cs:26-33 FilledRegionCreator Creates filled regions from selected elements: public sealed class FilledRegionCreator { public FilledRegionCreator(ITransactionRunner tx, Document doc, View activeView, ILogger logger); public (int CreatedCount, int SkippedCount) Run(ICollection<ElementId> selectedIds); } Source: csharp/src/Tools/Common/3DElementsFromList/Features/FilledRegionCreator.cs:23-31 Testing The tool includes comprehensive unit tests for the CSV parser: Test Categories Category Test Count Description Basic Success Cases 5 Valid CSV parsing scenarios Column Order Variations 4 Different header orderings Whitespace Handling 4 Trimming and empty row skipping Number Formats 6 Integer, negative, scientific notation Error Cases 6 Null, empty, missing columns Invalid Data Handling 3 Malformed rows ParseContent (String) 5 Line ending variations CoordinateRecord 5 Equality and hash code CsvParseResult 2 Success/failure factories Integration Scenarios 2 Real-world CSV examples Total: 42 tests Source: csharp/src/Tools/Common/3DElementsFromList/Tests/TEST_SUMMARY.md:14-104 Running Tests # Build test assemblies bash csharp/build.sh BuildTests # Run parser tests (headless, no Revit required) dotnet test csharp/testing/DBTools.BuildArtifacts.Tests/DBTools.BuildArtifacts.Tests.csproj \\ -c Release --filter \"FullyQualifiedName~CsvCoordinateParser\" Source: csharp/src/Tools/Common/3DElementsFromList/Tests/DBTools.ElementsFromList3D.Tests.csproj:19-20 User Workflow Creating 3D Elements Click 3D Elements From List in the ribbon Select a CSV file with x, y, z columns Tool parses CSV and validates format Family is loaded if not present Elements are created at each coordinate Summary dialog shows created/failed counts Creating Filled Regions Select wall or caisson elements in the view Click Filled Regions From Elements in the ribbon Tool identifies element types (wall vs. caisson) For walls: creates rectangular regions from bounding box For caissons: creates circular regions from diameter Summary dialog shows created/skipped counts Error Handling The tool follows DBTools error handling conventions: Error Condition Behavior CSV file not found Returns error message, no elements created Missing x/y/z columns Returns error message with column requirement Invalid number format Skips row, continues processing Family not found Attempts auto-load; fails with clear message if unavailable No levels in document Throws with descriptive message No selection (regions) Throws with user instruction No suitable region type Logs warning, returns with all skipped Source: csharp/src/Tools/Common/3DElementsFromList/Features/CsvElementPlacer.cs:36-45 All commands display results via the alert service with appropriate variant (Info/Error). Source: csharp/src/Tools/Common/3DElementsFromList/Features/ElementsFromList3DCommand.cs:49-66 Related Documentation Architecture Overview - DBTools architecture and tool discovery Global Mapper - Example of a complex tool module Source Files Reviewed File Purpose manifest.yml Tool declaration and ribbon configuration ElementsFromList3DToolModule.cs Module registration ElementsFromList3DCommand.cs CSV import command FilledRegionsFromElementsCommand.cs Filled region command CsvCoordinateParser.cs Pure CSV parsing logic CsvElementPlacer.cs Element creation service FilledRegionCreator.cs Region creation service DBTools.ElementsFromList3D.csproj Project configuration CsvCoordinateParserTests.cs Unit tests TEST_SUMMARY.md Test documentation"
  },
  "articles/tools/common/elevation-tags.html": {
    "href": "articles/tools/common/elevation-tags.html",
    "title": "Elevation Tags | DB Tools",
    "summary": "Elevation Tags Elevation Tags is a Revit add-in tool that automatically aligns spot elevation tags in floor and ceiling plan views, ensuring consistent text positioning relative to leader endpoints. Overview Elevation Tags provides two modes of operation: Automatic Update: Tags are aligned when activating floor/ceiling plan views Manual Update: Users can trigger alignment on-demand via the ribbon button The tool calculates precise text positioning based on: Tag type font metrics (size, width scale, font family) View scale factor Leader direction Configurable offsets and text position preferences Source: csharp/src/Tools/Common/ElevationTags/Features/ElevationTagsAutoUpdater.cs:59-91 Features Feature Description Auto-Update on View Activation Automatically aligns elevation tags when opening floor/ceiling plan views Manual Alignment Command Ribbon button to align tags in the active view on-demand Regex Tag Filtering Configure which tags to align using regex patterns (up to 3 patterns) Text Position Control Position text above or below the tag origin Offset Adjustments Fine-tune horizontal and vertical positioning with model-unit offsets Warning System Tool can be disabled via warnings, preventing accidental auto-updates Source: csharp/src/Tools/Common/ElevationTags/Settings/ElevationTagsSettings.cs:21-56 User Interface Ribbon Button The tool adds a single ribbon button: Display Text: \"Align Elevation Tags\" Tooltip: \"Align elevation tags in the active view\" Icon: align_elevation_tags_icon.png Availability: Only enabled when an active view is present Source: csharp/src/Tools/Common/ElevationTags/manifest.yml:18-26 Settings Panel The settings UI provides controls for: Auto-Update Toggle - Enable/disable automatic updates on view activation Tag Name Patterns - Regex patterns to match elevation tag names (max 3) Alignment Offsets - Horizontal and vertical offset values with spinner controls Text Position - Radio buttons for Above/Below positioning Source: csharp/src/Tools/Common/ElevationTags/Settings/ElevationTagsSettingsPackView.xaml:43-259 Architecture Module Structure csharp/src/Tools/Common/ElevationTags/ +-- DBTools.ElevationTags.csproj # Project file +-- ElevationTagsToolModule.cs # DI registration entry point +-- manifest.yml # Tool manifest +-- Assets/ | +-- align_elevation_tags_icon.png +-- Features/ | +-- AlignElevationTagsInViewCommand.cs # Ribbon command | +-- ElevationTagsAutoUpdater.cs # Core alignment logic +-- Hooks/ | +-- ElevationTagsViewActivatedTask.cs # View activation handler +-- Settings/ +-- ElevationTagsSettings.cs # Settings model +-- ElevationTagsSettingsPackContext.cs # Settings UI context +-- ElevationTagsSettingsPackView.xaml # Settings UI view +-- ElevationTagsSettingsPackView.xaml.cs Source: Directory structure of csharp/src/Tools/Common/ElevationTags/ Data Flow +---------------------------+ | View Activation / Command | +-----------+---------------+ | v +---------------------------+ | ElevationTagsViewActivated| | Task / Command | +-----------+---------------+ | | Retrieves settings, creates updater v +---------------------------+ | ElevationTagsAutoUpdater | +-----------+---------------+ | +----------------------+----------------------+ | | | v v v +--------------+ +-----------------+ +------------------+ | Collect Tags | | Compute Layout | | Update Positions | | (Regex Match)| | Inputs | | (Transaction) | +--------------+ +-----------------+ +------------------+ Key Classes Class File Purpose ElevationTagsToolModule ElevationTagsToolModule.cs:14-92 Tool module registration; registers settings, services, and settings packs AlignElevationTagsInViewCommand Features/AlignElevationTagsInViewCommand.cs:19-48 Ribbon command entry point; creates updater and runs alignment ElevationTagsAutoUpdater Features/ElevationTagsAutoUpdater.cs:15-232 Core alignment logic; computes text positions and updates spot dimensions ElevationTagsViewActivatedTask Hooks/ElevationTagsViewActivatedTask.cs:20-66 View activation hook; triggers auto-update on floor/ceiling plan views ElevationTagsSettings Settings/ElevationTagsSettings.cs:21-56 Settings model with default values ElevationTagsSettingsPackContext Settings/ElevationTagsSettingsPackContext.cs:18-242 MVVM context for settings UI with validation Source: csharp/src/Tools/Common/ElevationTags/ElevationTagsToolModule.cs:14-92 Alignment Algorithm The ElevationTagsAutoUpdater.TryUpdateSpot() method performs the alignment calculation: Extract Tag Properties Origin position, leader end position, current text position Tag type parameters (text height, width scale, font name) Elevation base setting (Project Base Point, Survey Point, Relative) Format Elevation Value Apply elevation indicator prefix/suffix Format using document unit settings Measure Text Use GDI+ to measure formatted text string Account for font size scaled to view Calculate New Position Horizontal offset based on text width and leader direction Vertical offset based on text height and position setting (Above/Below) Apply user-configured offset adjustments Update Position Only update if position changed (rounded to 2 decimal places) Set SpotDimension.TextPosition to new XYZ Source: csharp/src/Tools/Common/ElevationTags/Features/ElevationTagsAutoUpdater.cs:145-231 View Activation Hook The ElevationTagsViewActivatedTask implements ViewActivatedTaskBase<ElevationTagsSettings>: protected override Task<bool> ShouldRunInternalAsync( UIApplication uiapp, ViewActivatedEventArgs args, ElevationTagsSettings settings, CancellationToken ct) { var view = app.ActiveUIDocument?.Document?.ActiveView; if (view == null) return Task.FromResult(false); return Task.FromResult( view.ViewType == ViewType.FloorPlan || view.ViewType == ViewType.CeilingPlan); } The task only runs when: Auto-update is enabled in settings No active warning is set The activated view is a floor plan or ceiling plan Source: csharp/src/Tools/Common/ElevationTags/Hooks/ElevationTagsViewActivatedTask.cs:40-52 Settings Settings Model public sealed class ElevationTagsSettings : IAutoUpdateSettings { /// <summary>Whether auto-update on view activation is enabled.</summary> public bool AutoUpdateEnabled { get; set; } = true; /// <summary>Whether a warning has been set (disables auto-update).</summary> public bool HasWarning { get; set; } /// <summary> /// Regex patterns to match tag names. Tags matching any pattern will be aligned. /// Default pattern matches tags starting with \"DB Elevation Tag\". /// Maximum of 3 patterns. /// </summary> public List<string> TagNamePatterns { get; set; } = new() { \"^DB Elevation Tag\" }; /// <summary>Horizontal offset factor applied during text positioning (model units).</summary> public double HorizontalOffset { get; set; } /// <summary>Vertical offset factor applied during text positioning (model units).</summary> public double VerticalOffset { get; set; } /// <summary>Position of aligned text relative to the tag origin.</summary> public ElevationTextPosition TextPosition { get; set; } = ElevationTextPosition.Above; } Source: csharp/src/Tools/Common/ElevationTags/Settings/ElevationTagsSettings.cs:21-56 Text Position Enum public enum ElevationTextPosition { /// <summary>Text is positioned above the tag origin.</summary> Above = 0, /// <summary>Text is positioned below the tag origin.</summary> Below = 1 } Source: csharp/src/Tools/Common/ElevationTags/Settings/ElevationTagsSettings.cs:9-16 Default Values Setting Default Value Description AutoUpdateEnabled true Auto-update is enabled by default HasWarning false No warning set initially TagNamePatterns [\"^DB Elevation Tag\"] Matches tags starting with \"DB Elevation Tag\" HorizontalOffset 0.0 No additional horizontal offset VerticalOffset 0.0 No additional vertical offset TextPosition Above Text positioned above the tag origin Configuration Section Settings are stored under the Tools.ElevationTags configuration section. Source: csharp/src/Tools/Common/ElevationTags/manifest.yml:7 Manifest id: DBTools.ElevationTags assembly: DBTools moduleType: DBTools.ElevationTags.ElevationTagsToolModule order: 0 tool: settings: configSection: Tools.ElevationTags settingsPacks: - key: common.elevation_tags title: \"Elevation Tags\" warnings: - id: core.structural.elevation_tags title: \"Elevation Tags Disabled\" message: \"Elevation tag alignment is disabled due to a warning. Clear the warning to re-enable.\" disableTools: - DBTools.AlignElevationTagsInView ribbonTools: - internalName: DBTools.AlignElevationTagsInView commandType: DBTools.ElevationTags.AlignElevationTagsInViewCommand availabilityType: DBTools.App.Tools.Availability.DbtActiveViewAvailability runProfile: InlineUi displayText: \"Align Elevation\\nTags\" iconBaseKey: align_elevation_tags tooltip: \"Align elevation tags in the active view\" controlKind: PushButton order: 20 Source: csharp/src/Tools/Common/ElevationTags/manifest.yml:1-27 Manifest Properties Property Value Description id DBTools.ElevationTags Unique tool identifier assembly DBTools Target assembly name moduleType DBTools.ElevationTags.ElevationTagsToolModule Entry point class order 0 Load order priority configSection Tools.ElevationTags Settings configuration key runProfile InlineUi Runs on UI thread with inline modal gate availabilityType DbtActiveViewAvailability Command available when active view exists Warning System The tool defines a single warning that can disable functionality: Warning ID: core.structural.elevation_tags Title: \"Elevation Tags Disabled\" Effect: When active, disables the AlignElevationTagsInView command and auto-update When the warning is set: HasWarning becomes true AutoUpdateEnabled is forced to false The toggle in settings is disabled Source: csharp/src/Tools/Common/ElevationTags/ElevationTagsToolModule.cs:47-68 API Reference ElevationTagsAutoUpdater The main alignment class that processes spot elevation tags: public sealed class ElevationTagsAutoUpdater { public ElevationTagsAutoUpdater( ITransactionRunner tx, Document doc, View activeView, ILogger<ElevationTagsAutoUpdater> logger, ElevationTagsSettings? settings = null); /// <summary> /// Runs the alignment process and returns the count of updated tags. /// Only processes floor plan and ceiling plan views. /// </summary> public int Run(); } Source: csharp/src/Tools/Common/ElevationTags/Features/ElevationTagsAutoUpdater.cs:27-91 Filtering Logic Tags are collected using a FilteredElementCollector scoped to the active view: var tags = new FilteredElementCollector(_doc, _view.Id) .OfCategory(BuiltInCategory.OST_SpotElevations) .WhereElementIsNotElementType() .ToElements(); Each tag's name is tested against all configured regex patterns. Tags matching any pattern are included. Source: csharp/src/Tools/Common/ElevationTags/Features/ElevationTagsAutoUpdater.cs:96-122 Elevation Base Handling The tool respects the elevation base setting on tag types: Base Setting Behavior Survey Point Uses raw elevation value Project Base Point Subtracts project base point Z from elevation Relative Tag is skipped (not aligned) Source: csharp/src/Tools/Common/ElevationTags/Features/ElevationTagsAutoUpdater.cs:166-170 Troubleshooting Common Issues Issue Cause Resolution Tags not aligning No patterns match tag names Add regex pattern matching your tag family names Auto-update not running Warning is active Clear the warning in settings panel Auto-update not running Disabled in settings Enable auto-update toggle No tags in view View type not supported Only floor and ceiling plans are processed Invalid regex pattern Syntax error in pattern Check regex syntax; patterns are validated Tags with Relative base skipped By design Tags with Relative elevation base cannot be aligned Logging The tool logs diagnostic information via ILogger<ElevationTagsAutoUpdater>: Invalid regex patterns are logged as warnings Tags that fail to filter or update are logged (first occurrence only) Units format option errors are logged _logger.LogWarning(ex, \"[ElevationTags] Invalid regex pattern '{Pattern}'; skipping.\", pattern); _logger.LogWarning(\"[ElevationTags] No valid tag name patterns are configured; auto-update will be skipped.\"); _logger.LogWarning(ex, \"[ElevationTags] Some elevation tags could not be updated; continuing.\"); Source: csharp/src/Tools/Common/ElevationTags/Features/ElevationTagsAutoUpdater.cs:51-189 Related Documentation Architecture Overview - DBTools architecture fundamentals Theme System - UI theming for settings panels Source Files Reviewed File Purpose manifest.yml Tool declaration and ribbon configuration ElevationTagsToolModule.cs Module registration and DI setup AlignElevationTagsInViewCommand.cs Ribbon command entry point ElevationTagsAutoUpdater.cs Core alignment algorithm ElevationTagsViewActivatedTask.cs View activation hook ElevationTagsSettings.cs Settings model definition ElevationTagsSettingsPackContext.cs Settings UI view model ElevationTagsSettingsPackView.xaml Settings UI layout DBTools.ElevationTags.csproj Project configuration"
  },
  "articles/tools/common/gm.html": {
    "href": "articles/tools/common/gm.html",
    "title": "Global Mapper (GM) | DB Tools",
    "summary": "Global Mapper (GM) Global Mapper is a comprehensive Revit type-mapping tool that enables users to detect, plan, and apply bulk element replacements across families, types, materials, line styles, object styles, and shared parameters. Overview Global Mapper provides a unified interface for: Family/Type Mapping: Replace family instances with equivalent types from other families Duplicate Detection: Identify potential duplicate elements using similarity analysis Usage Analysis: Understand material, line style, and object style usage across families Deep Scan: Analyze family document contents to extract parameter names, style refs, and material refs Shared Parameter Authoring: Bind and embed shared parameters to families/categories Source: csharp/src/Tools/Common/GM/manifest.yml:1-26 Features Feature Description Duplicates Tab Detects potential duplicate families, materials, styles, and shared parameters using weighted similarity scoring Families Tab Browse families by category, select target mappings, and configure type replacements Line Styles Tab View and map line style usage with visual preview Object Styles Tab View and map object style usage with visual preview Materials Tab View and map material usage with color preview Shared Parameters Tab Manage shared parameter bindings across categories and families Deep Scan Analyze family documents to extract embedded parameter names, style references, and material references Mapping Persistence Save and restore mapping preferences per-project Conflict Detection Identify conflicting mappings before applying changes Source: csharp/src/Tools/Common/GM/Shell/UI/Views/GmWindow.xaml:293-361 (Ribbon tab definitions) User Interface The GM window uses a Fluent Ribbon with six main tabs: Duplicates (Index 0) - Duplicate detection and resolution Families (Index 1) - Family/type mapping with category filtering Line Styles (Index 2) - Line style replacement with preview Object Styles (Index 3) - Object style replacement with preview Materials (Index 4) - Material replacement with color preview Shared Parameters (Index 5) - Parameter binding and authoring Each tab provides: A main DataGrid with source items and target selection dropdowns Row expansion for nested details (types within families, pairs within duplicate groups) Visual previews where applicable (color swatches, style weights) Action buttons for applying changes Source: csharp/src/Tools/Common/GM/Shell/UI/Views/GmWindow.xaml:365-576 Global Header Controls The header bar provides cross-tab controls: Search: Filter visible items by name Threshold Slider: Adjust similarity scoring threshold (0-100%) Sort Mode: Toggle between Similarity and Alphabetical ordering Filters: Hide Unused, Hide Unscanned, Applied Only Source: csharp/src/Tools/Common/GM/Shell/UI/Views/GmWindow.xaml:179-288 Architecture Module Structure csharp/src/Tools/Common/GM/ +-- GmToolModule.cs # DI registration entry point +-- Bootstrap/ | +-- GmServiceExtensions.cs # Services.AddGmServices() wrapper +-- Features/ | +-- GmCommand.cs # Ribbon command entry point | +-- Duplicates/ # Duplicate detection feature | +-- Families/ # Family/type mapping feature | +-- Mapping/ # Apply/verify mapping logic | +-- SavedMappings/ # Persistence layer | +-- SharedParameters/ # SP authoring feature | +-- Similarity/ # Name and parameter similarity | +-- Usage/ # Usage index building | +-- DeepScan/ # Family document analysis +-- Shell/ | +-- GmShellLauncher.cs # Window construction | +-- DI/Services.cs # Full DI registration | +-- UI/Views/ # WPF windows and XAML | +-- UI/ViewModels/ # MVVM view models | +-- DesignTime/ # Design-time view models +-- Shared/ | +-- Kernel/ # Domain state (GmProjectState) | +-- Planning/ # Mapping plan generation | +-- Contracts/ # Service interfaces | +-- Caching/ # Cache strategies | +-- Context/ # Planning context | +-- Project/ # Project lifecycle +-- Tests/ # Unit and integration tests Source: Directory structure of csharp/src/Tools/Common/GM/ Data Flow +------------------+ | GmCommand | +--------+---------+ | Resolves services via DI v +------------------+ | GmShellLauncher | +--------+---------+ | Creates window + ViewModel v +-------------------+ | GmShellViewModel | +--------+----------+ | +------------+------------+------------+------------+ | | | | | v v v v v +----------+ +----------+ +---------+ +----------+ +---------+ | Families | | Usage | | Mapping | | Planning | | Kernel | | Pane VM | | Pane VM | | Service | | Service | | State | +----------+ +----------+ +---------+ +----------+ +---------+ Kernel Architecture The GmProjectState is the Single Source of Truth (SSOT) for GM domain state. It holds IDs only - no Revit types leak into the kernel. public sealed class GmProjectState { public long Version { get; set; } public GmSourceSnapshot? SourceSnapshot { get; set; } public Dictionary<int, GmFamilyRecord> Families { get; set; } public GmUsageIndex Usage { get; set; } public GmSharedParameterLedger SharedParameters { get; set; } public GmTabStateSet Tabs { get; set; } public Dictionary<int, string> FamilyNames { get; set; } public Dictionary<int, string> SymbolNames { get; set; } public Dictionary<int, IReadOnlyCollection<(string, string, int)>> NestedOwnerNameIndex { get; set; } } Source: csharp/src/Tools/Common/GM/Shared/Kernel/State/GmProjectState.cs:1-32 The GmKernelMapper provides read-only projections of kernel data for UI consumption: GetLineStyleFamilyCounts() - Style usage counts GetDeepScanStyleRefsByFamily() - DS style references GetDeepScanMaterialRefsByFamily() - DS material references GetDeepScanParamNamesByFamily() - DS parameter names Source: csharp/src/Tools/Common/GM/Shared/Kernel/State/GmKernelMapper.cs:53-264 Key Classes Entry Points Class File Purpose GmToolModule GmToolModule.cs:10-18 Tool module registration; calls AddGmServices() GmCommand Features/GmCommand.cs:31-145 Ribbon command entry point; resolves all services and launches UI GmShellLauncher Shell/GmShellLauncher.cs:35-117 Static launcher creating GmWindow and GmShellViewModel Source: csharp/src/Tools/Common/GM/GmToolModule.cs:10-18 View Models Class File Purpose GmShellViewModel Shell/UI/ViewModels/GmShellViewModel.*.cs Main shell view model (split across partials) FamiliesPaneViewModel Features/Families/FamiliesPaneViewModel.cs:9-36 Families tab state UsagePaneViewModel Features/Usage/UsagePaneViewModel.cs Usage tabs (styles, materials) state DuplicatesPaneViewModel Features/Duplicates/DuplicatesPaneViewModel.cs Duplicates tab state SharedParametersPaneViewModel Features/SharedParameters/SharedParametersPaneViewModel.cs SP tab state Source: csharp/src/Tools/Common/GM/Features/Families/FamiliesPaneViewModel.cs:9-36 Core Services Interface Implementation Purpose IProjectLifecycleService ProjectLifecycleService Build kernel from Revit document IGmPlanningService GmPlanningService Generate normalized mapping plans IGmMappingService GmMappingService Apply plans to Revit document IDuplicateDetectionService DuplicateDetectionService Detect duplicate elements INamingSimilarityService NamingSimilarityService Name-based similarity scoring IParameterSimilarityService ParameterSimilarityService Parameter overlap scoring Source: csharp/src/Tools/Common/GM/Shell/DI/Services.cs:33-106 Revit Adapters Interface Implementation Purpose ITypeChangeService TypeChangeService Replace type on instances IStyleChangeService StyleChangeService Replace line style on curves IMaterialChangeService MaterialChangeServiceWriter Replace material parameters IParameterChangeService ParameterChangeService Copy type parameters IHostChangeService HostChangeService Handle host/placement changes INestingChangeService NestingChangeService Replace nested families by name ITypeCreationService TypeCreationService Create new type symbols IDeepScanService DeepScanServiceAdapter Deep scan family documents Source: csharp/src/Tools/Common/GM/Shell/DI/Services.cs:66-86 Configuration Manifest id: DBTools.GM assembly: DBTools moduleType: DBTools.GM.GmToolModule order: 0 sandboxWindows: - id: DBTools.GM.Main displayName: \"Global Mapper\" group: \"Common\" windowType: \"DBTools.GM.Shell.UI.Views.GmWindow\" designTimeViewModelType: \"DBTools.GM.Shell.DesignTime.GmShellDesignTimeViewModel\" - id: DBTools.GM.MappingReport displayName: \"Global Mapper - Mapping Report\" group: \"Common\" windowType: \"DBTools.GM.Features.Mapping.UI.Views.GmMappingReportWindow\" tool: ribbonTools: - internalName: DBTools.GM commandType: DBTools.GM.Features.GmCommand availabilityType: DBTools.App.Tools.Availability.DbtDocumentAvailability runProfile: InlineUi displayText: \"Global Mapper\" iconBaseKey: gm tooltip: \"Open Global Mapper\" controlKind: PushButton order: 30 Source: csharp/src/Tools/Common/GM/manifest.yml:1-27 Caching GM uses project-scoped caching strategies: Cache Strategy Purpose Deep Scan DeepScanCacheStrategy Cache family document scan results UI State UiStateStrategy Persist UI selections between sessions Saved Mappings SavedMappingService Store user mapping preferences Cache files are stored under %LocalAppData%/DBTools/GM/. Source: csharp/src/Tools/Common/GM/Shell/DI/Services.cs:97-105 API Reference Planning Service The IGmPlanningService generates normalized mapping plans: public interface IGmPlanningService { Task<GmPlanningResult> BuildPlanAsync( IReadOnlyDictionary<int, int> typeMappings, IReadOnlyDictionary<int, int> materialMappings, IReadOnlyDictionary<int, int> styleMappings, CancellationToken ct = default); Task<GmPlanningResult> BuildPlanAsync( IReadOnlyDictionary<int, int> typeMappings, IReadOnlyDictionary<int, int> materialMappings, IReadOnlyDictionary<int, int> styleMappings, IReadOnlyDictionary<int, int> paramMappings, IReadOnlyCollection<(int sourceId, string? newName)> createType, IGmContext? context, CancellationToken ct = default); } Source: csharp/src/Tools/Common/GM/Shared/Planning/IGmPlanningService.cs:8-28 Operation Kinds Plans contain operations of these types: public enum GmOperationKind { ReplaceType, // Replace type on family instances ReplaceMaterial, // Replace material parameters ReplaceStyle, // Replace line/object styles MapParameter, // Copy parameter values between types AddNestedFamily, // Add nested family replacement (by name) ReplaceHost, // Handle host/placement mismatches CreateType, // Create new type symbol BindSharedParameter, // Bind SP at host level EmbedSharedParameter // Embed SP in family document } Source: csharp/src/Tools/Common/GM/Shared/Planning/GmOperationKind.cs:3-14 Mapping Service The IGmMappingService applies plans to the Revit document: public interface IGmMappingService { Task ImportAsync(string path, CancellationToken ct = default); Task ExportAsync(string path, CancellationToken ct = default); Task ImportSimpleAsync(string path, CancellationToken ct = default); Task ExportSimpleAsync(string path, CancellationToken ct = default); Task<GmMappingValidationResult> ValidateAsync(CancellationToken ct = default); Task<GmMappingApplyResult> ApplyAsync(CancellationToken ct = default); Task<GmMappingApplyResult> ApplyPlanAsync(GmPlanningResult plan, IProgress<string>? progress = null, CancellationToken ct = default); Task<GmMappingVerifyResult> VerifyAsync(GmPlanningResult plan, CancellationToken ct = default); Task AddDuplicateMappingsAsync(GmDuplicateApplyBatch batch, CancellationToken ct = default); } Source: csharp/src/Tools/Common/GM/Features/Mapping/IGmMappingService.cs:12-27 Duplicate Detection The IDuplicateDetectionService analyzes the kernel for potential duplicates: public interface IDuplicateDetectionService { Task<DuplicateDetectionResult> DetectAsync(GmProjectState kernel, CancellationToken ct = default); } Detection uses: Families: 70% name similarity + 30% parameter overlap (when DS data available) Styles: Preview signature matching (color, weight, pattern) Materials: Preview + name similarity Shared Parameters: Type display + normalized name Source: csharp/src/Tools/Common/GM/Features/Duplicates/Logic/DuplicateDetectionService.cs:43-98 Testing GM tests use a shared fixture that opens a dedicated test model: [NonParallelizable] public abstract class GmTestFixture { protected const string GmModelFileName = \"gm_test_model.rvt\"; protected UIApplication UiApp { get; private set; } protected Document? Doc { get; private set; } protected IRevitCallGate? Gate { get; private set; } protected ITransactionRunner? TxRunner { get; private set; } } Source: csharp/src/Tools/Common/GM/Tests/GMTestFixture.cs:20-53 Test Categories Test Class Purpose GM_PlanningServiceTests Planning result validation GM_MappingServiceTests Apply/verify cycle testing GM_MappingApplyPlanTests End-to-end plan application DuplicateDetectionServiceTests Duplicate detection accuracy GmKernelMapperTests Kernel projection correctness GmWindowViewModel_*Tests ViewModel behavior tests Running Tests # Build test assemblies bash csharp/build.sh BuildTests # Run via Revit test runner bash csharp/invoke-revit-tests.sh --smart --tool GM -y 2025 Troubleshooting Common Issues Issue Cause Resolution \"No families found\" Category filter too restrictive Select a different category or clear filters Empty duplicate groups Similarity threshold too high Lower the threshold slider Deep scan incomplete Family document errors Check Revit error log; try manual deep scan Mapping not applied Target type not available Verify target family is loaded in project Conflict panel showing Multiple sources map to same target Resolve conflicts in conflict panel Logging GM logs diagnostic information via ILogger. Enable debug logging to see: Kernel build timing Cache hit/miss statistics Plan operation details Apply stage progress _logger.LogDebug(\"GM: scanned {Count} families for categoryId={CategoryId}\", families.Count, SelectedCategory?.Id); Source: csharp/src/Tools/Common/GM/Shell/UI/ViewModels/GmShellViewModel.CoreAndCommands.cs:1043-1045 Related Documentation Architecture Overview - DBTools architecture DBTools.Core - Core infrastructure Test Pipeline - Test infrastructure Verification Status Check Status Source anchors for all claims Yes UNVERIFIED markers where needed No (all verified) Cross-references added Yes Examples tested N/A No assumptions without evidence Yes Verified by: docs-run-20260124-020412 Date: 2026-01-24"
  },
  "articles/tools/common/tdv.html": {
    "href": "articles/tools/common/tdv.html",
    "title": "TDV - Transfer Drafting Views | DB Tools",
    "summary": "TDV - Transfer Drafting Views TDV (Transfer Drafting Views) is a tool for importing and exporting drafting views between Revit documents and a central library. It enables teams to maintain a shared collection of standard drafting views that can be distributed across projects. Source: csharp/src/Tools/Common/TDV/manifest.yml:1-45 Overview TDV provides two primary operations: Export to Library - Copy drafting views from the active document to a central library file Import from Library - Copy drafting views from a library file to the active document The tool handles worksharing, creates local copies for edits, and synchronizes changes back to the central library file after export operations. Source: csharp/src/Tools/Common/TDV/Features/TdvExportCommand.cs:18-27 Features Core Capabilities Bi-directional transfer - Import and export drafting views between documents View type mapping - Map source view types to destination view types, or retain original type Conflict detection - Real-time detection of naming conflicts with existing views Replace mode - Option to replace existing views with the same name Preview panel - Live preview of selected drafting views with pan/zoom support Batch transfer - Transfer multiple views in a single operation Transaction grouping - All transfers wrapped in a transaction group for atomicity Progress tracking - Per-view progress feedback during transfer operations Source: csharp/src/Tools/Common/TDV/Revit/Services/TdvService.cs:106-291 Library Management Multiple library files - Configure multiple library files with fallback paths Path validation - Automatic validation of library file accessibility Local copy workflow - Creates local copies from central files for worksharing Automatic sync - Syncs changes back to central after export with detailed comments Source: csharp/src/Tools/Common/TDV/Revit/Services/TdvDocumentService.cs:26-126 View Transfer Details When transferring views, TDV: Creates or prepares the destination view with the selected view type Copies the view scale and description parameters Copies all elements from the source view (excluding viewports, title blocks, schedules, etc.) Copies element graphic overrides from source to destination Source: csharp/src/Tools/Common/TDV/Revit/Services/TdvOps.cs:145-189 Architecture TDV follows the MVVM pattern with a clean separation between UI, business logic, and Revit API operations. Project Structure csharp/src/Tools/Common/TDV/ ├── Bootstrap/ # DI registration ├── Contracts/ # Interfaces and DTOs ├── DesignTime/ # Design-time view models ├── Features/ # Command implementations ├── Properties/ # Design-time resources ├── Revit/Services/ # Revit API operations ├── Settings/ # Configuration models ├── Tests/ # Unit tests └── UI/ ├── ViewModels/ # MVVM view models └── Views/ # WPF views Service Registration Services are registered as scoped to properly handle Revit's run-scope dependencies: Source: csharp/src/Tools/Common/TDV/Bootstrap/TdvServiceExtensions.cs:11-33 services.AddScoped<ITdvTransferService>(sp => new TdvService(gate, tx, groups, logger)); services.AddScoped<ITdvLibraryService, TdvLibraryService>(); services.AddScoped<ITdvDocumentService, TdvDocumentService>(); Key Interfaces Interface Implementation Purpose ITdvTransferService TdvService Core transfer operations ITdvLibraryService TdvLibraryService Library path management ITdvDocumentService TdvDocumentService Document open/close/sync ITdvContext TdvService.RevitTdvContext Abstraction over Revit Document Source: csharp/src/Tools/Common/TDV/Contracts/ITdvTransferService.cs:1-23 Transfer Service Operations The ITdvTransferService interface defines: Method Description BuildViewItemsAsync Collects drafting views from source document ApplySelectionAsync Executes the transfer operation WouldConflictAsync Checks for naming conflicts ExportPreviewAsync Generates preview image for a view Source: csharp/src/Tools/Common/TDV/Contracts/ITdvTransferService.cs:6-22 UI Components Main Window (TdvWindow) The main transfer window provides: Filter controls - Filter by view type and search by name Data grid - Lists all drafting views with transfer options Preview panel - Shows selected view with pan/zoom Status bar - Displays selection counts and transfer results Source: csharp/src/Tools/Common/TDV/UI/Views/TdvWindow.xaml:1-537 ViewModel (TdvWindowViewModel) Key properties and commands: Property Type Description Items ObservableCollection<TdvViewItem> Filtered list of views Search string Search filter text SelectedViewTypeFilter string View type filter SelectedItem TdvViewItem Currently selected view PreviewSource ImageSource Preview image HasAnyConflict bool Indicates naming conflicts Status string Status bar text Command Description ApplySelectionCommand Executes the transfer ClearSelectedCommand Clears all selections ClearSearchCommand Clears search filter Source: csharp/src/Tools/Common/TDV/UI/ViewModels/TdvWindowViewModel.cs:22-409 View Item (TdvViewItem) Represents a single drafting view in the UI: Property Type Description SourceViewId int Revit element ID ViewName string Editable view name ViewType string Selected destination type ViewTypeName string Original source type name Checked bool Selected for transfer Replace bool Replace if exists HasConflict bool Has naming conflict HasTypeWarning bool Source type unavailable RowState string Transfer status (pending/success/failure) Source: csharp/src/Tools/Common/TDV/UI/ViewModels/TdvViewItem.cs:9-106 Preview Features The preview panel supports: Debounced loading - 200ms debounce prevents excessive exports LRU cache - Caches up to 32 preview images Pan and zoom - Interactive image manipulation via ImagePanZoomBehavior Dark theme background - Consistent preview appearance (RGB: 43, 44, 61) Source: csharp/src/Tools/Common/TDV/UI/ViewModels/TdvWindowViewModel.cs:74-81 Source: csharp/src/Tools/Common/TDV/Revit/Services/TdvOps.cs:19-28 Settings Configuration Library Settings TDV uses the MasterLibrarySettings class to store library file configurations: public sealed class MasterLibrarySettings { public IList<LibraryFileEntry> Files { get; set; } public bool HasWarnings { get; set; } } public sealed class LibraryFileEntry { public string? MainPath { get; set; } public string? FallbackPath { get; set; } } Source: csharp/src/Tools/Common/TDV/Settings/MasterLibrarySettings.cs:1-8 Source: csharp/src/Tools/Common/TDV/Settings/LibraryFileEntry.cs:1-8 Each library entry supports: Main path - Primary path to the library RVT file Fallback path - Alternative path (e.g., for different network locations) Settings Pack The LibrarySettingsPackContext provides the settings UI with: Tree-based library file management Add/remove library files Add/remove fallback paths Real-time path validation Pending changes tracking Source: csharp/src/Tools/Common/TDV/Settings/LibrarySettingsPackContext.cs:19-352 Path Validation Library paths are validated for: File existence .rvt extension Accessibility Invalid paths trigger a settings warning that disables the import/export commands. Source: csharp/src/Tools/Common/TDV/Revit/Services/TdvLibraryService.cs:100-141 Manifest Configuration The tool is configured via manifest.yml: id: DBTools.TDV assembly: DBTools moduleType: DBTools.TDV.TdvToolModule order: 0 sandboxWindows: - id: DBTools.TDV.Main displayName: \"Transfer Drafting Views\" group: \"Common\" windowType: \"DBTools.TDV.UI.Views.TdvWindow\" tool: settings: configSection: Core.MasterLibrary settingsPacks: - key: core.library title: \"Library Files\" warnings: - id: core.library.invalid title: \"Library Paths Invalid\" message: \"One or more library file paths are invalid...\" disableTools: - DBTools.ExportToLibrary - DBTools.ImportFromLibrary ribbonTools: - internalName: DBTools.ExportToLibrary commandType: DBTools.TDV.Features.TdvExportCommand availabilityType: DBTools.App.Tools.Availability.DbtDocumentAvailability runProfile: InlineUi displayText: \"Export\\nTo Library\" iconBaseKey: export tooltip: \"Export drafting views to the library\" controlKind: StackedButtonItem splitGroup: library_transfer - internalName: DBTools.ImportFromLibrary commandType: DBTools.TDV.Features.TdvImportCommand availabilityType: DBTools.App.Tools.Availability.DbtDocumentAvailability runProfile: InlineUi displayText: \"Import\\nFrom Library\" iconBaseKey: import tooltip: \"Import drafting views from the library\" controlKind: StackedButtonItem splitGroup: library_transfer Source: csharp/src/Tools/Common/TDV/manifest.yml:1-45 Ribbon Configuration Property Export Import Internal Name DBTools.ExportToLibrary DBTools.ImportFromLibrary Command TdvExportCommand TdvImportCommand Run Profile InlineUi InlineUi Icon export import Control Kind StackedButtonItem StackedButtonItem Split Group library_transfer library_transfer Error Handling Per-View Error Codes Transfer failures are categorized by error code: Code Description Unknown Unspecified error DestinationTypeMissing Target view type not found SourceTypeNameUnavailable Cannot read source view type CreateViewFailed Failed to create destination view CopyElementsFailed Failed to copy view elements OverridesFailed Failed to copy graphic overrides Source: csharp/src/Tools/Common/TDV/Contracts/TdvPerViewErrorCode.cs:1-12 Error Reporting After transfer, errors are displayed in a detailed alert dialog with: Summary counts (added, replaced, skipped) Error details table with source info and error messages Copy to clipboard functionality Source: csharp/src/Tools/Common/TDV/UI/Views/TdvWindow.xaml.cs:111-186 Revit API Operations Getting Drafting Views new FilteredElementCollector(doc) .OfClass(typeof(View)) .WhereElementIsNotElementType() .Cast<View>() .Where(v => v.ViewType == ViewType.DraftingView && !v.IsTemplate) Source: csharp/src/Tools/Common/TDV/Revit/Services/TdvOps.cs:30-39 Copying View Contents Elements are copied using ElementTransformUtils.CopyElements with a custom IDuplicateTypeNamesHandler that uses destination types when duplicates are found. Source: csharp/src/Tools/Common/TDV/Revit/Services/TdvOps.cs:145-162 Skipped Categories The following categories are excluded from copy operations: Title Blocks Viewports Views Schedules Guide Grids Source: csharp/src/Tools/Common/TDV/Revit/Services/TdvOps.cs:13-16 Command Reference Export Command Flow Validate library paths are configured Prompt user to select a library file Create local copy of central library file Open library document Show TdvWindow for view selection Execute transfer to library Sync changes to central with comment Close library and reactivate original document Source: csharp/src/Tools/Common/TDV/Features/TdvExportCommand.cs:31-137 Import Command Flow Validate library paths are configured Prompt user to select a library file Create local copy of central library file Open library document Show TdvWindow for view selection Execute transfer to active document Close library (no sync needed) Source: csharp/src/Tools/Common/TDV/Features/TdvImportCommand.cs:27-107 Cross-References Architecture Overview - Application architecture patterns App Project - Main application and tool hosting Testing TDV includes unit tests for: TdvViewItem - View model behavior TdvLibraryService - Path validation and library management TdvAdapter - Service adapter tests Source: csharp/src/Tools/Common/TDV/Tests/ Last updated: January 2026"
  },
  "articles/tools/structural/analytical-snap.html": {
    "href": "articles/tools/structural/analytical-snap.html",
    "title": "Analytical Snap To Level | DB Tools",
    "summary": "Analytical Snap To Level Analytical Snap To Level is a Revit tool that snaps selected analytical model elements (beams and columns) to a user-specified level elevation. Overview This tool provides a streamlined workflow for aligning analytical model geometry to structural levels. It supports two structural roles with role-specific snapping behavior: Beams: Both endpoints are moved to the target level elevation Columns: Only the endpoint closest to the target level is moved, preserving the other endpoint's position Source: csharp/src/Tools/Structural/AnalyticalSnapToLevel/Features/AnalyticalLevelSnapper.cs:88-119 Features Feature Description Selection-Based Operates on pre-selected analytical elements Level Picker Interactive dialog to choose target level Role-Aware Snapping Different snap behavior for beams vs columns Batch Processing Processes multiple elements in a single transaction Summary Report Displays processed/skipped counts after execution Source: csharp/src/Tools/Structural/AnalyticalSnapToLevel/Features/AnalyticalSnapToLevelCommand.cs:19-70 Workflow Select Elements: Pre-select analytical members in the Revit view Launch Tool: Click \"Analytical Snap To Level\" button on the ribbon Pick Level: Select target level from the level picker dialog Review Results: View summary showing processed and skipped element counts Supported Elements The tool only processes elements that meet these criteria: Category: OST_AnalyticalMember Type: Must be castable to AnalyticalMember Structural Role: \"Beam\" or \"Column\" (other roles are skipped) Geometry: Must have a valid curve Source: csharp/src/Tools/Structural/AnalyticalSnapToLevel/Features/AnalyticalLevelSnapper.cs:55-81 Snapping Behavior Beams Beams are horizontal members. Both endpoints are moved to the target elevation while preserving X and Y coordinates: Original: Start(X1, Y1, Z1) ---- End(X2, Y2, Z2) Snapped: Start(X1, Y1, TargetElev) ---- End(X2, Y2, TargetElev) Source: csharp/src/Tools/Structural/AnalyticalSnapToLevel/Features/AnalyticalLevelSnapper.cs:88-93 Columns Columns are vertical members. Only the endpoint closest to the target level is moved: Original: Top(X, Y, 20) | Bottom(X, Y, 10) Target at 12: Top(X, Y, 20) | Bottom(X, Y, 12) [bottom was closer] Source: csharp/src/Tools/Structural/AnalyticalSnapToLevel/Features/AnalyticalLevelSnapper.cs:95-112 Architecture Module Structure csharp/src/Tools/Structural/AnalyticalSnapToLevel/ +-- manifest.yml # Tool declaration +-- AnalyticalSnapToLevelToolModule.cs # DI module registration +-- DBTools.Structural.AnalyticalSnapToLevel.csproj # Project file +-- Features/ | +-- AnalyticalSnapToLevelCommand.cs # Ribbon command entry point | +-- AnalyticalLevelSnapper.cs # Core snapping logic +-- Assets/ +-- analytical_snap_icon.png # Ribbon icon Source: Directory structure of csharp/src/Tools/Structural/AnalyticalSnapToLevel/ Key Classes Class File Purpose AnalyticalSnapToLevelToolModule AnalyticalSnapToLevelToolModule.cs:5-7 Empty tool module for registration AnalyticalSnapToLevelCommand Features/AnalyticalSnapToLevelCommand.cs:17-71 Command entry point; orchestrates workflow AnalyticalLevelSnapper Features/AnalyticalLevelSnapper.cs:16-135 Core snapping service Source: csharp/src/Tools/Structural/AnalyticalSnapToLevel/AnalyticalSnapToLevelToolModule.cs:5-7 Data Flow +----------------------------+ | AnalyticalSnapToLevelCommand| +-------------+--------------+ | | 1. Get selected element IDs | 2. Show level picker v +-------------------+ | LevelPickerHelper | (from DBTools.Core) +-------------------+ | | Returns selected Level v +----------------------------+ | AnalyticalLevelSnapper | +-------------+--------------+ | | 3. Iterate selected IDs | 4. Filter to AnalyticalMember | 5. Check structural role | 6. Compute new curve | 7. SetCurve on member v +----------------------------+ | Summary Alert | +----------------------------+ Dependencies The tool depends on these core services: Service Source Purpose IAlertService DBTools.Core Show level picker and summary dialogs LevelPickerHelper DBTools.Core Utility for level selection UI ITransactionRunner DBTools.Core Transaction execution via call gate ILogger Microsoft.Extensions.Logging Debug logging Source: csharp/src/Tools/Structural/AnalyticalSnapToLevel/Features/AnalyticalSnapToLevelCommand.cs:35-46 Settings This tool has no persistent settings. All configuration is provided at runtime via: Element Selection: User pre-selects elements before invoking the command Target Level: User picks from level dialog at runtime Manifest id: DBTools.Structural.AnalyticalSnapToLevel assembly: DBTools moduleType: DBTools.Structural.AnalyticalSnapToLevel.AnalyticalSnapToLevelToolModule order: 0 tool: ribbonTools: - internalName: DBTools.AnalyticalSnapToLevel commandType: DBTools.Structural.AnalyticalSnapToLevel.AnalyticalSnapToLevelCommand availabilityType: DBTools.App.Tools.Availability.DbtSelectionAvailability runProfile: InlineUi displayText: \"Analytical Snap\\nTo Level\" iconBaseKey: analytical_snap tooltip: \"Snap analytical model elements to specified level\" controlKind: PushButton order: 20 Source: csharp/src/Tools/Structural/AnalyticalSnapToLevel/manifest.yml:1-15 Manifest Properties Property Value Description id DBTools.Structural.AnalyticalSnapToLevel Unique tool identifier availabilityType DbtSelectionAvailability Button enabled when elements are selected runProfile InlineUi Runs with inline UI support controlKind PushButton Standard push button control order 20 Position in ribbon panel Availability The command uses DbtSelectionAvailability, which enables the ribbon button when at least one element is selected: public class DbtSelectionAvailability : IExternalCommandAvailability { public bool IsCommandAvailable(UIApplication applicationData, CategorySet selectedCategories) { var selection = uidoc.Selection?.GetElementIds(); if (selection == null || selection.Count == 0) return false; // ... return selection.Any(id => /* element matches */); } } Source: csharp/src/DBTools.App/Tools/Availability/DbtSelectionAvailability.cs:13-51 Error Handling The tool handles errors at multiple levels: Command Level Throws InvalidOperationException if no elements are selected Throws InvalidOperationException if no target level is selected Source: csharp/src/Tools/Structural/AnalyticalSnapToLevel/Features/AnalyticalSnapToLevelCommand.cs:29-40 Snapper Level Elements are silently skipped (with debug logging) when: Element is null Element category is not OST_AnalyticalMember Element cannot be cast to AnalyticalMember Element has no curve geometry Structural role is not \"Beam\" or \"Column\" Any exception occurs during curve modification Source: csharp/src/Tools/Structural/AnalyticalSnapToLevel/Features/AnalyticalLevelSnapper.cs:46-129 Logging The tool logs debug information via ILogger: // Target level selection logger.LogDebug(\"[AnalyticalSnap] Target level: {LevelName} (Elev: {Elevation})\", targetLevel.Name, targetLevel.Elevation); // Skip reasons _logger.LogDebug(\"[AnalyticalSnap] Skipping element {ElementId} - not an analytical member.\", RevitId.ToInt(elementId)); // Success _logger.LogDebug(\"[AnalyticalSnap] Snapped {Role} {ElementId} to level {LevelName}.\", role, RevitId.ToInt(elementId), level.Name); // Summary logger.LogDebug(\"[AnalyticalSnap] Processed {Processed}; skipped {Skipped}.\", processed, skipped); Source: csharp/src/Tools/Structural/AnalyticalSnapToLevel/Features/AnalyticalSnapToLevelCommand.cs:42-52 API Reference AnalyticalLevelSnapper The core snapping service: public sealed class AnalyticalLevelSnapper { public AnalyticalLevelSnapper(ITransactionRunner tx, Document doc, ILogger logger); public (int ProcessedCount, int SkippedCount) Run( ICollection<ElementId> selectedIds, Level targetLevel); } Parameters Parameter Type Description tx ITransactionRunner Transaction runner for Revit operations doc Document Active Revit document logger ILogger Logger for debug output Return Value Returns a tuple with: ProcessedCount: Number of elements successfully snapped SkippedCount: Number of elements skipped (invalid category, role, or errors) Source: csharp/src/Tools/Structural/AnalyticalSnapToLevel/Features/AnalyticalLevelSnapper.cs:22-29 Troubleshooting Issue Cause Resolution Button disabled No elements selected Select analytical elements before clicking \"No elements selected\" error Selection cleared before command ran Re-select elements and try again High skip count Non-analytical elements in selection Select only analytical members Elements not moving Role is not \"Beam\" or \"Column\" Check element's Structural Role parameter Partial success Some elements have errors Check debug log for skip reasons Related Documentation SGT Tool - Structural Grid Tool (uses similar snapping concepts) Framing Joins - Related structural framing tool Source Files Reviewed File Purpose manifest.yml Tool declaration AnalyticalSnapToLevelToolModule.cs Module registration AnalyticalSnapToLevelCommand.cs Command entry point AnalyticalLevelSnapper.cs Core snapping logic DBTools.Structural.AnalyticalSnapToLevel.csproj Project configuration DbtSelectionAvailability.cs Availability predicate LevelPickerHelper.cs Level picker utility"
  },
  "articles/tools/structural/foundation-tags.html": {
    "href": "articles/tools/structural/foundation-tags.html",
    "title": "Foundation Tags | DB Tools",
    "summary": "Foundation Tags Overview The Foundation Tags tool automates the management and positioning of combined foundation tags in Revit structural documentation. It provides two main capabilities: updating parameter values on foundation elements based on pier associations, and moving tags to consistent corner positions on their tagged footings. Source: csharp/src/Tools/Structural/FoundationTags/manifest.yml:1-4 Location: csharp/src/Tools/Structural/FoundationTags/ Tool ID: DBTools.Structural.FoundationTags Ribbon Location: Structural group, split button foundation_tags Features Core Functionality Feature Description Update Combined Tags Updates pier-footing associations and elevation parameters Move Combined Tags Moves tags to corner positions on footings Auto-Update on View Automatically updates tags when activating floor/ceiling plans Linked Element Support Processes tags on footings in linked Revit models Selection Sets Creates timestamped selection sets for modified/skipped elements Source: csharp/src/Tools/Structural/FoundationTags/manifest.yml:19-39 Ribbon Commands Update Combined Foundation Tags Updates parameter values on piers and footings in the current view: Pier Processing: Calculates Foundation Pier Top elevation from Top Level + Top Offset Footing Processing: Associates each footing with its nearest pier (within 2-foot threshold) Parameter Updates: Sets Associated Pier (type mark) and Associated Pier Elevation on footings Source: csharp/src/Tools/Structural/FoundationTags/Features/CombinedFoundationTagsUpdater.cs:68-267 Command: DBTools.UpdateCombinedFoundationTags Display Text: \"Update Combined Foundation Tags\" Run Profile: InlineUi Source: csharp/src/Tools/Structural/FoundationTags/manifest.yml:20-29 Move Combined Foundation Tags Repositions foundation tags to specific corners of their tagged footings: Tag Collection: Finds structural foundation tags matching configured family patterns Footing Resolution: Retrieves tagged footing (host or linked) Corner Calculation: Computes footing corners using geometry tessellation Position Assignment: Moves tag to the corner specified by the tag name/type Source: csharp/src/Tools/Structural/FoundationTags/Features/CombinedFoundationTagsMover.cs:58-116 Command: DBTools.MoveCombinedFoundationTags Display Text: \"Move Combined Tags\" Run Profile: InlineUi Source: csharp/src/Tools/Structural/FoundationTags/manifest.yml:30-39 View-Activated Auto-Update When enabled, the tool automatically runs the Update Combined Tags operation when activating floor or ceiling plan views. Source: csharp/src/Tools/Structural/FoundationTags/Hooks/CombinedTagsViewActivatedTask.cs:37-49 Supported View Types: FloorPlan CeilingPlan Source: csharp/src/Tools/Structural/FoundationTags/Hooks/CombinedTagsViewActivatedTask.cs:48 Architecture Directory Structure csharp/src/Tools/Structural/FoundationTags/ +-- Features/ # Core feature implementations | +-- CombinedFoundationTagsUpdater.cs # Update logic | +-- CombinedFoundationTagsMover.cs # Move logic | +-- FoundationTagsGeometry.cs # Pure geometry calculations | +-- UpdateCombinedFoundationTagsCommand.cs | +-- MoveCombinedFoundationTagsCommand.cs +-- Hooks/ # Event handlers | +-- CombinedTagsViewActivatedTask.cs # Auto-update on view activation +-- Settings/ # Configuration | +-- FoundationTagsSettings.cs | +-- FoundationTagsSettingsPackContext.cs | +-- FoundationTagsSettingsPackView.xaml +-- Tests/ # Unit tests | +-- FoundationTagsGeometryTests.cs +-- FoundationTagsToolModule.cs # DI registration +-- manifest.yml # Tool manifest Key Components FoundationTagsToolModule The module class registers settings, services, and settings packs with the dependency injection container. Source: csharp/src/Tools/Structural/FoundationTags/FoundationTagsToolModule.cs:14-91 Registration Points: RegisterSettings: Binds FoundationTagsSettings to configuration section Tools.FoundationTags RegisterServices: Registers CombinedTagsViewActivatedTask as IViewActivatedTask RegisterSettingsPacks: Creates settings UI with warning definitions Source: csharp/src/Tools/Structural/FoundationTags/FoundationTagsToolModule.cs:16-81 CombinedFoundationTagsUpdater The core service that updates pier and footing parameters. Source: csharp/src/Tools/Structural/FoundationTags/Features/CombinedFoundationTagsUpdater.cs:16-275 Processing Flow: Collect piers matching configured family patterns Collect footings matching configured family patterns For each pier: calculate and set Foundation Pier Top For each footing: find nearest pier and set association parameters Create selection sets for modified and skipped elements Pier-Footing Association: Uses 2D distance (X, Y only) to find nearest pier Maximum distance threshold: 2 feet (squared distance = 4.0) Clears association if no pier found within threshold Source: csharp/src/Tools/Structural/FoundationTags/Features/CombinedFoundationTagsUpdater.cs:167 CombinedFoundationTagsMover The service that repositions tags to footing corners. Source: csharp/src/Tools/Structural/FoundationTags/Features/CombinedFoundationTagsMover.cs:18-376 Corner Selection Algorithm: Extract footing geometry points via tessellation Project corners onto view coordinate system (right/up axes) Select corner based on tag name using dot product projection Supported Corner Names: \"Top Right\" \"Top Left\" \"Bottom Right\" \"Bottom Left\" Source: csharp/src/Tools/Structural/FoundationTags/Features/FoundationTagsGeometry.cs:142-149 FoundationTagsGeometry A pure, testable geometry module with no Revit dependencies. Source: csharp/src/Tools/Structural/FoundationTags/Features/FoundationTagsGeometry.cs:112-250 Functions: Function Purpose SelectCornerByViewOrientation Selects corner based on view direction vectors FindNearestPoint2D Finds nearest candidate point within threshold IsValidCornerName Validates corner name strings Source: csharp/src/Tools/Structural/FoundationTags/Features/FoundationTagsGeometry.cs:123-249 Data Types: Type Description Point2D 2D point for distance calculations Point3D 3D point/vector for projections FootingCornerPoints Four corners of a rectangular footing NearestPointResult Result of nearest point search Source: csharp/src/Tools/Structural/FoundationTags/Features/FoundationTagsGeometry.cs:11-106 Settings Configuration Section Path: Tools.FoundationTags Source: csharp/src/Tools/Structural/FoundationTags/manifest.yml:7 FoundationTagsSettings Settings class implementing IAutoUpdateSettings. Source: csharp/src/Tools/Structural/FoundationTags/Settings/FoundationTagsSettings.cs:9-50 Property Type Default Description AutoUpdateEnabled bool true Enable auto-update on view activation HasWarning bool false Warning state (disables auto-update) TagFamilyPatterns List<string> See below Regex patterns for tag families PierFamilyPatterns List<string> See below Regex patterns for pier families FootingFamilyPatterns List<string> See below Regex patterns for footing families Source: csharp/src/Tools/Structural/FoundationTags/Settings/FoundationTagsSettings.cs:14-49 Default Patterns Tag Family Patterns (Move Combined Tags): ^Combined Foundation Tag ^DB Foundation Tag Source: csharp/src/Tools/Structural/FoundationTags/Settings/FoundationTagsSettings.cs:26-30 Pier Family Patterns (Update Combined Tags): ^Foundation Pier Source: csharp/src/Tools/Structural/FoundationTags/Settings/FoundationTagsSettings.cs:36-39 Footing Family Patterns (Update Combined Tags): ^Footing-Rectangular$ ^Pile Cap-Rectangular$ Source: csharp/src/Tools/Structural/FoundationTags/Settings/FoundationTagsSettings.cs:45-49 Settings UI The settings pack provides a configuration panel with: Auto-Update Toggle: Enable/disable automatic tag updates Tag Family Patterns: Up to 3 regex patterns for matching tag families Pier Family Patterns: Up to 3 regex patterns for matching pier families Footing Family Patterns: Up to 3 regex patterns for matching footing families Source: csharp/src/Tools/Structural/FoundationTags/Settings/FoundationTagsSettingsPackContext.cs:35-48 UI Features: Pattern validation with regex syntax checking Add/remove pattern buttons (max 3 per group) Warning state management with clear action Pending changes detection Source: csharp/src/Tools/Structural/FoundationTags/Settings/FoundationTagsSettingsPackContext.cs:132-166 Warning System The tool uses a warning system to disable functionality when issues occur. Warning Definition: ID: core.structural.combined_tags Title: \"Combined Foundation Tags Disabled\" Message: \"Combined foundation tag updates are disabled due to a warning. Clear the warning to re-enable.\" Source: csharp/src/Tools/Structural/FoundationTags/manifest.yml:12-18 Disabled Tools When Warning Active: DBTools.UpdateCombinedFoundationTags DBTools.MoveCombinedFoundationTags DBTools.OrganizeFoundationTypes Source: csharp/src/Tools/Structural/FoundationTags/manifest.yml:15-18 Manifest id: DBTools.Structural.FoundationTags assembly: DBTools moduleType: DBTools.Structural.FoundationTags.FoundationTagsToolModule order: 0 tool: settings: configSection: Tools.FoundationTags settingsPacks: - key: structural.foundation_tags title: \"Combined Foundation Tags\" warnings: - id: core.structural.combined_tags title: \"Combined Foundation Tags Disabled\" message: \"Combined foundation tag updates are disabled due to a warning. Clear the warning to re-enable.\" disableTools: - DBTools.UpdateCombinedFoundationTags - DBTools.MoveCombinedFoundationTags - DBTools.OrganizeFoundationTypes ribbonTools: - internalName: DBTools.UpdateCombinedFoundationTags commandType: DBTools.Structural.FoundationTags.UpdateCombinedFoundationTagsCommand availabilityType: DBTools.App.Tools.Availability.DbtActiveViewAvailability runProfile: InlineUi displayText: \"Update Combined\\nFoundation Tags\" iconBaseKey: update_combined tooltip: \"Update combined foundation tag instances\" controlKind: SplitButtonItem splitGroup: foundation_tags order: 0 - internalName: DBTools.MoveCombinedFoundationTags commandType: DBTools.Structural.FoundationTags.MoveCombinedFoundationTagsCommand availabilityType: DBTools.App.Tools.Availability.DbtActiveViewAvailability runProfile: InlineUi displayText: \"Move Combined Tags\" iconBaseKey: move_combined tooltip: \"Move combined foundation tags to corner positions\" controlKind: SplitButtonItem splitGroup: foundation_tags order: 1 Source: csharp/src/Tools/Structural/FoundationTags/manifest.yml:1-39 Integration Points Revit API Integration The tool interacts with Revit through standard API patterns: FilteredElementCollector: Queries piers, footings, and tags FamilyInstance.Location: Extracts element positions Parameter.Set/ClearValue: Updates element parameters IndependentTag.TagHeadPosition: Repositions tags SelectionFilterElement: Creates selection sets for results RevitLinkInstance: Supports linked model elements Source: csharp/src/Tools/Structural/FoundationTags/Features/CombinedFoundationTagsMover.cs:67-189 Transaction Management Operations use the ITransactionRunner interface for transaction management: _tx.RunAsync(_doc, \"DB Tools - Update Combined Foundation Tags...\", doc => { // Parameter updates }); Source: csharp/src/Tools/Structural/FoundationTags/Features/CombinedFoundationTagsUpdater.cs:96-222 Related Documentation System Architecture - Overall system design Organize Foundation Types - Related foundation tool Testing The tool includes unit tests for the geometry module: Test File: FoundationTagsGeometryTests.cs Source: csharp/src/Tools/Structural/FoundationTags/Tests/FoundationTagsGeometryTests.cs:12 Test Categories: Corner selection by view orientation Rotated view handling Case-insensitive corner name matching Invalid input handling Nearest point 2D search Corner name validation Source: csharp/src/Tools/Structural/FoundationTags/Tests/FoundationTagsGeometryTests.cs:24-432 Run headless tests: dotnet test csharp/src/Tools/Structural/FoundationTags/Tests/DBTools.Structural.FoundationTags.Tests.csproj -c Release Documentation Status: Complete Last Updated: 2026-01-24 Source Review: Verified against source files in csharp/src/Tools/Structural/FoundationTags/"
  },
  "articles/tools/structural/framing-joins.html": {
    "href": "articles/tools/structural/framing-joins.html",
    "title": "Framing Joins | DB Tools",
    "summary": "Framing Joins Control structural framing join behavior at beam endpoints with bulk operations on selected elements. Overview The Framing Joins tool provides two commands for managing structural framing joins in Revit: Allow Join - Enables joins at both ends of selected structural framing elements Disallow Join - Disables joins at both ends of selected structural framing elements These commands operate on the current selection and modify the join behavior using Revit's StructuralFramingUtils API. Source: csharp/src/Tools/Structural/FramingJoins/manifest.yml:1-26 Features Allow Join Selected Allows structural framing joins at both endpoints (index 0 and 1) of all selected framing elements. Source: csharp/src/Tools/Structural/FramingJoins/Features/AllowJoinSelectedCommand.cs:16-18 Behavior: Retrieves the current selection from the active document Filters to only FamilyInstance elements in the OST_StructuralFraming category For each valid element, calls StructuralFramingUtils.AllowJoinAtEnd() for both endpoints Displays a summary alert showing the number of modified elements Source: csharp/src/Tools/Structural/FramingJoins/Features/AllowJoinSelectedCommand.cs:29-84 Disallow Join Selected Disallows structural framing joins at both endpoints (index 0 and 1) of all selected framing elements. Source: csharp/src/Tools/Structural/FramingJoins/Features/DisallowJoinSelectedCommand.cs:16-18 Behavior: Retrieves the current selection from the active document Filters to only FamilyInstance elements in the OST_StructuralFraming category For each valid element, calls StructuralFramingUtils.DisallowJoinAtEnd() for both endpoints Displays a summary alert showing the number of modified elements Source: csharp/src/Tools/Structural/FramingJoins/Features/DisallowJoinSelectedCommand.cs:29-84 Architecture Project Structure FramingJoins/ ├── DBTools.Structural.FramingJoins.csproj ├── FramingJoinsToolModule.cs ├── manifest.yml ├── Assets/ │ ├── allow_join_icon.png │ └── disallow_join_icon.png └── Features/ ├── AllowJoinSelectedCommand.cs └── DisallowJoinSelectedCommand.cs Module Registration The tool module is a simple marker class that inherits from DbtToolModule: public sealed class FramingJoinsToolModule : DbtToolModule { } Source: csharp/src/Tools/Structural/FramingJoins/FramingJoinsToolModule.cs:1-8 Command Availability Both commands use the DbtStructuralFramingSelectionAvailability predicate, which requires at least one element from the OST_StructuralFraming category to be selected: public sealed class DbtStructuralFramingSelectionAvailability : DbtSelectionAvailability { protected override BuiltInCategory[]? RequiredCategories => new[] { BuiltInCategory.OST_StructuralFraming }; } Source: csharp/src/DBTools.App/Tools/Availability/DbtSelectionAvailability.cs:57-60 Transaction Handling Both commands use CallGateTransactionRunner with ModalInlineCallGate for transaction execution: var gate = new ModalInlineCallGate(context.UIApplication); var tx = new DBTools.Core.Revit.Transactions.CallGateTransactionRunner(gate); await tx.RunAsync(doc, \"DB Tools - Allow Join Selected\", d => { ... }); Source: csharp/src/Tools/Structural/FramingJoins/Features/AllowJoinSelectedCommand.cs:48-67 Error Handling Individual element failures are caught and logged without stopping the batch operation: catch (Exception ex) { logger.LogDebug(\"[AllowJoin] Failed for element {ElementId}: {Message}\", RevitId.ToInt(elem.Id), ex.Message); } Source: csharp/src/Tools/Structural/FramingJoins/Features/AllowJoinSelectedCommand.cs:62-65 Settings This tool has no configurable settings. It operates directly on the current selection. Manifest id: DBTools.Structural.FramingJoins assembly: DBTools moduleType: DBTools.Structural.FramingJoins.FramingJoinsToolModule order: 0 tool: ribbonTools: - internalName: DBTools.AllowJoinSelected commandType: DBTools.Structural.FramingJoins.AllowJoinSelectedCommand availabilityType: DBTools.App.Tools.Availability.DbtStructuralFramingSelectionAvailability runProfile: InlineUi displayText: \"Allow Join\" iconBaseKey: allow_join tooltip: \"Allow structural framing joins for selected elements\" controlKind: SplitButtonItem splitGroup: framing_joins order: 0 - internalName: DBTools.DisallowJoinSelected commandType: DBTools.Structural.FramingJoins.DisallowJoinSelectedCommand availabilityType: DBTools.App.Tools.Availability.DbtStructuralFramingSelectionAvailability runProfile: InlineUi displayText: \"Disallow Join\" iconBaseKey: disallow_join tooltip: \"Disallow structural framing joins for selected elements\" controlKind: SplitButtonItem splitGroup: framing_joins order: 1 Source: csharp/src/Tools/Structural/FramingJoins/manifest.yml:1-26 Manifest Properties Property Value Description id DBTools.Structural.FramingJoins Unique tool identifier assembly DBTools Target assembly (merged into main DBTools assembly) moduleType FramingJoinsToolModule DI module registration class runProfile InlineUi Runs inline with UI context controlKind SplitButtonItem Ribbon control type splitGroup framing_joins Groups both commands under a single split button Usage Select one or more structural framing elements (beams, braces, etc.) Click Allow Join or Disallow Join from the ribbon Review the summary dialog showing the number of modified elements Dependencies DBTools.Core - Core infrastructure, transactions, and UI services ricaun.Revit.UI.Tasks - Async task execution in Revit context Revit API (RevitAPI.dll, RevitAPIUI.dll) Source: csharp/src/Tools/Structural/FramingJoins/DBTools.Structural.FramingJoins.csproj:35-44"
  },
  "articles/tools/structural/joist-girder-weight.html": {
    "href": "articles/tools/structural/joist-girder-weight.html",
    "title": "Joist Girder Weight Tool | DB Tools",
    "summary": "Joist Girder Weight Tool Automatically estimates and updates weight parameters for joist girder elements in Revit structural models. Overview The Joist Girder Weight tool provides automated weight estimation for steel joist girders using moment-based structural engineering calculations. It calculates weight per linear foot based on the number of joists, point loads, span length, and girder depth, then writes the result to the element's Wt parameter. Source: csharp/src/Tools/Structural/JoistGirderWeight/Features/JoistGirderWeightCalculator.cs:9-74 The tool operates in two modes: Manual - User-initiated command via ribbon button Automatic - Triggered on view activation when auto-update is enabled Features Weight Calculation The calculator uses moment-based weight estimation derived from structural engineering principles: Panel Spacing Calculation - Girder length divided by number of joists Maximum Moment Calculation - Based on total reaction and span, with adjustments for even/odd panel counts Section Modulus Estimation - Uses engineering constants for chord and web member sizing Weight Aggregation - Combines top chord, bottom chord, and web weights Source: csharp/src/Tools/Structural/JoistGirderWeight/Features/JoistGirderWeightCalculator.cs:20-74 Engineering Constants The calculation employs the following constants: Constant Value Description Allowable Stress 50.0 ksi Design stress limit Section Modulus Factor 0.28356 Geometric section factor Depth Efficiency Factor 0.95 Effective depth ratio Top Chord Factor 1.06 Top chord sizing multiplier Bottom Chord Factor 1.13 Bottom chord sizing multiplier Web Member Factor 0.7 Web element sizing multiplier Connection Factor 0.6 Joint efficiency factor Source: csharp/src/Tools/Structural/JoistGirderWeight/Features/JoistGirderWeightCalculator.cs:51-58 Multi-Parameter Support The estimator supports multiple parameter naming conventions to handle legacy family definitions: Input Group Supported Parameter Names Number of Joists Number of Joists, SpaceNum, Number of Equal Spaces Point Load Panel Point Load, Point Load - User Defined, Point Load, Total Load - User Defined, Total Load, Joist Load Length Length Depth Depth Output Wt (required, writable) Parameters are resolved in priority order - the first match in each list wins. Both instance and type parameters are checked. Source: csharp/src/Tools/Structural/JoistGirderWeight/Features/JoistGirderWeightEstimator.cs:19-25 Element Filtering The tool targets structural framing elements where the family name or type name contains \"joist girder\" (case-insensitive): girders = collector .OfCategory(BuiltInCategory.OST_StructuralFraming) .WhereElementIsNotElementType() .Where(e => familyName.Contains(\"joist girder\", StringComparison.OrdinalIgnoreCase) || typeName.Contains(\"joist girder\", StringComparison.OrdinalIgnoreCase)); Source: csharp/src/Tools/Structural/JoistGirderWeight/Features/JoistGirderWeightEstimator.cs:36-48 Auto-Update on View Activation When enabled, the tool automatically updates joist girder weights whenever a view is activated. This is controlled by the AutoUpdateEnabled setting. Source: csharp/src/Tools/Structural/JoistGirderWeight/Hooks/JoistGirderViewActivatedTask.cs:19-44 Architecture Component Structure JoistGirderWeight/ ├── Features/ │ ├── JoistGirderWeightCalculator.cs # Pure calculation logic (no Revit dependencies) │ ├── JoistGirderWeightEstimator.cs # Revit integration and parameter handling │ └── UpdateJoistGirderWeightsCommand.cs # Ribbon command implementation ├── Hooks/ │ └── JoistGirderViewActivatedTask.cs # Auto-update on view change ├── Settings/ │ └── JoistGirderWeightSettings.cs # Configuration model ├── Assets/ │ └── joist_girder_icon.png # Ribbon button icon ├── JoistGirderWeightToolModule.cs # DI and module registration └── manifest.yml # Tool manifest Key Classes JoistGirderWeightCalculator Pure static calculation class with no Revit dependencies, enabling unit testing without Revit runtime. public static class JoistGirderWeightCalculator { public static double EstimateWeight( double numberOfJoists, double pointLoad, double lengthFeet, double depthFeet); public static bool ValidateInputs( double numberOfJoists, double pointLoad, double lengthFeet, double depthFeet); } Source: csharp/src/Tools/Structural/JoistGirderWeight/Features/JoistGirderWeightCalculator.cs:9-92 JoistGirderWeightEstimator Orchestrates the update process: Collects joist girder elements from the document Validates parameters and computes weights (outside transaction) Applies updates within a single transaction Reports success/failure counts Source: csharp/src/Tools/Structural/JoistGirderWeight/Features/JoistGirderWeightEstimator.cs:13-111 UpdateJoistGirderWeightsCommand The ribbon command entry point. Displays an alert with the update count upon completion. Source: csharp/src/Tools/Structural/JoistGirderWeight/Features/UpdateJoistGirderWeightsCommand.cs:15-42 Error Handling The tool follows the no-fallback, no-silent-failure principle: Pre-validation: All elements are validated before the transaction starts Partial updates: If some elements fail validation, valid ones are updated and a warning is logged Complete failure: If no elements can be updated, an InvalidOperationException is thrown with a sample error Source: csharp/src/Tools/Structural/JoistGirderWeight/Features/JoistGirderWeightEstimator.cs:84-97 Settings Configuration Schema # tools.json or per-user settings Tools: JoistGirderWeight: AutoUpdateEnabled: true # Enable/disable auto-update on view activation HasWarning: false # Warning state flag Source: csharp/src/Tools/Structural/JoistGirderWeight/Settings/JoistGirderWeightSettings.cs:5-10 Settings Properties Property Type Default Description AutoUpdateEnabled bool true Whether to auto-update weights on view activation HasWarning bool false Warning state - when true, disables auto-update Warning System When a warning is active: HasWarning is set to true AutoUpdateEnabled is forced to false The UpdateJoistGirderWeights command is disabled in the ribbon Source: csharp/src/Tools/Structural/JoistGirderWeight/JoistGirderWeightToolModule.cs:49-68 Manifest id: DBTools.Structural.JoistGirderWeight assembly: DBTools moduleType: DBTools.Structural.JoistGirderWeight.JoistGirderWeightToolModule order: 0 tool: settings: configSection: Tools.JoistGirderWeight settingsPacks: - key: structural.joist_girder_weight title: \"Joist Girder Weights\" warnings: - id: core.structural.joist_girder title: \"Joist Girder Weights Disabled\" message: \"Joist girder weight updates are disabled due to a warning...\" disableTools: - DBTools.UpdateJoistGirderWeights ribbonTools: - internalName: DBTools.UpdateJoistGirderWeights commandType: DBTools.Structural.JoistGirderWeight.UpdateJoistGirderWeightsCommand availabilityType: DBTools.App.Tools.Availability.DbtDocumentAvailability runProfile: InlineUi displayText: \"Update Joist\\nGirder Weights\" iconBaseKey: joist_girder tooltip: \"Update joist girder weights\" controlKind: PushButton order: 30 Source: csharp/src/Tools/Structural/JoistGirderWeight/manifest.yml:1-27 Ribbon Configuration Property Value Display Text \"Update Joist\\nGirder Weights\" Icon Key joist_girder Availability Document-dependent Run Profile InlineUi Order 30 Input Validation Required Constraints Parameter Constraint Rationale Number of Joists > 1 At least 2 joists required to create panel points Point Load >= 0 Negative loads are physically invalid Length > 0 Zero/negative span is invalid Depth > 0 Zero/negative depth is invalid Source: csharp/src/Tools/Structural/JoistGirderWeight/Features/JoistGirderWeightCalculator.cs:84-91 Validation Methods // Throws ArgumentOutOfRangeException for invalid inputs double weight = JoistGirderWeightCalculator.EstimateWeight(n, load, length, depth); // Returns bool for pre-validation bool isValid = JoistGirderWeightCalculator.ValidateInputs(n, load, length, depth); Testing The calculator has comprehensive unit test coverage (56 tests) covering: Valid input scenarios Scaling behavior (load, length, depth relationships) Invalid input handling Edge cases (overflow, underflow, fractional values) Input validation Determinism/consistency Source: csharp/src/Tools/Structural/JoistGirderWeight/Tests/JoistGirderWeightCalculatorTests.cs Running Tests # Build tests bash csharp/build.sh BuildTests # Run calculator tests (headless, no Revit required) dotnet test csharp/testing/DBTools.BuildArtifacts.Tests \\ --filter \"FullyQualifiedName~JoistGirderWeightCalculator\" Usage Notes Family Requirements For the tool to work correctly, joist girder families must: Belong to the Structural Framing category Have \"joist girder\" in the family name or type name Include at least one parameter from each input group Have a writable Wt parameter (Double storage type) Known Limitations Estimation only: Results are engineering estimates, not certified designs Single formula: Uses one calculation method regardless of manufacturer specifications No SJI validation: Does not validate against Steel Joist Institute load tables"
  },
  "articles/tools/structural/organize-foundation.html": {
    "href": "articles/tools/structural/organize-foundation.html",
    "title": "Organize Foundation Types | DB Tools",
    "summary": "Organize Foundation Types The Organize Foundation Types tool standardizes naming conventions and type marks for structural foundation elements. It processes pier and footing family types to ensure consistent naming patterns and eliminates duplicate types by merging instances. Source: csharp/src/Tools/Structural/OrganizeFoundationTypes/Features/OrganizeFoundationTypesCommand.cs:12-57 Overview This tool automates the tedious process of organizing foundation type names and type marks in Revit models. It: Renames types using standardized dimension-based naming (e.g., 3'-0\"x3'-0\" (P-1)) Assigns type marks with prefixes specific to each foundation category Merges duplicate types that have identical dimensions, consolidating instances Source: csharp/src/Tools/Structural/OrganizeFoundationTypes/Features/FoundationTypeOrganizer.cs:12-14 Supported Foundation Categories The tool processes four categories of foundation elements: Category Family Name Revit Category Type Mark Prefix Sort Criteria Foundation Piers Foundation Pier Structural Columns P Section area (b x h) Round Piers Foundation Pier - Round Structural Columns RP Diameter (d) Rectangular Footings Footing-Rectangular Structural Foundation F Width, Length, Thickness Pile Caps Pile Cap-Rectangular Structural Foundation CAP Width, Length, Thickness Source: csharp/src/Tools/Structural/OrganizeFoundationTypes/Features/FoundationTypeOrganizer.cs:39-42 Features Type Mark Generation Type marks are generated with predictable formats that support efficient scheduling and tagging: Pier/Round Pier Format: {PREFIX}-{counter} Examples: P-1, P-2, RP-1, RP-2 Footing/Pile Cap Format: {PREFIX}-{widthFeet}.{counter} Examples: F-3.0, F-3.1, CAP-4.0, CAP-4.1 The generator automatically finds the next available mark, filling gaps in sequences when possible. Source: csharp/src/Tools/Structural/OrganizeFoundationTypes/Features/TypeMarkGenerator.cs:22-64 Type Naming Conventions After processing, types are renamed to include dimensions and type mark: Foundation Type Naming Pattern Example Foundation Pier {b}x{h} ({mark}) 2'-6\"x2'-6\" (P-1) Round Pier {d} DIA. ({mark}) 2'-0\" DIA. (RP-1) Footing / Pile Cap {width}x{length}x{thickness} ({mark}) 3'-0\"x3'-0\"x1'-0\" (F-3.0) Source: csharp/src/Tools/Structural/OrganizeFoundationTypes/Features/FoundationTypeOrganizer.cs:127-129,197-198,276 Duplicate Type Merging When multiple types share identical dimensions, the tool: Identifies duplicate types based on dimension parameters Moves all instances from duplicate types to the primary type Deletes the now-empty duplicate types This reduces model clutter and ensures consistent type usage. Source: csharp/src/Tools/Structural/OrganizeFoundationTypes/Features/FoundationTypeOrganizer.cs:96-107,170-179,243-254 Overwrite Protection On execution, users are prompted whether to overwrite existing type marks: Yes: All type marks are regenerated, ensuring consistent sequential numbering No: Existing type marks are preserved; only types without marks receive new ones Source: csharp/src/Tools/Structural/OrganizeFoundationTypes/Features/OrganizeFoundationTypesCommand.cs:26-29 Architecture Component Structure OrganizeFoundationTypes/ Features/ OrganizeFoundationTypesCommand.cs -- Revit external command entry point FoundationTypeOrganizer.cs -- Core processing logic TypeMarkGenerator.cs -- Type mark generation (pure logic, testable) OrganizeFoundationTypesToolModule.cs -- DI module registration manifest.yml -- Ribbon and command configuration Class Responsibilities Class Responsibility OrganizeFoundationTypesCommand Entry point; prompts user, invokes organizer, displays results FoundationTypeOrganizer Collects types, processes each category, merges duplicates TypeMarkGenerator Pure static logic for generating unique type marks Source: csharp/src/Tools/Structural/OrganizeFoundationTypes/Features/OrganizeFoundationTypesCommand.cs:16, csharp/src/Tools/Structural/OrganizeFoundationTypes/Features/FoundationTypeOrganizer.cs:15, csharp/src/Tools/Structural/OrganizeFoundationTypes/Features/TypeMarkGenerator.cs:11 Transaction Strategy The organizer runs multiple transactions to isolate changes by category: DB Tools - Organize Foundation Pier Types (rectangular piers) DB Tools - Organize Round Pier Types (round piers) DB Tools - Organize Footing Types (footings and pile caps) Source: csharp/src/Tools/Structural/OrganizeFoundationTypes/Features/FoundationTypeOrganizer.cs:48-62 Dependencies DBTools.Core - Base infrastructure, transactions, logging, alerts ricaun.Revit.UI.Tasks - Async UI task handling Source: csharp/src/Tools/Structural/OrganizeFoundationTypes/DBTools.Structural.OrganizeFoundationTypes.csproj:35-44 Manifest Configuration id: DBTools.Structural.OrganizeFoundationTypes assembly: DBTools moduleType: DBTools.Structural.OrganizeFoundationTypes.OrganizeFoundationTypesToolModule order: 0 tool: ribbonTools: - internalName: DBTools.OrganizeFoundationTypes commandType: DBTools.Structural.OrganizeFoundationTypes.OrganizeFoundationTypesCommand availabilityType: DBTools.App.Tools.Availability.DbtDocumentAvailability runProfile: InlineUi displayText: \"Organize Foundation\\nTypes\" iconBaseKey: organize_types tooltip: \"Organize foundation types for tagging\" controlKind: SplitButtonItem splitGroup: foundation_tags order: 2 Source: csharp/src/Tools/Structural/OrganizeFoundationTypes/manifest.yml:1-16 Ribbon Placement The tool appears in the Foundation Tags split button group alongside: Order Tool Description 0 Update Combined Foundation Tags Updates tag instances 1 Move Combined Foundation Tags Repositions tags 2 Organize Foundation Types This tool Source: csharp/src/Tools/Structural/FoundationTags/manifest.yml:20-39, csharp/src/Tools/Structural/OrganizeFoundationTypes/manifest.yml:14-16 Availability Availability Class: DbtDocumentAvailability Requirement: An open Revit document (no active view requirement) Settings This tool has no configurable settings. All behavior is determined by the dimension parameters of the foundation types in the model. Parameter Requirements The tool reads specific parameters from each family type: Foundation Pier (Foundation Pier) Parameter Type Description b Length Pier width dimension h Length Pier depth dimension Type Mark Text Assigned type mark Round Pier (Foundation Pier - Round) Parameter Type Description d Length Pier diameter Type Mark Text Assigned type mark Footing / Pile Cap Parameter Type Description Width Length Footing width Length Length Footing length Foundation Thickness Length Footing depth Type Mark Text Assigned type mark Source: csharp/src/Tools/Structural/OrganizeFoundationTypes/Features/FoundationTypeOrganizer.cs:92-93,167,238-240 Processing Logic Pier Types (Rectangular) Collect all FamilySymbol instances from OST_StructuralColumns where family name is Foundation Pier Sort by section area (ascending) For each type: Check for duplicate (same b and h values) If duplicate found: merge instances to existing type, mark for deletion Otherwise: assign type mark (respecting overwrite setting), rename type Delete merged duplicate types Source: csharp/src/Tools/Structural/OrganizeFoundationTypes/Features/FoundationTypeOrganizer.cs:79-151 Round Pier Types Collect all FamilySymbol instances from OST_StructuralColumns where family name is Foundation Pier - Round Sort by diameter (ascending) For each type: Check for duplicate (same d value) If duplicate found: merge instances, mark for deletion Otherwise: assign type mark, rename with {d} DIA. ({mark}) format Delete merged duplicate types Source: csharp/src/Tools/Structural/OrganizeFoundationTypes/Features/FoundationTypeOrganizer.cs:154-218 Footing and Pile Cap Types Collect all FamilySymbol instances from OST_StructuralFoundation where family name matches Sort by Width, then Length, then Foundation Thickness (ascending) For each type: Check for duplicate (same Width, Length, and Foundation Thickness) If duplicate found: merge instances, mark for deletion Otherwise: assign footing-format type mark, rename with dimensions Delete merged duplicate types (best-effort, silently continues on failure) Source: csharp/src/Tools/Structural/OrganizeFoundationTypes/Features/FoundationTypeOrganizer.cs:221-293 Error Handling Individual type processing failures are logged at DEBUG level and skipped Type deletion failures are logged at WARNING or ERROR level Footing type deletions use best-effort (silently continue if deletion fails, as type may be in use elsewhere) The command displays a summary dialog showing counts of renamed and merged types Source: csharp/src/Tools/Structural/OrganizeFoundationTypes/Features/FoundationTypeOrganizer.cs:132-136,146-150,203-205,214-217,279-282,289-291 Testing Unit tests for the TypeMarkGenerator class verify: Sequential mark generation (P-1, P-2, P-3...) Gap filling in mark sequences Width-based footing mark format (F-3.0, F-3.1...) Null/invalid input handling Multiple prefix independence Source: csharp/src/Tools/Structural/OrganizeFoundationTypes/Tests/TypeMarkGeneratorTests.cs:1-346 Integration with Foundation Tags This tool is designed to work with the Combined Foundation Tags workflow: Run Organize Foundation Types to standardize type names and marks Use Update Combined Foundation Tags to update tag values Use Move Combined Foundation Tags to position tags The tools share a common warning system - if a warning is active on the structural.foundation_tags settings pack, all three tools are disabled until the warning is cleared. Source: csharp/src/Tools/Structural/FoundationTags/manifest.yml:12-18"
  },
  "articles/tools/structural/sgt.html": {
    "href": "articles/tools/structural/sgt.html",
    "title": "SGT (Super Girt Tool) | DB Tools",
    "summary": "SGT (Super Girt Tool) Overview The Super Girt Tool (SGT) is a Revit add-in for placing and managing structural steel girts and opening framing members (jambs, headers, sills) on foundation walls. It supports both host document walls and walls in linked Revit models. Source: csharp/src/Tools/Structural/SGT/manifest.yml:7-8 Location: csharp/src/Tools/Structural/SGT/ Tool ID: DBTools.SGT Ribbon Location: Structural group, order 40 Features Core Functionality Feature Description Wall Selection Select linked walls or host foundation walls for girt placement Girt Placement Auto-seed girts at configurable elevations with smart spacing Opening Framing Automatic detection and framing of openings (jambs, headers, sills) Live Preview Real-time 2D elevation and 3D preview of proposed framing Extent Control Configure girt extents by wall length, grids, openings, or manual distances Edit Mode Modify previously placed SGT systems with host-change reconciliation Source: csharp/src/Tools/Structural/SGT/Features/Commands/SgtNewCommand.cs:36-39 Supported Wall Types Linked Walls: Walls from Revit link instances (any function) Host Foundation Walls: Foundation walls in the host document (WallFunction.Foundation) Source: csharp/src/Tools/Structural/SGT/Features/Commands/SgtNewCommand.cs:96-99 Supported Framing Types The tool supports structural framing families filtered by shape: Shape Category Girts Opening Members Notes C Shapes Yes Yes Default: C10X15.3 MC Shapes Yes Yes Miscellaneous channels Z Shapes Yes No Intentionally excluded for openings HSS (Tube) Yes Yes Hollow structural sections Source: csharp/src/Tools/Structural/SGT/Common/Domain/SgtPlan.cs:137-144 Architecture SGT follows a domain-driven MVVM architecture with clear separation between UI, domain logic, and Revit API interactions. csharp/src/Tools/Structural/SGT/ +-- Common/ # Shared utilities, models, domain objects | +-- Domain/ # Core domain entities (SgtPlan, SgtWall, etc.) | +-- Models/ # UI-bound row items (SgtGirtRowItem, etc.) | +-- Units/ # Unit conversion service +-- Features/ # Feature-specific code | +-- Commands/ # Revit external commands | +-- Girts/ # Girt management services | +-- Openings/ # Opening detection | +-- Orientation/ # Family orientation analysis | +-- Place/ # Placement orchestration | +-- Preview/ # 2D/3D preview rendering | +-- Reconcile/ # Host-change reconciliation +-- Shell/ # UI layer | +-- Composition/ # DI registration | +-- DesignTime/ # Design-time ViewModels | +-- UI/ # Views and ViewModels +-- Shared/ # Cross-feature services +-- Contracts/ # Interfaces and DTOs +-- Extents/ # Extent resolution +-- Hydration/ # Domain hydration +-- Kernel/ # Validation, logging Key Design Patterns Single Source of Truth (SSOT) The SgtPlan object serves as the single source of truth for all SGT operations. It contains: Wall geometry and context (host/linked) Girt row configurations Opening row configurations Eligible framing types Pre-computed orientation data Grid positions Source: csharp/src/Tools/Structural/SGT/Common/Domain/SgtPlan.cs:12-17 Plan Store Pattern The ISgtPlanStore interface provides centralized plan state management with change notifications: public interface ISgtPlanStore { SgtPlan? Plan { get; } event EventHandler<PlanChangedEventArgs>? PlanChanged; void SetPlan(SgtPlan plan); void Clear(); } Source: csharp/src/Tools/Structural/SGT/Shared/Contracts/ISgtPlanStore.cs Orchestrator Pattern The SgtOrchestrator coordinates validation, domain object creation, and placement/update operations: Validate - Check plan integrity and extent resolution Build Domain - Create SgtWall with SgtMember and SgtOpening aggregates Hydrate - Resolve segments and connectivity Persist - Write to Revit document via ISgtDomainWriter Source: csharp/src/Tools/Structural/SGT/Features/Place/Logic/SgtOrchestrator.cs:17-40 UI Components Main Window Class: SgtWindow (WPF Window) ViewModel: SgtWindowViewModel Source: csharp/src/Tools/Structural/SGT/Shell/UI/Views/SgtWindow.xaml:2 The main window is a 1600x850 modal dialog with three main regions: Left Panel: Configuration Scope controls (wall offset, layer selection) Girts expander with DataGrid Openings expander with DataGrid Bulk edit flyout Center Splitter: Resizable divider Right Panel: Preview 2D elevation view 3D view (using HelixToolkit) Preview mode toggle Source: csharp/src/Tools/Structural/SGT/Shell/UI/Views/SgtWindow.xaml:243-255 Girt Grid Columns Column Property Description Elevation ElevationText Vertical position (feet-inches format) Girt Type GirtTypeId Family type selection Rotation Rotation Cross-section rotation (0/90/180/270) Y Justification YJustification Lateral positioning Z Justification ZJustification Vertical positioning Flip FlipHand Mirror orientation Source: csharp/src/Tools/Structural/SGT/Shell/UI/Views/SgtWindow.xaml:402-517 Opening Grid Columns Each opening row supports four framing roles with independent configuration: Left Jamb: Vertical member at opening left edge Right Jamb: Vertical member at opening right edge Header: Horizontal member at opening top Sill: Horizontal member at opening bottom (optional) Source: csharp/src/Tools/Structural/SGT/Common/Domain/OpeningRoleRules.cs Preview Modes Mode Description Elevation 2D front elevation view with girts and openings 3D Interactive 3D view with wall layers and framing Source: csharp/src/Tools/Structural/SGT/Features/Preview/Logic/Models/PreviewMode.cs:4-9 Services Dependency Injection All SGT services are registered via SgtServiceCollectionExtensions.AddSgt(): Source: csharp/src/Tools/Structural/SGT/Shell/Composition/SgtServiceCollectionExtensions.cs:29-83 Core Services Service Lifetime Purpose ISgtPlanStore Singleton Plan state management IUnitService Singleton Unit conversion SgtValidationService Singleton Plan validation ISgtSystemRepository Scoped Extensible storage access SgtPersistenceService Scoped Plan persistence Feature Services Service Lifetime Purpose RevitOpeningQuery Scoped Opening detection from walls FamilyCalibrationService Scoped Family profile extraction WallGeometryService Scoped Wall geometry analysis SgtOrientationAdapter Scoped Family orientation computation IExtentResolver Singleton Extent position resolution SegmentResolutionService Singleton Girt segment computation SgtAutoSeedingService Singleton Initial girt elevation seeding Placement Services Service Lifetime Purpose ISgtPlanBuilder Transient Build plan from wall context ISgtDomainWriter Transient Write domain objects to Revit SgtOrchestrator Transient Coordinate placement flow Smart Defaults Service The SgtSmartDefaultsService applies automatic orientation defaults based on family analysis: // For girts SgtSmartDefaultsService.ApplySmartDefaultsForGirt(row, plan); // For opening roles SgtSmartDefaultsService.TryApplySmartDefaultsForOpeningRole(row, role, plan); Source: csharp/src/Tools/Structural/SGT/Features/Girts/Services/SgtSmartDefaultsService.cs:43-70 Host Change Reconciliation When editing an existing SGT system, the tool detects changes to the host wall: Diff Detection: Compare stored vs current wall geometry Missing Wall Handling: Options for re-link or delete Geometry Mismatch: Options for scale, shift, or ignore Opening Changes: Sync manual openings to real elements Source: csharp/src/Tools/Structural/SGT/Features/Reconcile/SgtHostChangeReconciliationService.cs Configuration Manifest id: DBTools.SGT assembly: DBTools moduleType: DBTools.SGT.SgtToolModule order: 0 sandboxWindows: - id: DBTools.SGT.Main displayName: \"Super Girt Tool\" group: \"Structural\" windowType: \"DBTools.SGT.Shell.UI.Views.SgtWindow\" designTimeViewModelType: \"DBTools.SGT.Shell.DesignTime.SgtWindowDesignTimeViewModel\" tool: ribbonTools: - internalName: DBTools.SGT commandType: DBTools.SGT.Features.Commands.SgtNewCommand availabilityType: DBTools.App.Tools.Availability.DbtDocumentAvailability runProfile: InlineUi displayText: \"Super Girt Tool\" iconBaseKey: sgt tooltip: \"Launch Super Girt Tool\" controlKind: PushButton order: 40 Source: csharp/src/Tools/Structural/SGT/manifest.yml:1-21 UI State Persistence The ISgtUiStateStore persists user preferences: Expander states (Girts, Openings) Preview mode selection Column visibility Source: csharp/src/Tools/Structural/SGT/Shell/UI/Settings/ISgtUiStateStore.cs Domain Model Key Domain Entities SgtPlan The central data structure containing all configuration: public sealed class SgtPlan { // Wall context public int? HostWallId { get; init; } public int? LinkedWallId { get; init; } public int? LinkInstanceId { get; init; } public WallGeometry? WallGeometry { get; set; } // Girt configuration public List<SgtGirtRow> GirtRows { get; init; } public int SelectedGirtTypeId { get; set; } // Opening configuration public List<SgtOpeningRow> OpeningRows { get; set; } public IReadOnlyList<OpeningDetectionData> DetectedOpenings { get; set; } // Options public int DepthPlaneLayerIndex { get; set; } public double WallOffsetFeet { get; set; } public bool FoundationMode { get; set; } } Source: csharp/src/Tools/Structural/SGT/Common/Domain/SgtPlan.cs:16-193 Extent Types Girts support multiple extent modes: Extent Type Description FullLengthExtent Wall start to wall end AlongExtent Fixed distances from wall start GridExtent Between named grid lines with offsets OpeningEdgeExtent Relative to opening edges DualOpeningEdgeExtent Between two opening edges Source: csharp/src/Tools/Structural/SGT/Common/Domain/ (multiple files) Integration Points Revit API Integration SGT interacts with Revit through adapter services: WallGeometryService: Extract wall curves, layers, dimensions RevitOpeningQuery: Detect doors, windows, and openings in walls SgtDomainWriter: Create structural framing instances SgtSystemRepository: Store/retrieve SGT configurations in extensible storage Related Documentation System Architecture - Overall system design Application Host - How tools are loaded and hosted Tool Manifest Format - Manifest schema reference Testing SGT includes comprehensive tests: csharp/src/Tools/Structural/SGT/Tests/ +-- SgtAdapterTests.cs +-- SgtFrameBuilderTests.cs +-- SgtConfigHydratorTests.cs +-- SgtValidationServiceTests.cs +-- SgtOrchestratorExtentTests.cs +-- SgtHostChangeDiffServiceTests.cs +-- ... (additional test files) Source: csharp/src/Tools/Structural/SGT/Tests/DBTools.SGT.Tests.csproj Run tests via the Revit test runner: bash csharp/invoke-revit-tests.sh --smart --tool SGT Documentation Status: Complete Last Updated: 2026-01-24 Source Review: Verified against source files in csharp/src/Tools/Structural/SGT/"
  },
  "articles/tools/testing/vtc.html": {
    "href": "articles/tools/testing/vtc.html",
    "title": "View Template Comparer (VTC) | DB Tools",
    "summary": "View Template Comparer (VTC) The View Template Comparer (VTC) is a Testing category tool that enables side-by-side comparison of Revit view templates, allowing users to identify differences, selectively merge settings, and create new templates from combined configurations. Source: csharp/src/Tools/Testing/VTC/manifest.yml:1-21 Overview VTC provides a comprehensive solution for managing view template settings across Revit projects. The tool extracts complete template configurations including display settings, template parameter includes, category overrides, and filter overrides, presenting them in a hierarchical diff view for easy comparison and selective merging. Key Capabilities Side-by-side comparison of two view templates with visual diff highlighting Selective merging - choose individual settings from either template Apply to existing - update Template A or B with selected settings Create merged template - generate a new template combining selections from both sources JSON export/import - serialize template settings for cross-document transfer Template library - save and load configurations to local cache Text dump - export human-readable settings reports Source: csharp/src/Tools/Testing/VTC/Features/VtcCommand.cs:24-28 Features Template Selection The tool automatically loads all view templates from the active document, sorted alphabetically. Users select two templates for comparison: Template A (blue indicator) - the left/source template Template B (gold indicator) - the right/target template Templates can be swapped using the swap button for quick side-reversal. Source: csharp/src/Tools/Testing/VTC/Features/VtcCommand.cs:37-43 Settings Comparison VTC compares four categories of template settings: Category Description Display Properties Detail Level, Display Style, Parts Visibility, Discipline, Show Hidden Lines Template Parameters Which parameters are included/controlled by the template Category Overrides Visibility and graphics overrides per category and subcategory Filter Overrides Applied filters with visibility and graphics settings Source: csharp/src/Tools/Testing/VTC/Contracts/VtcEnums.cs:13-21 Each setting shows one of four difference states: State Meaning Same Values match in both templates Different Values differ between templates LeftMissing Setting exists only in Template B RightMissing Setting exists only in Template A Source: csharp/src/Tools/Testing/VTC/Contracts/VtcEnums.cs:38-44 Merge Operations Apply to Template A/B Applies selected settings to an existing template. The tool: Collects all user-selected settings from the diff tree Opens a Revit transaction Applies each selected value to the target template Updates non-controlled parameter list as needed Source: csharp/src/Tools/Testing/VTC/UI/ViewModels/VtcWindowViewModel.cs:198-226 Create Merged Template Creates a new view template combining settings from both sources: Duplicates the base template (user-selectable: Template A or B) Renames to user-specified name Applies all user-selected settings Commits the new template to the document Source: csharp/src/Tools/Testing/VTC/UI/ViewModels/VtcWindowViewModel.cs:228-275 Export/Import JSON Export Exports complete template settings to a JSON file containing: Template ID and name Display settings (detail level, discipline, etc.) Template parameter includes list Category graphics data (visibility, line colors, patterns, weights) Filter graphics data Source: csharp/src/Tools/Testing/VTC/Revit/Services/VtcSerializationService.cs:34-44 JSON Import Imports settings from a JSON file and applies them to the selected template. The import supports cross-document transfer by resolving elements by name when IDs don't match. Source: csharp/src/Tools/Testing/VTC/Revit/Services/VtcComparisonService.cs:236-270 Template Library VTC maintains a local cache of saved template configurations in %APPDATA%/DBTools/Cache/VTC/. Features include: Save - Store current template configuration with custom name Load - Apply saved configuration to Template A or B Delete - Remove saved configurations Refresh - Update the saved templates list Source: csharp/src/Tools/Testing/VTC/Services/VtcTemplateStorageService.cs:14-15 Text Dump Exports a human-readable text report of template settings including: Template name and view type All included parameters Display settings with current values Category visibility and graphics overrides Filter visibility and graphics overrides Output is written to a user-selected folder as {TemplateName}_template_dump.txt. Source: csharp/src/Tools/Testing/VTC/Revit/Services/VtcDumpService.cs:52-179 Architecture Module Structure DBTools.VTC/ +-- Bootstrap/ | +-- VtcServiceExtensions.cs # DI registration +-- Contracts/ | +-- IVtcComparisonService.cs # Comparison/merge interface | +-- IVtcDumpService.cs # Text export interface | +-- IVtcSerializationService.cs # JSON serialization interface | +-- VtcDataModels.cs # Data transfer objects | +-- VtcEnums.cs # Enumerations +-- Features/ | +-- VtcCommand.cs # Main command entry point +-- Revit/ | +-- Compat/ | | +-- ElementIdCompat.cs # ElementId compatibility layer | +-- Services/ | +-- VtcComparisonService.cs # Revit comparison implementation | +-- VtcDumpService.cs # Revit dump implementation | +-- VtcSerializationService.cs # Revit serialization implementation +-- Services/ | +-- VtcTemplateStorageService.cs # Local cache storage +-- UI/ | +-- Behaviors/ | | +-- ScrollSyncBehavior.cs # Synchronized scrolling | +-- Converters/ | | +-- VtcDiffBackgroundConverter.cs # Diff color converter | +-- ViewModels/ | | +-- VtcDiffNodeType.cs # Tree node types | | +-- VtcDiffTreeBuilder.cs # Tree construction | | +-- VtcDiffTreeNode.cs # Tree node model | | +-- VtcTemplateOption.cs # Dropdown item model | | +-- VtcWindowViewModel.cs # Main window ViewModel | +-- Views/ | +-- VtcWindow.xaml(.cs) # Main window +-- DesignTime/ | +-- VtcWindowDesignTimeViewModel.cs # XAML designer support +-- VtcToolModule.cs # Tool module registration +-- manifest.yml # Tool manifest Source: csharp/src/Tools/Testing/VTC/ Service Contracts IVtcComparisonService Core comparison and merge operations: public interface IVtcComparisonService { VtcTemplateSettingsModel Extract(object templateObject); VtcComparisonResult Compare(VtcTemplateSettingsModel left, VtcTemplateSettingsModel right); void ApplySelections(object target, VtcComparisonResult comparison, IReadOnlyCollection<VtcSelection> selections); void ApplySnapshot(object target, VtcTemplateSettingsModel source); } Source: csharp/src/Tools/Testing/VTC/Contracts/IVtcComparisonService.cs:8-29 IVtcSerializationService JSON import/export and template creation: public interface IVtcSerializationService { string Export(object templateObject, string path); VtcTemplateSettingsModel Import(string path); object CreateTemplateFromModel(object baseTemplate, VtcTemplateSettingsModel model, string newName); void ApplyModel(object targetTemplate, VtcTemplateSettingsModel model); } Source: csharp/src/Tools/Testing/VTC/Contracts/IVtcSerializationService.cs:6-27 IVtcDumpService Text report generation: public interface IVtcDumpService { (bool Success, string OutputPath) Run(object templateObject, string outputFolder); } Source: csharp/src/Tools/Testing/VTC/Contracts/IVtcDumpService.cs:6-12 Data Models VtcTemplateSettingsModel Complete template configuration for serialization: public sealed record VtcTemplateSettingsModel { public long TemplateId { get; init; } public string Name { get; init; } public VtcDisplaySettings Display { get; init; } public IReadOnlyList<VtcTemplateIncludeData> Includes { get; init; } public IReadOnlyList<VtcCategoryGraphicsData> Categories { get; init; } public IReadOnlyList<VtcFilterGraphicsData> Filters { get; init; } } Source: csharp/src/Tools/Testing/VTC/Contracts/VtcDataModels.cs:64-72 VtcSettingChange Represents a single difference between templates: public sealed record VtcSettingChange { public string Key { get; init; } public string DisplayName { get; init; } public VtcSettingType SettingType { get; init; } public VtcDisplayPropertyKind? DisplayProperty { get; init; } public VtcDifferenceKind DifferenceKind { get; init; } public string LeftDisplay { get; init; } public string RightDisplay { get; init; } public object? LeftValue { get; init; } public object? RightValue { get; init; } } Source: csharp/src/Tools/Testing/VTC/Contracts/VtcDataModels.cs:77-88 UI Components Hierarchical Diff Tree The comparison view uses a hierarchical TreeView with synchronized scrolling between left and right panels. The tree structure groups settings by type: Display Settings +-- Detail Level +-- Display Style +-- ... Template Parameters +-- Parameter 1 +-- Parameter 2 +-- ... Category Overrides +-- Walls | +-- Hidden Lines | +-- Surface Pattern +-- Structural Framing +-- ... Filter Overrides +-- Filter 1 +-- Filter 2 Source: csharp/src/Tools/Testing/VTC/UI/ViewModels/VtcDiffTreeBuilder.cs:17-43 Node types in the tree: Type Purpose Root Top-level category (Display Settings, Categories, etc.) CategoryGroup Parent category containing subcategories Setting Leaf node with actual values and selection checkboxes Source: csharp/src/Tools/Testing/VTC/UI/ViewModels/VtcDiffNodeType.cs:6-22 Settings VTC currently has no persistent user settings. All configuration is session-based through the UI. Cache Location Saved templates are stored in the user's local application data: %APPDATA%/DBTools/Cache/VTC/ Each saved template is stored as a JSON file with sanitized filename. Source: csharp/src/Tools/Testing/VTC/Services/VtcTemplateStorageService.cs:34 Manifest id: DBTools.VTC assembly: DBTools moduleType: DBTools.VTC.VtcToolModule order: 0 sandboxWindows: - id: DBTools.VTC.Main displayName: \"View Template Comparer\" group: \"Testing\" windowType: \"DBTools.VTC.UI.Views.VtcWindow\" designTimeViewModelType: \"DBTools.VTC.DesignTime.VtcWindowDesignTimeViewModel\" tool: ribbonTools: - internalName: DBTools.ViewTemplateComparer commandType: DBTools.VTC.Features.VtcCommand availabilityType: DBTools.App.Tools.Availability.DbtDocumentAvailability runProfile: InlineUi displayText: \"View Template\\nComparer\" iconBaseKey: vtc tooltip: \"Compare and merge view template settings\" controlKind: PushButton order: 50 Source: csharp/src/Tools/Testing/VTC/manifest.yml:1-21 Manifest Properties Property Value Description id DBTools.VTC Unique tool identifier moduleType DBTools.VTC.VtcToolModule Tool module class group Testing Ribbon panel group runProfile InlineUi Shows modeless window within Revit availabilityType DbtDocumentAvailability Requires active document controlKind PushButton Standard ribbon button Cross-Document Import VTC supports importing template settings from JSON files created in different Revit documents. When element IDs don't match (common across documents), the service falls back to name-based resolution: Parameters Searches ParameterElement and GlobalParameter types by name. Source: csharp/src/Tools/Testing/VTC/Revit/Services/VtcComparisonService.cs:239-270 Categories Handles both top-level and subcategories using \"Parent : Subcategory\" naming convention. Source: csharp/src/Tools/Testing/VTC/Revit/Services/VtcComparisonService.cs:296-340 Filters Searches ParameterFilterElement instances by name. Source: csharp/src/Tools/Testing/VTC/Revit/Services/VtcComparisonService.cs:398-415 Graphics Override Data VTC captures comprehensive graphics override settings for categories and filters: public sealed record VtcOverrideGraphicsData { public VtcColorData? ProjectionLineColor { get; init; } public long? ProjectionLinePatternId { get; init; } public int? ProjectionLineWeight { get; init; } public int? Transparency { get; init; } public int? CutLineWeight { get; init; } public VtcColorData? CutLineColor { get; init; } public long? CutLinePatternId { get; init; } public long? CutForegroundPatternId { get; init; } public VtcColorData? CutForegroundPatternColor { get; init; } } Source: csharp/src/Tools/Testing/VTC/Contracts/VtcDataModels.cs:17-28 Error Handling VTC uses the standard DBTools alert service for user notifications. The ViewModel provides centralized error and success messaging: No templates found - Warning shown if document contains no view templates Template not found - Error if selected template cannot be resolved No selections - Error if merge attempted without any settings selected Duplicate name - Error if new template name already exists Source: csharp/src/Tools/Testing/VTC/UI/ViewModels/VtcWindowViewModel.cs:472-488 Testing VTC includes unit tests for core logic that doesn't require Revit: VtcTemplateStorageServiceTests.cs - File I/O operations VtcDiffTreeNodeTests.cs - Tree node behavior VtcDiffTreeBuilderTests.cs - Tree construction from change lists Source: csharp/src/Tools/Testing/VTC/Tests/ Tests are located in csharp/src/Tools/Testing/VTC/Tests/ and run via the standard test runner without requiring Revit."
  },
  "articles/troubleshooting.html": {
    "href": "articles/troubleshooting.html",
    "title": "Troubleshooting Guide | DB Tools",
    "summary": "Troubleshooting Guide This guide covers common issues encountered when building, running, and debugging DBTools. Build Issues MSBuild Errors Error: DBT0001 - Build must be run through build.sh Symptom: error DBT0001: Raw 'dotnet build' from CLI is not supported. Use bash csharp/build.sh instead. Cause: The build system enforces that all builds go through the repository's build entrypoint to ensure proper configuration, vendored dependency staging, and multi-year target handling. Solution: Always use the build script: # Standard incremental build bash csharp/build.sh # Clean and rebuild bash csharp/build.sh --clean # Build specific Revit year bash csharp/build.sh -y 2025 BuildAll # Build only the app bash csharp/build.sh BuildApp Error: Windows dotnet.exe not found Symptom: Windows dotnet.exe not found at: /mnt/c/Program Files/dotnet/dotnet.exe Cause: The build script runs Windows dotnet.exe from WSL. The .NET SDK must be installed on the Windows host. Solution: Install .NET 8 SDK on Windows from dotnet.microsoft.com Verify installation: \"/mnt/c/Program Files/dotnet/dotnet.exe\" --version If installed to a non-default location, set the path in build.sh Missing Dependencies Vendored UI Assemblies Missing Symptom: Vendored UI assemblies missing under csharp/.artifacts/vendor; building them now... Or build failures referencing DBTools.HandyControl, DBTools.ControlzEx, or DBTools.Fluent.Ribbon. Cause: The vendored UI libraries (HandyControl, ControlzEx, FluentRibbon) must be built with custom namespaces before the main build. Solution: # Automatic (build.sh runs this if needed) bash csharp/build.sh # Manual rebuild of vendored deps bash csharp/build-vendored-deps.sh Expected output location: csharp/.artifacts/vendor/ handycontrol/net48/DBTools.HandyControl.dll handycontrol/net8.0-windows/DBTools.HandyControl.dll controlzex/net48/DBTools.ControlzEx.dll fluentribbon/net48/DBTools.Fluent.Ribbon.dll Assembly Load Failures Symptom: InvalidOperationException: Failed to load tool assembly 'DBTools.GM'. Cause: With file-linking architecture, tool assemblies (GM, TDV, SGT, VTC) are compiled into DBTools.dll. This error indicates the main assembly wasn't built correctly. Solution: Run a clean build: bash csharp/build.sh --clean Verify build output exists in csharp/.artifacts/bin/ Check that the Revit add-in is loading the correct version Source: DbtToolAssemblyLoader.cs:10 Runtime Issues Theme Validation Failures Theme validation runs at startup to catch XAML resource issues early. Failures here indicate broken theme dictionaries or missing resources. Theme Dictionary Merge Failed Symptom: InvalidOperationException: Theme dictionary merge failed at 'pack://application:,,,/DBTools.Themes;component/Themes/App.Brushes.xaml'. Cause: A XAML resource dictionary failed to load. Common causes: Missing assembly reference Broken StaticResource chain Syntax error in XAML Solution: Verify DBTools.Themes.dll exists alongside DBTools.dll Check build output for XAML compilation errors If modifying themes, validate XAML syntax in Visual Studio Source: DbtThemeValidator.cs:69 Theme Resource Freeze Failed Symptom: InvalidOperationException: Theme resource freeze failed for key 'PrimaryBrush' in 'App.Brushes.xaml'. Cause: A Freezable resource (brush, geometry) could not be frozen. This typically indicates the resource has unresolved bindings or dynamic references. Solution: Check the resource definition in the XAML file Ensure all referenced colors/values are static Remove any bindings from Freezable resources Source: DbtThemeValidator.cs:161 Theme Contract Mismatch Symptom: InvalidOperationException: Theme merged dictionary contract mismatch: expected 11 dictionaries but found 10 in 'App.Theme.xaml'. Cause: The theme root dictionary doesn't match the expected structure. This catches accidental removal or reordering of theme dictionaries. Expected merged dictionaries (in order): DBTools.HandyControl/Themes/SkinDark.xaml DBTools.HandyControl/Themes/Theme.xaml DBTools.Fluent.Ribbon/Themes/Generic.xaml DBTools.Themes/Themes/App.Tokens.xaml DBTools.Themes/Themes/App.Brushes.xaml DBTools.Themes/Themes/App.Converters.xaml DBTools.Themes/Themes/App.Controls.Base.xaml DBTools.Themes/Themes/App.DataGrid.xaml DBTools.Themes/Themes/App.Menus.xaml DBTools.Themes/Themes/App.Components.xaml DBTools.Themes/Themes/App.FluentRibbon.xaml Solution: Ensure App.Theme.xaml contains all dictionaries in the correct order. Source: DbtThemeValidator.cs:191 Revit API Errors RevitContextUnavailableException Symptom: RevitContextUnavailableException: No UIApplication in current gate scope. Or: RevitContextUnavailableException: ActiveUIDocument is required but was not available. Cause: Code attempted to access Revit API objects outside of a valid Revit context. This happens when: A modeless window tries to access Revit without using the call gate An async operation continues after the document was closed Code runs during Revit shutdown Solution: Ensure Revit API calls are wrapped in IRevitCallGate.RunAsync() Check for document availability before operations Handle cancellation when documents close Source: RevitContextUnavailableException.cs:6 WPF Dispatcher Issues Symptom: InvalidOperationException: No WPF Dispatcher is available (Application.Current is null and no Revit window dispatcher could be resolved). Or: InvalidOperationException: WPF Dispatcher is shutting down. Cause: WPF UI operations attempted when no dispatcher is available, typically during early startup or late shutdown. Solution: Use WpfUiThread.TryGetDispatcher() and check for null Check dispatcher.HasShutdownStarted before operations Use BeginInvoke instead of Invoke for non-blocking operations Source: WpfUiThread.cs:21 Tool-Specific Issues Generic Model Tool (GM) GmKernelBuildException Error Code Message Solution 1001 Failed to resolve family or type names Check that all referenced families exist in the project 1002 Failed to build nesting index Verify nested family relationships are valid 1003 Shared parameter deserialization failed Check shared parameter file integrity 1004 Usage data collection failed Ensure document is fully loaded before scanning Source: GmKernelExceptions.cs:6 GmInvalidMappingException Error Code Message Solution 2001 Operation metadata missing Ensure mapping configuration is complete 2002 Target type creation failed Check family loading and type creation permissions 2003 Shared parameter bind failed Verify parameter definitions exist 2004 Shared parameter embed failed Check parameter embedding permissions 2005 Replacement operation failed Validate replacement targets exist GmSnapshotLoadException Error Code Message Solution 4001 Snapshot deserialization failed Re-export snapshot; file may be corrupt 4002 Snapshot checksum mismatch Re-export snapshot; data integrity issue Transfer Drafting Views Tool (TDV) Error Code Message Solution DestinationTypeMissing Destination view type not found Create matching view type in destination SourceTypeNameUnavailable Source view type name not available Check source view is a valid drafting view CreateViewFailed Failed to create destination view Verify write permissions and view limits CopyElementsFailed Failed to copy view elements Check element validity and target view OverridesFailed Failed to copy view overrides Some overrides may not be transferable Source: TdvPerViewErrorCode.cs:3 Debugging Enabling Debug Mode Debug mode provides detailed logging and surfaces the logger window on errors. Methods to enable: Programmatically: debugModeService.SetEnabled(true) On error: Debug mode auto-enables when ISafeExecutor catches an exception Via Logger Window: Toggle the debug checkbox in the logger window toolbar Effects of debug mode: Log level changes from Information to Debug Logger window becomes visible More detailed stack traces in logs Faster log buffer flush (120ms vs 600ms) Log File Locations Log files are written to the user's local app data directory: %LOCALAPPDATA%\\DBTools\\Logs\\ Log file naming pattern: dbtools-{RevitYear}-{InstanceId}-{Timestamp}-{Nonce}.log Example: dbtools-2025-ABC123-20260124-143022345-a1b2c3d4.log Log retention policy: Maximum 50 files across all instances Maximum 14 days retention Maximum 100 MB total size Automatic cleanup on startup Source: LoggingConstants.cs:119 Using the Logger Window The logger window provides real-time log viewing with filtering capabilities. Features: Level filtering: Toggle INFO, WARN, ERROR, DEBUG visibility Search: Filter logs by text content Export: Save filtered logs to a file Auto-scroll: Automatically scroll to new entries Correlation IDs: Track related log entries across operations Window title format: DB Tools Log - Revit {Year} [{InstanceId}] Opening the logger window: Automatically opens when debug mode is enabled Automatically opens when an unhandled error occurs Can be opened via tools menu (if available) Understanding Correlation IDs Every operation executed through ISafeExecutor is assigned a correlation ID (GUID). This ID appears in all related log entries: [Start] GM Apply starting (CorrelationId=abc123...) ... operation logs ... [Complete] GM Apply completed in 1234ms (CorrelationId=abc123...) Use the correlation ID to: Filter related log entries Track operation duration Correlate errors with their triggering operations Common Error Messages Quick Reference Table Error Message Category Solution DBT0001: Raw 'dotnet build' not supported Build Use bash csharp/build.sh Theme dictionary merge failed Theme Rebuild themes, check XAML syntax Theme resource freeze failed Theme Remove bindings from Freezable resources Failed to load tool assembly Assembly Clean rebuild: build.sh --clean No UIApplication in current gate scope Revit API Wrap calls in IRevitCallGate.RunAsync() ActiveUIDocument is required Revit API Check document is open before operations WPF Dispatcher is shutting down UI Check dispatcher state before UI operations AppRuntime not initialized Runtime Ensure add-in is fully loaded Manifest missing required field Manifest Check tool manifest YAML syntax Tool module type not found Assembly Verify assembly name in manifest ISafeExecutor Error Phases All tool entrypoints run through ISafeExecutor, which logs structured execution phases: Phase Log Level Meaning [Start] Info Operation beginning [Complete] Info Operation finished successfully [Cancel] Warning Operation was cancelled [Error] Error Operation failed with exception Source: SafeExecutor.cs:12 Getting Help Diagnostic Information to Collect When reporting issues, gather: Log file from %LOCALAPPDATA%\\DBTools\\Logs\\ Revit version (year and build number) DBTools version (from add-in manifest) Correlation ID from the error log Steps to reproduce the issue Screenshot of any error dialogs Log Export Use the logger window's export feature to save filtered logs: Open logger window (enable debug mode if needed) Apply any relevant filters Click Export button Save to file with timestamp Export filename pattern: DBToolsLog_{Timestamp}.txt"
  },
  "developer-guide/architecture/build-pipeline.html": {
    "href": "developer-guide/architecture/build-pipeline.html",
    "title": "Build Pipeline | DB Tools",
    "summary": "Build Pipeline Overview DBTools uses a sophisticated build pipeline designed for: Multi-year Revit support (2024, 2025, 2026) Multi-framework targeting (net48 for Revit 2024, net8.0-windows for 2025+) WSL/Windows interoperability (development in WSL, builds via Windows dotnet.exe) Assembly merging (ILRepack for net48, AssemblyLoadContext for net8) Centralized artifacts (all outputs to .artifacts/, no per-project bin/obj) Source: csharp/build.sh:1-162, csharp/build/Build.cs:1-200 Quick Reference # Fast incremental build (default) bash csharp/build.sh # Clean + full rebuild bash csharp/build.sh --clean # Build specific Revit year bash csharp/build.sh -y 2025 BuildAll # Debug configuration bash csharp/build.sh --debug # Build only the app (skip tests) bash csharp/build.sh BuildApp # Clean outputs only bash csharp/build.sh Clean Source: csharp/build.sh:33-61 Architecture Build System Stack ┌─────────────────────────────────────────────────────────────┐ │ build.sh │ │ (Bash wrapper - WSL/Git Bash compatible) │ ├─────────────────────────────────────────────────────────────┤ │ Windows dotnet.exe │ │ (via wslpath/cygpath conversion) │ ├─────────────────────────────────────────────────────────────┤ │ NUKE Build │ │ (Build.cs, BuildTargets.cs, etc.) │ ├─────────────────────────────────────────────────────────────┤ │ MSBuild + .NET SDK │ │ (Directory.Build.props/targets, *.csproj) │ └─────────────────────────────────────────────────────────────┘ Key Files File Purpose build.sh Entry point - WSL/Git Bash wrapper build/Build.cs NUKE orchestration, parameters, cleanup build/BuildTargets.cs Build targets, Revit path resolution build/BuildMerging.cs ILRepack assembly merging (net48) build/BuildHelpers.cs Path conversion utilities build/ArtifactManagement.cs Metadata, fingerprinting, promotion Directory.Build.props Centralized project properties Directory.Build.targets Build targets, NUKE enforcement Version.props Product version build/Revit.props Revit-specific TFM definitions Source: csharp/build/Build.cs:17-24 Entry Point: build.sh The build script (build.sh) is the required entry point for all builds. Direct dotnet build is blocked by MSBuild. WSL Detection The script auto-detects the environment and configures appropriate path conversion: if [[ -f /proc/version ]] && grep -qi microsoft /proc/version 2>/dev/null; then # WSL environment WIN_DOTNET_EXE=\"/mnt/c/Program Files/dotnet/dotnet.exe\" to_win_path() { wslpath -w \"$1\"; } else # Git Bash or other WIN_DOTNET_EXE=\"/c/Program Files/dotnet/dotnet.exe\" to_win_path() { cygpath -w \"$1\"; } fi Source: csharp/build.sh:6-15 Build Server Cleanup The script ensures MSBuild daemon processes are terminated on exit to prevent file locks: cleanup_build_servers() { \"$WIN_DOTNET_EXE\" build-server shutdown 2>/dev/null || true } trap cleanup_build_servers EXIT INT TERM Source: csharp/build.sh:17-20 Vendored Dependencies Before non-Clean targets, the script checks for vendored UI assemblies and builds them if missing: ensure_vendored_deps() { local vendor_root=\"$SCRIPT_DIR/.artifacts/vendor\" local missing=false for tfm in net48 net8.0-windows; do [[ -f \"$vendor_root/handycontrol/$tfm/DBTools.HandyControl.dll\" ]] || missing=true [[ -f \"$vendor_root/controlzex/$tfm/DBTools.ControlzEx.dll\" ]] || missing=true [[ -f \"$vendor_root/fluentribbon/$tfm/DBTools.Fluent.Ribbon.dll\" ]] || missing=true done if $missing; then echo \"Vendored UI assemblies missing; building them now...\" bash \"$SCRIPT_DIR/build-vendored-deps.sh\" fi } Source: csharp/build.sh:116-130 NUKE Build System Parameters Parameter Default Description --Configuration Release Build configuration --Years 2024 2025 2026 Revit years to target --SkipClean true Skip clean for fast incremental builds --DryRun false Simulate actions without executing --ValidateManifests true Validate embedded manifests --ValidateTools true Validate tool UIs Source: csharp/build/Build.cs:36-51 Key Targets flowchart LR subgraph Preflight[\"Preflight\"] A[PreflightRevitInstalls] end subgraph Build[\"Build Phase\"] B[BuildCore] C[BuildApp] D[VendoredStageUiToYearOutputs] E[BuildTests] end subgraph Package[\"Package Phase\"] F[FlattenYearOutputs] G[PromoteToDist] H[WriteMetadata] I[ValidateDist] end A --> B --> C --> D --> E --> F --> G --> H --> I style Preflight fill:#fff3e0 style Build fill:#e3f2fd style Package fill:#e8f5e9 BuildAll ├── PreflightRevitInstalls ├── BuildCore ├── BuildApp ├── VendoredStageUiToYearOutputs ├── BuildTests ├── FlattenYearOutputs ├── PromoteToDist ├── WriteMetadata └── ValidateDist Target Description BuildAll Full build with validation BuildOnly Build without validation (CI use) BuildApp Build DBTools.App only BuildCore Build DBTools.Core only BuildTests Build all test projects Clean Delete staging/intermediate outputs PromoteToDist Copy validated outputs to dist/ Source: csharp/build/Build.cs:165-177 Revit Path Resolution NUKE auto-detects Revit installations using ricaun.Nuke: var installs = RevitInstallationUtils.InstalledRevit ?? Array.Empty<RevitInstallation>(); foreach (var inst in installs) Serilog.Log.Information(\" - Version={Version}, Location={Location}\", inst.Version, inst.InstallLocation); Override with parameters if needed: --Revit2024Dir --Revit2025Dir --Revit2026Dir Source: csharp/build/BuildTargets.cs:35-78 MSBuild Configuration Directory.Build.props The centralized props file establishes: Artifact paths - All outputs to .artifacts/ Year-based organization - bin/{Config}/{Year}/{TFM}/ Design-time support - XAML designer compatibility Code analysis - Warnings as errors, nullable enabled Centralized Artifacts <PropertyGroup> <BaseArtifactsDir>$(MSBuildThisFileDirectory).artifacts\\</BaseArtifactsDir> <BaseIntermediateOutputPath>$(BaseArtifactsDir)obj\\</BaseIntermediateOutputPath> <BaseOutputPath>$(BaseArtifactsDir)bin\\</BaseOutputPath> </PropertyGroup> Source: csharp/Directory.Build.props:12-14 Year-Based Output <PropertyGroup Condition=\"'$(DesignTimeBuild)'!='true'\"> <DBT_OutputYear Condition=\"'$(RevitYear)'!=''\">$(RevitYear)</DBT_OutputYear> <DBT_OutputYear Condition=\"'$(RevitYear)'==''\">shared</DBT_OutputYear> <OutputPath>$(BaseOutputPath)$(Configuration)\\$(DBT_OutputYear)\\</OutputPath> </PropertyGroup> This produces: .artifacts/ ├── bin/ │ ├── Release/ │ │ ├── 2024/ │ │ │ └── net48/ │ │ ├── 2025/ │ │ │ └── net8.0-windows/ │ │ └── 2026/ │ │ └── net8.0-windows/ │ └── Debug/ │ └── ... └── obj/ └── ... Source: csharp/Directory.Build.props:105-121 Code Quality Settings <PropertyGroup> <TreatWarningsAsErrors>true</TreatWarningsAsErrors> <LangVersion>latest</LangVersion> <Nullable>enable</Nullable> <EnableNETAnalyzers>true</EnableNETAnalyzers> <AnalysisLevel>latest-recommended</AnalysisLevel> </PropertyGroup> Source: csharp/Directory.Build.props:142-150 Directory.Build.targets NUKE Entry Point Enforcement Direct dotnet build from CLI is blocked to ensure consistent builds: <Target Name=\"DBT_EnforceEntryPoint\" BeforeTargets=\"CoreCompile\" Condition=\"'$(DesignTimeBuild)'!='true' and '$(DBT_Entry)'!='true'\"> <Error Code=\"DBT0001\" Text=\"Direct builds are blocked. Use ./csharp/build.sh\" /> </Target> Only builds via build.sh (which sets DBT_Entry=true) are allowed. Source: csharp/Directory.Build.targets:32-37 WPF Designer Fixes The targets file includes several fixes for WPF/XAML designer compatibility: Platform target override for designer (AnyCPU instead of x64) Intermediate path fixes for wpftmp projects Reference resolution before XAML compilation Duplicate file removal for generated code Source: csharp/Directory.Build.targets:8-63 Multi-Year Targeting Target Framework Matrix Revit Year .NET Version TFM 2024 .NET Framework 4.8 net48 2025 .NET 8 net8.0-windows 2026 .NET 8 net8.0-windows Revit.props Defines canonical TFMs for Revit-facing projects: <PropertyGroup> <RevitTargetFrameworks>net48;net8.0-windows</RevitTargetFrameworks> </PropertyGroup> Source: csharp/build/Revit.props Conditional Compilation Projects use conditional compilation for version-specific code: #if REVIT2024 // net48-specific code #elif REVIT2025 || REVIT2026 // net8-specific code #endif Assembly Merging ILRepack (net48 / Revit 2024) For Revit 2024 (net48), dependencies are merged into DBTools.dll using ILRepack: // Merge ALL DLLs except whitelist: var keepSeparate = new HashSet<string> { \"DBTools.dll\", // Primary assembly \"DBTools.Loader.dll\", // Entry point \"DBTools.HandyControl.dll\", \"DBTools.Fluent.Ribbon.dll\", \"DBTools.ControlzEx.dll\", \"DBTools.Themes.dll\", // Revit API (shouldn't be in output) \"RevitAPI.dll\", \"RevitAPIUI.dll\", }; Why merge? Revit add-ins share the AppDomain Without merging, different add-ins with same dependency versions can conflict ILRepack internalizes types to prevent conflicts What stays separate? WPF theme assemblies (need file Location for pack:// URIs) Loader assembly (Revit's entry point) Logging abstractions (shared type identity) Source: csharp/build/BuildMerging.cs:17-65 AssemblyLoadContext (net8 / Revit 2025+) For Revit 2025+ (net8), isolation is achieved via AssemblyLoadContext: Each add-in gets its own load context Dependencies are isolated without merging No ILRepack needed Source: csharp/build/BuildMerging.cs:11-14 Artifact Structure Build Outputs .artifacts/ ├── bin/ │ └── Release/ │ ├── 2024/ │ │ └── net48/ │ │ ├── DBTools.dll (merged) │ │ ├── DBTools.Loader.dll │ │ ├── DBTools.Themes.dll │ │ └── DBTools.*.dll (UI assemblies) │ ├── 2025/ │ │ └── net8.0-windows/ │ │ ├── DBTools.dll │ │ ├── DBTools.Loader.dll │ │ └── *.dll (dependencies) │ └── 2026/ │ └── net8.0-windows/ │ └── ... ├── tests/ │ └── Release/ │ ├── 2024/ │ ├── 2025/ │ └── 2026/ ├── vendor/ │ ├── handycontrol/ │ ├── controlzex/ │ └── fluentribbon/ └── .staging/ └── {BuildId}/ ├── bundle/ ├── installer/ └── logs/ Distribution After PromoteToDist, production payloads are in: .artifacts/dist/ ├── 2024/ ├── 2025/ └── 2026/ Troubleshooting Common Issues Problem Solution \"Direct builds are blocked\" (DBT0001) Use build.sh instead of dotnet build \"Windows dotnet.exe not found\" Ensure .NET SDK installed on Windows side \"Vendored UI assemblies missing\" Run build-vendored-deps.sh XAML designer errors Build once via build.sh to populate artifacts MSBuild daemon file locks Script auto-cleans; or run dotnet build-server shutdown Verbose Logging # Add --Verbose for detailed NUKE output bash csharp/build.sh --Verbose BuildAll Clean Rebuild # Full clean + rebuild bash csharp/build.sh --clean BuildAll Related Documentation Project References - Dependency relationships ILRepack & Embedding - Assembly merging details Test Pipeline - Testing infrastructure Verification Status Check Status Source anchors for all claims Yes UNVERIFIED markers where needed No (all verified) Cross-references added Yes Examples tested N/A (documentation) No assumptions without evidence Yes Verified by: initial-wiki-session Date: 2026-01-16"
  },
  "developer-guide/architecture/ilrepack-embedding.html": {
    "href": "developer-guide/architecture/ilrepack-embedding.html",
    "title": "ILRepack and Assembly Embedding | DB Tools",
    "summary": "ILRepack and Assembly Embedding This document describes how DBTools merges and embeds assemblies to achieve a minimal deployment footprint while avoiding conflicts with other Revit add-ins. Overview DBTools uses two complementary strategies to manage dependencies: Strategy Framework Purpose ILRepack net48 only Merges most dependencies INTO DBTools.dll Embedding Both TFMs Embeds assemblies as resources, loaded on-demand Both strategies aim to: Minimize deployment files (ideally just DBTools.dll + DBTools.Loader.dll + WPF theme DLLs) Avoid conflicts with other Revit add-ins that may load different versions of shared libraries Prevent GAC/Revit-provided assemblies from being used instead of our versions Source: csharp/build/BuildMerging.cs:11-22 Why ILRepack? The Revit Add-in Conflict Problem Revit add-ins share a single AppDomain (net48) or AssemblyLoadContext (net8). When multiple add-ins depend on the same library (e.g., Serilog, Newtonsoft.Json), the first-loaded version wins. Problems this causes: Type identity mismatches (your code expects Serilog 4.0, but Serilog 2.0 was loaded first) Missing method exceptions (newer API called on older assembly) Mysterious crashes when reflection fails ILRepack's solution: Merge dependencies INTO DBTools.dll with internalized types Types become internal to your assembly, invisible to other add-ins No conflict possible because types aren't shared Source: csharp/build/BuildMerging.cs:17-21 net48 vs net8.0-windows Strategy Differences net48 (Revit 2024) Uses both ILRepack merging AND embedding: +-------------------+ | DBTools.dll | | (ILRepack'd) | <-- Contains merged types from Serilog, M.E.*, etc. +-------------------+ | +-- Embedded resources: ricaun.Revit.UI.*.dll (loaded from bytes) | +-- Separate files: DBTools.Fluent.Ribbon.dll, DBTools.Themes.dll, etc. net8.0-windows (Revit 2025/2026) Uses embedding only (no ILRepack): +-------------------+ | DBTools.dll | | (standard) | +-------------------+ | +-- Embedded resources: ALL dependencies (DBTools.Core, Serilog, M.E.*, etc.) | +-- Separate files: DBTools.Fluent.Ribbon.dll, DBTools.Themes.dll, etc. Why no ILRepack for net8? .NET 8's AssemblyLoadContext provides natural isolation Each add-in can have its own isolated context ILRepack has compatibility issues with some .NET 8 assemblies Source: csharp/build/BuildMerging.cs:13-14, csharp/src/DBTools.Loader/AssemblyResolution/EmbeddedAssemblyResolver.cs:32-37 ILRepack Merging (net48) Target: MergeNet48Assemblies The build target MergeNet48Assemblies performs the merge: Target MergeNet48Assemblies => _ => _ .Description(\"Merge ALL dependencies into DBTools.dll for net48 via ILRepack (except WPF themes)\") .DependsOn(FlattenYearOutputs) .After(BuildApp, BuildTests) .Before(PromoteToDist) Source: csharp/build/BuildMerging.cs:23-28 What Gets Merged (Everything Except Whitelist) The strategy is \"merge everything EXCEPT a small whitelist\": var keepSeparate = new HashSet<string>(StringComparer.OrdinalIgnoreCase) { \"DBTools.dll\", // Primary assembly (merging INTO this) \"DBTools.Loader.dll\", // Entry point loaded by Revit \"DBTools.HandyControl.dll\", // WPF theme - needs file Location \"DBTools.Fluent.Ribbon.dll\", // WPF theme - needs file Location \"DBTools.ControlzEx.dll\", // WPF theme - needs file Location \"DBTools.Themes.dll\", // WPF theme - needs file Location \"Microsoft.Extensions.Logging.Abstractions.dll\", // Shared with sandbox // Revit API (shouldn't be in output) \"RevitAPI.dll\", \"RevitAPIUI.dll\", \"AdWindows.dll\", \"UIFramework.dll\" }; Source: csharp/build/BuildMerging.cs:50-65 Prefix-Based Exclusions Some assemblies are excluded by prefix (because NuGet adds version numbers): var keepSeparatePrefixes = new[] { \"ricaun.Revit.UI\" }; Why ricaun assemblies aren't merged: ILRepack corrupts ricaun IL, causing runtime crashes Instead, ricaun assemblies are EMBEDDED as resources Source: csharp/build/BuildMerging.cs:68-70 Internalization with Exclusions ILRepack internalizes merged types, but some namespaces must stay public: var excludeFile = yearDir / \"ilrepack-exclude.txt\"; File.WriteAllText(excludeFile, \"^DBTools\\\\.Core\\\\.\\n^Serilog\\\\.\\n^Microsoft\\\\.Extensions\\\\.\\n^Microsoft\\\\.Bcl\\\\.\\n^System\\\\.\\n^ricaun\\\\.Revit\\\\.\"); Namespace Why Public DBTools.Core.* Base classes used by tools Serilog.* Reflection-based sink discovery Microsoft.Extensions.* DI and configuration Microsoft.Bcl.* Polyfill interfaces (IAsyncDisposable) System.* Polyfill types Source: csharp/build/BuildMerging.cs:115-127 ILRepack Command The actual merge command: args.Append($\"/internalize:\\\"{excludeFile}\\\" \"); // Internalize with exclusions args.Append(\"/allowdup \"); // Handle duplicate polyfill types args.Append(\"/ndebug \"); // Skip debug info args.Append($\"/lib:\\\"{revitPath}\\\" \"); // Resolve Revit API references args.Append($\"/out:\\\"{dbToolsDll}\\\" \"); // Output to DBTools.dll args.Append($\"\\\"{backupOriginal}\\\" \"); // Primary assembly // + all assemblies to merge Source: csharp/build/BuildMerging.cs:129-144 Assembly Embedding Strategy Build Target: DBT_EmbedCopyLocalAssemblies The embedding happens during MSBuild via a custom target: <Target Name=\"DBT_EmbedCopyLocalAssemblies\" AfterTargets=\"ResolveReferences\" Condition=\"'$(DesignTimeBuild)'!='true'\"> Source: csharp/src/DBTools.App/DBTools.App.csproj:234-236 Resource Naming Convention Embedded assemblies use a logical name pattern: DBTools.EmbeddedAssemblies.{AssemblyName}.dll For example: DBTools.EmbeddedAssemblies.Serilog.dll DBTools.EmbeddedAssemblies.DBTools.Core.dll <ItemGroup> <_EmbedLogical Include=\"@(_EmbedIdentity->'DBTools.EmbeddedAssemblies.%(Name).dll')\"> <SourcePath>%(OriginalItemSpec)</SourcePath> </_EmbedLogical> <EmbeddedResource Include=\"%(_EmbedLogicalDistinct.SourcePath)\" LogicalName=\"%(_EmbedLogicalDistinct.Identity)\" /> </ItemGroup> Source: csharp/src/DBTools.App/DBTools.App.csproj:262-268 Exclusions from Embedding Revit-provided assemblies (never copy/embed): <_EmbedCandidate Remove=\"@(_EmbedCandidate)\" Condition=\"'%(Filename)%(Extension)' == 'RevitAPI.dll'\" /> <_EmbedCandidate Remove=\"@(_EmbedCandidate)\" Condition=\"'%(Filename)%(Extension)' == 'Newtonsoft.Json.dll'\" /> WPF theme assemblies (need file Location): <_EmbedCandidate Remove=\"@(_EmbedCandidate)\" Condition=\"$([System.String]::Copy('%(Filename)').StartsWith('DBTools.Fluent.Ribbon'))\" /> <_EmbedCandidate Remove=\"@(_EmbedCandidate)\" Condition=\"$([System.String]::Copy('%(Filename)').StartsWith('DBTools.ControlzEx'))\" /> <_EmbedCandidate Remove=\"@(_EmbedCandidate)\" Condition=\"$([System.String]::Copy('%(Filename)').StartsWith('DBTools.Themes'))\" /> Source: csharp/src/DBTools.App/DBTools.App.csproj:241-251 Runtime Assembly Resolution EmbeddedAssemblyResolver The resolver is installed early during add-in startup: public static void Install(Assembly mainAssembly, string? deployedDir = null) { // ... #if NET8_0_OR_GREATER var alc = AssemblyLoadContext.GetLoadContext(mainAssembly) ?? AssemblyLoadContext.Default; alc.Resolving += (context, name) => ResolveNet8(context, mainAssembly, name); #else AppDomain.CurrentDomain.AssemblyResolve += (_, args) => Resolve(mainAssembly, args.Name); #endif } Source: csharp/src/DBTools.Loader/AssemblyResolution/EmbeddedAssemblyResolver.cs:24-38 Resolution Flow (net48) Assembly requested (e.g., \"Serilog\") | v 1. Already loaded in AppDomain? YES -> Return existing (prevents duplicates) | v 2. Try embedded resource: \"DBTools.EmbeddedAssemblies.Serilog.dll\" FOUND -> Assembly.Load(bytes) | v 3. Check if merged via ILRepack (TryGetMergedAssembly) MERGED -> Return mainAssembly | v 4. DBTools.* namespace? Try file-based fallbacks FOUND -> Assembly.LoadFrom(path) | v 5. Return null (let CLR handle) Source: csharp/src/DBTools.Loader/AssemblyResolution/EmbeddedAssemblyResolver.cs:40-95 Merged Assembly Detection (net48) For ILRepack'd assemblies, the resolver returns the main assembly: private static Assembly? TryGetMergedAssembly(Assembly mainAssembly, string requestedName) { // WPF themes NOT merged if (requestedName.Equals(\"DBTools.Fluent.Ribbon\", ...) || requestedName.Equals(\"DBTools.ControlzEx\", ...) || requestedName.Equals(\"DBTools.Themes\", ...) || requestedName.Equals(\"DBTools.Loader\", ...)) return null; // DBTools.Core is merged if (requestedName.Equals(\"DBTools.Core\", ...)) return mainAssembly; // Other merged deps if (requestedName.StartsWith(\"Serilog\", ...) || requestedName.StartsWith(\"Microsoft.Extensions\", ...) || requestedName.Equals(\"YamlDotNet\", ...)) return mainAssembly; return null; } Source: csharp/src/DBTools.Loader/AssemblyResolution/EmbeddedAssemblyResolver.cs:223-263 Resolution Flow (net8) private static Assembly? ResolveNet8(AssemblyLoadContext alc, Assembly mainAssembly, AssemblyName requested) { // 1. Already loaded? Return it var alreadyLoaded = alc.Assemblies.FirstOrDefault(...); if (alreadyLoaded != null) return alreadyLoaded; // 2. Try embedded resource var resourceName = ResourcePrefix + requestedName + \".dll\"; using var stream = mainAssembly.GetManifestResourceStream(resourceName); if (stream != null) { return alc.LoadFromStream(ms); // Load into same ALC } // 3. File-based fallbacks for WPF assemblies return TryLoadFromFileFallbacksNet8(alc, mainAssembly, requestedName); } Source: csharp/src/DBTools.Loader/AssemblyResolution/EmbeddedAssemblyResolver.cs:146-189 WPF Theme Assemblies: Why They Stay Separate The pack:// URI Problem WPF's XAML parser uses pack:// URIs to locate resources within assemblies: <ResourceDictionary Source=\"pack://application:,,,/DBTools.Fluent.Ribbon;component/Themes/Generic.xaml\" /> The parser uses Assembly.Location to resolve these URIs. Assemblies loaded from byte arrays have Location = \"\", breaking resource lookup. Source: csharp/src/DBTools.Loader/AssemblyResolution/EmbeddedAssemblyResolver.cs:93-94, csharp/src/DBTools.App/DBTools.App.csproj:244-251 Which Assemblies Need File Location Assembly Reason DBTools.Fluent.Ribbon Contains BAML for ribbon controls DBTools.ControlzEx Contains BAML for window behaviors DBTools.HandyControl Contains BAML for HandyControl widgets DBTools.Themes Contains merged theme dictionaries Source: csharp/build/BuildMerging.cs:53-57 File-Based Resolution Fallbacks For WPF assemblies, the resolver tries file-based loading: private static Assembly? TryLoadFromFileFallbacks(Assembly mainAssembly, string requestedName) { // 1. Check %APPDATA%/DBTools/vendor/<type>/<tfm>/ var appDataPath = Path.Combine( Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData), \"DBTools\", \"vendor\", vendorType, vendorTfm, dllName); if (File.Exists(appDataPath)) return Assembly.LoadFrom(appDataPath); // 2. Check deployed directory (next to DBTools.Loader.dll) return TryLoadFromDeployedDir(deployedDir, dllName); } Source: csharp/src/DBTools.Loader/AssemblyResolution/EmbeddedAssemblyResolver.cs:101-129 Preloading Critical Assemblies (net48) The GAC Problem On net48, AssemblyResolve only fires when an assembly CAN'T be found. If an older version exists in the GAC or was loaded by another add-in, the CLR uses it instead of asking our resolver. Solution: Preload During Startup Before any code uses these assemblies, DBTools.Loader preloads them from embedded resources: #if !NET8_0_OR_GREATER PreloadEmbeddedConfigurationAssemblies(assembly); PreloadEmbeddedSerilogAssemblies(assembly); #endif Source: csharp/src/DBTools.Loader/Addin/AddinEntry.cs:25-28 Configuration Assembly Preload private static void PreloadEmbeddedConfigurationAssemblies(Assembly mainAssembly) { var configAssemblies = new[] { \"Microsoft.Extensions.Primitives\", \"Microsoft.Extensions.FileProviders.Abstractions\", \"Microsoft.Extensions.FileProviders.Physical\", \"Microsoft.Extensions.Configuration.Abstractions\", \"Microsoft.Extensions.Configuration\", \"Microsoft.Extensions.Configuration.FileExtensions\", \"Microsoft.Extensions.Configuration.Json\", \"Microsoft.Extensions.Configuration.Binder\" }; foreach (var name in configAssemblies) { var alreadyLoaded = GetLoadedAssemblyBySimpleName(name); if (alreadyLoaded != null) continue; var resourceName = \"DBTools.EmbeddedAssemblies.\" + name + \".dll\"; using (var stream = mainAssembly.GetManifestResourceStream(resourceName)) { if (stream == null) continue; using (var ms = new MemoryStream()) { stream.CopyTo(ms); Assembly.Load(ms.ToArray()); } } } } Source: csharp/src/DBTools.Loader/Addin/AddinEntry.cs:109-143 Serilog Assembly Preload Critical: Dependencies must be loaded BEFORE dependents: var serilogAssemblies = new[] { // 1. Base abstractions first \"Microsoft.Extensions.Logging.Abstractions\", \"Microsoft.Extensions.DependencyInjection.Abstractions\", // 2. M.E.Logging (depends on Abstractions) \"Microsoft.Extensions.Logging\", // 3. Serilog core \"Serilog\", // 4. Serilog extensions (depend on above) \"Serilog.Extensions.Logging\", \"Serilog.Enrichers.Thread\", \"Serilog.Sinks.File\" }; Source: csharp/src/DBTools.Loader/Addin/AddinEntry.cs:150-170 Forbidden Host Assemblies Build-Time Guardrails The build prevents certain assemblies from landing in output: <ItemGroup> <ForbiddenHostAssembly Include=\"RevitAPI.dll\" /> <ForbiddenHostAssembly Include=\"RevitAPIUI.dll\" /> <ForbiddenHostAssembly Include=\"AdWindows.dll\" /> <ForbiddenHostAssembly Include=\"UIFramework.dll\" /> <ForbiddenHostAssembly Include=\"Newtonsoft.Json.dll\" /> <ForbiddenHostAssembly Include=\"System.Runtime.dll\" /> <ForbiddenHostAssembly Include=\"System.ObjectModel.dll\" /> </ItemGroup> Source: csharp/src/DBTools.App/DBTools.App.csproj:169-177 Automatic Cleanup A build target removes forbidden assemblies if transitive dependencies copied them: <Target Name=\"DBT_RemoveForbiddenAfterCopy\" AfterTargets=\"CopyFilesToOutputDirectory\" BeforeTargets=\"FailIfHostAssembliesInOutput\"> <Delete Files=\"@(_DBT_ForbiddenToClear)\" /> </Target> Source: csharp/src/DBTools.App/DBTools.App.csproj:181-196 Build Failure on Violation If any forbidden assemblies remain after cleanup, the build fails: <Target Name=\"FailIfHostAssembliesInOutput\"> <Error Text=\"Forbidden host assemblies detected in output: @(_ForbiddenInOutput).\" Condition=\"'@(_ForbiddenInOutput)' != ''\" /> </Target> Source: csharp/src/DBTools.App/DBTools.App.csproj:198-211 Summary: What Goes Where Assembly Type net48 net8.0-windows Location DBTools.Core ILRepack merged Embedded resource Inside DBTools.dll Serilog.* ILRepack merged Embedded resource Inside DBTools.dll M.E.DI/Config ILRepack merged Embedded resource Inside DBTools.dll YamlDotNet ILRepack merged Embedded resource Inside DBTools.dll ricaun.Revit.* Embedded resource Embedded resource Inside DBTools.dll DBTools.Themes Separate file Separate file Next to DBTools.dll DBTools.Fluent.Ribbon Separate file Separate file Next to DBTools.dll DBTools.ControlzEx Separate file Separate file Next to DBTools.dll DBTools.HandyControl Separate file Separate file Next to DBTools.dll DBTools.Loader Separate file Separate file Next to DBTools.dll RevitAPI/UI Never copied Never copied Revit provides Troubleshooting Issue: \"Type X not found\" or \"Method Y not found\" Cause: Assembly version mismatch - another add-in loaded a different version first. Solutions: Ensure dependencies are embedded or merged Check if the assembly is in keepSeparate whitelist unnecessarily Preload the assembly during startup Issue: WPF resource not found (pack:// URI failure) Cause: WPF assembly loaded from bytes instead of file. Solutions: Ensure WPF assemblies are in keepSeparate whitelist Verify DLLs are deployed next to DBTools.Loader.dll Check EmbeddedAssemblyResolver file fallback paths Issue: ILRepack crash or corrupted IL Cause: Some assemblies have IL that ILRepack can't process. Solutions: Add to keepSeparatePrefixes to exclude from merge Embed as resource instead of merging Check ILRepack version compatibility Issue: Duplicate type definitions after merge Cause: Multiple assemblies define the same polyfill type. Solution: ILRepack /allowdup flag handles this: args.Append(\"/allowdup \"); // Handle duplicate polyfill types Source: csharp/build/BuildMerging.cs:131 Related Documentation Architecture Overview - High-level system architecture Project References - How projects reference each other Build Pipeline - Build system details DBTools.Loader - Assembly loading at runtime Verification Status Check Status Source anchors for all claims Yes UNVERIFIED markers where needed No (all verified) Cross-references added Yes Examples tested N/A No assumptions without evidence Yes Verified by: docs-run-20260124-020412 Date: 2026-01-24"
  },
  "developer-guide/architecture/overview.html": {
    "href": "developer-guide/architecture/overview.html",
    "title": "Architecture Overview | DB Tools",
    "summary": "Architecture Overview DBTools is a modular Revit add-in suite built with modern C#/.NET practices. It provides a collection of productivity tools for structural engineers working in Autodesk Revit. High-Level Architecture graph TB subgraph Revit[\"Revit Host\"] RevitAPI[\"Revit API<br/>(RevitAPI.dll, RevitAPIUI.dll)\"] end subgraph DBTools[\"DBTools Add-in\"] Loader[\"DBTools.Loader<br/>(Entry Point)\"] App[\"DBTools.App<br/>(DBTools.dll)\"] Core[\"DBTools.Core<br/>(Core Library)\"] Themes[\"DBTools.Themes<br/>(WPF Resources)\"] subgraph Tools[\"Tool Modules (File-linked)\"] GM[\"GM\"] SGT[\"SGT\"] TDV[\"TDV\"] Others[\"...\"] end end Revit -->|\".addin manifest\"| Loader Loader -->|\"Loads & resolves\"| App App --> Core App --> Themes App -->|\"Discovers via manifest.yml\"| Tools Core --> RevitAPI style Revit fill:#f5f5f5,stroke:#333 style DBTools fill:#e3f2fd,stroke:#1946B9 style Tools fill:#fff3e0,stroke:#FEC425 ASCII Diagram (for reference) +-----------------------------------------------------------------------------------+ | Revit Host | +-----------------------------------------------------------------------------------+ | | v v +-------------------+ +----------------------+ | DBTools.Loader | <-- Revit .addin manifest | Revit API | | (Entry Point) | points here | (RevitAPI.dll, | +-------------------+ | RevitAPIUI.dll) | | +----------------------+ | Loads DBTools.dll, installs ^ | EmbeddedAssemblyResolver | v | +-------------------+ References +----------------------+ | | DBTools.App | -----------------> | DBTools.Core |-+ | (DBTools.dll) | | (Core Library) | | | +----------------------+ | - AddinEntry | ^ | - Tool Modules | | | - Ribbon UI | References | | - Commands | -----------------> +----------------------+ +-------------------+ | DBTools.Themes | | | (WPF Resources) | | Discovers via manifest.yml +----------------------+ v +-------------------+ | Tool Modules | | (File-linked) | | - GM, SGT, TDV | | - Settings | | - Structural/* | +-------------------+ Source: csharp/src/DBTools.Loader/Addin/AddinEntry.cs:12-38 Project Organization The solution follows a layered architecture with clear separation of concerns: Core Projects Project Purpose Target Frameworks DBTools.Loader Revit entry point; loads DBTools.dll and resolves embedded assemblies net48, net8.0-windows DBTools.App Main application assembly (outputs as DBTools.dll); contains ribbon UI and tool registration net48, net8.0-windows DBTools.Core Core library with shared infrastructure (DI, logging, settings, Revit abstractions) net48, net8.0-windows DBTools.Themes WPF theme resources and styling (HandyControl, Fluent.Ribbon) net48, net8.0-windows DBTools.Sandbox Standalone WPF app for UI development without Revit net48, net8.0-windows Source: csharp/src/ directory structure Tool Projects (File-Linked into DBTools.App) Tools are organized under csharp/src/Tools/ and compiled into the main DBTools.dll assembly via MSBuild file linking: Tools/ +-- Common/ | +-- GM/ # Global Mapper | +-- TDV/ # Type Data Viewer | +-- ElevationTags/ | +-- 3DElementsFromList/ +-- Structural/ | +-- SGT/ # Structural Grid Tool | +-- FoundationTags/ | +-- FramingJoins/ | +-- JoistGirderWeight/ | +-- OrganizeFoundationTypes/ | +-- AnalyticalSnapToLevel/ +-- Settings/ # Settings management tool +-- Testing/ +-- VTC/ # View Test Coordinator Source: csharp/src/DBTools.App/DBTools.App.csproj:62-78 (file linking configuration) Tool source files are linked (not copied) into the DBTools.App project: <Compile Include=\"..\\Tools\\**\\*.cs\" Exclude=\"..\\Tools\\**\\Tests\\**\\*.cs;..\\Tools\\**\\obj\\**\\*.cs\" Link=\"Tools\\%(RecursiveDir)%(Filename)%(Extension)\" /> Source: csharp/src/DBTools.App/DBTools.App.csproj:64-66 Multi-Year Revit Support DBTools supports multiple Revit versions through dual target frameworks: Revit Version Target Framework Runtime Revit 2024 net48 .NET Framework 4.8 Revit 2025+ net8.0-windows .NET 8 Source: csharp/build/Revit.props:2-6 The build system auto-detects installed Revit versions and builds for all available years: <DBT_RevitLegacyTFM>net48</DBT_RevitLegacyTFM> <DBT_RevitModernTFM>net8.0-windows</DBT_RevitModernTFM> <DBT_RevitTargetFrameworks>$(DBT_RevitLegacyTFM);$(DBT_RevitModernTFM)</DBT_RevitTargetFrameworks> Source: csharp/build/Revit.props:3-5 Tool Discovery and Registration DBTools uses a YAML manifest-driven tool discovery system. Each tool declares its module, commands, and UI configuration in a manifest.yml file. Manifest Structure id: DBTools.GM assembly: DBTools moduleType: DBTools.GM.GmToolModule order: 0 sandboxWindows: - id: DBTools.GM.Main displayName: \"Global Mapper\" windowType: \"DBTools.GM.Shell.UI.Views.GmWindow\" tool: ribbonTools: - internalName: DBTools.GM commandType: DBTools.GM.Features.GmCommand availabilityType: DBTools.App.Tools.Availability.DbtDocumentAvailability displayText: \"Global Mapper\" iconBaseKey: gm controlKind: PushButton Source: csharp/src/Tools/Common/GM/manifest.yml:1-26 Discovery Flow sequenceDiagram participant App as DBTools.App participant Loader as DbtToolManifestLoader participant Catalog as DbtToolModuleCatalog participant Module as DbtToolModule participant DI as IServiceCollection participant Ribbon as RibbonManager App->>Loader: ScanEmbeddedResources() Loader-->>App: List<DbtToolManifest> loop For each manifest App->>Catalog: CreateModule(manifest) Catalog->>Module: new() via reflection Module-->>Catalog: DbtToolModule instance App->>Module: RegisterSettings() App->>Module: RegisterServices() Module->>DI: AddScoped<T>() App->>Module: RegisterHooks() App->>Ribbon: RegisterRibbonToolsFromManifest() end Manifest Loading: DbtToolManifestLoader scans embedded resources for manifest.yml files Module Instantiation: DbtToolModuleCatalog creates DbtToolModule instances via reflection Service Registration: Each module's RegisterServices(), RegisterSettings(), and RegisterHooks() are called Ribbon Tool Registration: RegisterRibbonToolsFromManifest() parses ribbon definitions and registers commands Source: csharp/src/DBTools.Core/Tools/DbtToolModuleCatalog.cs:11-64 Tool Module Base Class All tools inherit from DbtToolModule, which provides hooks for: RegisterSettings() - Bind configuration sections to strongly-typed options RegisterServices() - Register tool-specific DI services RegisterSettingsPacks() - Register settings UI definitions RegisterHooks() - Register event handlers (e.g., DocumentOpened, ViewActivated) Source: csharp/src/DBTools.Core/Tools/DbtToolModule.cs:9-49 Dependency Injection Architecture DBTools uses Microsoft.Extensions.DependencyInjection with a two-tier service scope pattern: Singleton Services (Application Lifetime) IDbtLoggingHost - Serilog-based logging infrastructure IConfiguration - Settings from settings.json DbtToolRegistry - Discovered tool registrations ISafeExecutor - Centralized error handling ISettingsProvider - Settings read/write access Scoped Services (Per-Command Lifetime) IRevitRunScope - Active command execution context IRevitCallGate - Thread-safe Revit API access ITransactionRunner - Transaction management ITransactionGroupService - Transaction grouping Source: csharp/src/DBTools.App/Bootstrap/DbtServiceBootstrapper.cs:68-130 Assembly Loading Strategy Loader Bootstrap The DBTools.Loader assembly is the Revit entry point. It: Locates DBTools.dll in the same directory Installs EmbeddedAssemblyResolver for runtime dependency resolution Pre-loads critical assemblies (Configuration, Serilog) on net48 Reflectively creates and invokes DBTools.App.AddinEntry Source: csharp/src/DBTools.Loader/Addin/AddinEntry.cs:17-47 Embedded Dependencies Dependencies are embedded as resources in DBTools.dll to minimize deployment complexity: <EmbeddedResource Include=\"%(_EmbedLogicalDistinct.SourcePath)\" LogicalName=\"%(_EmbedLogicalDistinct.Identity)\" /> Source: csharp/src/DBTools.App/DBTools.App.csproj:267-268 The resolver uses different strategies per framework: Framework Strategy net48 ILRepack merges most assemblies; ricaun.* embedded as resources net8.0 All dependencies embedded as resources, loaded via AssemblyLoadContext Source: csharp/src/DBTools.Loader/AssemblyResolution/EmbeddedAssemblyResolver.cs:14-96 WPF Theme Assemblies WPF assemblies (Fluent.Ribbon, ControlzEx, HandyControl) cannot be embedded because they require Assembly.Location for pack:// URI resolution. These are: Vendored/renamed to avoid conflicts with pyRevit (e.g., DBTools.Fluent.Ribbon) Deployed as files alongside DBTools.dll Source: csharp/src/DBTools.Loader/AssemblyResolution/EmbeddedAssemblyResolver.cs:134-143 Build System Overview The build uses NUKE (C# build automation) invoked via build.sh: # Fast incremental build (default) bash csharp/build.sh # Clean rebuild bash csharp/build.sh --clean # Build specific Revit year bash csharp/build.sh -y 2025 BuildAll # Common targets bash csharp/build.sh BuildAll # Build everything bash csharp/build.sh BuildApp # Build DBTools.dll only bash csharp/build.sh BuildSandbox # Build UI sandbox bash csharp/build.sh PromoteToDist # Stage for deployment Source: csharp/build.sh:33-60 Key build features: Centralized Artifacts: All outputs go to csharp/.artifacts/ (not per-project bin/obj) Vendored Dependencies: UI assemblies built via build-vendored-deps.sh Strict Analysis: TreatWarningsAsErrors=true, Roslyn analyzers enabled Multi-Year: Builds for all detected Revit installations Source: csharp/Directory.Build.props:8-28 For detailed build pipeline documentation, see Build Pipeline. Error Handling Philosophy All entrypoints execute within ISafeExecutor, which: Catches and logs all exceptions Displays user-friendly error dialogs Prevents silent failures Centralizes error reporting Source: csharp/src/DBTools.App/Bootstrap/DbtServiceBootstrapper.cs:435-436 Non-Negotiable Rules: No fallbacks that hide failures No silent exception swallowing No returning defaults as if nothing failed Related Documentation Build Pipeline - Detailed build system reference Test Pipeline - Testing infrastructure Project References - Dependency relationships DBTools.Core - Core library documentation DBTools.Loader - Revit entry point Verification Status Check Status Source anchors for all claims Yes UNVERIFIED markers where needed No (all verified) Cross-references added Yes Examples tested N/A No assumptions without evidence Yes Verified by: docs-run-20260124-020412 Date: 2026-01-24"
  },
  "developer-guide/architecture/project-references.html": {
    "href": "developer-guide/architecture/project-references.html",
    "title": "Project References and Dependency Management | DB Tools",
    "summary": "Project References and Dependency Management This document describes how DBTools projects reference each other, manage dependencies, and use file linking patterns. Project Dependency Graph +-----------------------+ | DBTools.Themes | | (WPF theme resources)| +-----------+-----------+ | +------------------------+------------------------+ | | +---------v---------+ +---------v---------+ | DBTools.Core |<----------------------------+ DBTools.App | | (shared services, | | (assembly output: | | UI, Revit infra) | | DBTools.dll) | +---------+---------+ +---------+---------+ ^ ^ | | +-----------+-----------+ +-----------+-----------+ | | | | +-------+-------+ +-------+-------+ +-------+-------+ +-------+-------+ | DBTools.GM | | DBTools.SGT | | File-linked | | File-linked | | (XAML design) | | (XAML design) | | tool sources | | tool assets | +---------------+ +---------------+ +---------------+ +---------------+ ^ ^ | | +-------+-------+ +-------+-------+ |DBTools.GM.Tests| |DBTools.SGT.Tests| +---------------+ +---------------+ +-------------------+ +-------------------+ | DBTools.Loader | | DBTools.Sandbox | | (Revit entrypoint)| | (standalone exe) | +-------------------+ +-------------------+ Source: csharp/src/DBTools.App/DBTools.App.csproj:56-59 Key Relationships From To Reference Type Purpose DBTools.App DBTools.Core ProjectReference Core services, UI infrastructure DBTools.App DBTools.Themes ProjectReference WPF theme resources DBTools.Core DBTools.Themes ProjectReference ComponentResourceKey definitions Tool projects DBTools.Core ProjectReference Shared infrastructure Test projects DBTools.App + DBTools.Core ProjectReference Test compilation DBTools.Sandbox DBTools.Core + DBTools.Themes ProjectReference Standalone preview File Linking vs Project References DBTools uses two distinct patterns for code sharing: Pattern 1: Project References (Standard) Used when the referenced assembly should be included as a separate DLL in output. <!-- From DBTools.Core.csproj:165 --> <ProjectReference Include=\"..\\DBTools.Themes\\DBTools.Themes.csproj\" /> Source: csharp/src/DBTools.Core/DBTools.Core.csproj:165 When to use: Shared infrastructure code (Core, Themes) Code that defines types needed at runtime via reflection WPF resources that use pack:// URIs Pattern 2: File Linking (Compile-time inclusion) Used when source files should be compiled directly into another assembly. <!-- From DBTools.App.csproj:64-67 --> <Compile Include=\"..\\Tools\\**\\*.cs\" Exclude=\"..\\Tools\\**\\Tests\\**\\*.cs;..\\Tools\\**\\obj\\**\\*.cs\" Link=\"Tools\\%(RecursiveDir)%(Filename)%(Extension)\" /> Source: csharp/src/DBTools.App/DBTools.App.csproj:64-67 When to use: Tool source code compiled into DBTools.dll Shared test utilities across test projects Polyfill files for net48 compatibility File Linking Patterns in Detail Tool Source Files into DBTools.App All tool code from src/Tools/ is file-linked into DBTools.App: <!-- C# source files --> <Compile Include=\"..\\Tools\\**\\*.cs\" Exclude=\"..\\Tools\\**\\Tests\\**\\*.cs;..\\Tools\\**\\obj\\**\\*.cs\" Link=\"Tools\\%(RecursiveDir)%(Filename)%(Extension)\" /> <!-- XAML files --> <Page Include=\"..\\Tools\\**\\*.xaml\" Exclude=\"..\\Tools\\**\\obj\\**\\*.xaml;..\\Tools\\**\\Properties\\DesignTimeResources.xaml\" Link=\"Tools\\%(RecursiveDir)%(Filename)%(Extension)\" /> <!-- Icon assets --> <EmbeddedResource Include=\"..\\Tools\\**\\Assets\\*.png\" Link=\"Resources\\Icons\\%(RecursiveDir)%(Filename)%(Extension)\" /> Source: csharp/src/DBTools.App/DBTools.App.csproj:63-78 Why file linking for tools? Single deployable assembly (DBTools.dll) Eliminates plugin DLL proliferation Tool projects exist primarily for XAML designer support Shared Test Utilities Test projects link shared test infrastructure: <!-- From DBTools.GM.Tests.csproj:62-79 --> <Compile Include=\"..\\..\\..\\..\\..\\testing\\TestSupport\\ApsEnv.cs\" Link=\"TestSupport\\ApsEnv.cs\" /> <Compile Include=\"..\\..\\..\\..\\..\\testing\\TestSupport\\CommonTestDoubles.cs\" Link=\"TestSupport\\CommonTestDoubles.cs\" /> <Compile Include=\"..\\..\\..\\..\\..\\testing\\TestSupport\\TestHost\\RevitHost.cs\" Link=\"TestSupport\\TestHost\\RevitHost.cs\" /> <!-- ... more linked files ... --> Source: csharp/src/Tools/Common/GM/Tests/DBTools.GM.Tests.csproj:62-79 BCL Polyfills for net48 Polyfill files enable C# 10+ features on .NET Framework: <!-- From Directory.Build.props:215-219 --> <Compile Include=\"$(MSBuildThisFileDirectory)build/BuildSupport/Polyfills/IsExternalInit.cs\" Condition=\"'$(TargetFramework)'=='net48'\" /> <Compile Include=\"$(MSBuildThisFileDirectory)build/BuildSupport/Polyfills/StringExtensions.cs\" Condition=\"'$(TargetFramework)'=='net48'\" /> Source: csharp/Directory.Build.props:215-219 Centralized Package Management Directory.Packages.props All NuGet package versions are centralized: <Project> <PropertyGroup> <ManagePackageVersionsCentrally>true</ManagePackageVersionsCentrally> <CentralPackageTransitivePinningEnabled>true</CentralPackageTransitivePinningEnabled> </PropertyGroup> <ItemGroup> <!-- Package versions defined once --> <PackageVersion Include=\"CommunityToolkit.Mvvm\" Version=\"8.2.2\" /> <PackageVersion Include=\"Microsoft.Extensions.DependencyInjection\" Version=\"8.0.1\" /> <!-- ... --> </ItemGroup> </Project> Source: csharp/Directory.Packages.props:1-5 Consuming Packages Projects reference packages without specifying versions: <!-- From DBTools.Core.csproj:107-127 --> <PackageReference Include=\"CSharpFunctionalExtensions\" /> <PackageReference Include=\"Ardalis.GuardClauses\" /> <PackageReference Include=\"AutoMapper\" /> <PackageReference Include=\"Serilog\" /> Source: csharp/src/DBTools.Core/DBTools.Core.csproj:107-127 Version Pinning Strategy Package Category Version Strategy Rationale M.E.* (DI, Config, Logging) 8.x Match Revit 2026 .NET 8 runtime Serilog 4.x/6.x/8.x Compatible with both TFMs BCL packages (System.Memory) Pinned Align with vendored Fluent.Ribbon Source: csharp/Directory.Packages.props:73-95 Multi-Targeting Configuration Target Framework Definitions All Revit-facing projects target both frameworks: <!-- From Revit.props:2-6 --> <PropertyGroup Label=\"Revit TFMs\"> <DBT_RevitLegacyTFM>net48</DBT_RevitLegacyTFM> <DBT_RevitModernTFM>net8.0-windows</DBT_RevitModernTFM> <DBT_RevitTargetFrameworks>$(DBT_RevitLegacyTFM);$(DBT_RevitModernTFM)</DBT_RevitTargetFrameworks> </PropertyGroup> Source: csharp/build/Revit.props:2-6 Consuming in Projects <!-- Standard pattern in all Revit projects --> <TargetFrameworks>$(DBT_RevitTargetFrameworks)</TargetFrameworks> Source: csharp/src/DBTools.Core/DBTools.Core.csproj:3 Revit API Reference Patterns References are conditional on TFM and build type: <!-- net48 references Revit 2024 --> <ItemGroup Condition=\"'$(TargetFramework)'=='net48'\"> <Reference Include=\"RevitAPI\"> <HintPath>$(REVIT2024_DIR)\\RevitAPI.dll</HintPath> <Private>false</Private> </Reference> </ItemGroup> <!-- net8 references Revit 2025/2026 --> <ItemGroup Condition=\"'$(TargetFramework)'=='net8.0-windows'\"> <Reference Include=\"RevitAPI\" Condition=\"'$(REVIT_NET8_DIR)'!=''\"> <HintPath>$(REVIT_NET8_DIR)\\RevitAPI.dll</HintPath> <Private>false</Private> </Reference> </ItemGroup> Source: csharp/src/DBTools.App/DBTools.App.csproj:110-165 Vendored Dependencies Why Vendored? Some UI libraries are vendored (renamed) to avoid conflicts with other Revit add-ins: <!-- From DBTools.Core.csproj:144-152 --> <Reference Include=\"DBTools.Fluent.Ribbon\"> <HintPath>$(DBT_VendorArtifactsRoot)fluentribbon\\$(TargetFramework)\\DBTools.Fluent.Ribbon.dll</HintPath> <Private>true</Private> </Reference> <Reference Include=\"DBTools.ControlzEx\"> <HintPath>$(DBT_VendorArtifactsRoot)controlzex\\$(TargetFramework)\\DBTools.ControlzEx.dll</HintPath> <Private>true</Private> </Reference> Source: csharp/src/DBTools.Core/DBTools.Core.csproj:144-152 Vendored Libraries Original Vendored As Reason Fluent.Ribbon DBTools.Fluent.Ribbon Avoid pyRevit conflicts ControlzEx DBTools.ControlzEx Avoid pyRevit conflicts HandyControl DBTools.HandyControl Avoid host conflicts Source: csharp/src/DBTools.Themes/DBTools.Themes.csproj:53-70 Assembly Embedding (DBTools.App) Embedded Assembly Strategy DBTools.App embeds most dependencies into the main DLL: <!-- From DBTools.App.csproj:234-270 --> <Target Name=\"DBT_EmbedCopyLocalAssemblies\" AfterTargets=\"ResolveReferences\" Condition=\"'$(DesignTimeBuild)'!='true'\"> <ItemGroup> <_EmbedCandidate Include=\"@(ReferenceCopyLocalPaths)\" Condition=\"...\" /> <!-- Exclude host-provided assemblies --> <_EmbedCandidate Remove=\"@(_EmbedCandidate)\" Condition=\"'%(Filename)%(Extension)' == 'RevitAPI.dll'\" /> </ItemGroup> <ItemGroup> <EmbeddedResource Include=\"%(_EmbedLogicalDistinct.SourcePath)\" LogicalName=\"%(_EmbedLogicalDistinct.Identity)\" /> </ItemGroup> </Target> Source: csharp/src/DBTools.App/DBTools.App.csproj:234-270 What Gets Embedded Embedded Not Embedded Reason DBTools.Core RevitAPI/RevitAPIUI Revit provides at runtime Serilog.* Newtonsoft.Json Revit provides M.E.DependencyInjection DBTools.Fluent.Ribbon WPF needs file-based Location AutoMapper DBTools.ControlzEx WPF needs file-based Location Test Project References Reference Strategy Test projects reference both App and Core: <!-- From DBTools.GM.Tests.csproj:83-86 --> <ItemGroup> <ProjectReference Include=\"..\\..\\..\\..\\DBTools.App\\DBTools.App.csproj\" /> <ProjectReference Include=\"..\\..\\..\\..\\DBTools.Core\\DBTools.Core.csproj\" /> </ItemGroup> Source: csharp/src/Tools/Common/GM/Tests/DBTools.GM.Tests.csproj:83-86 Why reference both? Tool code is file-linked into App (need App for tool types) Core exposes internal types via InternalsVisibleTo Tests need access to both layers InternalsVisibleTo Declarations <!-- From DBTools.Core.csproj:27-32 --> <ItemGroup> <InternalsVisibleTo Include=\"DBTools.App\" /> <InternalsVisibleTo Include=\"DBTools.GM.Tests\" /> <InternalsVisibleTo Include=\"DBTools.SGT.Tests\" /> <InternalsVisibleTo Include=\"DBTools.TDV.Tests\" /> </ItemGroup> Source: csharp/src/DBTools.Core/DBTools.Core.csproj:27-32 Common Pitfalls and Solutions Pitfall 1: Circular Reference Between Themes and Core Problem: DBTools.Core needs theme resources; themes might need Core types. Solution: Theme dictionaries that need Core types are kept as raw Resource XAML (not compiled BAML): <!-- From DBTools.Themes.csproj:38-46 --> <ItemGroup> <Page Remove=\"Themes\\App.Converters.xaml\" /> <Resource Include=\"Themes\\App.Converters.xaml\" /> </ItemGroup> Source: csharp/src/DBTools.Themes/DBTools.Themes.csproj:38-46 Pitfall 2: Forbidden Host Assemblies in Output Problem: Transitive dependencies may copy Revit-provided DLLs to output. Solution: Build targets explicitly remove forbidden assemblies: <!-- From DBTools.App.csproj:169-177 --> <ItemGroup> <ForbiddenHostAssembly Include=\"RevitAPI.dll\" /> <ForbiddenHostAssembly Include=\"Newtonsoft.Json.dll\" /> <!-- ... --> </ItemGroup> <Target Name=\"DBT_RemoveForbiddenAfterCopy\" AfterTargets=\"CopyFilesToOutputDirectory\"> <Delete Files=\"@(_DBT_ForbiddenToClear)\" /> </Target> Source: csharp/src/DBTools.App/DBTools.App.csproj:169-196 Pitfall 3: XAML Designer Cannot Load x64 Assemblies Problem: XDesProc.exe is 32-bit; DBTools.App is x64 for Revit. Solution: Override PlatformTarget during design-time builds: <!-- From Directory.Build.targets:27-30 --> <PropertyGroup Condition=\"'$(DBT_IsDesignerBuild)'=='true' and '$(TargetFramework)'=='net48'\"> <PlatformTarget>AnyCPU</PlatformTarget> <Prefer32Bit>false</Prefer32Bit> </PropertyGroup> Source: csharp/Directory.Build.targets:27-30 Pitfall 4: Test Projects Missing Revit API Types Problem: Revit API references aren't transitive. Solution: Test projects explicitly reference Revit APIs: <!-- From DBTools.GM.Tests.csproj:95-109 --> <ItemGroup Condition=\"'$(TargetFramework)'=='net48'\"> <Reference Include=\"RevitAPI\"> <HintPath>$(REVIT2024_DIR)\\RevitAPI.dll</HintPath> <Private>false</Private> </Reference> </ItemGroup> Source: csharp/src/Tools/Common/GM/Tests/DBTools.GM.Tests.csproj:95-109 Pitfall 5: DBTools.Themes Polyfill Conflicts Problem: Themes is referenced by other net48 projects; polyfill types could conflict. Solution: Themes explicitly removes polyfill files: <!-- From DBTools.Themes.csproj:24-29 --> <ItemGroup Condition=\"'$(TargetFramework)'=='net48'\"> <Compile Remove=\"$(MSBuildThisFileDirectory)../../build/BuildSupport/Polyfills/IsExternalInit.cs\" /> <Compile Remove=\"$(MSBuildThisFileDirectory)../../build/BuildSupport/Polyfills/StringExtensions.cs\" /> </ItemGroup> Source: csharp/src/DBTools.Themes/DBTools.Themes.csproj:24-29 Build Configuration Inheritance Directory.Build.props Flow csharp/Directory.Build.props | +-- Imports Version.props (version numbers) +-- Imports build/Revit.props (TFM definitions) +-- Sets artifact paths (.artifacts/) +-- Configures analyzers, warnings +-- Defines shared package references Source: csharp/Directory.Build.props:1-6 Directory.Build.targets Flow csharp/Directory.Build.targets | +-- Enforces NUKE entrypoint (DBT_Entry) +-- Handles WPF temp project intermediates +-- Copies vendored DLLs for XAML designer +-- Cleans up wpftmp artifacts Source: csharp/Directory.Build.targets:1-312 Quick Reference: Adding a New Project Tool Project Checklist Create project in src/Tools/{Category}/{ToolName}/ Use standard template: <TargetFrameworks>$(DBT_RevitTargetFrameworks)</TargetFrameworks> <ProjectReference Include=\"..\\..\\..\\DBTools.Core\\DBTools.Core.csproj\" /> Add conditional Revit API references (copy from existing tool) Tool sources are automatically file-linked into DBTools.App via wildcard Test Project Checklist Create in src/Tools/{Category}/{ToolName}/Tests/ Reference both App and Core: <ProjectReference Include=\"..\\..\\..\\..\\DBTools.App\\DBTools.App.csproj\" /> <ProjectReference Include=\"..\\..\\..\\..\\DBTools.Core\\DBTools.Core.csproj\" /> Link shared test utilities from testing/TestSupport/ Add explicit Revit API references (not transitive) Related Documentation Build Pipeline - How projects are built ILRepack & Embedding - Assembly merging details Architecture Overview - High-level system architecture Verification Status Check Status Source anchors for all claims Yes UNVERIFIED markers where needed No (all verified) Cross-references added Yes Examples tested N/A No assumptions without evidence Yes Verified by: docs-run-20260124-020412 Date: 2026-01-24"
  },
  "developer-guide/architecture/revit-execution-and-progress-overlay.html": {
    "href": "developer-guide/architecture/revit-execution-and-progress-overlay.html",
    "title": "Revit Execution and Progress Overlay | DB Tools",
    "summary": "Revit Execution and Progress Overlay This guide captures the required execution flow for Revit API access and the progress overlay system used by DBTools tools. It summarizes the current contracts in code and shows practical do/don’t examples. Centralized runner responsibilities DbtToolCommand Owns the top-level Revit command entrypoint: Execute runs through ISafeExecutor, creates the run scope via AppRuntime.CreateRunScope(...), and builds a DbtToolContext with the active run scope and profile before calling RunAsync.【F:csharp/src/DBTools.Core/Revit/Execution/DbtToolCommand.cs†L71-L130】 Provides convenience helpers that still route through the call gate: RunInRevitAsync(...) delegates to context.RevitRunScope.CallGate.RunAsync(...) and enforces RequiresActiveView. Use these helpers or call the call gate directly—never Revit API calls outside the gate.【F:csharp/src/DBTools.Core/Revit/Execution/DbtToolCommand.cs†L136-L204】 RevitRunScopeFactory Composes the run scope: CreateScope(...) selects a call gate based on the profile (Inline or Queued), constructs CallGateTransactionRunner + CallGateTransactionGroupService, and publishes RevitAppContext.Current.【F:csharp/src/DBTools.Core/Revit/Execution/RevitRunScopeFactory.cs†L42-L74】 Profiles are the switch: InlineUi uses ModalInlineCallGate; QueuedModeless uses ModelessQueuedCallGate. The profile determines whether Revit API calls run inline (modal) or are queued via IRevitTask (modeless).【F:csharp/src/DBTools.Core/Revit/Execution/IRevitRunScope.cs†L17-L42】【F:csharp/src/DBTools.Core/Revit/Execution/RevitRunScopeFactory.cs†L55-L67】 IRevitCallGate profiles Modal inline (InlineUi): ModalInlineCallGate runs callbacks immediately on the Revit UI thread and validates context (thread and ActiveUIDocument). Use for modal commands and RevitTest flows where Revit already owns the thread.【F:csharp/src/DBTools.Core/Revit/Execution/ModalInlineCallGate.cs†L10-L69】 Queued modeless (QueuedModeless): ModelessQueuedCallGate schedules work via IRevitTask (ExternalEvent/Idling-style host) and enforces synchronous delegates (throws if a Task is returned). Use for modeless windows or long-running flows that must be queued to the UI thread.【F:csharp/src/DBTools.Core/Revit/Execution/ModelessQueuedCallGate.cs†L12-L122】 When to use InlineUi vs QueuedModeless InlineUi: modal Revit commands or RevitTest contexts that already run on the UI thread and do not require ExternalEvent/Idling pumping.【F:csharp/src/DBTools.Core/Revit/Execution/IRevitRunScope.cs†L23-L33】 QueuedModeless: modeless tool windows or long-running workflows that must marshal Revit API work onto the UI thread via the queued host.【F:csharp/src/DBTools.Core/Revit/Execution/IRevitRunScope.cs†L35-L42】 ITransactionRunner / ITransactionGroupService Always use the scope-provided services (context.RevitRunScope.TransactionRunner / TransactionGroupService) to ensure Revit API access is routed through the call gate and wrapped in proper transactions.【F:csharp/src/DBTools.Core/Revit/Execution/IRevitRunScope.cs†L12-L18】 CallGateTransactionRunner is explicitly built on top of IRevitCallGate and requires synchronous delegates (no async work inside the transaction). This keeps transactions and UI-thread access consistent with Revit’s rules.【F:csharp/src/DBTools.Core/Revit/Transactions/CallGateTransactionRunner.cs†L10-L78】 ITransactionGroupService.RunAsync(...) exists to guarantee cleanup on failures/cancellation—use it for multi-step operations that should commit/rollback as a unit.【F:csharp/src/DBTools.Core/Revit/Transactions/ITransactionGroupService.cs†L5-L15】 Prohibition: Revit API outside IRevitCallGate IRevitCallGate is the unified entry point for all Revit API access and enforces synchronous callbacks on the UI thread. Any direct Revit API usage outside the call gate risks invalid context exceptions or UI-thread violations.【F:csharp/src/DBTools.Core/Revit/Execution/IRevitCallGate.cs†L5-L26】 Execution context best practices (external refs) These are contextual practices aligned with Revit’s external API requirements and the current call-gate implementation. Modeless UI should use ExternalEvent/Idling-style dispatch. The queued gate relies on an IRevitTask host (from ricaun.Revit.UI.Tasks) to marshal work to the Revit UI thread, which maps to the ExternalEvent/Idling pattern used by Revit for modeless execution.【F:csharp/src/DBTools.Core/Revit/Execution/ModelessQueuedCallGate.cs†L12-L122】 Use task-based wrappers to schedule synchronous Revit work (e.g., Revit.Async-style wrappers). The call gate explicitly rejects async delegates—if your work returns a Task, it throws, so wrap async workflows outside the gate and keep in-gate delegates synchronous.【F:csharp/src/DBTools.Core/Revit/Execution/ModelessQueuedCallGate.cs†L86-L108】 Validate API context before inline execution. The RevitTest task binder probes ActiveAddInId and host context (InContext) to determine whether inline execution is allowed, guarding against context leaks and invalid subscriptions outside Revit API context.【F:csharp/src/DBTools.Core/Revit/Execution/RevitTestTaskBinder.cs†L120-L177】 Progress overlay usage Host requirements Host windows must derive from DbtWindowBase or DbtRibbonWindowBase. These base classes wire the initialization and ownership behaviors that the overlay system expects, and DbtRibbonWindowBase explicitly notes progress overlay integration as part of its contract.【F:csharp/src/DBTools.Core/UI/Windows/DbtWindowBase.cs†L9-L30】【F:csharp/src/DBTools.Core/UI/Windows/DbtRibbonWindowBase.cs†L9-L29】 Scope and dispatcher rules Always use Scope(...) for long operations. The overlay’s Scope(...) shows the overlay, ties it to the current async flow, and ensures cleanup on dispose.【F:csharp/src/DBTools.Core/UI/Progress/ProgressOverlayService.cs†L96-L146】 Show/Update/Hide are UI-dispatched. ProgressOverlayService marshals public calls to the WPF dispatcher via TryInvokeOnUi, so callers should use the overlay API and avoid touching overlay state directly from background threads.【F:csharp/src/DBTools.Core/UI/Progress/ProgressOverlayService.cs†L50-L115】【F:csharp/src/DBTools.Core/UI/Progress/ProgressOverlayService.cs†L164-L214】 Cancel handling Poll CancelRequested and bridge to your CTS. The overlay exposes a thread-safe CancelRequested property, and view models (SGT, GM) poll it to cancel longer workflows.【F:csharp/src/DBTools.Core/UI/Progress/ProgressOverlayService.cs†L78-L82】【F:csharp/src/Tools/Structural/SGT/Features/Shell/UI/ViewModels/SgtWindowViewModel.AnalysisAndHydration.cs†L118-L171】 Do/Don’t examples (from current code) Call gate usage Do: queue modeless work with synchronous delegates. await _gate.RunAsync(app => { // Revit API work here (sync only) return true; }); This aligns with ModelessQueuedCallGate.RunAsync(...), which marshals to the Revit UI thread and enforces sync-only delegates.【F:csharp/src/DBTools.Core/Revit/Execution/ModelessQueuedCallGate.cs†L24-L108】 Don’t: return or await a Task inside the call gate delegate. The queued gate throws if a delegate returns a Task to prevent invalid async Revit API usage.【F:csharp/src/DBTools.Core/Revit/Execution/ModelessQueuedCallGate.cs†L86-L108】 Progress overlay scope Do (SGT): create a scope and poll cancel status. using var scope = _overlay.Scope(ProgressScopeAnalyze, cancelable: true); _overlay.Update(ProgressCalibratingFamilies, 0.0); if (_overlay.CancelRequested) { linkedCts.Cancel(); } SGT’s view model creates a scope, updates it, and bridges cancel requests into the analysis CTS.【F:csharp/src/Tools/Structural/SGT/Features/Shell/UI/ViewModels/SgtWindowViewModel.AnalysisAndHydration.cs†L118-L171】 Do (GM): use Scope(...) and CancelRequested while applying mappings. using var scope = _overlay.Scope(\"Applying mappings...\", true); if (_overlay.CancelRequested) { _cts.Cancel(); } GM’s mapping report view model follows this pattern to keep UI cancel actions responsive during long operations.【F:csharp/src/Tools/Common/GM/Features/Mapping/UI/ViewModels/MappingReportViewModel.cs†L206-L242】 Don’t: manipulate overlay state directly or bypass the dispatcher. Use Show/Update/Hide/Scope so the overlay stays UI-thread safe.【F:csharp/src/DBTools.Core/UI/Progress/ProgressOverlayService.cs†L50-L169】 Common failure modes Dispatcher errors or missing host: calling overlay APIs without a registered DbtWindowBase/DbtRibbonWindowBase host or bypassing the overlay API can lead to dispatcher errors or missing state. Always use Scope/Show/Update/Hide on a supported window host.【F:csharp/src/DBTools.Core/UI/Progress/ProgressOverlayService.cs†L50-L214】【F:csharp/src/DBTools.Core/UI/Windows/DbtWindowBase.cs†L9-L30】 Revit context leaks: direct Revit API access outside IRevitCallGate or attempting async delegates inside the gate can lead to invalid context errors. Stick to the call gate + transaction runner, and keep delegates synchronous.【F:csharp/src/DBTools.Core/Revit/Execution/IRevitCallGate.cs†L5-L26】【F:csharp/src/DBTools.Core/Revit/Execution/ModelessQueuedCallGate.cs†L86-L108】【F:csharp/src/DBTools.Core/Revit/Transactions/CallGateTransactionRunner.cs†L10-L78】"
  },
  "developer-guide/architecture/sandbox-validator.html": {
    "href": "developer-guide/architecture/sandbox-validator.html",
    "title": "Sandbox Validator Architecture | DB Tools",
    "summary": "Sandbox Validator Architecture Overview The Sandbox Validator is a critical build-time validation system that verifies the integrity of DBTools dist outputs before deployment. It runs as part of the BuildAll target and catches XAML errors, manifest misconfigurations, binding failures, and assembly merge issues that would otherwise only manifest at runtime inside Revit. The validator operates in two modes: Headless mode (--headless): Used by the build pipeline for automated validation Interactive mode: A UI gallery for manual testing and development Source: csharp/src/DBTools.Sandbox/App.xaml.cs:21-77 Architecture Diagram NUKE BuildAll | v +-------------------+ | ValidateDist | | (BuildTargets) | +-------------------+ | | --headless --dist-dir <path> v +-------------------+ | DBTools.Sandbox | | (net48/net8) | +-------------------+ | +-----------------------------+-----------------------------+ | | | v v v +---------------+ +------------------+ +------------------+ | DistValidator | | ManifestValidator| | ToolWindowValidator| +---------------+ +------------------+ +------------------+ | | | | - Theme validation | - Manifest parsing | - Window instantiation | - Core window tests | - ModuleType checks | - Design-time VM binding | - Merge validation | - RibbonTool validation | - Tab interaction tests | - Binding error capture | - Assembly resolution | - Row expansion tests v v v +---------------+ +------------------+ +------------------+ | WindowGhost | | Assembly | | DbtSandboxCatalog| | Validator | | MetadataInspector| | (Discovery) | +---------------+ +------------------+ +------------------+ Source: csharp/build/BuildTargets.cs:1151-1259 Key Components DistValidator The main orchestrator that coordinates all validation steps. It: Resolves and validates the dist directory structure Ensures the validator runtime matches the dist target (net48 for Revit 2024, net8 for 2025+) Installs assembly resolvers for dist and Revit dependencies Activates sandbox mode to enable design-time ViewModels Runs theme, core window, manifest, and tool validations Source: csharp/src/DBTools.Sandbox/Validation/DistValidator.cs:15-327 Required Dist Layout The validator expects these files in the dist directory: File Purpose DBTools.Loader.dll Add-in entry point loader DBTools.dll Main merged assembly DBTools.Themes.dll Theme resource dictionaries DBTools.HandyControl.dll UI control library DBTools.ControlzEx.dll Window chrome library DBTools.Fluent.Ribbon.dll Ribbon UI library Source: csharp/src/DBTools.Sandbox/Validation/DistValidator.cs:149-167 ManifestValidator Validates that all tool manifests are correctly formed and that their referenced types exist: Loads manifest entries via DbtToolManifestLoader Verifies moduleType derives from DbtToolModule Validates commandType implements IExternalCommand Validates availabilityType implements IExternalCommandAvailability Uses metadata inspection (not runtime loading) to avoid Revit API dependencies Source: csharp/src/DBTools.Sandbox/Validation/ManifestValidator.cs:10-178 ToolWindowValidator Validates tool UI by instantiating windows with design-time ViewModels: Discovers sandbox windows via DbtSandboxCatalog Instantiates each window type and its design-time ViewModel Validates window layout via WindowGhostValidator Tests interactive behaviors: Tab cycling: Switches through all tabs in TabControl and Fluent.RibbonTabControl Row expansion: Toggles DataGrid row details visibility Preview modes: Cycles through preview modes for tools like SGT Source: csharp/src/DBTools.Sandbox/Validation/ToolWindowValidator.cs:13-412 WindowGhostValidator Performs \"ghost\" window validation by forcing layout passes without showing the window: Fixed size pass: Measures/arranges at 800x600 (typical window size) Infinite size pass: Catches controls that crash calculating \"desired\" size Content validation: Separately validates the window's content element Error localization: Walks visual tree to identify the failing element Source: csharp/src/DBTools.Sandbox/Validation/WindowGhostValidator.cs:9-129 BindingErrorListener Captures WPF data binding errors that normally fail silently: // Listens to WPF's binding trace source PresentationTraceSources.DataBindingSource.Listeners.Add(listener); PresentationTraceSources.DataBindingSource.Switch.Level = SourceLevels.Error; These silent failures are a major source of \"ghost UI\" issues - buttons that don't work, missing text, broken controls. The listener converts them into hard build failures. Source: csharp/src/DBTools.Sandbox/Validation/BindingErrorListener.cs:13-118 MergeValidator Validates the assembly merge/embedding strategy differs by target framework: net48 (ILRepack merge): Verifies sentinel types from merged assemblies exist in DBTools.dll Checks that assemblies like DynamicData.dll don't exist separately Validates internalization exclusions preserved required public types net8 (Embedded payloads): Verifies DBTools.EmbeddedAssemblies.DBTools.Core.dll resource exists Checks resource streams are loadable and have reasonable size Source: csharp/src/DBTools.Sandbox/Validation/MergeValidator.cs:17-222 Sandbox Window Configuration Tools opt into sandbox validation by adding sandboxWindows entries to their manifest.yml: # Example: csharp/src/Tools/Common/GM/manifest.yml id: DBTools.GM assembly: DBTools moduleType: DBTools.GM.GmToolModule order: 0 sandboxWindows: - id: DBTools.GM.Main displayName: \"Global Mapper\" group: \"Common\" windowType: \"DBTools.GM.Shell.UI.Views.GmWindow\" designTimeViewModelType: \"DBTools.GM.Shell.DesignTime.GmShellDesignTimeViewModel\" - id: DBTools.GM.MappingReport displayName: \"Global Mapper - Mapping Report\" group: \"Common\" windowType: \"DBTools.GM.Features.Mapping.UI.Views.GmMappingReportWindow\" designTimeViewModelType: \"DBTools.GM.Features.Mapping.DesignTime.GmMappingReportDesignTimeViewModel\" Source: csharp/src/Tools/Common/GM/manifest.yml:1-27 Required Fields Field Description id Unique identifier for the sandbox entry displayName Human-readable name shown in the sandbox gallery group Category for grouping related windows windowType Fully-qualified type name of the WPF Window designTimeViewModelType ViewModel providing mock data for validation assembly (Optional) Assembly containing the types; defaults to manifest's assembly Source: csharp/src/DBTools.Core/Tools/DbtSandboxCatalog.cs:24-46 Discovery Mechanism The DbtSandboxCatalog discovers sandbox windows by: Loading manifests embedded as resources in DBTools.dll Parsing sandboxWindows entries from each manifest Validating required fields and uniqueness of IDs Building DbtSandboxWindowSpec objects for runtime use public static IReadOnlyList<DbtSandboxWindowSpec> Discover(Assembly rootAssembly) { var entries = DbtToolManifestLoader.LoadEntries(rootAssembly); var specs = new List<DbtSandboxWindowSpec>(); foreach (var entry in entries) { foreach (var window in entry.Manifest.SandboxWindows ?? new List<>()) { // Validate and create spec... specs.Add(new DbtSandboxWindowSpec(...)); } } return specs; } Source: csharp/src/DBTools.Core/Tools/DbtSandboxCatalog.cs:8-59 SandboxMode Activation SandboxMode is a global flag that tells tool windows they're running outside Revit: namespace DBTools.Core.Compat; public static class SandboxMode { private static bool _isActive; public static bool IsActive => _isActive; public static void Activate() => _isActive = true; } Windows check this flag to: Skip Revit API calls Use design-time ViewModels Disable features requiring document context Skip UIErrorProtection.Attach in Loaded handlers Source: csharp/src/DBTools.Core/Compat/SandboxMode.cs:1-24 The SandboxModeActivator ensures the flag is set in all loaded assembly copies (handles ILMerge scenarios where multiple SandboxMode types exist): Source: csharp/src/DBTools.Sandbox/Validation/SandboxModeActivator.cs:9-119 Build Pipeline Integration The ValidateDist target in NUKE runs the validator: Target ValidateDist => _ => _ .Description(\"Validate dist outputs via DBTools.Sandbox headless runner\") .DependsOn(BuildSandbox) .After(PromoteToDist) .OnlyWhenDynamic(() => Configuration == \"Release\") .OnlyWhenDynamic(() => !SkipValidation) .Executes(() => { foreach (var year in RevitYears) { var tfm = year == 2024 ? \"net48\" : \"net8.0-windows\"; var validatorExe = ArtifactsDir / \"sandbox\" / Configuration / tfm / \"DBTools.Sandbox.exe\"; var args = new List<string> { \"--headless\", \"--dist-dir\", distDir, ValidateManifests ? \"--validate-manifests\" : \"--skip-validate-manifests\", ValidateTools ? \"--validate-tools\" : \"--skip-validate-tools\" }; // Execute with 3-minute timeout... } }); Source: csharp/build/BuildTargets.cs:1151-1259 Command-Line Options Flag Description --headless Run in validation mode (no UI) --dist-dir <path> Path to dist year folder (e.g., .artifacts/dist/Release/2026) --validate-manifests / --skip-validate-manifests Toggle manifest validation --validate-tools / --skip-validate-tools Toggle tool UI validation --screenshot --tool-id <id> --output <path> Capture tool window screenshot --list List available tool IDs for screenshot mode Source: csharp/src/DBTools.Sandbox/Validation/SandboxValidateOptions.cs:7-113 Validation Checks Summary Always Run (No Skip Flags) Check Description Dist layout Required files exist Runtime match net48 validator for 2024, net8 for 2025+ Theme validation DbtThemeValidator.ValidateOrThrow() Core windows AlertWindow, SettingsWindow, LoggerWindow Binding errors Silent WPF binding failures Merge/embed ILRepack (net48) or embedded payload (net8) With --validate-manifests Check Description Manifest parsing YAML structure, required keys ModuleType Derives from DbtToolModule RibbonTool commandType Implements IExternalCommand RibbonTool availabilityType Implements IExternalCommandAvailability With --validate-tools Check Description Window instantiation Parameterless constructor works ViewModel binding DataContext assignment succeeds Layout passes Fixed and infinite size measure/arrange Tab cycling All tabs can be selected Row expansion DataGrid row details toggle Preview modes Mode switching (e.g., SGT elevation/section/3D) Troubleshooting Validation Failures \"Window layout validation failed\" The window crashed during Measure, Arrange, or UpdateLayout. Common causes: Missing StaticResource: A resource key referenced in XAML doesn't exist in the merged resource dictionaries Constructor throws: The window constructor requires Revit context Binding converter crash: A value converter throws when given design-time data Solution: Check the exception message for the failing element name. Look for XAML bindings or resources that assume runtime context. \"WPF binding errors detected\" Silent binding failures were captured. The error message lists each failure: System.Windows.Data Error: 40 : BindingExpression path error: 'PropertyName' property not found on 'object' 'DesignTimeViewModel' Solution: Ensure design-time ViewModels expose all properties the XAML binds to. \"ILRepack merge validation failed\" Types that should have been merged exist as separate DLLs, or expected types are missing. Solution: Check csharp/build/ilrepack.txt for the merge whitelist configuration. \"Sandbox window ' ' failed to instantiate\" The window or ViewModel couldn't be created. Check: Does the window have a parameterless constructor? Does the ViewModel have a parameterless constructor? Is SandboxMode.IsActive checked before Revit API calls? Orphaned Validator Processes The build system kills orphaned DBTools.Sandbox.exe processes before validation to prevent stale state: Source: csharp/build/BuildTargets.cs:1292-1314 If validation hangs, check Task Manager for zombie sandbox processes. Related Documentation Test Pipeline - How tests use sandbox infrastructure Build Pipeline - Overall build and validation flow ILRepack & Embedding - Assembly merge strategy validated here Documentation Status: Complete Last Updated: January 2026"
  },
  "developer-guide/architecture/test-pipeline.html": {
    "href": "developer-guide/architecture/test-pipeline.html",
    "title": "Test Pipeline | DB Tools",
    "summary": "Test Pipeline This document describes the DBTools testing infrastructure, including test categories, execution methods, and shared test utilities. Overview DBTools uses a dual-tier testing strategy: Headless Tests - Run via dotnet test without Revit, validating build artifacts and cloud integrations Revit Integration Tests - Run inside a live Revit process using the ricaun.RevitTest adapter Source: csharp/invoke-revit-tests.sh:1-6 Test Categories Category System Tests are categorized using NUnit's [Category] attribute to enable selective execution: Category Description DA-Compatible RequiresRevitUI Needs UIApplication, UIDocument, TaskDialog, or STA thread No RequiresActiveDocument Needs an open Revit document with elements No Local Runs only in local Revit environment No Slow Takes >5 seconds, may be excluded from quick runs Yes Integration Requires external dependencies (network, cloud) Yes Source: csharp/testing/TestSupport/TestCategories.cs:14-42 DA vs Local Execution DA (Design Automation): Filter out UI-dependent tests: dotnet test --filter \"Category!=RequiresRevitUI&Category!=RequiresActiveDocument\" Local: Run all tests inside Revit Source: csharp/testing/TestSupport/TestCategories.cs:10-12 Test Project Organization Directory Structure csharp/testing/ DBTools.BuildArtifacts.Tests/ # Headless artifact validation DBTools.DA.Tests/ # Design Automation tests (cloud/headless) TestSupport/ # Shared test infrastructure GM/ # GM-specific test doubles SGT/ # SGT-specific test doubles TestHost/ # Revit host integration RevitTestModels/ # Test .rvt files by year 2024/GM/, 2024/SGT/ 2025/GM/, 2025/SGT/ 2026/GM/, 2026/SGT/ csharp/src/Tools/ Common/GM/Tests/ # GM integration tests Structural/SGT/Tests/ # SGT integration tests Testing/VTC/Tests/ # VTC tests Common/TDV/Tests/ # TDV tests Headless Test Projects DBTools.BuildArtifacts.Tests Validates build output without Revit: Assembly existence and validity per Revit year Target framework correctness (net48 for 2024, net8.0 for 2025+) Forbidden reference detection (RevitAPI, AdWindows) Namespace presence verification Embedded XAML resource validation Source: csharp/testing/DBTools.BuildArtifacts.Tests/AssemblyManifestTests.cs:14-20 Run command: dotnet test csharp/testing/DBTools.BuildArtifacts.Tests/DBTools.BuildArtifacts.Tests.csproj -c Release DBTools.DA.Tests Design Automation and APS integration tests: Links APS test files from tool directories (e.g., GM/Tests/APS/) Uses shared test utilities via <Compile Include> links Runs against Autodesk cloud services Source: csharp/testing/DBTools.DA.Tests/DBTools.DA.Tests.csproj:43-48 Run command: dotnet test csharp/testing/DBTools.DA.Tests/DBTools.DA.Tests.csproj -c Release Configuration: Uses da.runsettings for APS bucket configuration: <TestRunParameters> <Parameter name=\"APS_BUCKET\" value=\"dbtools-tests\" /> <Parameter name=\"APS_REGION\" value=\"US\" /> </TestRunParameters> Source: csharp/testing/da.runsettings:1-8 Tool-Specific Test Projects Each tool has its own test project under csharp/src/Tools/*/Tests/: Project Target Frameworks Revit Years DBTools.GM.Tests net48, net8.0-windows 2024, 2025, 2026 DBTools.SGT.Tests net48, net8.0-windows 2024, 2025, 2026 DBTools.TDV.Tests net48, net8.0-windows 2024, 2025, 2026 DBTools.VTC.Tests net48, net8.0-windows 2024, 2025, 2026 Source: csharp/src/Tools/Common/GM/Tests/DBTools.GM.Tests.csproj:4, csharp/src/Tools/Structural/SGT/Tests/DBTools.SGT.Tests.csproj:4 Key dependencies: ricaun.RevitTest.TestAdapter - Revit test execution ricaun.Revit.UI.Tasks - UI task scheduling NUnit 3 with test adapter Source: csharp/src/Tools/Common/GM/Tests/DBTools.GM.Tests.csproj:35-44 Test Runner: invoke-revit-tests.sh The primary test runner script for Revit integration tests. Prerequisites Required: gum (interactive terminal UI tool) # Install via Homebrew (macOS/Linux) brew install gum # Or Debian/Ubuntu sudo apt install gum # Or Go go install github.com/charmbracelet/gum@latest Source: csharp/invoke-revit-tests.sh:8-17 Basic Usage # Run all GM tests with smart mode (recommended) bash csharp/invoke-revit-tests.sh --smart --tool GM # Run SGT tests for Revit 2025 bash csharp/invoke-revit-tests.sh --smart --tool SGT -y 2025 # Run specific test by filter bash csharp/invoke-revit-tests.sh -f \"FullyQualifiedName~SomeTestName\" # Run specific fixture bash csharp/invoke-revit-tests.sh --smart --fixture GmAdapterTests Source: csharp/invoke-revit-tests.sh:202-204 Command-Line Options Test Execution Flag Description Default -y, --year YEAR Revit year: 2024, 2025, or 2026 2026 --debug, -d Use Debug configuration Auto-detect --release, -r Use Release configuration Auto-detect -f, --filter \"...\" VSTest filter (must include FullyQualifiedName) None -v, --verbosity N 0=quiet, 1=normal, 2=verbose 1 --timeout-minutes N Revit test timeout 4 --show-log Display DBTools log file path after completion Off Source: csharp/invoke-revit-tests.sh:130-140 Revit Instance Modes Flag Behavior --reuse Use existing Revit; fail if none running --persist Open new Revit and leave running after tests --close Open new Revit and close after tests (default) Source: csharp/invoke-revit-tests.sh:142-146 Smart Mode (Recommended) bash csharp/invoke-revit-tests.sh --smart --tool GM Smart mode auto-detects: If build changed since last test: opens fresh Revit (--persist) If build unchanged and session has Revit: reuses existing (--reuse) Source: csharp/invoke-revit-tests.sh:148-150 Tool/Fixture Shortcuts Flag Description --tool TOOL Run tests for GM, SGT, TDV, or VTC --fixture FIXTURE Run tests for specific fixture class Source: csharp/invoke-revit-tests.sh:149-150 Running Single Tests Recommended (via test runner): # Exact match bash csharp/invoke-revit-tests.sh --smart -y 2026 -f \"FullyQualifiedName=DBTools.GM.Tests.GmAdapterTests.SomeTest\" # Partial match (contains) bash csharp/invoke-revit-tests.sh --smart -f \"FullyQualifiedName~SomeTestName\" Headless projects only: dotnet test csharp/testing/DBTools.BuildArtifacts.Tests/DBTools.BuildArtifacts.Tests.csproj \\ -c Release --filter \"FullyQualifiedName~Metadata\" Source: csharp/invoke-revit-tests.sh:204, AGENTS.md Test Discovery The runner includes built-in test discovery: # List all available tests bash csharp/invoke-revit-tests.sh --discover # Rebuild test registry from source bash csharp/invoke-revit-tests.sh --discover --generate # Show test count summary bash csharp/invoke-revit-tests.sh --discover --summary # Filter by tool bash csharp/invoke-revit-tests.sh --discover --tool GM # Show only DA-compatible tests bash csharp/invoke-revit-tests.sh --discover --da-only # Show only local-only tests bash csharp/invoke-revit-tests.sh --discover --local-only Source: csharp/invoke-revit-tests.sh:171-180 Registry is stored at: .artifacts/metadata/test-registry.json Source: csharp/invoke-revit-tests.sh:647 Test History The runner tracks test execution history: # Show test run history bash csharp/invoke-revit-tests.sh --history # Show tests not run in last N days bash csharp/invoke-revit-tests.sh --show-stale 7 # Show tests that failed on last run bash csharp/invoke-revit-tests.sh --show-failed # Show error details for failed tests bash csharp/invoke-revit-tests.sh --get-errors \"GM\" Source: csharp/invoke-revit-tests.sh:183-189 History is stored at: .artifacts/test-history.json Source: csharp/invoke-revit-tests.sh:60 Parallel AI Agent Support For parallel test execution by multiple AI agents: # Agent 1 bash csharp/invoke-revit-tests.sh --smart --session agent-001 --tool GM # Agent 2 bash csharp/invoke-revit-tests.sh --smart --session agent-002 --tool SGT Each --session ID gets its own Revit instance for isolation. Source: csharp/invoke-revit-tests.sh:153-168 Session Management # List active sessions bash csharp/invoke-revit-tests.sh --sessions # Clean up stale sessions (dead Revit PIDs) bash csharp/invoke-revit-tests.sh --kill-orphans Source: csharp/invoke-revit-tests.sh:193-196 TestSupport Infrastructure Shared test utilities in csharp/testing/TestSupport/: Common Test Doubles Located in CommonTestDoubles.cs: Class Purpose RecordingNotifier Records error/success banner invocations RecordingOverlay Records progress overlay method calls InlineExecutor Runs actions inline (no async dispatch) InlineTransactionRunner Executes without Revit transactions InlineTransactionGroupService Executes without transaction groups Source: csharp/testing/TestSupport/CommonTestDoubles.cs:15-339 Test Host Integration RevitHost (TestHost/RevitHost.cs): Manages Revit context for async test execution Handles inline vs queued execution modes Integrates with RevitTestTaskBinder Source: csharp/testing/TestSupport/TestHost/RevitHost.cs:12-109 RevitAmbientScope (TestHost/RevitAmbientScope.cs): Provides ambient UIApplication access during tests Test Path Resolution TestPathResolver (TestPathResolver.cs): Resolves test model paths from dbtools.testparams.json Located at %APPDATA%/DBTools/dbtools.testparams.json Written by invoke-revit-tests.sh before test execution // Get model path var path = TestPathResolver.ResolveTestModelPath(\"2026\", \"GM\", \"gm_test_model.rvt\"); Source: csharp/testing/TestSupport/TestPathResolver.cs:10-65 Test Logging TestLoggingBridge (TestLoggingBridge.cs): Centralizes test logging setup Bridges to production logging when Revit is running Falls back to console mirroring in standalone mode [OneTimeSetUp] public void GlobalSetup() { TestLoggingBridge.Initialize(); } [OneTimeTearDown] public void GlobalTeardown() { TestLoggingBridge.Shutdown(); } Source: csharp/testing/TestSupport/TestLoggingBridge.cs:14-143 Tool-Specific Test Doubles GM (TestSupport/GM/): GmTestDataBuilder - Builds test data for GM GmRealisticTestDoubles - Production-like test doubles GmShellViewModelTestFactory - Creates shell ViewModels for testing SGT (TestSupport/SGT/): SgtTestDataBuilder - Builds test data for SGT SgtRealisticTestDoubles - Production-like test doubles InMemorySgtUiStateStore - In-memory UI state store Test Fixture Base Classes GmTestFixture Base class for GM integration tests: [NonParallelizable] public abstract class GmTestFixture { protected UIApplication UiApp { get; private set; } protected Document? Doc { get; private set; } protected IRevitCallGate? Gate { get; private set; } protected ITransactionRunner? TxRunner { get; private set; } [OneTimeSetUp] public virtual void GlobalSetup(UIApplication app) { // Opens gm_test_model.rvt // Initializes call gate and transaction runner } } Features: Opens tool-specific test model automatically Provides ResolveTypeIds(), ResolveStyleIds(), ResolveMaterialIds() helpers Manages document lifecycle Source: csharp/src/Tools/Common/GM/Tests/GMTestFixture.cs:14-128 Test Models Located in csharp/testing/RevitTestModels/: RevitTestModels/ model_info.txt 2024/ GM/gm_test_model.rvt SGT/sgt_test_model.rvt SGT/_LinkedModels/sgt_test_linked_model.rvt 2025/ GM/gm_test_model.rvt SGT/sgt_test_model.rvt SGT/_LinkedModels/sgt_test_linked_model.rvt 2026/ GM/gm_test_model.rvt SGT/sgt_test_model.rvt SGT/_LinkedModels/sgt_test_linked_model.rvt Each year has its own model versions for forward compatibility testing. Configuration Files .runsettings Revit Tests: Generated at runtime by invoke-revit-tests.sh: <RunSettings> <NUnit> <Version>2026</Version> <Language>ENU</Language> <Open>true</Open> <Close>false</Close> <Verbosity>2</Verbosity> <Timeout>4</Timeout> </NUnit> </RunSettings> Source: csharp/invoke-revit-tests.sh:1425-1442 DA Tests: csharp/testing/da.runsettings for APS configuration. Source: csharp/testing/da.runsettings:1-8 Test Parameters (dbtools.testparams.json) Written to %APPDATA%/DBTools/instances/<worktree-id>/dbtools.testparams.json: { \"ModelsDirectory\": \"C:\\\\...\\\\csharp\\\\testing\\\\RevitTestModels\", \"Year\": 2026 } Source: csharp/invoke-revit-tests.sh:1446-1451 Build Integration Tests depend on artifacts from build.sh: # Build all (required before running tests) bash csharp/build.sh BuildAll # Build tests specifically bash csharp/build.sh BuildTests The test runner validates artifact freshness: Checks .artifacts/metadata/build.json for source fingerprint Fails if artifacts are stale relative to source Source: csharp/invoke-revit-tests.sh:1201-1363 Guardrails (from AGENTS.md) Prime Directive When a test fails, investigate and fix PRODUCTION CODE first. Do not change tests or infrastructure to simulate missing production behavior. Forbidden Test Patterns Use test doubles only for TRUE externals (Revit API, filesystem, network) Never mock your own services/orchestrators Never assert only that mocks were called Every test must assert at least one real outcome Legitimate vs Illegitimate Stubbing Legitimate (external): Revit API File system Network Time/Random Illegitimate (your code): Your own services Orchestrators/handlers Anything in src/ you wrote Quick Reference Task Command Run GM tests (smart mode) bash csharp/invoke-revit-tests.sh --smart --tool GM Run SGT tests for 2025 bash csharp/invoke-revit-tests.sh --smart --tool SGT -y 2025 Run single test bash csharp/invoke-revit-tests.sh --smart -f \"FullyQualifiedName~TestName\" Run headless artifact tests dotnet test csharp/testing/DBTools.BuildArtifacts.Tests/ -c Release Run DA tests dotnet test csharp/testing/DBTools.DA.Tests/ -c Release List all tests bash csharp/invoke-revit-tests.sh --discover Show failed tests bash csharp/invoke-revit-tests.sh --show-failed Build before tests bash csharp/build.sh BuildAll Related Documentation Build Pipeline - Build system and artifact generation Architecture Overview - High-level system architecture Project References - Project structure and dependencies Verification Status Check Status Source anchors for all claims Yes UNVERIFIED markers where needed No (all verified) Cross-references added Yes Examples tested N/A No assumptions without evidence Yes Verified by: docs-run-20260124-020412 Date: 2026-01-24"
  },
  "developer-guide/architecture/theme-system.html": {
    "href": "developer-guide/architecture/theme-system.html",
    "title": "Theme System | DB Tools",
    "summary": "Theme System DBTools implements a comprehensive WPF theming system that provides a cohesive dark theme across all windows and controls. The system is designed to work within Revit's add-in environment while avoiding conflicts with other add-ins. Architecture Overview +-----------------------------------------------------------------------------------+ | DBTools Theme Stack | +-----------------------------------------------------------------------------------+ | | | +-------------------+ +--------------------+ +------------------------+ | | | DBTools.Themes | | Vendored Libraries | | DBTools.Core | | | | (Resources) | | (UI Frameworks) | | (Theme Loading) | | | +-------------------+ +--------------------+ +------------------------+ | | | | | | | v v v | | +----------------+ +---------------------+ +------------------------+ | | | App.Theme.xaml | --> | DBTools.HandyControl| --> | DbtWindowInitHelper | | | | (Root Dict) | | DBTools.Fluent.Ribbon| | DbtThemeValidator | | | +----------------+ | DBTools.ControlzEx | +------------------------+ | | | +---------------------+ | | v | | +---------------------------+ | | | Merged Dictionaries | | | | - App.Tokens.xaml | | | | - App.Brushes.xaml | | | | - App.Controls.Base.xaml | | | | - App.DataGrid.xaml | | | | - App.Menus.xaml | | | | - App.Components.xaml | | | | - App.FluentRibbon.xaml | | | +---------------------------+ | +-----------------------------------------------------------------------------------+ Source: csharp/src/DBTools.Themes/Themes/App.Theme.xaml:1-21 Project Structure The DBTools.Themes project contains all theme resources and references vendored UI libraries: DBTools.Themes/ +-- DBTools.Themes.csproj # Project configuration with vendored refs +-- BrushKeys.cs # ComponentResourceKey definitions +-- Assets/ | +-- db_tools_icon.png # Window icon +-- Themes/ +-- App.Theme.xaml # Root theme dictionary +-- App.Tokens.xaml # Spacing, sizing, typography tokens +-- App.Brushes.xaml # Color/brush definitions +-- App.Converters.xaml # Value converters +-- App.Controls.Base.xaml # Basic control styles +-- App.DataGrid.xaml # DataGrid-specific styles +-- App.Menus.xaml # Menu/ContextMenu styles +-- App.Components.xaml # Composite component styles +-- App.FluentRibbon.xaml # Fluent.Ribbon theme bridge Source: csharp/src/DBTools.Themes/DBTools.Themes.csproj:1-72 Vendored UI Libraries DBTools uses renamed/vendored copies of third-party UI libraries to avoid assembly conflicts with other Revit add-ins (especially pyRevit): Library Vendored Name Purpose HandyControl DBTools.HandyControl Base theme framework Fluent.Ribbon DBTools.Fluent.Ribbon Ribbon window/controls ControlzEx DBTools.ControlzEx Window chrome behaviors Source: csharp/src/DBTools.Themes/DBTools.Themes.csproj:54-71 Why Vendored Libraries? WPF theme assemblies cannot be ILRepack-merged or embedded as resources because they require Assembly.Location for pack:// URI resolution. The vendoring process: Clones upstream repos to vendor/ Renames assembly names and updates pack URIs Builds renamed assemblies to csharp/.artifacts/vendor/ Deploys alongside DBTools.dll Source: csharp/build-vendored-deps.sh:1-446 Theme Loading Mechanism Window-Scoped Theming DBTools applies themes at the window level (not application level) because Revit's Application.Resources are shared across all add-ins. This prevents theme pollution between add-ins. public static void EnsureWindowScopedTheme(Window window) { WpfUiThread.EnsurePackUriSupport(); if (!ResourceDictionaryHelper.HasSource(window.Resources, ThemeSource)) { window.Resources.MergedDictionaries.Add(new ResourceDictionary { Source = new Uri(ThemeSource, UriKind.Absolute) }); } DbtThemeValidator.FreezeFreezablesOrThrow(window.Resources); } Source: csharp/src/DBTools.Core/UI/Windows/DbtWindowInitHelper.cs:91-108 Theme Initialization Flow Window Constructor: DbtWindowInitHelper.Initialize() is called Pack URI Support: WpfUiThread.EnsurePackUriSupport() ensures pack:// scheme is registered Dictionary Merge: App.Theme.xaml is merged into Window.Resources Resource Freeze: All freezable resources are frozen to prevent runtime leaks Validation: Theme contract is validated (dictionary order, completeness) Source: csharp/src/DBTools.Core/UI/Windows/DbtWindowInitHelper.cs:44-78 Theme Opt-Out Windows can opt out of DBTools theming via IThemeOptOut: public interface IThemeOptOut { bool UseDefaultTheme { get; set; } } Source: csharp/src/DBTools.Core/UI/Windows/DbtWindowBase.cs:13-21 ResourceDictionary Structure Root Theme Dictionary App.Theme.xaml is the root dictionary that merges all theme components: <ResourceDictionary xmlns=\"http://schemas.microsoft.com/winfx/2006/xaml/presentation\"> <ResourceDictionary.MergedDictionaries> <!-- HandyControl Foundation --> <ResourceDictionary Source=\"pack://application:,,,/DBTools.HandyControl;component/Themes/SkinDark.xaml\"/> <ResourceDictionary Source=\"pack://application:,,,/DBTools.HandyControl;component/Themes/Theme.xaml\"/> <!-- Fluent.Ribbon for ribbon windows --> <ResourceDictionary Source=\"pack://application:,,,/DBTools.Fluent.Ribbon;component/Themes/Generic.xaml\"/> <!-- DBTools Custom Themes --> <ResourceDictionary Source=\"App.Tokens.xaml\"/> <ResourceDictionary Source=\"App.Brushes.xaml\"/> <ResourceDictionary Source=\"App.Converters.xaml\"/> <ResourceDictionary Source=\"App.Controls.Base.xaml\"/> <ResourceDictionary Source=\"App.DataGrid.xaml\"/> <ResourceDictionary Source=\"App.Menus.xaml\"/> <ResourceDictionary Source=\"App.Components.xaml\"/> <ResourceDictionary Source=\"App.FluentRibbon.xaml\"/> </ResourceDictionary.MergedDictionaries> </ResourceDictionary> Source: csharp/src/DBTools.Themes/Themes/App.Theme.xaml:1-21 Dictionary Order Contract The merged dictionary order is locked and validated at runtime: private static readonly IReadOnlyList<string> ExpectedMergedDictionarySources = new[] { \"pack://application:,,,/DBTools.HandyControl;component/Themes/SkinDark.xaml\", \"pack://application:,,,/DBTools.HandyControl;component/Themes/Theme.xaml\", \"pack://application:,,,/DBTools.Fluent.Ribbon;component/Themes/Generic.xaml\", \"pack://application:,,,/DBTools.Themes;component/Themes/App.Tokens.xaml\", \"pack://application:,,,/DBTools.Themes;component/Themes/App.Brushes.xaml\", // ... additional dictionaries }; Source: csharp/src/DBTools.Core/UI/Theming/DbtThemeValidator.cs:20-33 Design Tokens Spacing Tokens Standard spacing values for consistent layouts: <Thickness x:Key=\"Spacing4\">4</Thickness> <Thickness x:Key=\"Spacing8\">8</Thickness> <Thickness x:Key=\"Spacing12\">12</Thickness> <Thickness x:Key=\"Spacing16\">16</Thickness> <Thickness x:Key=\"Spacing32\">32</Thickness> <!-- Scalar variants for non-Thickness contexts --> <sys:Double x:Key=\"Spacing8.Value\">8</sys:Double> Source: csharp/src/DBTools.Themes/Themes/App.Tokens.xaml:5-18 Typography Tokens <sys:Double x:Key=\"FontSize.Caption\">11</sys:Double> <sys:Double x:Key=\"FontSize.Body.Small\">12</sys:Double> <sys:Double x:Key=\"FontSize.Body\">13</sys:Double> <sys:Double x:Key=\"FontSize.Subtitle\">14</sys:Double> <sys:Double x:Key=\"FontSize.Title\">16</sys:Double> <sys:Double x:Key=\"FontSize.Header\">20</sys:Double> Source: csharp/src/DBTools.Themes/Themes/App.Tokens.xaml:66-72 Corner Radius Tokens <CornerRadius x:Key=\"Radius4\">4</CornerRadius> <CornerRadius x:Key=\"Radius6\">6</CornerRadius> <CornerRadius x:Key=\"Radius8\">8</CornerRadius> <CornerRadius x:Key=\"Radius12\">12</CornerRadius> Source: csharp/src/DBTools.Themes/Themes/App.Tokens.xaml:43-46 Color System BrushKeys (ComponentResourceKeys) All brushes are defined using ComponentResourceKey to enable reliable cross-template resolution: public static class BrushKeys { public static ComponentResourceKey Primary => new(typeof(BrushKeys), \"Brush.Primary\"); public static ComponentResourceKey PrimaryLight => new(typeof(BrushKeys), \"Brush.PrimaryLight\"); public static ComponentResourceKey Paper => new(typeof(BrushKeys), \"Brush.Paper\"); public static ComponentResourceKey Surface => new(typeof(BrushKeys), \"Brush.Surface\"); public static ComponentResourceKey Body => new(typeof(BrushKeys), \"Brush.Body\"); // ... 130+ additional keys } Source: csharp/src/DBTools.Themes/BrushKeys.cs:1-139 Brand Colors DBTools uses a blue/gold brand palette: <!-- Core Brand Colors --> <SolidColorBrush x:Key=\"{x:Static theme:BrushKeys.Primary}\" Color=\"#FF1946B9\"/> <SolidColorBrush x:Key=\"{x:Static theme:BrushKeys.PrimaryLight}\" Color=\"#FF3D6AD4\"/> <SolidColorBrush x:Key=\"{x:Static theme:BrushKeys.Secondary}\" Color=\"#FFFEC425\"/> <SolidColorBrush x:Key=\"{x:Static theme:BrushKeys.SecondaryLight}\" Color=\"#FFFFD54F\"/> Source: csharp/src/DBTools.Themes/Themes/App.Brushes.xaml:14-19 Surface Colors Dark theme surfaces with subtle differentiation: <SolidColorBrush x:Key=\"{x:Static theme:BrushKeys.Paper}\" Color=\"#FF181820\"/> <SolidColorBrush x:Key=\"{x:Static theme:BrushKeys.Surface}\" Color=\"#FF222228\"/> <SolidColorBrush x:Key=\"{x:Static theme:BrushKeys.SurfaceAlt}\" Color=\"#FF1C1C22\"/> <SolidColorBrush x:Key=\"{x:Static theme:BrushKeys.CardSurface}\" Color=\"#FF1E1E24\"/> Source: csharp/src/DBTools.Themes/Themes/App.Brushes.xaml:24-30 Text Colors (WCAG Compliant) Text colors maintain minimum 4.5:1 contrast ratio for accessibility: <!-- WCAG AA compliant - min 4.5:1 contrast ratio on dark backgrounds --> <SolidColorBrush x:Key=\"{x:Static theme:BrushKeys.Body}\" Color=\"#FFE6E6E6\"/> <SolidColorBrush x:Key=\"{x:Static theme:BrushKeys.BodyLight}\" Color=\"#FFBDBDBD\"/> <SolidColorBrush x:Key=\"{x:Static theme:BrushKeys.TextMuted}\" Color=\"#FF999999\"/> Source: csharp/src/DBTools.Themes/Themes/App.Brushes.xaml:35-40 Status Colors Semantic colors for success, warning, error, and info states: <SolidColorBrush x:Key=\"{x:Static theme:BrushKeys.Success}\" Color=\"#FF4CAF50\"/> <SolidColorBrush x:Key=\"{x:Static theme:BrushKeys.Warning}\" Color=\"#FFFFA000\"/> <SolidColorBrush x:Key=\"{x:Static theme:BrushKeys.Error}\" Color=\"#FFCF6679\"/> <SolidColorBrush x:Key=\"{x:Static theme:BrushKeys.Info}\" Color=\"#FF1946B9\"/> Source: csharp/src/DBTools.Themes/Themes/App.Brushes.xaml:84-95 Window Base Classes DbtWindowBase Standard modal window with theme and progress overlay support: public class DbtWindowBase : Window, IWindowWithOwnerProvider, IThemeOptOut { public DbtWindowBase() { DbtWindowInitHelper.Initialize(this, nameof(DbtWindowBase)); } } Source: csharp/src/DBTools.Core/UI/Windows/DbtWindowBase.cs:27-32 The XAML style applies default theme properties and progress overlay: <Style TargetType=\"{x:Type core:DbtWindowBase}\" BasedOn=\"{StaticResource {x:Type Window}}\"> <Setter Property=\"Icon\" Value=\"pack://application:,,,/DBTools.Themes;component/Assets/db_tools_icon.png\"/> <Setter Property=\"Background\" Value=\"{DynamicResource {x:Static theme:BrushKeys.Paper}}\"/> <Setter Property=\"Foreground\" Value=\"{DynamicResource {x:Static theme:BrushKeys.Body}}\"/> <Setter Property=\"ContentTemplate\"> <Setter.Value> <DataTemplate> <Grid> <ContentPresenter/> <Border Panel.ZIndex=\"1000\" ...> <progress:ProgressOverlayControl .../> </Border> </Grid> </DataTemplate> </Setter.Value> </Setter> </Style> Source: csharp/src/DBTools.Themes/Themes/App.Controls.Base.xaml:13-33 DbtRibbonWindowBase Ribbon window for tool UIs with tab-based navigation: public class DbtRibbonWindowBase : RibbonWindow, IWindowWithOwnerProvider, IThemeOptOut { public DbtRibbonWindowBase() { DbtWindowInitHelper.Initialize(this, nameof(DbtRibbonWindowBase)); } } Source: csharp/src/DBTools.Core/UI/Windows/DbtRibbonWindowBase.cs:15-19 Fluent.Ribbon Theme Bridge App.FluentRibbon.xaml maps all 196+ Fluent.Ribbon internal brush keys to DBTools theme colors: <!-- Window Chrome --> <SolidColorBrush x:Key=\"Fluent.Ribbon.Brushes.RibbonWindow.Background\" Color=\"{Binding Source={StaticResource {x:Static theme:BrushKeys.Paper}}, Path=Color}\"/> <!-- Tab Control --> <SolidColorBrush x:Key=\"Fluent.Ribbon.Brushes.RibbonTabItem.Selected.Background\" Color=\"{Binding Source={StaticResource {x:Static theme:BrushKeys.SelectionGoldStrong}}, Path=Color}\"/> <!-- Buttons --> <SolidColorBrush x:Key=\"Fluent.Ribbon.Brushes.Button.MouseOver.Background\" Color=\"{Binding Source={StaticResource {x:Static theme:BrushKeys.Hover}}, Path=Color}\"/> Source: csharp/src/DBTools.Themes/Themes/App.FluentRibbon.xaml:24-211 TransitioningControl Hotfix A style override prevents animation failures during tab switching: <Style TargetType=\"{x:Type fluent:TransitioningControl}\"> <Setter Property=\"Template\"> <Setter.Value> <ControlTemplate TargetType=\"{x:Type fluent:TransitioningControl}\"> <Border ...> <Grid> <ContentPresenter x:Name=\"PART_CurrentContent\" .../> <ContentPresenter x:Name=\"PART_PreviousContent\" .../> </Grid> </Border> </ControlTemplate> </Setter.Value> </Setter> </Style> Source: csharp/src/DBTools.Themes/Themes/App.FluentRibbon.xaml:53-97 Control Styles Standard Controls Implicit styles override WPF defaults with theme colors: <Style TargetType=\"Button\" BasedOn=\"{StaticResource {x:Type Button}}\"> <Setter Property=\"MinWidth\" Value=\"88\"/> <Setter Property=\"MinHeight\" Value=\"36\"/> <Setter Property=\"Background\" Value=\"{DynamicResource {x:Static theme:BrushKeys.Surface}}\"/> <Setter Property=\"Foreground\" Value=\"{DynamicResource {x:Static theme:BrushKeys.Body}}\"/> <Setter Property=\"BorderBrush\" Value=\"{DynamicResource {x:Static theme:BrushKeys.Divider}}\"/> <Style.Triggers> <Trigger Property=\"IsMouseOver\" Value=\"True\"> <Setter Property=\"Background\" Value=\"{DynamicResource {x:Static theme:BrushKeys.SecondaryHover}}\"/> </Trigger> </Style.Triggers> </Style> Source: csharp/src/DBTools.Themes/Themes/App.Controls.Base.xaml:73-92 DataGrid Styles Custom DataGrid with accent stripe and enhanced selection: <Style TargetType=\"DataGridRow\" BasedOn=\"{StaticResource {x:Type DataGridRow}}\"> <Setter Property=\"Template\"> <Setter.Value> <ControlTemplate TargetType=\"DataGridRow\"> <Border x:Name=\"DGR_Border\" ...> <Grid> <Grid.ColumnDefinitions> <ColumnDefinition Width=\"3\"/> <!-- Accent stripe --> <ColumnDefinition Width=\"*\"/> </Grid.ColumnDefinitions> <Border x:Name=\"AccentStripe\" Grid.Column=\"0\" Background=\"Transparent\"/> <SelectiveScrollingGrid Grid.Column=\"1\"> <!-- Row content --> </SelectiveScrollingGrid> </Grid> </Border> <ControlTemplate.Triggers> <Trigger Property=\"IsSelected\" Value=\"True\"> <Setter TargetName=\"AccentStripe\" Property=\"Background\" Value=\"{DynamicResource {x:Static theme:BrushKeys.DataGridAccentStripe}}\"/> </Trigger> </ControlTemplate.Triggers> </ControlTemplate> </Setter.Value> </Setter> </Style> Source: csharp/src/DBTools.Themes/Themes/App.DataGrid.xaml:24-101 Menu Styles Full custom templates avoid Revit add-in styling conflicts: <Style x:Key=\"ContextMenu\" TargetType=\"ContextMenu\"> <Setter Property=\"Background\" Value=\"{DynamicResource {x:Static theme:BrushKeys.Surface}}\"/> <Setter Property=\"BorderBrush\" Value=\"{DynamicResource {x:Static theme:BrushKeys.Divider}}\"/> <Setter Property=\"Template\"> <Setter.Value> <ControlTemplate TargetType=\"ContextMenu\"> <Border Background=\"{TemplateBinding Background}\" CornerRadius=\"4\" SnapsToDevicePixels=\"True\"> <Border.Effect> <DropShadowEffect BlurRadius=\"8\" ShadowDepth=\"2\" Opacity=\"0.35\"/> </Border.Effect> <ScrollViewer> <ItemsPresenter/> </ScrollViewer> </Border> </ControlTemplate> </Setter.Value> </Setter> </Style> Source: csharp/src/DBTools.Themes/Themes/App.Menus.xaml:9-42 Component Styles Cards Elevated card surfaces with shadows: <Style x:Key=\"Card\" TargetType=\"Border\"> <Setter Property=\"Background\" Value=\"{DynamicResource {x:Static theme:BrushKeys.CardSurface}}\"/> <Setter Property=\"BorderBrush\" Value=\"{DynamicResource {x:Static theme:BrushKeys.CardBorder}}\"/> <Setter Property=\"CornerRadius\" Value=\"{DynamicResource Radius8}\"/> <Setter Property=\"Padding\" Value=\"{DynamicResource Card.Padding}\"/> </Style> <Style x:Key=\"Card.Elevated\" TargetType=\"Border\" BasedOn=\"{StaticResource Card}\"> <Setter Property=\"Effect\"> <Setter.Value> <DropShadowEffect BlurRadius=\"18\" ShadowDepth=\"4\" Opacity=\"0.35\"/> </Setter.Value> </Setter> </Style> Source: csharp/src/DBTools.Themes/Themes/App.Components.xaml:205-225 Toolbar Chips Toggle buttons styled as filter chips: <Style x:Key=\"ToolbarChip\" TargetType=\"ToggleButton\"> <Setter Property=\"Background\" Value=\"{DynamicResource {x:Static theme:BrushKeys.ToolbarChipBackground}}\"/> <Setter Property=\"Template\"> <Setter.Value> <ControlTemplate TargetType=\"ToggleButton\"> <Border x:Name=\"Chip\" CornerRadius=\"{DynamicResource Radius6}\" ...> <ContentPresenter/> </Border> <ControlTemplate.Triggers> <Trigger Property=\"IsChecked\" Value=\"True\"> <Setter TargetName=\"Chip\" Property=\"Background\" Value=\"{DynamicResource {x:Static theme:BrushKeys.ToolbarChipSelected}}\"/> </Trigger> </ControlTemplate.Triggers> </ControlTemplate> </Setter.Value> </Setter> </Style> Source: csharp/src/DBTools.Themes/Themes/App.Components.xaml:29-91 Theme Validation Startup Validation DbtThemeValidator.ValidateOrThrow() performs comprehensive theme validation: Incremental Merge Test: Merges each dictionary one-by-one to pinpoint failures Freezable Freeze: Freezes all brushes to prevent runtime leaks Contract Assertion: Validates merged dictionary order matches expected Ghost Validation: Creates invisible control tree to force template evaluation public static void ValidateOrThrow() { WpfUiThread.EnsurePackUriSupport(); // Incremental merge to pinpoint first broken dictionary var scratch = new ResourceDictionary(); foreach (var source in ExpectedMergedDictionarySources) { scratch.MergedDictionaries.Add(new ResourceDictionary { Source = new Uri(source, UriKind.Absolute) }); } FreezeFreezablesOrThrow(scratch); AssertMergedDictionariesContract(themeRoot); GhostValidate(themeRoot); } Source: csharp/src/DBTools.Core/UI/Theming/DbtThemeValidator.cs:52-92 Ghost Validation Creates an invisible visual tree to force template instantiation and catch deferred failures: private static void GhostValidate(ResourceDictionary themeRoot) { var root = new Grid { Width = 800, Height = 600 }; root.Resources.MergedDictionaries.Add(themeRoot); root.Children.Add(BuildProbeContent(root)); root.Measure(new Size(root.Width, root.Height)); root.Arrange(new Rect(0, 0, root.Width, root.Height)); root.UpdateLayout(); } Source: csharp/src/DBTools.Core/UI/Theming/DbtThemeValidator.cs:229-248 Using the Theme In XAML Reference brushes via DynamicResource and BrushKeys: <Window xmlns:theme=\"clr-namespace:DBTools.Themes;assembly=DBTools.Themes\"> <Border Background=\"{DynamicResource {x:Static theme:BrushKeys.Surface}}\"> <TextBlock Text=\"Hello\" Foreground=\"{DynamicResource {x:Static theme:BrushKeys.Body}}\"/> </Border> </Window> In Code Use SetResourceReference for dynamic binding: window.SetResourceReference(Window.BackgroundProperty, BrushKeys.Paper); window.SetResourceReference(Window.ForegroundProperty, BrushKeys.Body); Source: csharp/src/DBTools.Core/UI/Windows/DbtWindowInitHelper.cs:151-155 Extending the Theme Adding New Brushes Add ComponentResourceKey property in BrushKeys.cs: public static ComponentResourceKey MyNewBrush => new(typeof(BrushKeys), \"Brush.MyNew\"); Add brush definition in App.Brushes.xaml: <SolidColorBrush x:Key=\"{x:Static theme:BrushKeys.MyNewBrush}\" Color=\"#FF123456\"/> Adding New Styles Create new keyed style in appropriate dictionary: <Style x:Key=\"MyCustomButton\" TargetType=\"Button\" BasedOn=\"{StaticResource {x:Type Button}}\"> <Setter Property=\"Background\" Value=\"{DynamicResource {x:Static theme:BrushKeys.Primary}}\"/> </Style> For implicit styles, omit the x:Key: <Style TargetType=\"MyCustomControl\"> <Setter Property=\"Background\" Value=\"{DynamicResource {x:Static theme:BrushKeys.Surface}}\"/> </Style> XAML Resource File Types Some XAML files reference DBTools.Core types and cannot be compiled as BAML: <!-- These files are raw resources, not compiled BAML --> <Page Remove=\"Themes\\App.Converters.xaml\"/> <Page Remove=\"Themes\\App.Controls.Base.xaml\"/> <Page Remove=\"Themes\\App.Components.xaml\"/> <Resource Include=\"Themes\\App.Converters.xaml\"/> <Resource Include=\"Themes\\App.Controls.Base.xaml\"/> <Resource Include=\"Themes\\App.Components.xaml\"/> Source: csharp/src/DBTools.Themes/DBTools.Themes.csproj:38-46 Related Documentation Architecture Overview - High-level system architecture Project References - Project dependency graph Files Reviewed File Purpose csharp/src/DBTools.Themes/DBTools.Themes.csproj Project configuration csharp/src/DBTools.Themes/BrushKeys.cs ComponentResourceKey definitions csharp/src/DBTools.Themes/Themes/App.Theme.xaml Root theme dictionary csharp/src/DBTools.Themes/Themes/App.Tokens.xaml Design tokens csharp/src/DBTools.Themes/Themes/App.Brushes.xaml Color definitions csharp/src/DBTools.Themes/Themes/App.Controls.Base.xaml Base control styles csharp/src/DBTools.Themes/Themes/App.DataGrid.xaml DataGrid styles csharp/src/DBTools.Themes/Themes/App.Menus.xaml Menu styles csharp/src/DBTools.Themes/Themes/App.Components.xaml Component styles csharp/src/DBTools.Themes/Themes/App.FluentRibbon.xaml Fluent.Ribbon bridge csharp/src/DBTools.Themes/Themes/App.Converters.xaml Value converters csharp/src/DBTools.Core/UI/Theming/DbtThemeValidator.cs Theme validation csharp/src/DBTools.Core/UI/Windows/DbtWindowBase.cs Window base class csharp/src/DBTools.Core/UI/Windows/DbtRibbonWindowBase.cs Ribbon window base csharp/src/DBTools.Core/UI/Windows/DbtWindowInitHelper.cs Theme loading logic csharp/src/DBTools.Core/UI/Windows/ResourceDictionaryHelper.cs Dictionary utilities csharp/build-vendored-deps.sh Vendored library build script"
  },
  "developer-guide/developing/feature-warnings.html": {
    "href": "developer-guide/developing/feature-warnings.html",
    "title": "Feature Warnings | DB Tools",
    "summary": "Feature Warnings Feature warnings provide a mechanism to notify users of configuration issues and automatically disable affected tools until the problem is resolved. This guide covers warning definition, triggering, display, and clearing. Overview Feature warnings serve two purposes: User Notification: Display prominent warnings in the Settings window when configuration issues exist Tool Protection: Automatically disable ribbon buttons for tools that depend on valid configuration Warnings are declarative (defined in manifest.yml) but activated programmatically based on validation logic. When a warning is active: The warning card appears in the Settings window Associated ribbon buttons become disabled The Settings button icon shows a warning indicator The DB Tools tab gets a highlight marker Source: csharp/src/DBTools.Core/Settings/DbtSettingsWarningDefinition.cs:9-20 Warning Lifecycle 1. DEFINITION (manifest.yml) Warning metadata declared: id, title, message, disableTools | v 2. REGISTRATION (ToolModule.RegisterSettingsPacks) DbtSettingsWarningDefinition created with validation logic | v 3. VALIDATION (Settings window load / manual trigger) Pack context validates settings, sets HasWarning flag | v 4. ACTIVATION (IDbtSettingsWarningService.SetWarningAsync) Warning state persisted, ribbon buttons disabled | v 5. DISPLAY (SettingsWarningCardView) Warning card shown with Clear button | v 6. CLEARING (User clicks Clear / conditions change) Warning state cleared, ribbon buttons re-enabled Defining Warnings in manifest.yml Warnings are declared within settingsPacks in your tool's manifest.yml: Complete Schema tool: settingsPacks: - key: structural.foundation_tags # Unique pack identifier title: \"Combined Foundation Tags\" # Display title in Settings warnings: - id: core.structural.combined_tags # Unique warning identifier title: \"Combined Foundation Tags Disabled\" # Warning card title message: \"Combined foundation tag updates are disabled due to a warning. Clear the warning to re-enable.\" disableTools: # Tools to disable when active - DBTools.UpdateCombinedFoundationTags - DBTools.MoveCombinedFoundationTags - DBTools.OrganizeFoundationTypes Source: csharp/src/Tools/Structural/FoundationTags/manifest.yml:8-18 Warning Properties Reference Property Required Description id Yes Globally unique warning identifier (e.g., core.structural.combined_tags) title Yes Title shown in the warning card header message Yes Detailed message explaining the issue and resolution disableTools No List of ribbon tool internalName values to disable ID Naming Convention Use a hierarchical naming scheme: core.{domain}.{feature} - For core/shared functionality tools.{toolname}.{warning} - For tool-specific warnings Examples: core.library.invalid - Library paths are invalid core.structural.elevation_tags - Elevation tag alignment warning core.structural.joist_girder - Joist girder weight warning Warning Properties in Code The DbtToolWarningManifest class represents the YAML definition: public sealed class DbtToolWarningManifest { public string Id { get; set; } = string.Empty; public string Title { get; set; } = string.Empty; public string Message { get; set; } = string.Empty; public List<string>? DisableTools { get; set; } } Source: csharp/src/DBTools.Core/Tools/DbtToolManifest.cs:44-50 Registering Warning Definitions Warnings must be registered in your ToolModule.RegisterSettingsPacks() method. This connects the declarative manifest to the runtime validation logic. Complete Registration Pattern public override void RegisterSettingsPacks(IServiceCollection services, DbtToolManifest manifest) { Guard.NotNull(services, nameof(services)); Guard.NotNull(manifest, nameof(manifest)); var configSection = manifest.GetRequiredConfigSection(); var pack = manifest.GetSingleSettingsPack(); var warning = pack.GetSingleWarning(manifest.Id); var panel = DbtToolPanelResolver.GetSettingsPanelName(manifest.Id); services.AddSingleton<IDbtSettingsPackDefinition>(_ => { var warningDefinitions = new[] { new DbtSettingsWarningDefinition<MyToolSettings, MySettingsPackContext>( warning.Id, // From manifest pack.Key, // Pack key warning.Title, // From manifest warning.Message, // From manifest // Options getter - how to read from settings settings => settings.Get<MyToolSettings>(), // Options saver - how to persist settings (settings, options, ct) => settings.SaveAsync(configSection, options, ct), // Options flag getter - read warning state from options options => options.HasWarning, // Options flag setter - write warning state to options (options, active) => { options.HasWarning = active; if (active) options.AutoUpdateEnabled = false; // Disable auto-update when warning active }, // Context flag getter - read warning state from context context => context.HasWarning, // Context flag setter - write warning state to context (context, active) => { context.HasWarning = active; if (active) context.AutoUpdateEnabled = false; }, // Tools to disable (from manifest) warning.DisableTools?.ToArray() ?? Array.Empty<string>()) }; return new DbtSettingsPackDefinition<MyToolSettings, MySettingsPackContext>( pack.Key, pack.Title, panel, () => new MySettingsPackContext(), ctx => new MySettingsPackView { DataContext = ctx }, () => new MyToolSettings(), settings => settings.Get<MyToolSettings>(), (settings, options, ct) => settings.SaveAsync(configSection, options, ct), warningDefinitions); // Pass warning definitions to pack }); } Source: csharp/src/Tools/Structural/FoundationTags/FoundationTagsToolModule.cs:36-81 DbtSettingsWarningDefinition Constructor Parameters Parameter Type Description id string Warning identifier from manifest packKey string Parent settings pack key title string Display title message string Display message optionsGetter Func<ISettingsProvider, TOptions> How to read options from settings optionsSaver Func<ISettingsProvider, TOptions, CancellationToken, Task> How to save options optionsFlagGetter Func<TOptions, bool> Get warning flag from options optionsFlagSetter Action<TOptions, bool> Set warning flag on options contextFlagGetter Func<TContext, bool> Get warning flag from context contextFlagSetter Action<TContext, bool> Set warning flag on context toolInternalNamesToDisable IReadOnlyCollection<string>? Tools to disable Source: csharp/src/DBTools.Core/Settings/DbtSettingsWarningDefinition.cs:33-57 Settings Model Requirements Your settings class must include a HasWarning property for warning state persistence: using DBTools.Core.Settings.Models; namespace DBTools.MyTool.Settings; public sealed class MyToolSettings : IAutoUpdateSettings { public bool AutoUpdateEnabled { get; set; } public bool HasWarning { get; set; } // Other settings... } The IAutoUpdateSettings interface requires both properties: public interface IAutoUpdateSettings { bool AutoUpdateEnabled { get; set; } bool HasWarning { get; set; } } Source: csharp/src/DBTools.Core/Settings/Models/IAutoUpdateSettings.cs:3-7 Triggering Warnings Warnings are triggered through the IDbtSettingsWarningService: Service Interface public interface IDbtSettingsWarningService { IReadOnlyCollection<IDbtSettingsWarningDefinition> Definitions { get; } Task<bool> IsWarningActiveAsync(string warningId, CancellationToken ct = default); Task SetWarningAsync(string warningId, bool active, object? context = null, CancellationToken ct = default); Task PublishWarningChangesAsync(CancellationToken ct = default); Task PublishWarningStateAsync(CancellationToken ct = default); } Source: csharp/src/DBTools.Core/Settings/DbtSettingsWarningService.cs:11-18 Setting a Warning Active // In your validation logic var warningService = serviceProvider.GetRequiredService<IDbtSettingsWarningService>(); await warningService.SetWarningAsync(\"core.my_tool.warning\", true, packContext); Clearing a Warning await warningService.SetWarningAsync(\"core.my_tool.warning\", false, packContext); Validation in Settings Pack Context Typically, warnings are validated when the settings pack loads or saves. Implement validation in your context's ValidateAsync method: public async Task<DbtSettingsValidationResult> ValidateAsync(CancellationToken ct) { var errors = new List<string>(); // Validate configuration if (string.IsNullOrWhiteSpace(LibraryPath) || !Directory.Exists(LibraryPath)) { errors.Add($\"Library path '{LibraryPath}' does not exist.\"); HasWarnings = true; // Set context warning flag } else { HasWarnings = false; } return errors.Count > 0 ? DbtSettingsValidationResult.Failed(errors) : DbtSettingsValidationResult.Success(); } Source: csharp/src/Tools/Common/TDV/Settings/LibrarySettingsPackContext.cs:137-170 Warning UI in Settings Window When warnings are active, they appear as prominent cards in the Settings window: SettingsWarningCardView <Border Style=\"{DynamicResource WarningBar}\" Visibility=\"{Binding IsActive, Converter={StaticResource Converter.BoolToVisibility}}\"> <Grid> <Grid.ColumnDefinitions> <ColumnDefinition Width=\"*\" /> <ColumnDefinition Width=\"Auto\" /> </Grid.ColumnDefinitions> <StackPanel> <TextBlock FontWeight=\"SemiBold\" Foreground=\"{DynamicResource {x:Static theme:BrushKeys.Warning}}\" Text=\"{Binding Title}\" /> <TextBlock Margin=\"{DynamicResource TGap6}\" Style=\"{DynamicResource DescriptionText}\" Text=\"{Binding Message}\" /> </StackPanel> <Button Grid.Column=\"1\" MinWidth=\"70\" Command=\"{Binding ClearCommand}\" Content=\"Clear\" Style=\"{DynamicResource SubtleButton}\" /> </Grid> </Border> Source: csharp/src/DBTools.Core/Settings/Views/SettingsWarningCardView.xaml:14-36 Warning ViewModel The DbtSettingsWarningViewModel provides the binding context: public sealed partial class DbtSettingsWarningViewModel : ObservableObject, IDisposable { public string WarningId => _definition.Id; public string Title => _definition.Title; public string Message => _definition.Message; public bool IsActive => _definition.GetIsActive(_context); public IAsyncRelayCommand ClearCommand { get; } private async Task ClearAsync() { await _warnings.SetWarningAsync(_definition.Id, false, _context); OnPropertyChanged(nameof(IsActive)); } } Source: csharp/src/DBTools.Core/Settings/ViewModels/DbtSettingsWarningViewModel.cs:10-51 disableTools Mechanism When a warning is active, the specified ribbon tools are automatically disabled. Event Flow Warning Activated: IDbtSettingsWarningService.SetWarningAsync() is called Event Published: ISettingsChangePublisher.PublishWarningChanged() fires Listener Receives: RibbonSettingsListener.OnWarningChanged() handles event Buttons Disabled: RibbonRegistry.SetToolsEnabled() disables buttons // RibbonSettingsListener.cs private void OnWarningChanged(object? sender, SettingsWarningChangedEventArgs e) { RunOnUiThread( () => RibbonRegistry.SetToolsEnabled(e.ToolInternalNamesToDisable, !e.IsActive), \"Failed to apply ribbon warning change.\"); } Source: csharp/src/DBTools.App/Features/Ribbon/RibbonSettingsListener.cs:53-58 RibbonRegistry Implementation public static void SetToolsEnabled(IEnumerable<string> internalNames, bool enabled) { foreach (var name in internalNames) { try { SetToolEnabled(name, enabled); } catch (Exception ex) { Logger?.LogWarning(ex, \"Failed to set tool '{InternalName}' enabled state.\", name); } } } public static void SetToolEnabled(string internalName, bool enabled) { if (!_toolButtons.TryGetValue(internalName, out var button)) { Logger?.LogWarning(\"Tool button '{InternalName}' not found in registry.\", internalName); return; } button.Enabled = enabled; } Source: csharp/src/DBTools.App/Features/Ribbon/RibbonRegistry.cs:31-52 Visual Indicators When warnings exist: Settings Button Icon: Changes to show warning indicator Tab Highlight: DB Tools tab shows a \"New\" highlight private void OnWarningsChanged(object? sender, SettingsWarningsChangedEventArgs e) { RunOnUiThread( () => { RibbonRegistry.UpdateSettingsIcon(e.HasWarnings); RibbonRegistry.UpdateTabHighlight(e.HasWarnings); }, \"Failed to apply ribbon warning updates.\"); } Source: csharp/src/DBTools.App/Features/Ribbon/RibbonSettingsListener.cs:42-51 Conditional Warnings Warnings can be conditional based on settings or environment. Implement the condition in your validation logic: Based on Settings Value public async Task<DbtSettingsValidationResult> ValidateAsync(CancellationToken ct) { // Only validate if feature is enabled if (!AutoUpdateEnabled) { HasWarning = false; return DbtSettingsValidationResult.Success(); } // Validate when enabled if (!IsConfigurationValid()) { HasWarning = true; return DbtSettingsValidationResult.Failed(\"Configuration is invalid.\"); } HasWarning = false; return DbtSettingsValidationResult.Success(); } Based on Environment public async Task<DbtSettingsValidationResult> ValidateAsync(CancellationToken ct) { var errors = new List<string>(); foreach (var path in LibraryPaths) { if (!Directory.Exists(path)) { errors.Add($\"Path '{path}' does not exist.\"); } } HasWarnings = errors.Count > 0; return HasWarnings ? DbtSettingsValidationResult.Failed(errors) : DbtSettingsValidationResult.Success(); } Source: csharp/src/Tools/Common/TDV/Settings/LibrarySettingsPackContext.cs:137-170 Auto-Update Task Integration For tools with auto-update functionality (triggered on view activation), the ViewActivatedTaskBase checks warning state before execution: public async Task<bool> ShouldRunAsync(UIApplication uiapp, ViewActivatedEventArgs args, CancellationToken ct) { var settings = GetSettings(_settingsProvider) ?? new TSettings(); if (!settings.AutoUpdateEnabled) { LogSkip(\"auto-update disabled\"); return false; } if (settings.HasWarning) { LogSkip(\"warning active\"); return false; } return await ShouldRunInternalAsync(uiapp, args, settings, ct).ConfigureAwait(false); } Source: csharp/src/DBTools.Core/Tools/ViewActivatedTaskBase.cs:46-65 This ensures auto-update tasks don't run when warnings are active, protecting against potential failures. Clearing Warnings Warnings can be cleared in several ways: 1. User Clicks Clear Button The Settings window warning card has a \"Clear\" button that calls: private async Task ClearAsync() { await _warnings.SetWarningAsync(_definition.Id, false, _context); OnPropertyChanged(nameof(IsActive)); } 2. Programmatically When Conditions Change // After user fixes configuration if (IsConfigurationNowValid()) { await warningService.SetWarningAsync(\"core.my_tool.warning\", false, context); } 3. Through Settings Pack Context Reset public void ResetToDefaults() { AutoUpdateEnabled = true; HasWarning = false; // Clear warning flag // Reset other settings... } Source: csharp/src/Tools/Structural/FoundationTags/Settings/FoundationTagsSettingsPackContext.cs:206-212 Real Examples Example 1: Foundation Tags Warning Disables multiple related tools when foundation tag configuration has issues: # manifest.yml settingsPacks: - key: structural.foundation_tags title: \"Combined Foundation Tags\" warnings: - id: core.structural.combined_tags title: \"Combined Foundation Tags Disabled\" message: \"Combined foundation tag updates are disabled due to a warning. Clear the warning to re-enable.\" disableTools: - DBTools.UpdateCombinedFoundationTags - DBTools.MoveCombinedFoundationTags - DBTools.OrganizeFoundationTypes Source: csharp/src/Tools/Structural/FoundationTags/manifest.yml:8-18 Example 2: Library Paths Warning Disables import/export when library paths are invalid: # manifest.yml settingsPacks: - key: core.library title: \"Library Files\" warnings: - id: core.library.invalid title: \"Library Paths Invalid\" message: \"One or more library file paths are invalid. Fix the paths and clear the warning to re-enable import/export.\" disableTools: - DBTools.ExportToLibrary - DBTools.ImportFromLibrary Source: csharp/src/Tools/Common/TDV/manifest.yml:14-23 Example 3: Simple Single-Tool Warning # manifest.yml settingsPacks: - key: structural.joist_girder_weight title: \"Joist Girder Weights\" warnings: - id: core.structural.joist_girder title: \"Joist Girder Weights Disabled\" message: \"Joist girder weight updates are disabled due to a warning. Clear the warning to re-enable.\" disableTools: - DBTools.UpdateJoistGirderWeights Source: csharp/src/Tools/Structural/JoistGirderWeight/manifest.yml:8-16 Warning Event Args The warning system uses specific event args for state changes: SettingsWarningChangedEventArgs Fired when a specific warning's state changes: public sealed class SettingsWarningChangedEventArgs : EventArgs { public string WarningId { get; } public string PackKey { get; } public bool IsActive { get; } public IReadOnlyCollection<string> ToolInternalNamesToDisable { get; } } Source: csharp/src/DBTools.Core/Settings/Contracts/ISettingsChangePublisher.cs:25-43 SettingsWarningsChangedEventArgs Fired when the overall warning state changes (any warnings -> no warnings, or vice versa): public sealed class SettingsWarningsChangedEventArgs : EventArgs { public bool HasWarnings { get; } } Source: csharp/src/DBTools.Core/Settings/Contracts/ISettingsChangePublisher.cs:15-23 Best Practices 1. Clear Warning Messages Write messages that explain: What is wrong Why it matters How to fix it # Good message: \"One or more library file paths are invalid. Fix the paths and clear the warning to re-enable import/export.\" # Bad message: \"Warning active.\" 2. Disable Only Affected Tools Only list tools that actually depend on the valid configuration: # Good - only disables tools that use foundation tags disableTools: - DBTools.UpdateCombinedFoundationTags - DBTools.MoveCombinedFoundationTags # Bad - disables unrelated tools disableTools: - DBTools.UpdateCombinedFoundationTags - DBTools.SomeUnrelatedTool 3. Auto-Disable Auto-Update When setting a warning active, also disable auto-update to prevent background failures: (options, active) => { options.HasWarning = active; if (active) options.AutoUpdateEnabled = false; // Important! } 4. Test Warning Scenarios Ensure your tool handles: Warning active on startup Warning cleared mid-session Multiple warnings in same pack Cross-References Creating New Tools - Tool module registration Settings Packs - Settings pack configuration Modularity - Tool module architecture"
  },
  "developer-guide/developing/hooks.html": {
    "href": "developer-guide/developing/hooks.html",
    "title": "Hooks | DB Tools",
    "summary": "Hooks Hooks are the extensibility mechanism that allows DBTools modules to respond to Revit application events without coupling directly to the Revit API event system. They provide a clean, testable abstraction for behaviors like auto-updating elements when views change or injecting contextual ribbon UI. Overview What Are Hooks? Hooks are interfaces that define contracts for responding to specific application-level events. Rather than subscribing directly to Revit's UIControlledApplication events, tools register hook handlers that the central DbtHookHost dispatches to when events occur. Why Use Hooks? Direct Revit Events DBTools Hooks Scattered subscriptions across tools Centralized event management Manual exception handling Automatic error handling via ISafeExecutor Tight coupling to Revit API Testable abstractions Risk of blocking UI thread Async-first design Complex lifecycle management Automatic attach/detach Key Benefits Centralized Dispatch: All event handling flows through DbtHookHost, ensuring consistent error handling and logging Async Support: Hook handlers can perform async work without blocking Revit's UI thread Automatic Lifecycle: Hooks are attached/detached during app startup/shutdown Settings Integration: View-activated tasks integrate with the settings system for enable/disable control Warning System: Hooks can set warnings when they fail, disabling auto-update until the user resolves them Hook Architecture Component Overview flowchart TB subgraph Revit[\"Revit Application\"] Events[\"UIControlledApplication Events\"] end subgraph Core[\"DBTools.Core\"] HookHost[\"DbtHookHost\"] Registry[\"DbtToolRegistry\"] Executor[\"ISafeExecutor\"] end subgraph Handlers[\"Hook Handlers\"] VAH[\"ViewActivatedHookHandler\"] CRI[\"IContextualRibbonInjector\"] end subgraph Tasks[\"View Activated Tasks\"] ET[\"ElevationTagsViewActivatedTask\"] FT[\"FoundationTagsViewActivatedTask\"] JGT[\"JoistGirderViewActivatedTask\"] end Events -->|ViewActivated| HookHost Events -->|SelectionChanged| CRI HookHost --> Executor Executor --> VAH Executor --> CRI VAH --> ET VAH --> FT VAH --> JGT Registry -.->|\"GetHookImplementations<T>()\"| HookHost Source: csharp/src/DBTools.Core/Tools/DbtHookHost.cs:28-55 Registration Flow sequenceDiagram participant Boot as DbtServiceBootstrapper participant Module as ToolModule participant Registry as DbtToolRegistry participant Host as DbtHookHost participant DI as IServiceProvider Boot->>Module: RegisterHooks(registry, manifest) Module->>Registry: RegisterHook<THook, TImpl>() Note over Registry: Stores Type mapping Boot->>DI: BuildServiceProvider() Boot->>Host: Attach(application) Host->>Registry: GetHookImplementations<T>() Host->>DI: GetService(implType) Host->>Host: Subscribe to Revit events The DbtHookHost DbtHookHost is the central coordinator that: Resolves handlers from the DI container using types registered in DbtToolRegistry Subscribes to Revit events (e.g., ViewActivated) Dispatches to handlers wrapped in ISafeExecutor for error handling Manages lifecycle via Attach() and Detach() methods public sealed class DbtHookHost { private static readonly HashSet<Type> _supportedHookInterfaces = new(new[] { typeof(IViewActivatedHookHandler), typeof(IContextualRibbonInjector) }); public void Attach(UIControlledApplication application) { var viewHandlers = ResolveHandlers<IViewActivatedHookHandler>(); var contextualInjectors = ResolveHandlers<IContextualRibbonInjector>(); if (viewHandlers.Count > 0) application.ViewActivated += OnViewActivated; InitializeContextualInjectorsNonBlocking(application, contextualInjectors); } } Source: csharp/src/DBTools.Core/Tools/DbtHookHost.cs:57-79 Available Hook Types IViewActivatedHookHandler Responds to Revit's ViewActivated event, which fires whenever the user switches views. This is the primary hook for auto-update functionality. public interface IViewActivatedHookHandler { Task OnViewActivatedAsync( UIControlledApplication application, ViewActivatedEventArgs args, CancellationToken ct); } Source: csharp/src/DBTools.Core/Tools/DbtHookHost.cs:14-17 Use Cases: Auto-updating elevation tags when entering floor plans Refreshing parameter values on view change Updating cached view-specific data Important Considerations: Handler runs on the Revit UI thread context Must not block; use async patterns Errors are caught by ISafeExecutor and logged IContextualRibbonInjector Manages dynamic ribbon UI that appears based on application state (typically selection). Unlike view-activated hooks, contextual injectors manage their own event subscriptions. public interface IContextualRibbonInjector { Task InitializeAsync(UIControlledApplication application, CancellationToken ct); Task ShutdownAsync(UIControlledApplication application, CancellationToken ct); } Source: csharp/src/DBTools.Core/Tools/DbtHookHost.cs:19-23 Use Cases: Adding \"Edit\" buttons to contextual tabs when tool-specific elements are selected Showing/hiding ribbon controls based on selection state Injecting panels into Revit's contextual \"Modify\" tabs Lifecycle: InitializeAsync called during DbtHookHost.Attach() Injector subscribes to SelectionChanged or other events internally ShutdownAsync called during DbtHookHost.Detach() The IViewActivatedTask System For the common pattern of \"do something when a view activates,\" DBTools provides a higher-level abstraction: IViewActivatedTask. The single ViewActivatedHookHandler dispatches to all registered tasks. IViewActivatedTask Interface public interface IViewActivatedTask { string TaskId { get; } string DisplayName { get; } IReadOnlyCollection<string> WarningIdsToSetOnFailure { get; } Task<bool> ShouldRunAsync(UIApplication uiapp, ViewActivatedEventArgs args, CancellationToken ct); Task ExecuteAsync(UIApplication uiapp, ViewActivatedEventArgs args, CancellationToken ct); } Source: csharp/src/DBTools.Core/Tools/IViewActivatedTask.cs:9-16 ViewActivatedTaskBase A base class that provides settings integration and common checks: public abstract class ViewActivatedTaskBase<TSettings> : IViewActivatedTask where TSettings : class, IAutoUpdateSettings, new() { public async Task<bool> ShouldRunAsync(...) { var settings = GetSettings(_settingsProvider); // Built-in checks if (!settings.AutoUpdateEnabled) return false; if (settings.HasWarning) return false; // Delegate to subclass return await ShouldRunInternalAsync(uiapp, args, settings, ct); } protected abstract TSettings GetSettings(ISettingsProvider settingsProvider); protected virtual Task<bool> ShouldRunInternalAsync(...) => Task.FromResult(true); public abstract Task ExecuteAsync(...); } Source: csharp/src/DBTools.Core/Tools/ViewActivatedTaskBase.cs:15-85 Execution Flow sequenceDiagram participant Revit participant Host as DbtHookHost participant Exec as ISafeExecutor participant Handler as ViewActivatedHookHandler participant Task as IViewActivatedTask participant Settings as ISettingsProvider Revit->>Host: ViewActivated event Host->>Exec: RunAsync(handler logic) Exec->>Handler: OnViewActivatedAsync() loop For each registered task Handler->>Task: ShouldRunAsync() Task->>Settings: Get<TSettings>() alt AutoUpdateEnabled && !HasWarning Task-->>Handler: true Handler->>Exec: RunAsync(task.Execute) Exec->>Task: ExecuteAsync() alt Success Task-->>Exec: Complete else Failure Exec->>Settings: SetWarning(id, true) end else Disabled or has warning Task-->>Handler: false (skip) end end Registering Hooks In ToolModule.RegisterHooks() Override RegisterHooks in your DbtToolModule to register hook handlers: public sealed class MyToolModule : DbtToolModule { public override void RegisterServices(IServiceCollection services, DbtToolManifest manifest) { // Register the handler as a service services.AddSingleton<MyContextualInjector>(); } public override void RegisterHooks(DbtToolRegistry registry, DbtToolManifest manifest) { Guard.NotNull(registry, nameof(registry)); Guard.NotNull(manifest, nameof(manifest)); registry.RegisterHook<IContextualRibbonInjector, MyContextualInjector>(); } } Source: csharp/src/Tools/Structural/SGT/SgtToolModule.cs:20-25 Registering View Activated Tasks View-activated tasks use a different pattern. Instead of registering directly as hooks, they're registered as IViewActivatedTask services that the single ViewActivatedHookHandler collects: public override void RegisterServices(IServiceCollection services, DbtToolManifest manifest) { var warningIds = GetWarningIdsFromManifest(manifest); services.AddSingleton<IViewActivatedTask>(sp => new ElevationTagsViewActivatedTask( sp.GetRequiredService<ISettingsProvider>(), sp.GetRequiredService<IDbtLoggingHost>(), sp.GetRequiredService<ILogger<ElevationTagsViewActivatedTask>>(), warningIds)); } Source: csharp/src/Tools/Common/ElevationTags/ElevationTagsToolModule.cs:25-35 Registration in AppHookModule The core AppHookModule registers the single ViewActivatedHookHandler that dispatches to all tasks: public sealed class AppHookModule : DbtToolModule { public override void RegisterServices(IServiceCollection services, DbtToolManifest manifest) { services.AddSingleton<ViewActivatedHookHandler>(); } public override void RegisterHooks(DbtToolRegistry registry, DbtToolManifest manifest) { registry.RegisterHook<IViewActivatedHookHandler, ViewActivatedHookHandler>(); } } Source: csharp/src/DBTools.App/Features/Hooks/AppHookModule.cs:7-22 Implementing Hook Handlers Step 1: Define Your Handler Class public sealed class MyViewActivatedTask : ViewActivatedTaskBase<MyToolSettings> { public MyViewActivatedTask( ISettingsProvider settings, ILogger<MyViewActivatedTask> logger, IReadOnlyCollection<string> warningIds) : base(settings, logger, \"mytool.updater\", \"My Tool Auto-Update\", warningIds) { } protected override MyToolSettings GetSettings(ISettingsProvider provider) => provider.Get<MyToolSettings>(); } Step 2: Implement ShouldRunInternalAsync (Optional) Filter when your task should run based on view type, document state, etc.: protected override Task<bool> ShouldRunInternalAsync( UIApplication uiapp, ViewActivatedEventArgs args, MyToolSettings settings, CancellationToken ct) { var view = uiapp.ActiveUIDocument?.Document?.ActiveView; if (view == null) return Task.FromResult(false); // Only run in floor plans return Task.FromResult( view.ViewType == ViewType.FloorPlan || view.ViewType == ViewType.CeilingPlan); } Source: csharp/src/Tools/Common/ElevationTags/Hooks/ElevationTagsViewActivatedTask.cs:40-52 Step 3: Implement ExecuteAsync Perform the actual work: public override Task ExecuteAsync( UIApplication uiapp, ViewActivatedEventArgs args, CancellationToken ct) { var doc = uiapp.ActiveUIDocument?.Document ?? throw new InvalidOperationException(\"No active document.\"); var view = doc.ActiveView ?? throw new InvalidOperationException(\"No active view.\"); var settings = GetSettings(SettingsProvider); var gate = new ModalInlineCallGate(uiapp); var tx = new CallGateTransactionRunner(gate); var updater = new MyAutoUpdater(tx, doc, view, Logger, settings); updater.Run(); return Task.CompletedTask; } Source: csharp/src/Tools/Common/ElevationTags/Hooks/ElevationTagsViewActivatedTask.cs:54-65 Step 4: Register in Your ToolModule public override void RegisterServices(IServiceCollection services, DbtToolManifest manifest) { var warningIds = new[] { \"mytool.auto_update.warning\" }; services.AddSingleton<IViewActivatedTask>(sp => new MyViewActivatedTask( sp.GetRequiredService<ISettingsProvider>(), sp.GetRequiredService<ILogger<MyViewActivatedTask>>(), warningIds)); } Implementing Contextual Ribbon Injectors For tools that need dynamic ribbon UI (like SGT's \"Edit\" button on selected girts): Step 1: Implement IContextualRibbonInjector public sealed class MyContextualInjector : IContextualRibbonInjector { private readonly ILogger<MyContextualInjector> _logger; private readonly ISafeExecutor _executor; private bool _subscribed; public Task InitializeAsync(UIControlledApplication application, CancellationToken ct) { if (_subscribed) return Task.CompletedTask; // Subscribe to selection changes // Use ModelessQueuedCallGate for safe async access return _gate.RunAsync(app => { app.SelectionChanged += OnSelectionChanged; _subscribed = true; }, ct); } public Task ShutdownAsync(UIControlledApplication application, CancellationToken ct) { if (!_subscribed) return Task.CompletedTask; return _gate.RunAsync(app => { app.SelectionChanged -= OnSelectionChanged; _subscribed = false; RemoveInjectedUI(); }, ct); } } Source: csharp/src/Tools/Structural/SGT/Features/Commands/SgtContextualRibbonInjector.cs:53-82 Step 2: Handle Selection Changes private async void OnSelectionChanged(object? sender, SelectionChangedEventArgs e) { if (sender is not UIApplication uiapp) return; try { await _executor.RunAsync( () => RefreshAsync(uiapp, CancellationToken.None), _logger, notifier: null, opts: new SafeExecutor.SafeExecuteOptions { Name = \"My Contextual Selection Hook\", SuppressCompletionBanner = true, NotifyKind = SafeExecutor.NotifyKindKind.None, WorkPerformed = false }, ct: CancellationToken.None); } catch (OperationCanceledException) { } catch (Exception) { /* Logged by SafeExecutor */ } } Source: csharp/src/Tools/Structural/SGT/Features/Commands/SgtContextualRibbonInjector.cs:94-126 Step 3: Inject UI into Contextual Tabs private void EnsureInjected(UIApplication uiapp) { var ribbon = ComponentManager.Ribbon; if (ribbon == null) return; var targetTab = TryGetContextualTab(ribbon); if (targetTab == null) return; var panel = EnsurePanel(targetTab); var btn = BuildButton(); btn.CommandHandler = new RibbonButtonCommand(OnButtonClick); panel.Source.Items.Add(btn); } Source: csharp/src/Tools/Structural/SGT/Features/Commands/SgtContextualRibbonInjector.cs:206-238 Hook Execution Order Registration Order Hooks are resolved in the order they were registered: AppHookModule registers ViewActivatedHookHandler (core) Tool modules register their IViewActivatedTask implementations Tool modules register IContextualRibbonInjector implementations Dispatch Order flowchart LR subgraph Startup[\"App Startup\"] A1[Attach Hook Host] A2[Initialize Contextual Injectors] A3[Subscribe ViewActivated] end subgraph Runtime[\"Runtime Events\"] R1[ViewActivated fires] R2[For each handler in order] R3[For each task in order] end subgraph Shutdown[\"App Shutdown\"] S1[Detach Hook Host] S2[Shutdown Contextual Injectors] S3[Unsubscribe events] end A1 --> A2 --> A3 A3 -.->|\"User navigates\"| R1 R1 --> R2 --> R3 R3 -.->|\"App closes\"| S1 S1 --> S2 --> S3 Priority Considerations Currently, hooks execute in registration order without explicit priority. If you need guaranteed ordering: Register in a specific order in DbtServiceBootstrapper Or coordinate within a single handler that manages multiple sub-tasks Common Patterns Auto-Update on View Change The most common pattern for tools like Elevation Tags: // 1. Define settings with IAutoUpdateSettings public class MySettings : IAutoUpdateSettings { public bool AutoUpdateEnabled { get; set; } = true; public bool HasWarning { get; set; } } // 2. Create task extending ViewActivatedTaskBase public class MyAutoUpdateTask : ViewActivatedTaskBase<MySettings> { protected override Task<bool> ShouldRunInternalAsync(...) { // Filter by view type return Task.FromResult(view.ViewType == ViewType.FloorPlan); } public override Task ExecuteAsync(...) { // Perform update logic } } // 3. Register in ToolModule services.AddSingleton<IViewActivatedTask>(...); Contextual Ribbon Button For tools that need UI when specific elements are selected: // 1. Implement IContextualRibbonInjector public class MyInjector : IContextualRibbonInjector { // Track subscribed state private bool _subscribed; // Track injected buttons for visibility control private readonly Dictionary<string, RibbonButton> _buttons = new(); // Evaluate selection and show/hide button private void OnSelectionChanged(...) { bool hasMyElements = EvaluateSelection(uiapp); ToggleButtons(visible: hasMyElements); } } // 2. Register hook registry.RegisterHook<IContextualRibbonInjector, MyInjector>(); Warning Integration Tasks can set warnings when they fail, which disables auto-update until resolved: // In SafeExecutor options OnErrorAsync = async _ => { foreach (var warningId in task.WarningIdsToSetOnFailure) await _warnings.SetWarningAsync(warningId, true, null, ct); } The warning IDs must be defined in the tool's settings pack and match entries in manifest.yml. Creating New Hook Types To add a new hook type (advanced): Step 1: Define the Interface // In DBTools.Core/Tools/ public interface IDocumentClosingHookHandler { Task OnDocumentClosingAsync( UIControlledApplication application, DocumentClosingEventArgs args, CancellationToken ct); } Step 2: Register as Supported in DbtHookHost private static readonly HashSet<Type> _supportedHookInterfaces = new(new[] { typeof(IViewActivatedHookHandler), typeof(IContextualRibbonInjector), typeof(IDocumentClosingHookHandler) // Add new type }); Step 3: Add Resolution and Subscription public void Attach(UIControlledApplication application) { // ... existing code ... var closingHandlers = ResolveHandlers<IDocumentClosingHookHandler>(); if (closingHandlers.Count > 0) application.DocumentClosing += OnDocumentClosing; _closingHandlers = closingHandlers; } private async void OnDocumentClosing(object? sender, DocumentClosingEventArgs args) { if (_closingHandlers == null || _closingHandlers.Count == 0) return; try { await _executor.RunAsync( async () => { foreach (var handler in _closingHandlers) await handler.OnDocumentClosingAsync(_application!, args, CancellationToken.None); }, _logger, notifier: null, opts: new SafeExecutor.SafeExecuteOptions { /* ... */ }, ct: CancellationToken.None); } catch { /* Suppress to protect Revit */ } } Step 4: Add Detach Logic public void Detach(UIControlledApplication application) { // ... existing code ... try { _application.DocumentClosing -= OnDocumentClosing; } catch (Exception ex) { _logger.LogWarning(ex, \"Failed to detach document-closing hook.\"); } _closingHandlers = null; } Performance Considerations Don't Block the UI Thread Hooks run in response to Revit events. Blocking causes UI freezes: // BAD - blocks UI public Task ExecuteAsync(...) { Thread.Sleep(5000); // Never do this! return Task.CompletedTask; } // GOOD - async work public async Task ExecuteAsync(...) { await SomeAsyncOperation(); } Use SafeExecutor Options Wisely For frequent hooks like view activation, suppress banners: new SafeExecutor.SafeExecuteOptions { SuppressCompletionBanner = true, NoBannerOnSuccess = true, NotifyKind = SafeExecutor.NotifyKindKind.Error, // Only show errors WorkPerformed = false // Don't log \"no work\" for frequent events } Filter Early with ShouldRunAsync Avoid expensive work when the hook shouldn't run: protected override Task<bool> ShouldRunInternalAsync(...) { // Quick checks first var view = uiapp.ActiveUIDocument?.Document?.ActiveView; if (view == null) return Task.FromResult(false); if (view.ViewType != ViewType.FloorPlan) return Task.FromResult(false); // Only then check more expensive conditions return Task.FromResult(true); } Batch Operations in Transactions When modifying elements, batch changes in a single transaction: public override Task ExecuteAsync(...) { using var tx = new Transaction(doc, \"Auto Update\"); tx.Start(); foreach (var element in elementsToUpdate) UpdateElement(element); tx.Commit(); return Task.CompletedTask; } Real Examples ElevationTags Auto-Update The Elevation Tags tool uses a view-activated task to update tag values when entering floor plans: public sealed class ElevationTagsViewActivatedTask : ViewActivatedTaskBase<ElevationTagsSettings> { public ElevationTagsViewActivatedTask( ISettingsProvider settings, IDbtLoggingHost loggingHost, ILogger<ElevationTagsViewActivatedTask> logger, IReadOnlyCollection<string> warningIds) : base(settings, logger, \"structural.elevation_tags.updater\", \"Elevation Tags\", warningIds) { _loggingHost = loggingHost; } protected override Task<bool> ShouldRunInternalAsync(...) { var view = uiapp.ActiveUIDocument?.Document?.ActiveView; return Task.FromResult( view?.ViewType == ViewType.FloorPlan || view?.ViewType == ViewType.CeilingPlan); } public override Task ExecuteAsync(...) { var updater = new ElevationTagsAutoUpdater(tx, doc, view, logger, settings); updater.Run(); return Task.CompletedTask; } } Source: csharp/src/Tools/Common/ElevationTags/Hooks/ElevationTagsViewActivatedTask.cs:20-66 SGT Contextual Ribbon The Super Girt Tool injects an \"Edit\" button into the contextual \"Modify | Structural Framing\" tab: public sealed class SgtContextualRibbonInjector : IContextualRibbonInjector { public Task InitializeAsync(UIControlledApplication application, CancellationToken ct) { return _gate.RunAsync(app => { app.SelectionChanged += OnSelectionChanged; _subscribed = true; EnsureInjected(app); EvaluateAndToggle(app); }, ct); } private void EvaluateAndToggle(UIApplication uiapp) { var (hasGirts, systemIds) = EvaluateSelection(uiapp); UpdateSystemIds(systemIds); ToggleButtons(hasGirts, hasGirts); } private void EnsureInjected(UIApplication uiapp) { var targetTab = TryGetContextualModifyStructuralTab(ribbon); var panel = EnsurePanel(targetTab); var btn = BuildButton(); panel.Source.Items.Add(btn); } } Source: csharp/src/Tools/Structural/SGT/Features/Commands/SgtContextualRibbonInjector.cs:24-238 AppHookModule Registration The core hook module that wires up view-activated handling: public sealed class AppHookModule : DbtToolModule { public override void RegisterServices(IServiceCollection services, DbtToolManifest manifest) { services.AddSingleton<ViewActivatedHookHandler>(); } public override void RegisterHooks(DbtToolRegistry registry, DbtToolManifest manifest) { registry.RegisterHook<IViewActivatedHookHandler, ViewActivatedHookHandler>(); } } Source: csharp/src/DBTools.App/Features/Hooks/AppHookModule.cs:7-22 Debugging Hooks Enable Debug Logging Hook handlers log at debug level. Enable in your development configuration: { \"Serilog\": { \"MinimumLevel\": { \"Override\": { \"DBTools.App.Features.Hooks\": \"Debug\" } } } } Common Issues Symptom Possible Cause Solution Hook never fires Not registered in RegisterHooks Verify RegisterHook<>() call Handler not resolved Service not registered Add AddSingleton<>() in RegisterServices UI thread deadlock Sync-waiting on async in hook Use async void for event handlers, never .Wait() Hook runs but no effect ShouldRunAsync returning false Check settings (AutoUpdateEnabled, HasWarning) Exception in hook Various Check logs; ISafeExecutor logs all errors See Also Creating a New Tool - Complete guide to building DBTools tools Architecture Overview - System architecture and component interactions Settings System - How tools integrate with the settings infrastructure"
  },
  "developer-guide/developing/modularity.html": {
    "href": "developer-guide/developing/modularity.html",
    "title": "Leveraging DBTools Modularity | DB Tools",
    "summary": "Leveraging DBTools Modularity DBTools is designed as a modular Revit add-in platform where tools share common infrastructure while maintaining clear boundaries. This guide explains how to leverage the shared services from DBTools.Core and DBTools.Themes to build tools that integrate seamlessly with the platform. Philosophy DBTools follows these modularity principles: Shared Infrastructure, Independent Tools - Core services are centralized; tools are self-contained Dependency Injection First - All services are resolved through DI, enabling testing and flexibility Contract-Driven - Interfaces define contracts; implementations can vary per context Error Handling at Boundaries - All entrypoints run inside ISafeExecutor Window-Scoped Theming - Each window owns its theme resources to avoid cross-add-in conflicts Source: csharp/src/DBTools.App/Bootstrap/DbtServiceBootstrapper.cs:69-130 Two-Tier DI Architecture DBTools uses a two-tier dependency injection model: Tier Lifetime Purpose Examples Singleton Application lifetime Infrastructure services ISafeExecutor, IAlertService, ISettingsProvider, DbtToolRegistry Scoped Per-command lifetime Revit context services ITransactionRunner, IRevitCallGate, IRevitRunScope Source: csharp/src/DBTools.App/Bootstrap/DbtServiceBootstrapper.cs:77-79 Shared Services from DBTools.Core ISafeExecutor The central error handling service. All tool entrypoints must execute within ISafeExecutor. public interface ISafeExecutor { Task RunAsync(Func<Task> action, ILogger logger, IErrorNotifier? notifier = null, CancellationToken ct = default); Task RunAsync(Func<Task> action, ILogger logger, IErrorNotifier? notifier, SafeExecutor.SafeExecuteOptions? opts, CancellationToken ct = default); } Source: csharp/src/DBTools.Core/Execution/ISafeExecutor.cs:6-16 What it provides: Correlation IDs for log tracing Execution timing Exception logging with full stack traces and inner exceptions User notification via banners Automatic debug mode activation on fatal errors Lifecycle hooks (OnSuccessAsync, OnCancelAsync, OnErrorAsync) Source: csharp/src/DBTools.Core/Execution/SafeExecutor.cs:12-467 Usage in a command: // Commands automatically use ISafeExecutor via DbtToolCommand base class public sealed class GmCommand : DbtToolCommand { protected override async Task RunAsync(IDbtToolContext context) { var exec = context.Resolve<ISafeExecutor>(); // For nested async operations that need error handling: await exec.RunAsync(async () => { // Your work here }, context.Logger, context.ErrorNotifier); } } Source: csharp/src/Tools/Common/GM/Features/GmCommand.cs:32-93 ITransactionRunner Unified API for executing Revit model modifications with automatic transaction management. public interface ITransactionRunner { Task RunAsync(string name, Action action, CancellationToken ct = default); Task<T> RunAsync<T>(string name, Func<T> action, CancellationToken ct = default); Task RunAsync(string name, Action<Document> action, CancellationToken ct = default); Task<T> RunAsync<T>(string name, Func<Document, T> action, CancellationToken ct = default); Task RunAsync(string name, Action<UIApplication, Document> action, CancellationToken ct = default); Task<T> RunAsync<T>(string name, Func<UIApplication, Document, T> action, CancellationToken ct = default); // Overloads with explicit Document parameter Task RunAsync(Document doc, string name, Action<Document> action, CancellationToken ct = default); Task<T> RunAsync<T>(Document doc, string name, Func<Document, T> action, CancellationToken ct = default); } Source: csharp/src/DBTools.Core/Revit/Transactions/ITransactionRunner.cs:6-53 Key behaviors: Auto-selects transaction type: SubTransaction if doc.IsModifiable, otherwise new Transaction Cross-document protection Failure handling with SilentFailuresPreprocessor Usage example: public class FoundationTypeOrganizer { private readonly ITransactionRunner _tx; public FoundationTypeOrganizer(ITransactionRunner tx, Document doc, ILogger logger) { _tx = tx; // ... } public async Task OrganizeAsync() { await _tx.RunAsync(\"Organize Foundation Types\", doc => { // Modify document - transaction is automatic }); } } Source: csharp/src/Tools/Structural/OrganizeFoundationTypes/Features/FoundationTypeOrganizer.cs:19-27 ITransactionGroupService Manages transaction groups for operations requiring multiple transactions to appear as a single undo item. public interface ITransactionGroupService { bool IsActive { get; } Task BeginAsync(string name, CancellationToken ct = default); Task FinalizeAsync(bool commit, CancellationToken ct = default); Task RunAsync(string name, bool commit, Func<Task> work, CancellationToken ct = default); } Source: csharp/src/DBTools.Core/Revit/Transactions/ITransactionGroupService.cs:3-14 Usage for batch operations: public class TdvService { private readonly ITransactionRunner _tx; private readonly ITransactionGroupService _group; public TdvService(IRevitCallGate gate, ITransactionRunner tx, ITransactionGroupService group, ILogger<TdvService> logger) { _tx = tx; _group = group; // ... } public async Task ApplyMultipleChangesAsync() { await _group.RunAsync(\"Batch Apply\", commit: true, async () => { // Multiple transactions appear as one undo item await _tx.RunAsync(\"Step 1\", doc => { /* ... */ }); await _tx.RunAsync(\"Step 2\", doc => { /* ... */ }); await _tx.RunAsync(\"Step 3\", doc => { /* ... */ }); }); } } Source: csharp/src/Tools/Common/TDV/Revit/Services/TdvService.cs:20-23 IAlertService Service for showing alert dialogs with various body types. public interface IAlertService { AlertResult Show(AlertRequest request); bool Confirm(string message, string title = \"DB Tools\"); T? SelectSingle<T>(IEnumerable<T> items, Func<T, string> displayFunc, string windowTitle, string header, string? message = null, AlertWindowOptions? options = null) where T : class; IReadOnlyList<T> SelectMultiple<T>(IEnumerable<T> items, Func<T, string> displayFunc, string windowTitle, string header, string? message = null, AlertWindowOptions? options = null) where T : class; } Source: csharp/src/DBTools.Core/UI/Alerts/Services/IAlertService.cs:5-26 Usage examples: // Simple confirmation var alerts = context.Resolve<IAlertService>(); if (alerts.Confirm(\"Delete 15 elements?\", \"Confirm Delete\")) { // Proceed } // Single selection var selectedLevel = alerts.SelectSingle( levels, level => level.Name, windowTitle: \"Select Level\", header: \"Target Level\", message: \"Choose the level to place elements on\"); // Multiple selection var selectedTypes = alerts.SelectMultiple( familyTypes, t => t.Name, windowTitle: \"Select Types\", header: \"Types to Process\"); Source: csharp/src/DBTools.Core/UI/Alerts/Services/AlertService.cs:51-183 ILogger DBTools uses Microsoft.Extensions.Logging with Serilog as the provider. // Resolve from DI var logger = context.Resolve<ILogger<MyService>>(); // Or use the context's logger var logger = context.Logger; // Structured logging logger.LogInformation(\"Processing {Count} elements in {Document}\", elements.Count, doc.Title); logger.LogWarning(\"[GM] Failed to compute DocumentKey: {Message}\", ex.Message); logger.LogError(ex, \"[{Command}] execution failed.\", GetType().Name); Source: csharp/src/DBTools.App/Bootstrap/DbtServiceBootstrapper.cs:381-386 Important: Always use structured logging with named placeholders, not string interpolation. IRevitRunScope Represents a single Revit run scope (command, modeless session, or test). Provides access to the current Revit context. public interface IRevitRunScope { UIApplication UIApplication { get; } IRevitCallGate CallGate { get; } ITransactionRunner TransactionRunner { get; } ITransactionGroupService TransactionGroupService { get; } UIDocument GetActiveUiDocument(); Document GetActiveDocument(); Document GetLockedDocument(Document expectedDocument, string? context = null); } Source: csharp/src/DBTools.Core/Revit/Execution/IRevitRunScope.cs:11-20 Run Scope Profiles: Profile Use Case Description InlineUi Modal commands, RevitTest Executes directly on Revit UI thread QueuedModeless Long-running/modeless tools Uses ExternalEvent/RevitTask Source: csharp/src/DBTools.Core/Revit/Execution/IRevitRunScope.cs:22-36 ISettingsProvider / IOptionsMonitor Type-safe settings access with persistence and hot-reload support. public interface ISettingsProvider { TSettings Get<TSettings>() where TSettings : class, new(); Task SaveAsync<TSettings>(string section, TSettings settings, CancellationToken ct = default) where TSettings : class; } Source: csharp/src/DBTools.Core/Settings/ISettingsProvider.cs:1-8 Usage: // Via ISettingsProvider (singleton) var settings = context.Resolve<ISettingsProvider>(); var gmSettings = settings.Get<GmSettings>(); // Via IOptionsMonitor (for reactive updates) var monitor = context.Resolve<IOptionsMonitor<GmSettings>>(); var currentSettings = monitor.CurrentValue; Source: csharp/src/DBTools.App/Bootstrap/DiAppRuntime.cs:78 Shared UI from DBTools.Themes BrushKeys All theme brushes are defined using ComponentResourceKey for reliable cross-template resolution: public static class BrushKeys { // Brand colors public static ComponentResourceKey Primary => new(typeof(BrushKeys), \"Brush.Primary\"); public static ComponentResourceKey Secondary => new(typeof(BrushKeys), \"Brush.Secondary\"); // Surface colors public static ComponentResourceKey Paper => new(typeof(BrushKeys), \"Brush.Paper\"); public static ComponentResourceKey Surface => new(typeof(BrushKeys), \"Brush.Surface\"); public static ComponentResourceKey CardSurface => new(typeof(BrushKeys), \"Brush.CardSurface\"); // Text colors (WCAG AA compliant) public static ComponentResourceKey Body => new(typeof(BrushKeys), \"Brush.Body\"); public static ComponentResourceKey TextSecondary => new(typeof(BrushKeys), \"Brush.TextSecondary\"); public static ComponentResourceKey TextMuted => new(typeof(BrushKeys), \"Brush.TextMuted\"); // Status colors public static ComponentResourceKey Success => new(typeof(BrushKeys), \"Brush.Success\"); public static ComponentResourceKey Warning => new(typeof(BrushKeys), \"Brush.Warning\"); public static ComponentResourceKey Error => new(typeof(BrushKeys), \"Brush.Error\"); // DataGrid specific public static ComponentResourceKey DataGridRowSelected => new(typeof(BrushKeys), \"Brush.DataGrid.RowSelected\"); public static ComponentResourceKey DataGridAccentStripe => new(typeof(BrushKeys), \"Brush.DataGrid.AccentStripe\"); // ... 130+ additional keys } Source: csharp/src/DBTools.Themes/BrushKeys.cs:9-139 Usage in XAML: <Window xmlns:theme=\"clr-namespace:DBTools.Themes;assembly=DBTools.Themes\"> <Border Background=\"{DynamicResource {x:Static theme:BrushKeys.Surface}}\"> <TextBlock Text=\"Hello\" Foreground=\"{DynamicResource {x:Static theme:BrushKeys.Body}}\"/> </Border> </Window> Design Tokens Standard spacing, sizing, and typography values for consistent layouts: <!-- Spacing --> <Thickness x:Key=\"Spacing4\">4</Thickness> <Thickness x:Key=\"Spacing8\">8</Thickness> <Thickness x:Key=\"Spacing16\">16</Thickness> <!-- Padding --> <Thickness x:Key=\"Pad8\">8</Thickness> <Thickness x:Key=\"Card.Padding\">16,12</Thickness> <!-- Corner radius --> <CornerRadius x:Key=\"Radius4\">4</CornerRadius> <CornerRadius x:Key=\"Radius8\">8</CornerRadius> <!-- Typography --> <sys:Double x:Key=\"FontSize.Body\">13</sys:Double> <sys:Double x:Key=\"FontSize.Title\">16</sys:Double> <sys:Double x:Key=\"FontSize.Header\">20</sys:Double> Source: csharp/src/DBTools.Themes/Themes/App.Tokens.xaml:5-72 Window Base Classes DbtWindowBase Standard modal window with automatic theme loading and progress overlay: public class DbtWindowBase : Window, IWindowWithOwnerProvider, IThemeOptOut { public DbtWindowBase() { DbtWindowInitHelper.Initialize(this, nameof(DbtWindowBase)); } public IWindowOwnerProvider? OwnerProvider { get; set; } public bool UseDefaultTheme { get; set; } } Source: csharp/src/DBTools.Core/UI/Windows/DbtWindowBase.cs:27-47 DbtRibbonWindowBase Ribbon window for tools with tab-based navigation: public class DbtRibbonWindowBase : RibbonWindow, IWindowWithOwnerProvider, IThemeOptOut { public DbtRibbonWindowBase() { DbtWindowInitHelper.Initialize(this, nameof(DbtRibbonWindowBase)); } } Source: csharp/src/DBTools.Core/UI/Windows/DbtRibbonWindowBase.cs:15-35 What window bases provide: Window-scoped theme loading (avoids cross-add-in conflicts) Revit window ownership binding Progress overlay integration UI error protection DBTools icon Source: csharp/src/DBTools.Core/UI/Windows/DbtWindowInitHelper.cs:44-78 DI Patterns Creating a Tool Module Every tool implements DbtToolModule to register its services: public sealed class GmToolModule : DbtToolModule { public override void RegisterServices(IServiceCollection services, DbtToolManifest manifest) { Guard.NotNull(services, nameof(services)); Guard.NotNull(manifest, nameof(manifest)); services.AddGmServices(); // Extension method for cleaner registration } } Source: csharp/src/Tools/Common/GM/GmToolModule.cs:10-18 DbtToolModule Base Class public abstract class DbtToolModule { /// <summary>Registers tool settings types (Options pattern).</summary> public virtual void RegisterSettings(IServiceCollection services, IConfiguration configuration, DbtToolManifest manifest) { } /// <summary>Registers services required by this tool module.</summary> public virtual void RegisterServices(IServiceCollection services, DbtToolManifest manifest) { } /// <summary>Registers settings pack definitions for the Settings UI.</summary> public virtual void RegisterSettingsPacks(IServiceCollection services, DbtToolManifest manifest) { } /// <summary>Registers hook handlers with the tool registry.</summary> public virtual void RegisterHooks(DbtToolRegistry registry, DbtToolManifest manifest) { } } Source: csharp/src/DBTools.Core/Tools/DbtToolModule.cs:9-49 Service Registration Patterns public static class GmServiceCollectionExtensions { public static IServiceCollection AddGm(this IServiceCollection services) { // === Pure/shared logic (scoped) === services.AddScoped<IProjectLifecycleService, ProjectLifecycleService>(); services.AddScoped<INamingSimilarityService, NamingSimilarityService>(); // === Services with complex initialization === services.AddScoped<IGmMappingService>(sp => { var logger = sp.GetRequiredService<ILogger<GmMappingService>>(); var usage = sp.GetRequiredService<IUsageIndexService>(); var tx = sp.GetRequiredService<ITransactionRunner>(); // ... resolve other dependencies return new GmMappingService(logger, usage, tx, writers); }); // === Revit infrastructure (scoped) === services.AddScoped<ICategoryService, CategoryService>(); services.AddScoped<IElementQuery, ElementQueryService>(); // === UI services === services.AddScoped<IReportWindowService, ReportWindowService>(); return services; } } Source: csharp/src/Tools/Common/GM/Shell/DI/Services.cs:28-108 Resolving Services in Commands protected override async Task RunAsync(IDbtToolContext context) { // Single service var alerts = context.Resolve<IAlertService>(); // Multiple services (tuple pattern) var (tx, groups, mapping, planner, lifecycle) = context.Resolve< ITransactionRunner, ITransactionGroupService, IGmMappingService, IGmPlanningService, IProjectLifecycleService>(); } Source: csharp/src/Tools/Common/GM/Features/GmCommand.cs:59-91 Best Practices 1. Always Use ISafeExecutor at Entrypoints // DO: Inherit from DbtToolCommand (uses ISafeExecutor internally) public sealed class MyCommand : DbtToolCommand { protected override async Task RunAsync(IDbtToolContext context) { // ISafeExecutor wraps this automatically } } // DON'T: Create IExternalCommand without error handling public class BadCommand : IExternalCommand { public Result Execute(...) { // No error handling - will crash Revit } } Source: csharp/src/DBTools.Core/Revit/Execution/DbtToolCommand.cs:35-126 2. Prefer Scoped Services for Revit-Dependent Code // DO: Scoped registration for services that need Revit context services.AddScoped<ICategoryService, CategoryService>(); services.AddScoped<IElementQuery, ElementQueryService>(); // DON'T: Singleton for services that capture Document references services.AddSingleton<IBadService, ServiceThatHoldsDocument>(); // Memory leak! 3. Use Transaction Services, Not Raw Transactions // DO: Use ITransactionRunner await _tx.RunAsync(\"Create Wall\", doc => { Wall.Create(doc, curve, levelId, false); }); // DON'T: Create raw Transaction objects using var tx = new Transaction(doc, \"Create Wall\"); tx.Start(); Wall.Create(doc, curve, levelId, false); tx.Commit(); // Manual error handling required 4. Reference Theme Brushes via BrushKeys <!-- DO: Use BrushKeys for reliable resolution --> <Border Background=\"{DynamicResource {x:Static theme:BrushKeys.Surface}}\"/> <!-- DON'T: Use string keys (fragile) --> <Border Background=\"{DynamicResource Brush.Surface}\"/> 5. Inherit from Window Base Classes // DO: Inherit from DbtWindowBase public partial class MyToolWindow : DbtWindowBase { // Theme, progress overlay, error protection all included } // DON'T: Use raw Window public partial class MyToolWindow : Window { // No theme, no error protection, no Revit ownership } Anti-Patterns to Avoid 1. Service Locator Pattern // DON'T: Use AppRuntime.Resolve outside of command constructors public class BadService { public void DoWork() { var alerts = AppRuntime.Resolve<IAlertService>(); // Hidden dependency } } // DO: Inject via constructor public class GoodService { private readonly IAlertService _alerts; public GoodService(IAlertService alerts) { _alerts = alerts; } } 2. Silent Failures // DON'T: Swallow exceptions try { DoWork(); } catch { /* silent failure */ } // DON'T: Return defaults pretending success catch (Exception) { return new List<Element>(); } // DO: Let ISafeExecutor handle errors await executor.RunAsync(async () => { DoWork(); // Exception propagates to error handling }, logger, notifier); 3. Capturing Document References // DON'T: Hold Document references in singleton services public class BadService { private readonly Document _doc; // Will become stale! public BadService(Document doc) => _doc = doc; } // DO: Accept Document per-call public class GoodService { public void DoWork(Document doc) { // Fresh reference each call } } 4. Raw Console/MessageBox Output // DON'T: Use Console or MessageBox Console.WriteLine(\"Debug info\"); MessageBox.Show(\"Error occurred\"); // DO: Use logging and IAlertService _logger.LogDebug(\"Debug info\"); _alerts.Show(new AlertRequest(\"Error\", new MessageBodyViewModel(\"Error occurred\"))); 5. Bypassing Theme System // DON'T: Use hard-coded colors <Border Background=\"#222228\"/> // DO: Use theme brushes <Border Background=\"{DynamicResource {x:Static theme:BrushKeys.Surface}}\"/> Related Documentation DBTools.Core Project - Complete Core API reference Theme System - Detailed theming documentation Architecture Overview - System-wide architecture Quick Reference Table Need Service Lifetime Error handling at entrypoints ISafeExecutor Singleton Model modifications ITransactionRunner Scoped Batch undo operations ITransactionGroupService Scoped User dialogs IAlertService Singleton Logging ILogger<T> Singleton Revit context IRevitRunScope Scoped Thread-safe API access IRevitCallGate Scoped Settings access ISettingsProvider Singleton Reactive settings IOptionsMonitor<T> Singleton"
  },
  "developer-guide/developing/new-tool-guide.html": {
    "href": "developer-guide/developing/new-tool-guide.html",
    "title": "Creating New Tools in DBTools | DB Tools",
    "summary": "Creating New Tools in DBTools This guide covers the complete process of creating a new tool for the DBTools Revit add-in platform. By the end, you'll understand the tool module system, manifest configuration, command implementation, and UI patterns. Overview DBTools uses a manifest-driven plugin architecture. Each tool: Lives in its own folder under csharp/src/Tools/ Declares metadata via manifest.yml Implements a DbtToolModule subclass for DI registration Provides one or more DbtToolCommand implementations Optionally includes WPF UI, settings, and hooks Tool Module Lifecycle stateDiagram-v2 [*] --> Discovered: Manifest scan at startup Discovered --> Instantiated: Reflection creates module Instantiated --> Registered: RegisterSettings()<br/>RegisterServices()<br/>RegisterHooks() Registered --> Active: Ribbon composed Active --> Active: Commands executed Active --> [*]: OnShutdown note right of Discovered DbtToolManifestLoader scans embedded manifest.yml files end note note right of Registered DI container configured, hooks attached end note Key architectural principle: Tool source files are file-linked into DBTools.App at build time. Individual tool .csproj files exist for IDE navigation and per-tool test projects, but the final DBTools.dll assembly contains all tool code compiled together. Source: csharp/src/DBTools.App/DBTools.App.csproj:61-78 Prerequisites Before creating a new tool: Ensure you can build the solution: bash csharp/build.sh Understand the target Revit versions (net48 for 2024, net8.0-windows for 2025+) Decide on a tool category: Common, Structural, Testing, or new category Choose a unique tool ID (e.g., DBTools.MyTool) Step 1: Directory Structure Create your tool folder under the appropriate category: csharp/src/Tools/ Common/ # General-purpose tools GM/ # Global Mapper (complex example) ElevationTags/ # Simple example Structural/ # Structural engineering tools SGT/ # Super Girt Tool (complex example) FramingJoins/ # Simple example Testing/ # Testing/debug tools Minimal Tool Structure csharp/src/Tools/<Category>/<ToolName>/ Assets/ my_tool.png # 32x32 icon for ribbon (required) my_tool_16.png # 16x16 small icon (optional) Features/ MyToolCommand.cs # IExternalCommand implementation manifest.yml # Tool metadata and ribbon config <ToolName>ToolModule.cs # DI registration DBTools.<ToolName>.csproj # Project file (for IDE/tests) Complex Tool Structure (with UI) csharp/src/Tools/<Category>/<ToolName>/ Assets/ *.png # Icons Bootstrap/ ServiceExtensions.cs # DI extension methods Features/ Commands/ MyToolCommand.cs Logic/ MyService.cs IMyService.cs Shell/ DI/ Services.cs # Detailed DI registrations DesignTime/ MyWindowDesignTimeViewModel.cs UI/ Views/ MyWindow.xaml MyWindow.xaml.cs ViewModels/ MyWindowViewModel.cs Shared/ Models/ Contracts/ Tests/ # Separate test project folder DBTools.<ToolName>.Tests.csproj Properties/ DesignTimeResources.xaml # For XAML designer manifest.yml <ToolName>ToolModule.cs DBTools.<ToolName>.csproj Source: Reference structure from csharp/src/Tools/Common/GM/ and csharp/src/Tools/Structural/SGT/ Step 2: Project File (.csproj) Create a project file for IDE support and test isolation. The project file is NOT used for the main build (files are linked into DBTools.App), but it enables: IntelliSense and navigation Per-tool test projects Design-time XAML preview Minimal Project File <Project Sdk=\"Microsoft.NET.Sdk\"> <PropertyGroup> <TargetFrameworks>$(DBT_RevitTargetFrameworks)</TargetFrameworks> <LangVersion>latest</LangVersion> <Nullable>enable</Nullable> <ImplicitUsings>enable</ImplicitUsings> <RootNamespace>DBTools.MyTool</RootNamespace> </PropertyGroup> <!-- Exclude Revit-dependent code during design-time builds --> <ItemGroup Condition=\"'$(DesignTimeBuild)'=='true' or '$(DBT_IsSandboxBuild)'=='true'\"> <Compile Remove=\"**\\Revit\\**\\*.cs\" /> </ItemGroup> <ItemGroup Condition=\"'$(DBT_IsSandboxBuild)'=='true'\"> <Compile Remove=\"Features\\MyToolCommand.cs\" /> <Compile Remove=\"MyToolToolModule.cs\" /> </ItemGroup> <ItemGroup> <Compile Remove=\"Tests\\**\\*.cs\" /> </ItemGroup> <PropertyGroup Condition=\"'$(TargetFramework)'=='net48'\"> <NoWarn>$(NoWarn);CS0618;MA0038;MA0051;MA0048;MA0016;MA0098;MA0004;CA1068;CA1707;CA1725</NoWarn> <PlatformTarget>x64</PlatformTarget> <Prefer32Bit>false</Prefer32Bit> </PropertyGroup> <PropertyGroup Condition=\"'$(TargetFramework)'=='net8.0-windows'\"> <NoWarn>$(NoWarn);CS0618;MA0038;MA0048;MA0016;MA0051;MA0098;MA0004;CA1707;CA1725;CA1068;MSB3277</NoWarn> <Nullable>enable</Nullable> <SupportedOSPlatformVersion>6.1</SupportedOSPlatformVersion> </PropertyGroup> <ItemGroup> <ProjectReference Include=\"..\\..\\..\\DBTools.Core\\DBTools.Core.csproj\" /> </ItemGroup> <!-- Embed icons --> <ItemGroup> <EmbeddedResource Include=\"Assets\\\\*.png\"> <Link>Resources\\\\Icons\\\\%(Filename)%(Extension)</Link> </EmbeddedResource> </ItemGroup> <!-- Required packages --> <ItemGroup> <PackageReference Include=\"ricaun.Revit.UI.Tasks\" /> </ItemGroup> <!-- Revit API references --> <ItemGroup Condition=\"'$(DesignTimeBuild)'!='true' and '$(DBT_IsSandboxBuild)'!='true' and '$(TargetFramework)'=='net48'\"> <Reference Include=\"RevitAPI\"> <HintPath>$(REVIT2024_DIR)\\RevitAPI.dll</HintPath> <Private>false</Private> </Reference> <Reference Include=\"RevitAPIUI\"> <HintPath>$(REVIT2024_DIR)\\RevitAPIUI.dll</HintPath> <Private>false</Private> </Reference> <Reference Include=\"WindowsBase\" /> </ItemGroup> <ItemGroup Condition=\"'$(DesignTimeBuild)'!='true' and '$(DBT_IsSandboxBuild)'!='true' and '$(TargetFramework)'=='net8.0-windows'\"> <Reference Include=\"RevitAPI\" Condition=\"'$(REVIT_NET8_DIR)'!='' and Exists('$(REVIT_NET8_DIR)\\\\RevitAPI.dll')\"> <HintPath>$(REVIT_NET8_DIR)\\RevitAPI.dll</HintPath> <Private>false</Private> </Reference> <Reference Include=\"RevitAPIUI\" Condition=\"'$(REVIT_NET8_DIR)'!='' and Exists('$(REVIT_NET8_DIR)\\\\RevitAPIUI.dll')\"> <HintPath>$(REVIT_NET8_DIR)\\RevitAPIUI.dll</HintPath> <Private>false</Private> </Reference> </ItemGroup> </Project> Source: csharp/src/Tools/Structural/FramingJoins/DBTools.Structural.FramingJoins.csproj:1-69 For Tools with WPF UI Add the following to your .csproj: <PropertyGroup> <UseWPF>true</UseWPF> </PropertyGroup> <!-- Additional packages for MVVM --> <ItemGroup> <PackageReference Include=\"CommunityToolkit.Mvvm\" /> </ItemGroup> <!-- Fluent Ribbon if using ribbon-based window --> <ItemGroup> <Reference Include=\"DBTools.Fluent.Ribbon\"> <HintPath>$(DBT_VendorArtifactsRoot)fluentribbon\\$(TargetFramework)\\DBTools.Fluent.Ribbon.dll</HintPath> <Private>true</Private> </Reference> <Reference Include=\"DBTools.ControlzEx\"> <HintPath>$(DBT_VendorArtifactsRoot)controlzex\\$(TargetFramework)\\DBTools.ControlzEx.dll</HintPath> <Private>true</Private> </Reference> </ItemGroup> <!-- Design-time resources --> <ItemGroup> <Page Update=\"Properties\\DesignTimeResources.xaml\"> <SubType>Designer</SubType> <Generator>MSBuild:Compile</Generator> <ContainsDesignTimeResources>true</ContainsDesignTimeResources> </Page> </ItemGroup> Source: csharp/src/Tools/Common/GM/DBTools.GM.csproj:1-94 Step 3: manifest.yml (Complete Schema) The manifest file declares your tool's metadata, ribbon configuration, and optional settings. Complete Schema Reference # Required: Unique tool identifier id: DBTools.MyTool # Required: Assembly name (without .dll) - always \"DBTools\" for main tools assembly: DBTools # Required: Fully-qualified type name of DbtToolModule subclass moduleType: DBTools.MyTool.MyToolToolModule # Required: Load order (lower = earlier). Use 0 unless you need ordering. order: 0 # Optional: Sandbox windows for design-time preview sandboxWindows: - id: DBTools.MyTool.Main displayName: \"My Tool\" group: \"Common\" # or \"Structural\", \"Testing\" windowType: \"DBTools.MyTool.Shell.UI.Views.MyToolWindow\" designTimeViewModelType: \"DBTools.MyTool.Shell.DesignTime.MyToolDesignTimeViewModel\" # Required: Tool configuration tool: # Optional: Settings configuration settings: configSection: Tools.MyTool # Section in settings.json # Optional: Settings packs for Settings window settingsPacks: - key: common.my_tool title: \"My Tool\" warnings: - id: core.my_tool.warning title: \"My Tool Disabled\" message: \"Tool is disabled due to a configuration issue.\" disableTools: - DBTools.MyToolCommand # Required: Ribbon button definitions ribbonTools: - internalName: DBTools.MyToolCommand commandType: DBTools.MyTool.Features.MyToolCommand availabilityType: DBTools.App.Tools.Availability.DbtDocumentAvailability runProfile: InlineUi displayText: \"My Tool\" iconBaseKey: my_tool tooltip: \"Launch My Tool\" controlKind: PushButton order: 50 Manifest Properties Reference Property Required Description id Yes Unique identifier (e.g., DBTools.MyTool) assembly Yes Assembly name without .dll (always DBTools) moduleType Yes Full type name of DbtToolModule subclass order Yes Load order (0 for most tools) sandboxWindows No Design-time preview windows tool.settings.configSection No settings.json section for Options pattern tool.settingsPacks No Settings window configuration tool.ribbonTools Yes At least one ribbon button definition Ribbon Tool Properties Property Required Description internalName Yes Unique button identifier commandType Yes Full type name of command class availabilityType No IExternalCommandAvailability implementation runProfile No InlineUi (default), BackgroundWork, etc. displayText Yes Button label (use \\n for line breaks) iconBaseKey Yes Icon filename without extension tooltip Yes Button tooltip text controlKind Yes PushButton, SplitButtonItem, PulldownButtonItem, StackedButtonItem splitGroup No Group name for split/pulldown/stacked buttons order Yes Button order within panel groupDisplayText No Header text for pulldown groups groupTooltip No Tooltip for pulldown header groupIconBaseKey No Icon for pulldown header Source: csharp/src/DBTools.Core/Tools/DbtToolManifest.cs:1-68 and csharp/src/DBTools.Core/Tools/DbtToolManifestLoader.cs:287-307 Example: Simple Tool id: DBTools.Structural.FramingJoins assembly: DBTools moduleType: DBTools.Structural.FramingJoins.FramingJoinsToolModule order: 0 tool: ribbonTools: - internalName: DBTools.AllowJoinSelected commandType: DBTools.Structural.FramingJoins.AllowJoinSelectedCommand availabilityType: DBTools.App.Tools.Availability.DbtStructuralFramingSelectionAvailability runProfile: InlineUi displayText: \"Allow Join\" iconBaseKey: allow_join tooltip: \"Allow structural framing joins for selected elements\" controlKind: SplitButtonItem splitGroup: framing_joins order: 0 - internalName: DBTools.DisallowJoinSelected commandType: DBTools.Structural.FramingJoins.DisallowJoinSelectedCommand availabilityType: DBTools.App.Tools.Availability.DbtStructuralFramingSelectionAvailability runProfile: InlineUi displayText: \"Disallow Join\" iconBaseKey: disallow_join tooltip: \"Disallow structural framing joins for selected elements\" controlKind: SplitButtonItem splitGroup: framing_joins order: 1 Source: csharp/src/Tools/Structural/FramingJoins/manifest.yml:1-27 Example: Complex Tool with UI id: DBTools.GM assembly: DBTools moduleType: DBTools.GM.GmToolModule order: 0 sandboxWindows: - id: DBTools.GM.Main displayName: \"Global Mapper\" group: \"Common\" windowType: \"DBTools.GM.Shell.UI.Views.GmWindow\" designTimeViewModelType: \"DBTools.GM.Shell.DesignTime.GmShellDesignTimeViewModel\" - id: DBTools.GM.MappingReport displayName: \"Global Mapper - Mapping Report\" group: \"Common\" windowType: \"DBTools.GM.Features.Mapping.UI.Views.GmMappingReportWindow\" designTimeViewModelType: \"DBTools.GM.Features.Mapping.DesignTime.GmMappingReportDesignTimeViewModel\" tool: ribbonTools: - internalName: DBTools.GM commandType: DBTools.GM.Features.GmCommand availabilityType: DBTools.App.Tools.Availability.DbtDocumentAvailability runProfile: InlineUi displayText: \"Global Mapper\" iconBaseKey: gm tooltip: \"Open Global Mapper\" controlKind: PushButton order: 30 Source: csharp/src/Tools/Common/GM/manifest.yml:1-27 Step 4: ToolModule Class The DbtToolModule subclass registers services with the DI container. Minimal Implementation For simple tools with no custom services: using DBTools.Core.Tools; namespace DBTools.Structural.FramingJoins; public sealed class FramingJoinsToolModule : DbtToolModule { } Source: csharp/src/Tools/Structural/FramingJoins/FramingJoinsToolModule.cs:1-8 With Service Registration using DBTools.Core.Tools; using DBTools.Core.Compat; using Microsoft.Extensions.DependencyInjection; namespace DBTools.MyTool; public sealed class MyToolToolModule : DbtToolModule { public override void RegisterServices(IServiceCollection services, DbtToolManifest manifest) { Guard.NotNull(services, nameof(services)); Guard.NotNull(manifest, nameof(manifest)); // Register tool-specific services services.AddScoped<IMyService, MyService>(); services.AddScoped<MyOtherService>(); } } Source: csharp/src/Tools/Common/GM/GmToolModule.cs:1-19 With Hooks using DBTools.Core.Tools; using DBTools.Core.Compat; using Microsoft.Extensions.DependencyInjection; namespace DBTools.SGT; public sealed class SgtToolModule : DbtToolModule { public override void RegisterServices(IServiceCollection services, DbtToolManifest manifest) { Guard.NotNull(services, nameof(services)); Guard.NotNull(manifest, nameof(manifest)); services.AddSgtServices(); services.AddSingleton<SgtContextualRibbonInjector, SgtContextualRibbonInjector>(); } public override void RegisterHooks(DbtToolRegistry registry, DbtToolManifest manifest) { Guard.NotNull(registry, nameof(registry)); Guard.NotNull(manifest, nameof(manifest)); // Register contextual ribbon hook registry.RegisterHook<IContextualRibbonInjector, SgtContextualRibbonInjector>(); } } Source: csharp/src/Tools/Structural/SGT/SgtToolModule.cs:1-27 DbtToolModule Virtual Methods Method Purpose RegisterSettings Register Options pattern settings types RegisterServices Register services for DI container RegisterSettingsPacks Register settings pack definitions RegisterHooks Register event hooks (ViewActivated, ContextualRibbon) Source: csharp/src/DBTools.Core/Tools/DbtToolModule.cs:1-50 Step 5: Command Implementation Commands implement DbtToolCommand (not IExternalCommand directly) to get automatic error handling, logging, and run scope management. Basic Command Structure using System; using System.Threading.Tasks; using Autodesk.Revit.Attributes; using DBTools.Core.Compat; using DBTools.Core.Revit.Execution; using Microsoft.Extensions.Logging; namespace DBTools.MyTool.Features; [Transaction(TransactionMode.Manual)] public sealed class MyToolCommand : DbtToolCommand { protected override async Task RunAsync(IDbtToolContext context) { Guard.EnsureNotNull(context, nameof(context)); var logger = context.Logger; var doc = context.Document; var uidoc = context.UIDocument; logger.LogDebug(\"[MyTool] Starting execution\"); // Your tool logic here await Task.CompletedTask.ConfigureAwait(false); } protected override SafeExecutor.SafeExecuteOptions CreateExecuteOptions( Autodesk.Revit.UI.ExternalCommandData commandData) { return new SafeExecutor.SafeExecuteOptions { Name = \"My Tool\", ShowCompletionToUser = true, SuppressCompletionBanner = false }; } } With Transaction [Transaction(TransactionMode.Manual)] public sealed class AllowJoinSelectedCommand : DbtToolCommand { protected override async Task RunAsync(IDbtToolContext context) { Guard.EnsureNotNull(context, nameof(context)); var uidoc = context.UIDocument; var doc = context.Document; var logger = context.Logger; // Get selection var selectedIds = uidoc.Selection.GetElementIds(); if (selectedIds == null || selectedIds.Count == 0) { throw new InvalidOperationException(\"Please select elements.\"); } // Create transaction runner var gate = new ModalInlineCallGate(context.UIApplication); var tx = new DBTools.Core.Revit.Transactions.CallGateTransactionRunner(gate); int modified = 0; await tx.RunAsync(doc, \"DB Tools - Allow Join\", d => { foreach (var id in selectedIds) { var elem = doc.GetElement(id) as FamilyInstance; if (elem == null) continue; StructuralFramingUtils.AllowJoinAtEnd(elem, 0); StructuralFramingUtils.AllowJoinAtEnd(elem, 1); modified++; } }).ConfigureAwait(false); logger.LogDebug(\"[AllowJoin] Modified {Count} elements.\", modified); // Show result var alerts = context.Resolve<IAlertService>(); _ = alerts.Show(new AlertRequest( \"Allow Join\", new MessageBodyViewModel($\"Allowed joins on {modified} element(s).\")) { Buttons = new[] { new AlertButtonSpec(\"ok\", \"OK\") { IsDefault = true } } }); } } Source: csharp/src/Tools/Structural/FramingJoins/Features/AllowJoinSelectedCommand.cs:1-89 IDbtToolContext Properties Property Description UIApplication Revit UIApplication UIDocument Active UIDocument Document Active Document Logger ILogger for the command Resolve<T>() Resolve service from DI Source: csharp/src/DBTools.Core/Revit/Execution/DbtToolCommand.cs:1-239 Step 6: UI Implementation (MVVM Pattern) For tools with UI, follow the MVVM pattern with DBTools conventions. Window Base Classes Class Use Case DbtWindowBase Modal dialogs DbtRibbonWindowBase Windows with Fluent Ribbon Source: csharp/src/DBTools.Core/UI/Windows/DbtWindowBase.cs:1-48 XAML Window Template <?xml version=\"1.0\" encoding=\"utf-8\"?> <core:DbtWindowBase x:Class=\"DBTools.MyTool.Shell.UI.Views.MyToolWindow\" xmlns=\"http://schemas.microsoft.com/winfx/2006/xaml/presentation\" xmlns:x=\"http://schemas.microsoft.com/winfx/2006/xaml\" xmlns:d=\"http://schemas.microsoft.com/expression/blend/2008\" xmlns:mc=\"http://schemas.openxmlformats.org/markup-compatibility/2006\" xmlns:core=\"clr-namespace:DBTools.Core.UI.Windows;assembly=DBTools.Core\" xmlns:theme=\"clr-namespace:DBTools.Themes;assembly=DBTools.Themes\" xmlns:dt=\"clr-namespace:DBTools.MyTool.Shell.DesignTime\" d:DataContext=\"{d:DesignInstance Type=dt:MyToolDesignTimeViewModel, IsDesignTimeCreatable=True}\" Title=\"My Tool\" Width=\"800\" Height=\"600\" MinWidth=\"600\" MinHeight=\"400\" ResizeMode=\"CanResize\" mc:Ignorable=\"d\"> <Window.Resources> <ResourceDictionary> <ResourceDictionary.MergedDictionaries> <ResourceDictionary Source=\"pack://application:,,,/DBTools.Themes;component/Themes/App.Theme.xaml\" /> </ResourceDictionary.MergedDictionaries> </ResourceDictionary> </Window.Resources> <Grid> <!-- Your UI content --> </Grid> </core:DbtWindowBase> Source: csharp/src/Tools/Common/GM/Shell/UI/Views/GmWindow.xaml:1-26 ViewModel Pattern Use CommunityToolkit.Mvvm for MVVM implementation: using CommunityToolkit.Mvvm.ComponentModel; using CommunityToolkit.Mvvm.Input; namespace DBTools.MyTool.Shell.UI.ViewModels; public partial class MyToolWindowViewModel : ObservableObject { [ObservableProperty] private string _searchText = string.Empty; [ObservableProperty] private bool _isBusy; [RelayCommand] private async Task ExecuteAsync() { IsBusy = true; try { // Do work } finally { IsBusy = false; } } } Design-Time ViewModel Create a design-time ViewModel for XAML preview: using System.Windows.Input; using DBTools.Core.UI; namespace DBTools.MyTool.Shell.DesignTime; /// <summary> /// Design-time ViewModel for XAML Designer support. /// DO NOT instantiate at runtime. /// </summary> [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)] public sealed class MyToolDesignTimeViewModel { // Commands - use DesignTimeRelayCommand for all public ICommand ExecuteCommand => DesignTimeRelayCommand.Instance; public ICommand CloseCommand => DesignTimeRelayCommand.Instance; // Properties with sample data public string SearchText { get; set; } = \"Sample search\"; public bool IsBusy => false; public MyToolDesignTimeViewModel() { // Initialize sample data for designer preview } } Source: csharp/src/Tools/Common/GM/Shell/DesignTime/GmShellDesignTimeViewModel.cs:1-250 Step 7: Settings (Optional) Defining Settings Create a settings class: namespace DBTools.MyTool.Settings; public sealed class MyToolSettings { public bool EnableFeatureX { get; set; } = true; public int Threshold { get; set; } = 50; } Registering Settings In your ToolModule: public override void RegisterSettings( IServiceCollection services, IConfiguration configuration, DbtToolManifest manifest) { Guard.NotNull(services, nameof(services)); Guard.NotNull(configuration, nameof(configuration)); Guard.NotNull(manifest, nameof(manifest)); var section = manifest.Tool?.Settings?.ConfigSection ?? \"Tools.MyTool\"; services.Configure<MyToolSettings>(configuration.GetSection(section)); } Using Settings public sealed class MyService { private readonly MyToolSettings _settings; public MyService(IOptionsMonitor<MyToolSettings> options) { _settings = options.CurrentValue; } } settings.json Structure { \"Tools\": { \"MyTool\": { \"EnableFeatureX\": true, \"Threshold\": 75 } } } Step 8: Hooks (Optional) Available Hook Interfaces Interface Purpose IViewActivatedHookHandler React to view changes IContextualRibbonInjector Add contextual ribbon tabs Source: csharp/src/DBTools.Core/Tools/DbtHookHost.cs:14-23 ViewActivated Hook using DBTools.Core.Tools; using Autodesk.Revit.UI; using Autodesk.Revit.UI.Events; namespace DBTools.MyTool.Features.Hooks; public sealed class MyViewActivatedHandler : IViewActivatedHookHandler { public Task OnViewActivatedAsync( UIControlledApplication application, ViewActivatedEventArgs args, CancellationToken ct) { // React to view changes return Task.CompletedTask; } } Register in your ToolModule: public override void RegisterHooks(DbtToolRegistry registry, DbtToolManifest manifest) { registry.RegisterHook<IViewActivatedHookHandler, MyViewActivatedHandler>(); } public override void RegisterServices(IServiceCollection services, DbtToolManifest manifest) { services.AddSingleton<MyViewActivatedHandler>(); } Step 9: Availability Types Availability types control when ribbon buttons are enabled. Built-in Availability Types Type Description DbtDocumentAvailability Requires an open document DbtActiveViewAvailability Requires an active view DbtSelectionAvailability Requires selected elements Source: csharp/src/DBTools.App/Tools/Availability/DbtDocumentAvailability.cs:1-17 Custom Availability using Autodesk.Revit.DB; using Autodesk.Revit.UI; namespace DBTools.App.Tools.Availability; public sealed class MyCustomAvailability : IExternalCommandAvailability { public bool IsCommandAvailable(UIApplication applicationData, CategorySet selectedCategories) { var doc = applicationData?.ActiveUIDocument?.Document; if (doc == null) return false; // Custom logic return selectedCategories?.Contains(Category.GetCategory(doc, BuiltInCategory.OST_Walls)) == true; } } Step 10: File Linking (How It Works) Tool source files are compiled into DBTools.dll via file linking in DBTools.App.csproj: <!-- Tool Source Files --> <ItemGroup Label=\"Tool Source Files\"> <Compile Include=\"..\\Tools\\**\\*.cs\" Exclude=\"..\\Tools\\**\\Tests\\**\\*.cs;..\\Tools\\**\\obj\\**\\*.cs\" Link=\"Tools\\%(RecursiveDir)%(Filename)%(Extension)\" /> </ItemGroup> <!-- Tool XAML Files --> <ItemGroup Label=\"Tool XAML Files\"> <Page Include=\"..\\Tools\\**\\*.xaml\" Exclude=\"..\\Tools\\**\\obj\\**\\*.xaml;..\\Tools\\**\\Properties\\DesignTimeResources.xaml\" Link=\"Tools\\%(RecursiveDir)%(Filename)%(Extension)\" /> </ItemGroup> <!-- Tool Icons --> <ItemGroup Label=\"Tool Embedded Assets\"> <EmbeddedResource Include=\"..\\Tools\\**\\Assets\\*.png\" Link=\"Resources\\Icons\\%(RecursiveDir)%(Filename)%(Extension)\" /> </ItemGroup> <!-- Tool Manifests --> <ItemGroup> <EmbeddedResource Include=\"..\\Tools\\**\\manifest.yml\" LogicalName=\"DBTools.ToolManifests.%(RecursiveDir)%(Filename)%(Extension)\" /> </ItemGroup> Source: csharp/src/DBTools.App/DBTools.App.csproj:61-78, 218-222 Step 11: Testing Setup Test Project Structure csharp/src/Tools/<Category>/<ToolName>/Tests/ DBTools.<ToolName>.Tests.csproj MyToolCommandTests.cs MyServiceTests.cs Test Project File <Project Sdk=\"Microsoft.NET.Sdk\"> <PropertyGroup> <TargetFramework>net8.0-windows</TargetFramework> <IsPackable>false</IsPackable> <Nullable>enable</Nullable> <ImplicitUsings>enable</ImplicitUsings> </PropertyGroup> <ItemGroup> <PackageReference Include=\"Microsoft.NET.Test.Sdk\" /> <PackageReference Include=\"xunit\" /> <PackageReference Include=\"xunit.runner.visualstudio\" /> <PackageReference Include=\"NSubstitute\" /> </ItemGroup> <ItemGroup> <ProjectReference Include=\"..\\..\\..\\..\\DBTools.App\\DBTools.App.csproj\" /> <ProjectReference Include=\"..\\..\\..\\..\\testing\\TestSupport\\DBTools.TestSupport.csproj\" /> </ItemGroup> </Project> Running Tests # Run all tests for a tool bash csharp/invoke-revit-tests.sh --smart --tool MyTool -y 2025 # Run specific test bash csharp/invoke-revit-tests.sh --smart -f \"FullyQualifiedName~MyTestName\" Common Patterns and Best Practices 1. Service Extension Pattern Centralize DI registration in an extension method: // Bootstrap/MyToolServiceExtensions.cs namespace DBTools.MyTool.Bootstrap; public static class MyToolServiceExtensions { public static IServiceCollection AddMyToolServices(this IServiceCollection services) { Guard.NotNull(services, nameof(services)); services.AddScoped<IMyService, MyService>(); services.AddScoped<MyOtherService>(); return services; } } Then in ToolModule: services.AddMyToolServices(); Source: csharp/src/Tools/Common/GM/Bootstrap/GmServiceExtensions.cs:1-16 2. Error Handling Never swallow exceptions. Use ISafeExecutor for top-level error handling (provided by DbtToolCommand): // DON'T do this: try { DoWork(); } catch { } // Silent failure // DO this: // Exceptions propagate to DbtToolCommand's ISafeExecutor DoWork(); // Let exceptions propagate 3. Logging Use the injected logger, not Console.WriteLine: var logger = context.Logger; logger.LogDebug(\"[MyTool] Processing {Count} elements\", count); logger.LogWarning(\"[MyTool] Skipped invalid element {Id}\", elementId); logger.LogError(ex, \"[MyTool] Failed to process\"); 4. Transactions Always name transactions descriptively: await tx.RunAsync(doc, \"DB Tools - My Tool Operation\", d => { // Modifications here }).ConfigureAwait(false); 5. Icon Naming Main icon: my_tool.png (32x32) Small icon: my_tool_16.png (16x16, optional) Match the iconBaseKey in manifest (without extension) 6. Namespace Conventions DBTools.<ToolName> # Root namespace DBTools.<ToolName>.Bootstrap # DI extensions DBTools.<ToolName>.Features # Commands and feature logic DBTools.<ToolName>.Features.Commands # Revit commands DBTools.<ToolName>.Features.Logic # Business logic DBTools.<ToolName>.Shell # Application shell DBTools.<ToolName>.Shell.DI # Detailed DI registrations DBTools.<ToolName>.Shell.UI # Views and ViewModels DBTools.<ToolName>.Shell.DesignTime # Design-time ViewModels DBTools.<ToolName>.Shared # Shared types/contracts Checklist: New Tool Completion [ ] Created directory structure under csharp/src/Tools/<Category>/<ToolName>/ [ ] Added manifest.yml with unique id and valid ribbonTools [ ] Created <ToolName>ToolModule.cs extending DbtToolModule [ ] Implemented command(s) extending DbtToolCommand [ ] Added icon(s) in Assets/ folder [ ] Created .csproj file for IDE support [ ] Build passes: bash csharp/build.sh [ ] Tool appears in Revit ribbon [ ] Command executes successfully [ ] (Optional) Created test project [ ] (Optional) Added UI with design-time preview Cross-References Architecture Overview DI Container Guide UI Theming Guide Testing Guide"
  },
  "developer-guide/developing/sandbox-integration.html": {
    "href": "developer-guide/developing/sandbox-integration.html",
    "title": "Sandbox Integration Guide | DB Tools",
    "summary": "Sandbox Integration Guide This guide covers integrating DBTools tool windows with the Sandbox system for design-time previews and automated UI validation. Overview The Sandbox is a standalone WPF application that validates tool UI without requiring Revit. It serves two critical purposes: Interactive Mode - Launch and preview tool windows during development Headless Mode - Automated validation in CI pipelines (ValidateDist target) Why Validation Matters UI defects that slip past development often surface only when loaded in Revit: XAML binding errors that fail silently Theme resource resolution failures (ghost buttons, missing styles) ILRepack merge issues causing type resolution failures Design-time ViewModel instantiation crashes The Sandbox catches these issues before deployment by: Loading the actual dist artifacts (post-merge assemblies) Instantiating windows with design-time ViewModels Forcing full layout passes to surface XAML errors Monitoring WPF binding errors that normally fail silently Source: csharp/src/DBTools.Sandbox/Validation/DistValidator.cs:73-118 Sandbox Architecture flowchart TB subgraph Build[\"Build Pipeline\"] NUKE[NUKE Build] BuildSandbox[BuildSandbox Target] ValidateDist[ValidateDist Target] end subgraph Sandbox[\"DBTools.Sandbox.exe\"] App[App.xaml.cs] DistValidator[DistValidator] ToolWindowValidator[ToolWindowValidator] ManifestValidator[ManifestValidator] MergeValidator[MergeValidator] BindingErrorListener[BindingErrorListener] WindowGhostValidator[WindowGhostValidator] end subgraph Dist[\"Dist Artifacts\"] DBToolsDll[DBTools.dll] Manifests[Embedded Manifests] ToolAssemblies[Tool Types] end subgraph Core[\"DBTools.Core\"] SandboxMode[SandboxMode] DbtSandboxCatalog[DbtSandboxCatalog] DbtToolManifestLoader[DbtToolManifestLoader] end NUKE --> BuildSandbox BuildSandbox --> ValidateDist ValidateDist --> |--headless| App App --> |Run| DistValidator DistValidator --> MergeValidator DistValidator --> ManifestValidator DistValidator --> ToolWindowValidator ToolWindowValidator --> DbtSandboxCatalog DbtSandboxCatalog --> Manifests DistValidator --> BindingErrorListener ToolWindowValidator --> WindowGhostValidator DistValidator --> |Activate| SandboxMode DBToolsDll --> ToolAssemblies ToolAssemblies --> |Instantiate| WindowGhostValidator Key Components Component Purpose DistValidator Orchestrates full validation pipeline ToolWindowValidator Instantiates and validates each tool window ManifestValidator Validates manifest.yml entries and command types MergeValidator Verifies ILRepack merge (net48) or embedded payload (net8) WindowGhostValidator Forces layout passes to surface XAML errors BindingErrorListener Captures silent WPF binding failures SandboxMode Signals to tools they're running without Revit DbtSandboxCatalog Discovers sandbox window specs from manifests Registering Sandbox Windows Tools register their windows for sandbox validation in manifest.yml: manifest.yml Schema id: DBTools.MyTool assembly: DBTools moduleType: DBTools.MyTool.MyToolModule order: 0 sandboxWindows: - id: DBTools.MyTool.Main displayName: \"My Tool\" group: \"Common\" windowType: \"DBTools.MyTool.UI.Views.MyToolWindow\" designTimeViewModelType: \"DBTools.MyTool.DesignTime.MyToolDesignTimeViewModel\" Required Fields Field Description id Unique identifier (must be globally unique across all tools) displayName Human-readable name shown in sandbox launcher group Category for grouping (e.g., \"Common\", \"Structural\") windowType Fully-qualified Window class name designTimeViewModelType Fully-qualified design-time ViewModel class name Optional Fields Field Description assembly Assembly name override (defaults to manifest's assembly) Source: csharp/src/DBTools.Core/Tools/DbtSandboxCatalog.cs:10-59 Example: GM Manifest # csharp/src/Tools/Common/GM/manifest.yml id: DBTools.GM assembly: DBTools moduleType: DBTools.GM.GmToolModule order: 0 sandboxWindows: - id: DBTools.GM.Main displayName: \"Global Mapper\" group: \"Common\" windowType: \"DBTools.GM.Shell.UI.Views.GmWindow\" designTimeViewModelType: \"DBTools.GM.Shell.DesignTime.GmShellDesignTimeViewModel\" - id: DBTools.GM.MappingReport displayName: \"Global Mapper - Mapping Report\" group: \"Common\" windowType: \"DBTools.GM.Features.Mapping.UI.Views.GmMappingReportWindow\" designTimeViewModelType: \"DBTools.GM.Features.Mapping.DesignTime.GmMappingReportDesignTimeViewModel\" Source: csharp/src/Tools/Common/GM/manifest.yml:1-15 Example: SGT Manifest # csharp/src/Tools/Structural/SGT/manifest.yml id: DBTools.SGT assembly: DBTools moduleType: DBTools.SGT.SgtToolModule order: 0 sandboxWindows: - id: DBTools.SGT.Main displayName: \"Super Girt Tool\" group: \"Structural\" windowType: \"DBTools.SGT.Shell.UI.Views.SgtWindow\" designTimeViewModelType: \"DBTools.SGT.Shell.DesignTime.SgtWindowDesignTimeViewModel\" Source: csharp/src/Tools/Structural/SGT/manifest.yml:1-10 Design-Time ViewModels Design-time ViewModels provide mock data for sandbox/designer rendering without Revit dependencies. Requirements Parameterless Constructor - Must be instantiable without DI No Revit API Calls - All data must be mocked Same Interface as Runtime ViewModel - XAML bindings must resolve Sample Data - Populate collections with representative test data Pattern namespace DBTools.MyTool.DesignTime; /// <summary> /// Design-time ViewModel for MyToolWindow XAML Designer support. /// DO NOT instantiate at runtime. /// </summary> [EditorBrowsable(EditorBrowsableState.Never)] public sealed class MyToolDesignTimeViewModel { // Commands - use DesignTimeRelayCommand for all commands public ICommand ExecuteCommand => DesignTimeRelayCommand.Instance; public ICommand CloseCommand => DesignTimeRelayCommand.Instance; // Properties - provide reasonable defaults public bool IsBusy => false; public string Status => \"Ready\"; // Collections - populate with sample data public ObservableCollection<ItemRow> Items { get; } = new(); public MyToolDesignTimeViewModel() { // Add sample data for designer preview Items.Add(new ItemRow { Name = \"Sample Item 1\", Value = 42 }); Items.Add(new ItemRow { Name = \"Sample Item 2\", Value = 100 }); } } Source: csharp/src/Tools/Common/GM/Shell/DesignTime/GmShellDesignTimeViewModel.cs:19-246 Using DesignTimeRelayCommand All commands should use the shared DesignTimeRelayCommand.Instance: public ICommand ScanCommand => DesignTimeRelayCommand.Instance; public ICommand ApplyCommand => DesignTimeRelayCommand.Instance; This provides a no-op command that satisfies bindings without runtime behavior. Analyzer Suppressions Design-time ViewModels typically need these suppressions: #pragma warning disable CA1822 // Instance members for XAML binding #pragma warning disable MA0041 // Design-time uses instance bindings #pragma warning disable CA1861 // Array allocations acceptable in design-time SandboxMode Detection Tools detect sandbox mode to skip Revit-dependent initialization: Checking SandboxMode using DBTools.Core.Compat; public partial class MyToolWindow : DbtRibbonWindowBase { public MyToolWindow() { InitializeComponent(); if (DesignerProperties.GetIsInDesignMode(this)) return; // Skip Revit initialization in sandbox if (SandboxMode.IsActive) { DataContext = new MyToolDesignTimeViewModel(); return; } // Normal runtime initialization with DI } } Source: csharp/src/Tools/Common/GM/Shell/UI/Views/GmWindow.xaml.cs:37-48 SandboxMode API namespace DBTools.Core.Compat; public static class SandboxMode { /// <summary> /// Returns true if running in the sandbox executable (no Revit API available). /// </summary> public static bool IsActive { get; } /// <summary> /// Called once at sandbox app startup to enable sandbox mode. /// </summary> public static void Activate(); } Source: csharp/src/DBTools.Core/Compat/SandboxMode.cs:1-23 Common Uses Location Purpose Window constructors Use design-time ViewModel Preview renderers Skip GPU/DirectX initialization Service calls Return mock data Logging initialization Use null logger Validation Checks DistValidator Pipeline The DistValidator runs these checks in sequence: flowchart LR A[Dist Layout] --> B[Assembly Resolver] B --> C[Embedded Resolver] C --> D[Merge/Payload Validation] D --> E[Addin Entrypoint] E --> F[SandboxMode Activation] F --> G[Theme Validation] G --> H[Core Windows] H --> I[Manifest Validation] I --> J[Tool Windows] J --> K[Binding Error Check] Source: csharp/src/DBTools.Sandbox/Validation/DistValidator.cs:73-117 1. Dist Layout Validation Verifies required files exist: var required = new[] { \"DBTools.Loader.dll\", \"DBTools.dll\", \"DBTools.Themes.dll\", \"DBTools.HandyControl.dll\", \"DBTools.ControlzEx.dll\", \"DBTools.Fluent.Ribbon.dll\" }; 2. Merge/Embedded Payload Validation Net48 (ILRepack): Verifies types from merged assemblies exist inside DBTools.dll Checks that merged assemblies don't exist as separate files Validates internalization exclusions (required public types) Net8 (Embedded Payload): Verifies DBTools.EmbeddedAssemblies.DBTools.Core.dll resource exists Checks resource is loadable and has reasonable size (>1KB) Source: csharp/src/DBTools.Sandbox/Validation/MergeValidator.cs:17-221 3. Manifest Validation For each manifest.yml: Validates moduleType derives from DbtToolModule Validates ribbon command types implement IExternalCommand Validates availability types implement IExternalCommandAvailability Source: csharp/src/DBTools.Sandbox/Validation/ManifestValidator.cs:10-178 4. Tool Window Validation For each sandbox window spec: Load the tool assembly Resolve window type and ViewModel type Instantiate both with parameterless constructors Set DataContext on window Run WindowGhostValidator (layout passes) Validate tab interactions (cycle through tabs) Validate DataGrid row expansion Validate preview mode switching Source: csharp/src/DBTools.Sandbox/Validation/ToolWindowValidator.cs:13-412 5. WindowGhostValidator Forces layout passes to surface XAML errors: // Pass 1: Fixed size (800x600) - typical window size ValidateLayoutPass(window, new Size(800, 600), \"fixed size\"); // Pass 2: Infinite size - catches controls that crash on \"desired\" size ValidateLayoutPass(window, new Size(double.PositiveInfinity, double.PositiveInfinity), \"infinite size\"); Source: csharp/src/DBTools.Sandbox/Validation/WindowGhostValidator.cs:9-129 6. BindingErrorListener Captures WPF data binding errors that normally fail silently: using var bindingListener = BindingErrorListener.Install(); // ... validation code ... bindingListener.ThrowIfErrors(\"full validation\"); Source: csharp/src/DBTools.Sandbox/Validation/BindingErrorListener.cs:8-118 Running Sandbox Locally Interactive Mode Launch the sandbox for manual window exploration: # Build dist first bash csharp/build.sh BuildAll # Run sandbox (auto-detects dist) csharp/.artifacts/sandbox/Release/net8.0-windows/DBTools.Sandbox.exe # Or specify dist directory DBTools.Sandbox.exe --dist-dir \"C:/path/to/dist/Release/2026\" The sandbox launcher shows all registered windows grouped by category. Headless Mode (Manual) Run validation without UI: # Validate with all checks DBTools.Sandbox.exe --headless --dist-dir \"path/to/dist/Release/2026\" # Skip tool validation (faster) DBTools.Sandbox.exe --headless --dist-dir \"path/to/dist/Release/2026\" --skip-validate-tools # Skip manifest validation DBTools.Sandbox.exe --headless --dist-dir \"path/to/dist/Release/2026\" --skip-validate-manifests Command-Line Options Option Description --headless Run validation without UI (exit code 0=pass, 1=fail) --dist-dir <path> Path to dist folder (defaults to build output) --revit-dir <path> Path to Revit installation (for RevitAPI resolution) --validate-manifests Enable manifest validation (default: true) --skip-validate-manifests Disable manifest validation --validate-tools Enable tool window validation (default: true) --skip-validate-tools Disable tool window validation --screenshot Screenshot mode for documentation --list List available tools (screenshot mode) --tool-id <id> Specific tool to screenshot --output <path> Screenshot output path Source: csharp/src/DBTools.Sandbox/Validation/SandboxValidateOptions.cs:7-113 Headless Mode (CI) The sandbox runs in CI as part of the ValidateDist NUKE target. Build Pipeline Integration # Full build with validation bash csharp/build.sh BuildAll # Build without validation (faster local dev) bash csharp/build.sh BuildOnly # Run validation separately after build bash csharp/build.sh ValidateDist ValidateDist Target The NUKE build invokes the sandbox for each Revit year: Target ValidateDist => _ => _ .Description(\"Validate dist outputs via DBTools.Sandbox headless runner\") .DependsOn(BuildSandbox) .After(PromoteToDist) .OnlyWhenDynamic(() => Configuration == \"Release\") .Executes(() => { foreach (var year in RevitYears) { var distDir = ArtifactsDir / \"dist\" / Configuration / year; var validatorExe = ArtifactsDir / \"sandbox\" / Configuration / tfm / \"DBTools.Sandbox.exe\"; var args = new[] { \"--headless\", \"--dist-dir\", distDir, \"--validate-manifests\", \"--validate-tools\" }; // Execute with 3-minute timeout Process.Start(validatorExe, args); } }); Source: csharp/build/BuildTargets.cs:1150-1258 TFM Selection The validator executable matches the Revit year's target framework: 2024: net48 validator 2025+: net8.0-windows validator Troubleshooting Common Failures \"Sandbox window type not found\" Cause: WindowType in manifest doesn't match actual class name Fix: Verify fully-qualified type name in manifest.yml matches code: windowType: \"DBTools.MyTool.UI.Views.MyToolWindow\" # Exact match required \"Design-time ViewModel must have parameterless constructor\" Cause: ViewModel constructor requires DI parameters Fix: Create a dedicated design-time ViewModel: public MyToolDesignTimeViewModel() // No parameters { // Initialize with mock data } \"WPF binding errors detected\" Cause: XAML bindings referencing properties that don't exist on design-time ViewModel Fix: Ensure design-time ViewModel exposes all bound properties: // XAML: {Binding Items} public ObservableCollection<Item> Items { get; } = new(); // XAML: {Binding SelectedItem} public Item? SelectedItem { get; set; } \"ILRepack merge validation failed\" Cause: Assembly merge configuration changed, expected types missing from DBTools.dll Fix: Review ILRepack configuration in csharp/src/DBTools.App/DBTools.App.csproj: <ILRepackOutput>$(ArtifactsDir)dist\\...</ILRepackOutput> <ILRepackInputAssemblies>...</ILRepackInputAssemblies> \"Window layout validation failed (infinite size)\" Cause: Control doesn't handle infinite available size during measure pass Fix: Add size constraints or check for infinite values: protected override Size MeasureOverride(Size availableSize) { var width = double.IsInfinity(availableSize.Width) ? 800 : availableSize.Width; var height = double.IsInfinity(availableSize.Height) ? 600 : availableSize.Height; // ... } \"SandboxMode activation failed\" Cause: DBTools.Core not loaded correctly from dist Fix: Ensure dist build completed successfully: bash csharp/build.sh Clean bash csharp/build.sh BuildAll Debug Tips Run sandbox interactively to see actual UI rendering Check sandbox logs in %LOCALAPPDATA%\\DBTools\\Logs\\Sandbox-*.log Enable verbose output by running from command line Test single window by removing others from manifest temporarily Real Examples GM: Multiple Windows GM registers multiple windows for different features: sandboxWindows: - id: DBTools.GM.Main displayName: \"Global Mapper\" group: \"Common\" windowType: \"DBTools.GM.Shell.UI.Views.GmWindow\" designTimeViewModelType: \"DBTools.GM.Shell.DesignTime.GmShellDesignTimeViewModel\" - id: DBTools.GM.MappingReport displayName: \"Global Mapper - Mapping Report\" group: \"Common\" windowType: \"DBTools.GM.Features.Mapping.UI.Views.GmMappingReportWindow\" designTimeViewModelType: \"DBTools.GM.Features.Mapping.DesignTime.GmMappingReportDesignTimeViewModel\" The design-time ViewModel populates extensive sample data: public GmShellDesignTimeViewModel() { // Families tab with expanded row var expandedFamily = new MatchingRow(12345, \"W10x33 (Expanded)\", hasDeepScan: true) { IsExpanded = true, CanExpandDetails = true }; expandedFamily.ChildTypeMatches.Add(new MatchingRow(100, \"W10x33\", hasDeepScan: false)); Families.FamilyMatches.Add(expandedFamily); // Duplicates tab Duplicates.DuplicateGroups.Add(new DuplicateGroupRow(...)); // Materials, Line Styles, etc. } Source: csharp/src/Tools/Common/GM/Shell/DesignTime/GmShellDesignTimeViewModel.cs:89-246 SGT: Window with SandboxMode Check SGT window uses SandboxMode in constructor: public SgtWindow() { InitializeComponent(); if (DesignerProperties.GetIsInDesignMode(this)) return; if (SandboxMode.IsActive) { DataContext = new SgtWindowDesignTimeViewModel(); return; } } Source: csharp/src/Tools/Structural/SGT/Shell/UI/Views/SgtWindow.xaml.cs:43-47 The design-time ViewModel provides preview data including mock wall geometry: public WallPreviewData PreviewData { get; } = SgtDesignTimePreviewDataFactory.CreateMockWallPreviewData(); public bool HasPreviewData => true; public bool Is3DAvailable => false; // GPU not available in sandbox public string Unavailable3DReason => \"3D preview requires GPU (not available in sandbox/designer mode)\"; Source: csharp/src/Tools/Structural/SGT/Shell/DesignTime/SgtWindowDesignTimeViewModel.cs:51-71 See Also Sandbox Validator Architecture DBTools.Sandbox Project New Tool Guide UI Development Guide"
  },
  "developer-guide/developing/settings-packs.html": {
    "href": "developer-guide/developing/settings-packs.html",
    "title": "Settings Packs | DB Tools",
    "summary": "Settings Packs Settings Packs are the mechanism for tools to expose user-configurable options in the DBTools Settings window. This guide covers the complete settings lifecycle: from manifest declaration to runtime access and persistence. Overview What Are Settings Packs? A Settings Pack bundles together: Settings Model - A typed class holding the configuration values Settings Pack Context - A ViewModel that manages UI state and data binding Settings Pack View - A WPF UserControl rendered in the Settings window Warning Definitions - Optional conditions that can disable tool functionality Settings Packs appear as collapsible cards in the Settings window, organized by ribbon panel (Common, Structural, Testing). Why Use Settings Packs? Centralized configuration: Users manage all tool settings in one place Automatic persistence: Settings are saved to settings.json with atomic writes Change notification: IOptionsMonitor<T> provides live reload without restart Feature warnings: Link settings validation to tool availability Consistent UX: All tools share the same settings interface pattern Architecture The Options Pattern in DBTools DBTools uses Microsoft.Extensions.Options with a custom persistence layer: ┌─────────────────────┐ ┌──────────────────────┐ │ settings.json │────>│ IConfiguration │ │ (user data) │ │ (read from file) │ └─────────────────────┘ └──────────┬───────────┘ │ ┌──────────▼───────────┐ │ IOptionsMonitor<T> │ │ (live reload) │ └──────────┬───────────┘ │ ┌─────────────────────────────┼─────────────────────────────┐ │ │ │ ┌────────▼────────┐ ┌──────────▼──────────┐ ┌──────────▼──────────┐ │ Tool Command │ │ ViewActivatedTask │ │ Settings Window │ │ (read current) │ │ (check auto-update) │ │ (edit & save) │ └─────────────────┘ └─────────────────────┘ └──────────┬──────────┘ │ ┌──────────▼──────────┐ │ IOptionsWriter │ │ (atomic persist) │ └──────────┬──────────┘ │ ┌──────────▼──────────┐ │ settings.json │ │ (updated) │ └─────────────────────┘ Key Interfaces Interface Purpose ISettingsProvider Read typed settings: Get<T>() and SaveAsync<T>() IOptionsMonitor<T> Live-reloading settings with CurrentValue IOptionsWriter Atomic write to settings file sections IDbtSettingsPackDefinition Metadata about a settings pack (title, key, view factory) IDbtSettingsPackContext<T> ViewModel interface for settings UI IDbtSettingsWarningDefinition Warning linked to settings validation Source: csharp/src/DBTools.Core/Settings/ISettingsProvider.cs:3-8 Defining Settings in manifest.yml Settings packs are declared in the tool's manifest.yml under tool.settingsPacks: Schema tool: settings: configSection: \"<section-name>\" # Required: JSON key in settings.json settingsPacks: - key: \"<unique-pack-key>\" # Required: Globally unique identifier title: \"<display-title>\" # Required: Shown in Settings window warnings: # Optional: Associated warnings - id: \"<warning-id>\" # Required: Unique warning identifier title: \"<warning-title>\" # Required: Warning card title message: \"<warning-msg>\" # Required: Explanation shown to user disableTools: # Optional: Tools disabled when warning active - \"<tool-internal-name>\" - \"<another-tool>\" Complete Example: FoundationTags id: DBTools.Structural.FoundationTags assembly: DBTools moduleType: DBTools.Structural.FoundationTags.FoundationTagsToolModule order: 0 tool: settings: configSection: Tools.FoundationTags settingsPacks: - key: structural.foundation_tags title: \"Combined Foundation Tags\" warnings: - id: core.structural.combined_tags title: \"Combined Foundation Tags Disabled\" message: \"Combined foundation tag updates are disabled due to a warning. Clear the warning to re-enable.\" disableTools: - DBTools.UpdateCombinedFoundationTags - DBTools.MoveCombinedFoundationTags - DBTools.OrganizeFoundationTypes ribbonTools: # ... ribbon tool definitions Source: csharp/src/Tools/Structural/FoundationTags/manifest.yml:1-18 Key Naming Conventions Property Convention Example configSection {Category}.{ToolName} Tools.FoundationTags key {category}.{feature} structural.foundation_tags warnings[].id core.{category}.{feature} core.structural.combined_tags Settings Model Classes Basic Settings Model A settings model is a POCO class with public properties: namespace DBTools.Structural.JoistGirderWeight.Settings; public sealed class JoistGirderWeightSettings : IAutoUpdateSettings { public bool AutoUpdateEnabled { get; set; } = true; public bool HasWarning { get; set; } } Source: csharp/src/Tools/Structural/JoistGirderWeight/Settings/JoistGirderWeightSettings.cs:3-7 IAutoUpdateSettings Interface For tools with auto-update on view activation, implement IAutoUpdateSettings: namespace DBTools.Core.Settings.Models; public interface IAutoUpdateSettings { bool AutoUpdateEnabled { get; set; } bool HasWarning { get; set; } } Source: csharp/src/DBTools.Core/Settings/Models/IAutoUpdateSettings.cs:1-7 Complex Settings Model Settings can include collections, nested objects, and custom defaults: namespace DBTools.Structural.FoundationTags.Settings; public sealed class FoundationTagsSettings : IAutoUpdateSettings { public bool AutoUpdateEnabled { get; set; } = true; public bool HasWarning { get; set; } /// <summary> /// Regex patterns to match tag family names. /// </summary> public List<string> TagFamilyPatterns { get; set; } = new() { \"^Combined Foundation Tag\", \"^DB Foundation Tag\" }; /// <summary> /// Regex patterns to match pier family names. /// </summary> public List<string> PierFamilyPatterns { get; set; } = new() { \"^Foundation Pier\" }; /// <summary> /// Regex patterns to match footing family names. /// </summary> public List<string> FootingFamilyPatterns { get; set; } = new() { \"^Footing-Rectangular$\", \"^Pile Cap-Rectangular$\" }; } Source: csharp/src/Tools/Structural/FoundationTags/Settings/FoundationTagsSettings.cs:1-50 JSON Representation Settings are stored in settings.json under the configSection key: { \"Tools.FoundationTags\": { \"AutoUpdateEnabled\": true, \"HasWarning\": false, \"TagFamilyPatterns\": [ \"^Combined Foundation Tag\", \"^DB Foundation Tag\" ], \"PierFamilyPatterns\": [ \"^Foundation Pier\" ], \"FootingFamilyPatterns\": [ \"^Footing-Rectangular$\", \"^Pile Cap-Rectangular$\" ] } } Registering Settings Settings registration happens in two phases within your DbtToolModule: Phase 1: RegisterSettings() Bind the settings model to configuration using the Options pattern: public override void RegisterSettings( IServiceCollection services, IConfiguration configuration, DbtToolManifest manifest) { Guard.NotNull(services, nameof(services)); Guard.NotNull(configuration, nameof(configuration)); Guard.NotNull(manifest, nameof(manifest)); var configSection = manifest.GetRequiredConfigSection(); services.AddOptions<FoundationTagsSettings>(configuration, configSection); } Source: csharp/src/Tools/Structural/FoundationTags/FoundationTagsToolModule.cs:16-23 This registration: Reads the configSection from manifest (Tools.FoundationTags) Binds IOptions<FoundationTagsSettings> to that section Enables IOptionsMonitor<T> for live configuration reload Phase 2: RegisterSettingsPacks() Register the full settings pack definition with UI factory: public override void RegisterSettingsPacks(IServiceCollection services, DbtToolManifest manifest) { Guard.NotNull(services, nameof(services)); Guard.NotNull(manifest, nameof(manifest)); var configSection = manifest.GetRequiredConfigSection(); var pack = manifest.GetSingleSettingsPack(); var warning = pack.GetSingleWarning(manifest.Id); var panel = DbtToolPanelResolver.GetSettingsPanelName(manifest.Id); services.AddSingleton<IDbtSettingsPackDefinition>(_ => { // Define warnings var warningDefinitions = new[] { new DbtSettingsWarningDefinition<FoundationTagsSettings, FoundationTagsSettingsPackContext>( warning.Id, pack.Key, warning.Title, warning.Message, settings => settings.Get<FoundationTagsSettings>(), (settings, options, ct) => settings.SaveAsync(configSection, options, ct), options => options.HasWarning, (options, active) => { options.HasWarning = active; if (active) options.AutoUpdateEnabled = false; }, context => context.HasWarning, (context, active) => { context.HasWarning = active; if (active) context.AutoUpdateEnabled = false; }, warning.DisableTools?.ToArray() ?? Array.Empty<string>()) }; // Create pack definition return new DbtSettingsPackDefinition<FoundationTagsSettings, FoundationTagsSettingsPackContext>( pack.Key, pack.Title, panel, () => new FoundationTagsSettingsPackContext(), // Context factory ctx => new FoundationTagsSettingsPackView { DataContext = ctx }, // View factory () => new FoundationTagsSettings(), // Defaults factory settings => settings.Get<FoundationTagsSettings>(), // Options getter (settings, options, ct) => settings.SaveAsync(configSection, options, ct), // Options saver warningDefinitions); }); } Source: csharp/src/Tools/Structural/FoundationTags/FoundationTagsToolModule.cs:36-81 Using AutoUpdateSettingsPackContext (Simpler Pattern) For simple auto-update settings without custom UI, use the built-in context: public override void RegisterSettingsPacks(IServiceCollection services, DbtToolManifest manifest) { var configSection = manifest.GetRequiredConfigSection(); var pack = manifest.GetSingleSettingsPack(); var warning = pack.GetSingleWarning(manifest.Id); var panel = DbtToolPanelResolver.GetSettingsPanelName(manifest.Id); services.AddSingleton<IDbtSettingsPackDefinition>(_ => { var warningDefinitions = new[] { new DbtSettingsWarningDefinition<JoistGirderWeightSettings, AutoUpdateSettingsPackContext<JoistGirderWeightSettings>>( warning.Id, pack.Key, warning.Title, warning.Message, settings => settings.Get<JoistGirderWeightSettings>(), (settings, options, ct) => settings.SaveAsync(configSection, options, ct), options => options.HasWarning, (options, active) => { options.HasWarning = active; if (active) options.AutoUpdateEnabled = false; }, context => context.HasWarning, (context, active) => { context.HasWarning = active; if (active) context.AutoUpdateEnabled = false; }, warning.DisableTools?.ToArray() ?? Array.Empty<string>()) }; return new DbtSettingsPackDefinition<JoistGirderWeightSettings, AutoUpdateSettingsPackContext<JoistGirderWeightSettings>>( pack.Key, pack.Title, panel, () => new AutoUpdateSettingsPackContext<JoistGirderWeightSettings>( \"Auto Update Joist Girder Weights\", \"Automatically calculate joist girder weights when opening views.\", \"Enable automatic joist girder weight updates when opening views\"), ctx => new AutoUpdateSettingsPackView { DataContext = ctx }, () => new JoistGirderWeightSettings(), settings => settings.Get<JoistGirderWeightSettings>(), (settings, options, ct) => settings.SaveAsync(configSection, options, ct), warningDefinitions); }); } Source: csharp/src/Tools/Structural/JoistGirderWeight/JoistGirderWeightToolModule.cs:37-85 Settings Pack Context The context is the ViewModel for your settings UI. It must implement IDbtSettingsPackContext<T>. Required Interface Methods public interface IDbtSettingsPackContext<TOptions> : IDbtSettingsPackContext { void Load(TOptions options); // Load settings into bindable properties TOptions BuildOptionsSnapshot(); // Create settings object from current state } public interface IDbtSettingsPackContext { void Load(object options); object BuildOptionsSnapshot(); Task<DbtSettingsValidationResult> ValidateAsync(CancellationToken ct = default); } Source: csharp/src/DBTools.Core/Settings/DbtToolSettingsPack.cs:8-22 Optional Context Interfaces Interface Purpose IDbtSettingsPackContextWithState Fire StateChanged event when properties change IDbtSettingsPackContextWithPendingChanges Track HasPendingChanges for save button state IDbtSettingsPackContextOwnerAware Receive parent window for file dialogs IDbtSettingsPackContextSaveAware Reset baseline after save via MarkSaved() IDbtSettingsPackContextValidateAware Trigger warning evaluation via WarningId Source: csharp/src/DBTools.Core/Settings/DbtSettingsPackContextContracts.cs:1-29 Built-in: AutoUpdateSettingsPackContext For standard auto-update toggle + warning, use the built-in context: public sealed partial class AutoUpdateSettingsPackContext<TSettings> : ObservableObject, IDbtSettingsPackContext<TSettings>, IDbtSettingsPackContextWithState, IDbtSettingsPackContextWithPendingChanges where TSettings : class, IAutoUpdateSettings, new() { public AutoUpdateSettingsPackContext(string title, string description, string toggleToolTip) { // Validates inputs and stores for binding } public string Title { get; } public string Description { get; } public string ToggleToolTip { get; } public bool AutoUpdateEnabled { get; set; } public bool HasWarning { get; set; } public bool ToggleEnabled => !HasWarning; public bool HasPendingChanges { get; } public event EventHandler? StateChanged; public void Load(TSettings options) { /* ... */ } public TSettings BuildOptionsSnapshot() { /* ... */ } public Task<DbtSettingsValidationResult> ValidateAsync(CancellationToken ct) { /* ... */ } } Source: csharp/src/DBTools.Core/Settings/AutoUpdateSettingsPackContext.cs:8-130 Custom Context Example For tools requiring additional UI beyond the toggle, create a custom context: public sealed partial class FoundationTagsSettingsPackContext : ObservableObject, IDbtSettingsPackContext<FoundationTagsSettings>, IDbtSettingsPackContextWithState, IDbtSettingsPackContextWithPendingChanges { private const int MaxPatterns = 3; private FoundationTagsSettings _baseline = new(); [ObservableProperty] [NotifyPropertyChangedFor(nameof(ToggleEnabled))] private bool _autoUpdateEnabled = true; [ObservableProperty] [NotifyPropertyChangedFor(nameof(ToggleEnabled))] private bool _hasWarning; public FoundationTagsSettingsPackContext() { TagFamilyPatterns = new ObservableCollection<RegexPatternEntry>(); PierFamilyPatterns = new ObservableCollection<RegexPatternEntry>(); FootingFamilyPatterns = new ObservableCollection<RegexPatternEntry>(); // Subscribe to collection changes TagFamilyPatterns.CollectionChanged += (_, _) => NotifyStateChanged(); // ... etc } public ObservableCollection<RegexPatternEntry> TagFamilyPatterns { get; } public ObservableCollection<RegexPatternEntry> PierFamilyPatterns { get; } public ObservableCollection<RegexPatternEntry> FootingFamilyPatterns { get; } public void Load(FoundationTagsSettings options) { AutoUpdateEnabled = options.AutoUpdateEnabled; HasWarning = options.HasWarning; LoadPatternCollection(TagFamilyPatterns, options.TagFamilyPatterns, \"^Combined Foundation Tag\"); // ... load other collections _baseline = CloneOptions(options); NotifyStateChanged(); } public FoundationTagsSettings BuildOptionsSnapshot() { return new FoundationTagsSettings { AutoUpdateEnabled = HasWarning ? false : AutoUpdateEnabled, HasWarning = HasWarning, TagFamilyPatterns = TagFamilyPatterns.Select(p => p.Pattern).Where(p => !string.IsNullOrWhiteSpace(p)).ToList(), // ... etc }; } public Task<DbtSettingsValidationResult> ValidateAsync(CancellationToken ct = default) { var errors = new List<string>(); ValidatePatternGroup(errors, TagFamilyPatterns, \"tag family\"); // ... validate other groups return errors.Count == 0 ? Task.FromResult(DbtSettingsValidationResult.Success) : Task.FromResult(DbtSettingsValidationResult.FromErrors(errors.ToArray())); } [RelayCommand] private void AddTagPattern() => AddPattern(TagFamilyPatterns, nameof(CanAddTagPattern), nameof(CanRemoveTagPattern)); [RelayCommand] private void ClearWarning() { HasWarning = false; NotifyStateChanged(); } } Source: csharp/src/Tools/Structural/FoundationTags/Settings/FoundationTagsSettingsPackContext.cs:18-272 Accessing Settings at Runtime In Commands (One-time Read) Use ISettingsProvider.Get<T>() for a snapshot of current settings: public class MyCommand : DbtToolCommand { protected override Result ExecuteCore(ExternalCommandData commandData, ref string message, ElementSet elements) { var settings = AppRuntime.Settings.Get<MyToolSettings>(); if (!settings.SomeFeatureEnabled) { message = \"Feature is disabled in settings.\"; return Result.Cancelled; } // Use settings.SomeValue, settings.SomeList, etc. } } In Services (Live Reload) Inject IOptionsMonitor<T> for settings that update without restart: public class MyService { private readonly IOptionsMonitor<MyToolSettings> _options; public MyService(IOptionsMonitor<MyToolSettings> options) { _options = options; } public void DoWork() { // Always reflects current settings.json values var current = _options.CurrentValue; if (current.AutoUpdateEnabled && !current.HasWarning) { // Perform auto-update logic } } } In ViewActivatedTask (Auto-update Pattern) The ViewActivatedTaskBase<T> abstracts settings access for view-activated tools: public sealed class CombinedTagsViewActivatedTask : ViewActivatedTaskBase<FoundationTagsSettings> { public CombinedTagsViewActivatedTask( ISettingsProvider settingsProvider, ILogger<CombinedTagsViewActivatedTask> logger, string[] warningIds) : base(settingsProvider, logger, warningIds) { } protected override FoundationTagsSettings GetSettings(ISettingsProvider settingsProvider) => settingsProvider.Get<FoundationTagsSettings>(); protected override void ExecuteTask(Document document, View view) { // Called only when AutoUpdateEnabled && !HasWarning } } Source: csharp/src/DBTools.Core/Tools/ViewActivatedTaskBase.cs:16-80 Persisting Settings Automatic Save (Settings Window) When the user clicks Save in the Settings window, SettingsViewModel.Save() handles persistence: // Inside SettingsViewModel.Save() foreach (var pack in _packLookup.Values) { var snapshot = pack.Pack.BuildOptionsSnapshot(); await pack.Definition.SaveOptionsAsync(_settings, snapshot, CancellationToken.None); _publisher.PublishPackChanged(pack.Key, pack.Definition.OptionsType, snapshot); } Source: csharp/src/DBTools.Core/Settings/ViewModels/SettingsViewModel.cs:259-292 Manual Save (Programmatic) Save settings directly using ISettingsProvider: var settings = AppRuntime.Settings.Get<MyToolSettings>(); settings.SomeValue = newValue; await AppRuntime.Settings.SaveAsync(\"Tools.MyTool\", settings); IOptionsWriter (Low-level) For direct section writes, use IOptionsWriter: public interface IOptionsWriter { /// <summary> /// Save a typed settings object under a named section in the settings file. /// The write must be atomic (write temp + replace). /// </summary> Task SaveSectionAsync<T>(string section, T data, CancellationToken ct = default) where T : class; } Source: csharp/src/DBTools.Core/Settings/Contracts/IOptionsWriter.cs:1-10 The OptionsWriter implementation ensures atomic writes: Write to settings.json.tmp Use File.Replace() for atomic swap Retry on IOException (file in use) Source: csharp/src/DBTools.Core/Settings/OptionsWriter.cs:27-110 Settings UI Integration View Location Settings pack views are rendered in the Settings window under their assigned panel. The panel is determined by DbtToolPanelResolver.GetSettingsPanelName(): Tool ID Pattern Panel DBTools.Settings DB Tools Settings DBTools.Structural.* or DBTools.SGT DB Tools Structural DBTools.VTC or DBTools.Testing.* DB Tools Testing Everything else DB Tools Common Source: csharp/src/DBTools.Core/Tools/DbtToolPanelResolver.cs:27-44 Built-in AutoUpdateSettingsPackView For simple toggle + description, use the provided view: <UserControl x:Class=\"DBTools.Core.Settings.Views.AutoUpdateSettingsPackView\"> <Border Style=\"{DynamicResource FeatureCard}\"> <Grid> <ToggleButton IsChecked=\"{Binding AutoUpdateEnabled, Mode=TwoWay}\" IsEnabled=\"{Binding ToggleEnabled}\" Style=\"{DynamicResource SwitchToggleButton}\" ToolTip=\"{Binding ToggleToolTip}\" /> <TextBlock Text=\"{Binding Title}\" /> <TextBlock Text=\"{Binding Description}\" TextWrapping=\"Wrap\" /> </Grid> </Border> </UserControl> Source: csharp/src/DBTools.Core/Settings/Views/AutoUpdateSettingsPackView.xaml:1-54 Custom Views For complex settings, create a custom view in your tool's Settings/ folder: <UserControl x:Class=\"DBTools.Structural.FoundationTags.Settings.FoundationTagsSettingsPackView\"> <StackPanel> <!-- Auto-update toggle --> <CheckBox IsChecked=\"{Binding AutoUpdateEnabled}\" IsEnabled=\"{Binding ToggleEnabled}\" /> <!-- Tag pattern list --> <ItemsControl ItemsSource=\"{Binding TagFamilyPatterns}\"> <ItemsControl.ItemTemplate> <DataTemplate> <TextBox Text=\"{Binding Pattern, UpdateSourceTrigger=PropertyChanged}\" /> </DataTemplate> </ItemsControl.ItemTemplate> </ItemsControl> <!-- Add/Remove buttons --> <Button Command=\"{Binding AddTagPatternCommand}\" IsEnabled=\"{Binding CanAddTagPattern}\" /> </StackPanel> </UserControl> Warning Integration How Warnings Work Warnings are conditions that disable tool functionality: Warning activates: Validation fails (e.g., invalid path) Tools disabled: Ribbon buttons grayed out, commands rejected User notified: Warning card appears in Settings window User fixes: Corrects settings, clicks \"Clear Warning\" Tools re-enabled: Ribbon buttons active again Warning Definition In RegisterSettingsPacks(), create a DbtSettingsWarningDefinition: new DbtSettingsWarningDefinition<TSettings, TContext>( id: \"core.structural.combined_tags\", // Unique warning ID packKey: \"structural.foundation_tags\", // Parent pack key title: \"Combined Foundation Tags Disabled\", message: \"Combined foundation tag updates are disabled due to a warning...\", optionsGetter: settings => settings.Get<TSettings>(), optionsSaver: (settings, options, ct) => settings.SaveAsync(section, options, ct), optionsFlagGetter: options => options.HasWarning, optionsFlagSetter: (options, active) => { options.HasWarning = active; if (active) options.AutoUpdateEnabled = false; }, contextFlagGetter: context => context.HasWarning, contextFlagSetter: (context, active) => { context.HasWarning = active; if (active) context.AutoUpdateEnabled = false; }, toolInternalNamesToDisable: new[] { \"DBTools.MyCommand\" }) Source: csharp/src/DBTools.Core/Settings/DbtSettingsWarningDefinition.cs:22-99 Warning Service IDbtSettingsWarningService manages warning state across the application: public interface IDbtSettingsWarningService { IReadOnlyCollection<IDbtSettingsWarningDefinition> Definitions { get; } Task<bool> IsWarningActiveAsync(string warningId, CancellationToken ct = default); Task SetWarningAsync(string warningId, bool active, object? context = null, CancellationToken ct = default); Task PublishWarningStateAsync(CancellationToken ct = default); } Source: csharp/src/DBTools.Core/Settings/DbtSettingsWarningService.cs:11-18 Validation-Triggered Warnings Implement IDbtSettingsPackContextValidateAware to automatically trigger warnings on validation: public sealed partial class LibrarySettingsPackContext : ObservableObject, IDbtSettingsPackContext<MasterLibrarySettings>, IDbtSettingsPackContextValidateAware // <-- Key interface { public string WarningId => _warningId; // From constructor public async Task<DbtSettingsValidationResult> ValidateAsync(CancellationToken ct = default) { var options = BuildOptionsSnapshot(); var invalidEntries = options.Files.Where(f => !IsValid(f)).ToList(); HasWarnings = invalidEntries.Count > 0; if (HasWarnings) return new DbtSettingsValidationResult(false, new[] { \"Invalid library path\" }); return DbtSettingsValidationResult.Success; } } Source: csharp/src/Tools/Common/TDV/Settings/LibrarySettingsPackContext.cs:19-169 Real Examples Example 1: JoistGirderWeight (Simple Auto-Update) Use case: Toggle auto-calculation on view activation. Settings model: public sealed class JoistGirderWeightSettings : IAutoUpdateSettings { public bool AutoUpdateEnabled { get; set; } = true; public bool HasWarning { get; set; } } Source: csharp/src/Tools/Structural/JoistGirderWeight/Settings/JoistGirderWeightSettings.cs:3-7 Registration: Uses AutoUpdateSettingsPackContext<T> and AutoUpdateSettingsPackView. Manifest: settingsPacks: - key: structural.joist_girder_weight title: \"Joist Girder Weights\" warnings: - id: core.structural.joist_girder title: \"Joist Girder Weights Disabled\" disableTools: - DBTools.UpdateJoistGirderWeights Source: csharp/src/Tools/Structural/JoistGirderWeight/manifest.yml:8-16 Example 2: FoundationTags (Custom Patterns) Use case: Configure regex patterns for family matching. Settings model: Includes List<string> for patterns. Source: csharp/src/Tools/Structural/FoundationTags/Settings/FoundationTagsSettings.cs:1-50 Context: Custom FoundationTagsSettingsPackContext with pattern editing commands. Source: csharp/src/Tools/Structural/FoundationTags/Settings/FoundationTagsSettingsPackContext.cs:18-272 View: Custom FoundationTagsSettingsPackView.xaml with pattern lists. Example 3: TDV Library (Complex Validation) Use case: Configure library file paths with validation warnings. Settings model: public sealed class MasterLibrarySettings { public IList<LibraryFileEntry> Files { get; set; } = new List<LibraryFileEntry>(); public bool HasWarnings { get; set; } } Source: csharp/src/Tools/Common/TDV/Settings/MasterLibrarySettings.cs:1-7 Context: LibrarySettingsPackContext with file picker, tree view, and validation. Source: csharp/src/Tools/Common/TDV/Settings/LibrarySettingsPackContext.cs:19-352 Key features: IDbtSettingsPackContextOwnerAware for file dialogs IDbtSettingsPackContextSaveAware for baseline reset IDbtSettingsPackContextValidateAware for automatic warning activation Best Practices Do Use IAutoUpdateSettings for tools with view-activated auto-update Clone settings in context to detect HasPendingChanges Fire StateChanged when any bindable property changes Implement validation that returns meaningful error messages Use existing patterns - check JoistGirderWeight for simple, FoundationTags for complex Don't Don't save directly from context - let SettingsViewModel.Save() handle persistence Don't bypass warnings - respect HasWarning in command availability Don't block UI thread - use async for file I/O in validation Don't ignore CancellationToken - validation can be cancelled Testing Settings Build artifacts tests verify settings structure Integration tests can mock ISettingsProvider Manual testing in Revit validates UI binding Related Documentation Creating New Tools - Complete tool creation guide Feature Warnings - Deep dive on the warning system Core Infrastructure - DBTools.Core project reference Summary Settings Packs provide a unified way to expose tool configuration: Declare in manifest.yml with settingsPacks Model settings as a typed class (optionally implementing IAutoUpdateSettings) Register via RegisterSettings() and RegisterSettingsPacks() in your tool module Access at runtime with ISettingsProvider.Get<T>() or IOptionsMonitor<T> Persist automatically through the Settings window or manually via IOptionsWriter Warn users when validation fails, disabling affected tools until resolved The system provides live-reload, atomic persistence, and consistent UX across all DBTools tools."
  },
  "developer-guide/developing/test-refactoring-strategy.html": {
    "href": "developer-guide/developing/test-refactoring-strategy.html",
    "title": "Test Refactoring Strategy: GM and SGT | DB Tools",
    "summary": "Test Refactoring Strategy: GM and SGT Overview This document outlines the strategy for refactoring GM and SGT tests to achieve: DA-compatible (headless) tests for all pure logic Realistic test doubles that exercise actual code paths Contract-based testing for service compliance Comprehensive ViewModel tests without faking results Current State Assessment GM Tests Audit Test File Verdict Reason GM_PlanningServiceTests KEEP Tests actual GmPlanningService with real inputs GM_PlanningKernelTests KEEP Tests actual kernel with realistic GmProjectState GM_PlanningValidationTests KEEP Tests exception throwing for invalid mappings GM_KernelDeterminismTests KEEP Tests fingerprinting with real state objects GM_DomainInvariantsTests KEEP Tests domain object defaults GmAdapterTests KEEP Integration tests using real Revit model GmBaselines KEEP SSOT reference constants GM_MappingApplyPlanTests REFACTOR FakeX classes pass null! for Document GM_MappingServiceTests REFACTOR Same issue - null! Document GmWindowViewModel_UiStateTests REFACTOR Uses Noop stubs that bypass real logic GmWindowViewModelTestFactory REFACTOR Creates VMs with all Noop dependencies SGT Tests Audit Test File Verdict Reason ElevationSnapServiceTests KEEP Excellent pure logic tests SgtSegmentResolutionTests KEEP Very thorough domain logic tests SgtFrameBuilderTests KEEP Good geometric validation SgtBaselines KEEP SSOT reference constants SgtStorageMapperTests KEEP Tests serialization/deserialization SgtConfigHydratorTests KEEP Tests configuration hydration SgtElementConnectivityTests KEEP Tests connectivity logic SgtWindowViewModelCommandTests REFACTOR Uses stub factories, tests with reflection Critical Issues Found StubTxRunner passes null! for Document - Tests don't exercise real code paths Noop* classes return empty data - Bypass actual business logic FakeX classes only track call counts - Don't validate actual behavior Duplicate implementations - 4 copies of StubTxRunner across test files Reflection to invoke private methods - Brittle, bypasses normal code paths Target Architecture Test Categories Tests/ ├── Unit/ # DA-Compatible (Category: Unit) │ ├── GM/ │ │ ├── Domain/ # Value objects, records, invariants │ │ ├── Planning/ # GmPlanningService, operations │ │ ├── Kernel/ # State construction, fingerprinting │ │ └── Serialization/ # UI state round-trip, snapshots │ └── SGT/ │ ├── Domain/ # Value objects (Elevation, Distance, etc.) │ ├── Snapping/ # ElevationSnapService │ ├── Segments/ # SegmentResolutionService │ └── Frames/ # WallFrame construction │ ├── Contract/ # DA-Compatible (Category: Unit) │ ├── GM/ │ │ ├── IPlanningServiceContract.cs │ │ ├── IMappingServiceContract.cs │ │ └── IKernelContextContract.cs │ └── SGT/ │ ├── IPlanBuilderContract.cs │ ├── IOrchestratorContract.cs │ └── IPlacementWriterContract.cs │ ├── ViewModel/ # DA-Compatible (Category: Unit) │ ├── GM/ │ │ ├── TabNavigationTests.cs │ │ ├── FilteringTests.cs │ │ ├── SelectionTests.cs │ │ └── StateRoundTripTests.cs │ └── SGT/ │ ├── GirtRowManagementTests.cs │ ├── OpeningRowManagementTests.cs │ ├── PreviewModeTests.cs │ └── PlacementGatesTests.cs │ └── Integration/ # Requires Revit (Category: Local, RequiresActiveDocument) ├── GM/ │ ├── AdapterSmokes.cs │ ├── DeepScanTests.cs │ └── MappingApplyTests.cs └── SGT/ ├── WallAnalysisTests.cs ├── PlacementWriterTests.cs └── StorageTests.cs Realistic Test Doubles Instead of Noop* classes that return empty results, we create realistic doubles that: Return actual data structures with meaningful values Exercise real business logic in consuming code Can be configured with different scenarios // BAD: NoopPlanner - returns empty, bypasses everything class NoopPlanner : IGmPlanningService { Task<GmPlanningResult> BuildPlanAsync(...) => Task.FromResult(new GmPlanningResult(Array.Empty<GmPlanOperation>(), ...)); } // GOOD: RealisticPlanner - returns meaningful data class RealisticPlanningService : IGmPlanningService { private readonly List<GmPlanOperation> _operations = new(); public void SetupTypeMappings(params (int from, int to)[] mappings) { foreach (var (from, to) in mappings) _operations.Add(new GmPlanOperation(GmOperationKind.ReplaceType, from, to)); } public Task<GmPlanningResult> BuildPlanAsync(...) => Task.FromResult(new GmPlanningResult( _operations, normalizedLog: BuildLog(_operations), typeOpCount: _operations.Count(o => o.Kind == GmOperationKind.ReplaceType), ...)); } Contract-Based Testing Define contracts that specify what services MUST produce: public static class GmPlanningServiceContract { /// <summary> /// INVARIANT: BuildPlanAsync must return operations sorted by execution order /// (Params → Create → Host → Nested → Type → Style → Material → SP) /// </summary> public static void AssertOperationOrder(GmPlanningResult result) { var kinds = result.Operations.Select(o => o.Kind).ToList(); var expected = new[] { GmOperationKind.MapParameter, GmOperationKind.CreateType, GmOperationKind.ReplaceHost, GmOperationKind.AddNestedFamily, GmOperationKind.ReplaceType, GmOperationKind.ReplaceStyle, GmOperationKind.ReplaceMaterial, GmOperationKind.BindSharedParameter, GmOperationKind.EmbedSharedParameter }; var lastIndex = -1; foreach (var kind in kinds) { var index = Array.IndexOf(expected, kind); Assert.That(index, Is.GreaterThanOrEqualTo(lastIndex), $\"Operation {kind} appears before expected order\"); lastIndex = index; } } /// <summary> /// INVARIANT: Zero/negative IDs must be rejected /// </summary> public static void AssertRejectsInvalidIds(IGmPlanningService svc) { Assert.ThrowsAsync<GmInvalidMappingException>(() => svc.BuildPlanAsync(new Dictionary<int,int> { [0] = 1 }, ...)); Assert.ThrowsAsync<GmInvalidMappingException>(() => svc.BuildPlanAsync(new Dictionary<int,int> { [-1] = 1 }, ...)); Assert.ThrowsAsync<GmInvalidMappingException>(() => svc.BuildPlanAsync(new Dictionary<int,int> { [1] = 1 }, ...)); // self-mapping } } Implementation Plan Phase 1: Infrastructure Cleanup Delete duplicate StubTxRunner implementations Consolidate into single implementation in TestSupport Remove from individual test files Delete Noop classes from GmWindowViewModelTestFactory* Replace with realistic implementations Create shared test builders GmProjectStateBuilder - fluent builder for test states SgtPlanBuilder - fluent builder for test plans Phase 2: GM Test Refactoring Refactor GmWindowViewModelTestFactory Replace NoopPlanner with RealisticPlanningService Replace NoopMapping with RealisticMappingService Remove null! Document passing Add contract tests GmPlanningServiceContract GmMappingServiceContract GmKernelContextContract Add comprehensive ViewModel tests Tab navigation (lazy loading) Filtering (search, threshold) Selection (row selection, target combobox) Phase 3: SGT Test Refactoring Refactor SgtWindowViewModelCommandTests Replace stub factories with realistic doubles Remove reflection for private method invocation Add contract tests SgtPlanBuilderContract SgtOrchestratorContract SgtPlacementWriterContract Add comprehensive ViewModel tests Girt row management Opening row management Preview mode transitions Placement gates (all conditions) Phase 4: DA Compatibility Ensure all Unit tests are DA-compatible No Revit UI dependencies Category: \"Unit\" Mark Integration tests correctly Category: \"Local\", \"RequiresActiveDocument\" Update DBTools.DA.Tests to link appropriate tests Success Criteria No tests pass null! for Document/UIApplication No tests return empty data that bypasses business logic All pure logic tests are DA-compatible Contract tests verify spec compliance ViewModel tests exercise real state management Zero duplicate test infrastructure code"
  },
  "developer-guide/developing/testing-tools.html": {
    "href": "developer-guide/developing/testing-tools.html",
    "title": "Testing Tools for DBTools Development | DB Tools",
    "summary": "Testing Tools for DBTools Development This guide covers the complete testing infrastructure for DBTools, including test categories, running tests, writing effective tests, and using the TestSupport library. Overview: Testing Philosophy DBTools follows a production-first testing philosophy: Fix production code before changing tests - When a test fails, investigate production code first Assert outcomes, not interactions - Tests must verify real results, not just that mocks were called Stub only true externals - Mock the Revit API, filesystem, and network; never mock your own services No fake tests - If a test passes regardless of production correctness, delete it Source: .claude/skills/test-audit/README.md What Makes a Test Legitimate Legitimate (KEEP) Illegitimate (DELETE) Revit API stubs Your own service mocks File system stubs Orchestrator/handler mocks Network stubs Test doubles with domain behavior Time/Random stubs for determinism \"Mock was called\" assertions only Test Categories DBTools has two broad categories of tests, determined by execution environment. 1. Headless Tests (No Revit Required) Tests that can run without Revit, via dotnet test: Build Artifacts Tests - Verify DLL assembly structure and metadata Unit Tests - Pure logic tests for services, algorithms, similarity detection DA Tests - Design Automation-compatible tests # Run headless tests dotnet test csharp/testing/DBTools.BuildArtifacts.Tests/DBTools.BuildArtifacts.Tests.csproj -c Release 2. Revit Integration Tests Tests that require a running Revit instance, executed via invoke-revit-tests.sh: UI Tests - ViewModel integration tests Document Tests - Tests requiring Revit documents with elements Adapter Tests - Tests verifying Revit API interactions # Run via test runner bash csharp/invoke-revit-tests.sh --smart --tool GM Test Category Markers Use the TestCategories constants to mark tests appropriately: Source: csharp/testing/TestSupport/TestCategories.cs:1-43 using DBTools.Tests.Shared; [TestFixture] public class MyTests { [Test] [Category(TestCategories.RequiresRevitUI)] public void Test_RequiringUIApplication() { // Requires UIApplication, TaskDialog, or STA thread } [Test] [Category(TestCategories.RequiresActiveDocument)] public void Test_RequiringOpenDocument() { // Requires an open Revit document with elements } [Test] [Category(TestCategories.Slow)] public void Test_TakesLongTime() { // Tests > 5 seconds; may be excluded from quick runs } [Test] [Category(TestCategories.Integration)] public void Test_RequiringNetwork() { // Requires external dependencies (cloud, network) } } Category Effects: RequiresRevitUI - Excluded from Design Automation runs RequiresActiveDocument - Excluded from headless runs Slow - May be filtered out in quick test cycles Local - Runs only in local Revit environment Test Project Structure Tests live in two locations: 1. In-Tool Tests (csharp/src/Tools/<Tool>/Tests/) Tool-specific tests embedded alongside the tool code: csharp/src/Tools/ ├── Common/GM/Tests/ │ ├── Duplicates/ │ │ ├── DuplicateDetectionServiceTests.cs │ │ └── GmWindowViewModel_SpDuplicatesTests.cs │ └── Reports/ │ └── GmWindowViewModel_SpPlanningTests.cs └── Structural/SGT/Tests/ ├── SgtAdapterTests.cs ├── SgtSegmentResolutionTests.cs ├── SgtUiServicesTests.cs └── ExtentResolverTests.cs 2. Standalone Test Projects (csharp/testing/) Infrastructure and cross-cutting tests: csharp/testing/ ├── DBTools.BuildArtifacts.Tests/ # Assembly verification (headless) ├── DBTools.DA.Tests/ # Design Automation tests (headless) ├── TestSupport/ # Shared test utilities │ ├── CommonTestDoubles.cs │ ├── TestCategories.cs │ ├── TestPathResolver.cs │ ├── GM/ # GM-specific test utilities │ └── SGT/ # SGT-specific test utilities └── RevitTestModels/ # Test Revit models by year ├── 2024/ ├── 2025/ └── 2026/ Setting Up a New Test Project Create the test class in the appropriate Tests/ directory Add NUnit attributes: [TestFixture] and [Test] Reference TestSupport: Add using DBTools.Tests.Shared Add categories if the test has special requirements TestSupport Library The TestSupport library provides shared utilities for all tests. Core Test Doubles Source: csharp/testing/TestSupport/CommonTestDoubles.cs:1-340 RecordingNotifier Records error and success banner calls for verification: var notifier = new RecordingNotifier(); // ... run code that triggers notifications ... Assert.That(notifier.ErrorCount, Is.EqualTo(1)); Assert.That(notifier.LastTitle, Does.Contain(\"Error\")); Assert.That(notifier.AllBanners, Has.Count.EqualTo(2)); RecordingOverlay Records progress overlay interactions: var overlay = new RecordingOverlay(); // ... run code using progress overlay ... Assert.That(overlay.ShowCount, Is.EqualTo(1)); Assert.That(overlay.CurrentTitle, Is.EqualTo(\"Processing...\")); Assert.That(overlay.StepUpdates, Has.Count.GreaterThan(0)); InlineExecutor Runs ISafeExecutor actions synchronously (no async dispatch): var executor = new InlineExecutor(); // ... inject into ViewModel ... Assert.That(executor.RunCount, Is.EqualTo(1)); InlineTransactionRunner Executes transactions inline without actual Revit transactions: var runner = new InlineTransactionRunner(); // ... inject into service ... Assert.That(runner.RunCount, Is.EqualTo(2)); Assert.That(runner.TransactionNames, Contains.Item(\"Apply Mappings\")); GM Test Utilities Source: csharp/testing/TestSupport/GM/GmTestDataBuilder.cs:1-475 GmTestDataBuilder Fluent builder for creating realistic GM test state: var state = new GmTestDataBuilder() .AddFamilyWithIds( familyId: 100, familyName: \"Detail Plate A\", placement: \"Face-Based\", instanceCount: 10, (101, \"Type A-1\"), (102, \"Type A-2\")) .AddMaterialsWithIds( (1001, \"Steel - Chrome\"), (1002, \"Steel - Brushed\")) .LinkFamilyToMaterials(100, 1001, 1002) .Build(); Pre-built Test States // Standard state with families, types, materials, styles var standard = GmTestDataBuilder.CreateStandardTestState(); // Minimal state for simple tests var minimal = GmTestDataBuilder.CreateMinimalTestState(); GmRealisticTestDoubles Source: csharp/testing/TestSupport/GM/GmRealisticTestDoubles.cs:1-914 Realistic implementations of GM contracts: // Project lifecycle that returns configured state var lifecycle = RealisticProjectLifecycle.WithStandardTestState(); // Duplicate detection with pre-configured results var duplicates = RealisticDuplicateDetection.WithStandardDuplicates(); // Element queries from state var queries = new RealisticElementQuery(state); // Configurable services for specific scenarios var mapping = new ConfigurableMappingService() .WithApplyResult(new GmMappingApplyResult(...)); SGT Test Utilities Source: csharp/testing/TestSupport/SGT/SgtRealisticTestDoubles.cs:1-300 ConfigurableOrchestratorFactory var factory = new ConfigurableOrchestratorFactory() .Succeeds() // or .FailsWithError(\"message\") .SucceedsWithOutcome(new PlacementOutcome { ... }); // After test execution Assert.That(factory.PlaceCallCount, Is.EqualTo(1)); Assert.That(factory.LastPlacedPlan, Is.Not.Null); ConfigurablePlanBuilder var builder = new ConfigurablePlanBuilder() .ReturnsNewPlan(expectedPlan); // After test execution Assert.That(builder.BuildNewPlanCallCount, Is.EqualTo(1)); Assert.That(builder.LastTarget, Is.Not.Null); Test Path Resolution Source: csharp/testing/TestSupport/TestPathResolver.cs:1-66 Resolves test model paths from the test runner environment: // Get base test models directory var modelsDir = TestPathResolver.ResolveTestModelsDir(); // Get specific model path var gmModel = TestPathResolver.ResolveTestModelPath(\"2026\", \"GM\", \"gm_test_model.rvt\"); Writing Headless Tests Headless tests run via dotnet test without Revit. Example: Unit Test for Service Logic Source: csharp/src/Tools/Common/GM/Tests/Duplicates/DuplicateDetectionServiceTests.cs:1-184 [TestFixture] public class DuplicateDetectionServiceTests { // Minimal stubs for true external dependencies only private sealed class StubNames : IElementQuery { private readonly Dictionary<int, string> _map; public StubNames(Dictionary<int, string> map) { _map = map; } public Task<string?> GetElementNameAsync(int elementId, CancellationToken ct = default) => Task.FromResult(_map.TryGetValue(elementId, out var n) ? n : null); public Task<IReadOnlyDictionary<int, string>> GetElementNamesAsync( IReadOnlyCollection<int> elementIds, CancellationToken ct = default) => Task.FromResult((IReadOnlyDictionary<int, string>) _map.Where(kv => elementIds.Contains(kv.Key)) .ToDictionary(kv => kv.Key, kv => kv.Value)); } [Test] public async Task Families_With_SameStem_And_ParamOverlap_Generate_Pairs() { // Arrange: Build real kernel state var kernel = new GmProjectState { Families = new Dictionary<int, GmFamilyRecord> { [100] = new GmFamilyRecord { ElementId = 100, Name = \"Plate\" }, [101] = new GmFamilyRecord { ElementId = 101, Name = \"Plate1\" } } }; kernel.Families[100].Types[1000] = new GmTypeRecord { SymbolId = 1000, FamilyId = 100, DeepScanPayload = new GmTypeDeepScan { ParameterNames = new[] { \"Width\", \"Height\" } } }; // Real service with minimal stubs var svc = new DuplicateDetectionService( new NamingSimilarityService(), // Real service new ParameterSimilarityService(), // Real service new StubNames(new Dictionary<int, string> { { 100, \"Plate\" }, { 101, \"Plate1\" } }), new StubMatPrev(new Dictionary<int, MaterialPreviewInfo?>()), new StubStylePrev(new Dictionary<int, StylePreviewInfo?>()), NullLogger.Instance); // Act var res = await svc.DetectAsync(kernel); // Assert: Real outcome var famGroups = res.Groups.Where(g => g.Kind == DuplicateKind.Families).ToList(); Assert.That(famGroups.Count, Is.GreaterThanOrEqualTo(1)); var anyPair = famGroups .SelectMany(g => g.Pairs) .Any(p => p.FromId == 100 && p.ToId == 101 && p.Score >= 90.0); Assert.That(anyPair, Is.True, \"Expected high-score pair between 100 -> 101.\"); } } Example: Build Artifacts Test Source: csharp/testing/DBTools.BuildArtifacts.Tests/AssemblyManifestTests.cs:1-341 [TestFixture] [Category(\"BuildArtifacts\")] public sealed class AssemblyManifestTests { private static readonly int[] SupportedYears = { 2024, 2025, 2026 }; [TestCaseSource(nameof(SupportedYears))] public void DBTools_TargetFrameworkCorrect(int year) { if (!DistExists()) Assert.Inconclusive(\"Build artifacts not found. Run build first.\"); var path = Path.Combine(GetYearPath(year), \"DBTools.dll\"); var tfm = GetTargetFramework(path); if (year == 2024) { Assert.That(tfm, Does.Contain(\".NETFramework\").Or.Contain(\"net48\"), $\"Year {year} should target .NET Framework 4.8\"); } else { Assert.That(tfm, Does.Contain(\".NETCoreApp\").Or.Contain(\"net8.0\"), $\"Year {year} should target .NET 8.0\"); } } [TestCaseSource(nameof(SupportedYears))] public void DBTools_NoForbiddenReferences(int year) { var refs = GetReferencedAssemblies(path); foreach (var forbidden in ForbiddenReferences) { Assert.That(refs.Any(r => r.Equals(forbidden, StringComparison.OrdinalIgnoreCase)), Is.False, $\"Year {year}: Should not directly reference {forbidden}\"); } } } Writing Revit Tests Revit integration tests use the ricaun.RevitTest framework. Example: SGT UI Service Test Source: csharp/src/Tools/Structural/SGT/Tests/SgtUiServicesTests.cs:1-150 [TestFixture] public class SgtUiServicesTests { private IUnitService _units = null!; [SetUp] public void SetUp() { _units = new UnitService(); // Real service, not a mock } private static ILogger<T> CreateLogger<T>() => TestLoggingBridge.Initialize().CreateLogger<T>(); private static WallPreviewData SampleWall(double length = 20.0) { return new WallPreviewData { WallId = 1, LengthFeet = length, BaseElevationFeet = 0.0, TopElevationFeet = 10.0, ThicknessFeet = 0.5, StartPoint = Vector3.Create(0, 0, 0).Value, EndPoint = Vector3.Create(length, 0, 0).Value, WallTypeId = 1, WallTypeName = \"Type-A\", Grids = new List<GridMarker> { new GridMarker { Name = \"A\", T = 0.25 }, new GridMarker { Name = \"B\", T = 0.75 }, }, Openings = new List<ElevationOpeningRect> { new ElevationOpeningRect { OpeningKey = \"H:1:101\", T0 = 0.40, T1 = 0.60, Y0 = 3.0, Y1 = 6.0 }, } }; } [Test] public void SgtGridManagementService_UpdateExtentEnables_RespectsGridCounts() { var svc = new SgtGridManagementService(CreateLogger<SgtGridManagementService>()); var row = new SgtGirtRowItem { StartExtent = \"A\", EndExtent = \"B\" }; var opts = new ObservableCollection<string> { \"Full Length\" }; // 0 grids => both disabled and reset to Full Length SgtGridManagementService.UpdateExtentEnables(row, opts); Assert.That(row.StartExtentEnabled, Is.False); Assert.That(row.EndExtentEnabled, Is.False); Assert.That(row.StartExtent, Is.EqualTo(\"Full Length\")); Assert.That(row.EndExtent, Is.EqualTo(\"Full Length\")); // 1 grid => only one side enabled at a time opts.Add(\"A\"); SgtGridManagementService.UpdateExtentEnables(row, opts); Assert.That(row.StartExtentEnabled ^ row.EndExtentEnabled, Is.True); // 2+ grids => both enabled opts.Add(\"B\"); SgtGridManagementService.UpdateExtentEnables(row, opts); Assert.That(row.StartExtentEnabled && row.EndExtentEnabled, Is.True); } } Using RevitHost for Context Source: csharp/testing/TestSupport/TestHost/RevitHost.cs:1-111 For tests requiring Revit context: [Test] [Category(TestCategories.RequiresRevitUI)] public async Task MyTest_WithRevitContext(UIApplication app) { await RevitHost.RunAsync(app, async () => { // Code runs within Revit context var doc = app.ActiveUIDocument?.Document; Assert.That(doc, Is.Not.Null); }); } Test Doubles: Guidelines When to Use Test Doubles Scenario Approach Revit API dependency Stub it File system access Stub it Network/cloud services Stub it Time-sensitive logic Stub with deterministic time Your own services Use the real implementation Orchestrators/handlers Use the real implementation Anti-patterns to Avoid // BAD: Mocking your own service to make test pass var mockOrchestrator = new Mock<ISgtOrchestrator>(); mockOrchestrator.Setup(o => o.PlaceAsync(It.IsAny<SgtPlan>(), It.IsAny<CancellationToken>())) .ReturnsAsync(Result.Success(new PlacementOutcome())); // BAD: Asserting only mock interactions mockService.Verify(s => s.DoSomething(), Times.Once); // Missing: actual outcome assertion! // BAD: Test double that adds domain behavior public class FakeOrchestrator : ISgtOrchestrator { public Task<Result<PlacementOutcome, string>> PlaceAsync(...) { // WRONG: Implementing domain logic in test double var outcome = ComputePlacement(plan); return Task.FromResult(Result.Success(outcome)); } } Correct Pattern // GOOD: Use real services, stub only true externals var realService = new DuplicateDetectionService( new NamingSimilarityService(), // Real new ParameterSimilarityService(), // Real new StubElementQuery(testData), // Stub: wraps Revit API new StubMaterialService(testData), // Stub: wraps Revit API NullLogger.Instance); // GOOD: Assert real outcomes var result = await realService.DetectAsync(kernel); Assert.That(result.Groups, Has.Count.GreaterThan(0)); Assert.That(result.Groups[0].Pairs, Contains.Item( Has.Property(\"FromId\").EqualTo(100) .And.Property(\"ToId\").EqualTo(101))); Running Tests Local: invoke-revit-tests.sh Source: csharp/invoke-revit-tests.sh:1-1529 The primary test runner for Revit integration tests. Basic Usage # Run all tests for a tool bash csharp/invoke-revit-tests.sh --tool GM # Smart mode (recommended) - auto-detects build changes bash csharp/invoke-revit-tests.sh --smart --tool GM # Specific Revit year bash csharp/invoke-revit-tests.sh --smart --tool SGT -y 2025 # Custom filter bash csharp/invoke-revit-tests.sh -f \"FullyQualifiedName~DuplicateDetection\" # Specific fixture bash csharp/invoke-revit-tests.sh --fixture SgtUiServicesTests Revit Instance Modes Mode Description --smart Auto-detect if build changed; reuse if unchanged --reuse Use existing Revit instance; fail if none running --persist Open new Revit and leave it running after tests --close Open new Revit and close it after tests (default) Test Discovery # List all available tests bash csharp/invoke-revit-tests.sh --discover # List GM tests only bash csharp/invoke-revit-tests.sh --discover --tool GM # Show test count summary bash csharp/invoke-revit-tests.sh --discover --summary # Show DA-compatible tests only bash csharp/invoke-revit-tests.sh --discover --da-only Test History # Show recent test history bash csharp/invoke-revit-tests.sh --history # Show failed tests bash csharp/invoke-revit-tests.sh --show-failed # Show tests not run in 7 days bash csharp/invoke-revit-tests.sh --show-stale 7 # Show error details for specific tests bash csharp/invoke-revit-tests.sh --get-errors \"GM\" Parallel Agent Support For multiple AI agents running tests simultaneously: # Agent 1 bash csharp/invoke-revit-tests.sh --smart --session agent-001 --tool GM # Agent 2 bash csharp/invoke-revit-tests.sh --smart --session agent-002 --tool SGT CI: dotnet test For headless tests in CI pipelines: # Build artifacts tests dotnet test csharp/testing/DBTools.BuildArtifacts.Tests/DBTools.BuildArtifacts.Tests.csproj \\ -c Release # Run with specific filter dotnet test csharp/testing/DBTools.BuildArtifacts.Tests/DBTools.BuildArtifacts.Tests.csproj \\ -c Release \\ --filter \"FullyQualifiedName~Metadata\" # Exclude slow tests dotnet test . --filter \"Category!=Slow\" Debugging Test Failures Common Issues 1. \"Missing required test params file\" Cause: Running Revit tests outside of invoke-revit-tests.sh Fix: Always run Revit tests via the runner: bash csharp/invoke-revit-tests.sh --smart --tool GM 2. \"Artifacts are stale relative to source snapshot\" Cause: Source code changed since last build Fix: Rebuild before testing: bash csharp/build.sh BuildAll bash csharp/invoke-revit-tests.sh --smart --tool GM 3. \"No running Revit.exe instance was found\" Cause: Using --reuse mode without a running Revit Fix: Use --smart or --persist instead: bash csharp/invoke-revit-tests.sh --smart --tool GM 4. Test passes in isolation but fails in batch Cause: Shared state pollution between tests Fix: Ensure [SetUp] and [TearDown] properly isolate state: [SetUp] public void SetUp() { _notifier = new RecordingNotifier(); _overlay = new RecordingOverlay(); // Reset any shared state } [TearDown] public void TearDown() { _notifier.Reset(); _overlay.Reset(); } 5. Assert.Inconclusive: \"Build artifacts not found\" Cause: Running build artifacts tests without building first Fix: Build before testing: bash csharp/build.sh BuildAll dotnet test csharp/testing/DBTools.BuildArtifacts.Tests/DBTools.BuildArtifacts.Tests.csproj Viewing Test Logs # Show log file path after test run bash csharp/invoke-revit-tests.sh --smart --tool GM --show-log Session Management # List active test sessions bash csharp/invoke-revit-tests.sh --sessions # Clean up stale sessions bash csharp/invoke-revit-tests.sh --kill-orphans Real Examples from the Codebase GM: Duplicate Detection Tests Source: csharp/src/Tools/Common/GM/Tests/Duplicates/DuplicateDetectionServiceTests.cs:58-87 Tests the real duplicate detection algorithm with minimal stubs: [Test] public async Task Families_With_SameStem_And_ParamOverlap_Generate_Pairs() { var kernel = new GmProjectState { ... }; var svc = new DuplicateDetectionService( new NamingSimilarityService(), // Real new ParameterSimilarityService(), // Real new StubNames(...), // Stub: Revit element names new StubMatPrev(...), // Stub: Revit materials new StubStylePrev(...), // Stub: Revit styles NullLogger.Instance); var res = await svc.DetectAsync(kernel); // Assert on actual detection results Assert.That(famGroups.Count, Is.GreaterThanOrEqualTo(1)); Assert.That(anyPair, Is.True, \"Expected high-score pair between 100 -> 101.\"); } SGT: UI Services Tests Source: csharp/src/Tools/Structural/SGT/Tests/SgtUiServicesTests.cs:60-117 Tests grid management logic with real service and sample data: [Test] public void SgtGridManagementService_ResolveExtentTR_ComputesForGridAndOpening() { var wall = SampleWall(length: 40.0); // Real test data var gridT = new Dictionary<string, double> { [\"A\"] = 0.25, [\"B\"] = 0.75 }; var openingT = new Dictionary<string, (double, double)> { [\"H:1:101\"] = (0.40, 0.60) }; var row = new SgtGirtRowItem { ... }; // Test real service logic SgtGridManagementService.ResolveExtentTR(wall, gridT, openingT, row, isStart: true, out tL, ref warnings); SgtGridManagementService.ResolveExtentTR(wall, gridT, openingT, row, isStart: false, out tR, ref warnings); Assert.That(tL, Is.EqualTo(0.25).Within(1e-9)); Assert.That(tR, Is.EqualTo(0.60).Within(1e-9)); Assert.That(string.IsNullOrWhiteSpace(warnings), Is.True); } Build Artifacts: Assembly Validation Source: csharp/testing/DBTools.BuildArtifacts.Tests/AssemblyManifestTests.cs:86-106 Tests that built assemblies meet contract requirements: [TestCaseSource(nameof(YearAssemblyPairs))] public void Assembly_ExistsAndIsValid(int year, string assemblyName) { if (!DistExists()) Assert.Inconclusive(\"Build artifacts not found. Run build first.\"); var path = Path.Combine(GetYearPath(year), assemblyName); Assert.That(File.Exists(path), Is.True, $\"Missing: {path}\"); var asmName = AssemblyName.GetAssemblyName(path); Assert.That(asmName, Is.Not.Null); Assert.That(asmName.Name, Does.StartWith(\"DBTools\")); } Cross-References Test Pipeline Architecture: ../architecture/test-pipeline.md New Tool Guide: new-tool-guide.md Build System: ../architecture/build-system.md Summary Checklist When writing tests, ensure: [ ] Tests use real service implementations where possible [ ] Only true externals (Revit API, filesystem, network) are stubbed [ ] Tests assert on outcomes, not just mock interactions [ ] Tests are marked with appropriate categories (RequiresRevitUI, etc.) [ ] [SetUp] and [TearDown] properly isolate test state [ ] Test doubles don't add domain behavior [ ] Failing tests trigger production code investigation first"
  },
  "developer-guide/index.html": {
    "href": "developer-guide/index.html",
    "title": "Developer Guide | DB Tools",
    "summary": "Developer Guide Welcome to the DB Tools Developer Guide. This documentation is intended for developers working on the DBTools codebase or building integrations. Quick Navigation Section Description Architecture System design, build pipeline, project structure Projects Deep dives into each project Tools (Technical) Internal tool implementation details Developing Guides for creating new tools Getting Started Prerequisites Visual Studio 2022 or later .NET SDK 8.0+ Revit 2024, 2025, or 2026 Building # From repository root cd csharp bash build.sh # Or for a specific Revit year bash build.sh -y 2025 BuildAll Testing # Run Revit integration tests bash invoke-revit-tests.sh --smart --tool GM # Run headless tests dotnet test testing/DBTools.BuildArtifacts.Tests/DBTools.BuildArtifacts.Tests.csproj -c Release Architecture Overview ┌─────────────────────────────────────────────────────────────┐ │ Revit │ ├─────────────────────────────────────────────────────────────┤ │ DBTools.Loader │ │ (Revit Add-in Entry Point) │ ├─────────────────────────────────────────────────────────────┤ │ DBTools.App │ │ (Application Shell, Ribbon UI) │ ├──────────────┬──────────────┬──────────────┬────────────────┤ │ GM Tool │ SGT Tool │ Other Tools │ Settings │ ├──────────────┴──────────────┴──────────────┴────────────────┤ │ DBTools.Core │ │ (Shared Infrastructure, Transactions, UI) │ ├─────────────────────────────────────────────────────────────┤ │ DBTools.Themes │ │ (UI Theming System) │ └─────────────────────────────────────────────────────────────┘ Key Concepts Manifest-Driven Tools Each tool declares its configuration via manifest.yml: Ribbon button definitions Command types and availability Settings schemas Sandbox windows for validation Single-DLL Deployment All tool code compiles into DBTools.dll via MSBuild file-linking. Dependencies are embedded as resources and extracted at runtime. Window-Scoped Theming WPF themes apply at window level (not application level) to avoid conflicts with other Revit add-ins. Documentation Sections Architecture System Overview Build Pipeline Test Pipeline Project References ILRepack & Embedding Sandbox Validator Theme System Projects DBTools.Core DBTools.App DBTools.Loader DBTools.Sandbox DBTools.Themes Tools (Technical) Internal implementation details for each tool. Developing Creating New Tools Leveraging Modularity Settings Packs (coming soon) Feature Warnings (coming soon) Hooks (coming soon) Sandbox Integration (coming soon) Testing Tools (coming soon) Troubleshooting See Troubleshooting for common issues and solutions."
  },
  "developer-guide/projects/app.html": {
    "href": "developer-guide/projects/app.html",
    "title": "DBTools.App | DB Tools",
    "summary": "DBTools.App Purpose: Main application assembly containing all tools and bootstrapping logic. Output: DBTools.dll Target Frameworks: net48, net8.0-windows Overview DBTools.App is the main application assembly that compiles to DBTools.dll. It is loaded by DBTools.Loader and serves as the host for all tool implementations, the dependency injection container, ribbon composition, and Revit lifecycle management. This project uses file linking to compile tool source code from src/Tools/ into the single DBTools.dll assembly. Individual tool projects exist primarily for IDE organization, isolated testing, and XAML designer support, but at runtime everything executes within this unified assembly. Source: csharp/src/DBTools.App/DBTools.App.csproj:1-13 Responsibilities Responsibility Implementation Application entry point AddinEntry implements IExternalApplication Runtime initialization AppRuntimeFactory creates DiAppRuntime DI container setup DbtServiceBootstrapper.Build() registers all services Tool discovery DbtToolModuleCatalog.Discover() scans embedded YAML manifests Ribbon composition DbtRibbonComposer creates tab, panels, and buttons Hook coordination DbtHookHost dispatches view-activated and contextual ribbon events Test API hosting TestApiHost enables API calls from test harnesses File-linked tool compilation MSBuild items compile src/Tools/**/*.cs into this assembly Source: csharp/src/DBTools.App/Addin/AddinEntry.cs:29-247 Key Components AddinEntry (Application Entry Point) The AddinEntry class is the inner application entry point, loaded by DBTools.Loader.AddinEntry after assembly resolution is configured. public class AddinEntry : IExternalApplication { public static IRevitTask? RevitTask { get; private set; } private static DbtHookHost? _hookHost; private static DbtToolRegistry? _toolRegistry; private static DbtRibbonComposer? _ribbonComposer; public Result OnStartup(UIControlledApplication application) { ... } public Result OnShutdown(UIControlledApplication application) { ... } } Source: csharp/src/DBTools.App/Addin/AddinEntry.cs:29-43 Key Static Fields: RevitTask - The IRevitTask for marshaling work to Revit's UI thread _hookHost - Coordinates view-activated and contextual ribbon hooks _toolRegistry - Registry of discovered tool commands _ribbonComposer - Manages ribbon tab/panel creation Source: csharp/src/DBTools.App/Addin/AddinEntry.cs:33-36 Bootstrap System AppRuntimeFactory Factory class that creates the application runtime: public static class AppRuntimeFactory { public static IAppRuntime Create() => new DiAppRuntime(); } Source: csharp/src/DBTools.App/Bootstrap/AppRuntimeFactory.cs:5-8 DiAppRuntime The DI-based implementation of IAppRuntime that owns the service provider: public sealed class DiAppRuntime : IAppRuntime { private readonly IServiceProvider _root; public DiAppRuntime() { var root = DbtServiceBootstrapper.Build(); _root = root.Services; _logger = _root.GetRequiredService<ILogger<DiAppRuntime>>(); _settings = _root.GetRequiredService<ISettingsProvider>(); } public IAppRunScope CreateRunScope(UIApplication uiapp, RevitRunScopeProfile profile) { var scope = _root.GetRequiredService<IServiceScopeFactory>().CreateScope(); var rsFactory = scope.ServiceProvider.GetRequiredService<IRevitRunScopeFactory>(); var accessor = scope.ServiceProvider.GetRequiredService<IRevitRunScopeAccessor>(); var rs = rsFactory.CreateScope(uiapp, profile); accessor.Current = rs; return new DiRunScope(scope); } } Source: csharp/src/DBTools.App/Bootstrap/DiAppRuntime.cs:17-62 DbtServiceBootstrapper The central DI container builder that registers all services: public static class DbtServiceBootstrapper { public static DbtServiceRoot Build(Action<IServiceCollection>? configure = null) { // 1. Create logging host // 2. Load configuration from settings.json // 3. Register core services // 4. Discover and register tool modules // 5. Start hosted services } } Source: csharp/src/DBTools.App/Bootstrap/DbtServiceBootstrapper.cs:163-248 Service Categories Registered: Logging - IDbtLoggingHost, ILoggerFactory, ILogger<T> Debug - IDebugModeService (session-only) Settings - IOptionsMonitor<T>, IOptionsWriter, ISettingsProvider Revit Scope - IRevitRunScopeFactory, IRevitRunScopeAccessor, IRevitCallGate Transactions - ITransactionRunner, ITransactionGroupService Execution - ISafeExecutor, IAlertService Hosted Services - ILoggerWindowManager, HostedServiceCoordinator Source: csharp/src/DBTools.App/Bootstrap/DbtServiceBootstrapper.cs:376-437 DbtServiceRoot Container holding all initialized services: public sealed class DbtServiceRoot { public IServiceProvider Services { get; } public IConfiguration Configuration { get; } public IDbtLoggingHost LoggingHost { get; } public DbtToolRegistry ToolRegistry { get; } public IReadOnlyList<DbtToolModule> ToolModules { get; } } Source: csharp/src/DBTools.App/Bootstrap/DbtServiceBootstrapper.cs:34-67 Ribbon Composition DbtRibbonComposer Composes the DB Tools ribbon from tool specifications: public sealed class DbtRibbonComposer : IDisposable { public void Compose(DbtToolRegistry registry, Flags flags) { // 1. Create ribbon tab // 2. Create panels in defined order // 3. Build control plans for each tool // 4. Execute plans in order (push buttons, split buttons, pulldowns, stacked) // 5. Subscribe to settings changes } } Source: csharp/src/DBTools.App/Features/Ribbon/DbtRibbonComposer.cs:19-102 Control Kind Description PushButton Standard button SplitButtonItem Primary + dropdown items PulldownButtonItem Dropdown menu StackedButtonItem 2-3 buttons in vertical stack Source: csharp/src/DBTools.App/Features/Ribbon/DbtRibbonComposer.cs:159-252 Panel Order: Settings Common Structural Testing Any additional panels (alphabetical) Source: csharp/src/DBTools.App/Features/Ribbon/DbtRibbonComposer.cs:109-121 RibbonDefinition Defines ribbon constants (tab name, panel names, command names): public static class RibbonDefinition { public const string TabName = SettingsConstants.Ribbon.TabName; public static class Panels { public const string Settings = SettingsConstants.Ribbon.Panels.Settings; public const string Structural = SettingsConstants.Ribbon.Panels.Structural; public const string Testing = SettingsConstants.Ribbon.Panels.Testing; public const string Common = SettingsConstants.Ribbon.Panels.Common; } } Source: csharp/src/DBTools.App/Features/Ribbon/RibbonDefinition.cs:5-21 Availability Predicates Located in Tools/Availability/, these classes control when ribbon buttons are enabled. DbtDocumentAvailability Requires an active document to be open: public sealed class DbtDocumentAvailability : IExternalCommandAvailability { public bool IsCommandAvailable(UIApplication applicationData, CategorySet selectedCategories) { return applicationData?.ActiveUIDocument?.Document != null; } } Source: csharp/src/DBTools.App/Tools/Availability/DbtDocumentAvailability.cs:10-16 DbtSelectionAvailability Base class requiring element selection, with optional category filtering: public class DbtSelectionAvailability : IExternalCommandAvailability { protected virtual BuiltInCategory[]? RequiredCategories => null; protected virtual bool IsElementMatch(Element element) => true; public bool IsCommandAvailable(UIApplication applicationData, CategorySet selectedCategories) { // Check for selection and optional category/element matching } } Source: csharp/src/DBTools.App/Tools/Availability/DbtSelectionAvailability.cs:13-52 DbtStructuralFramingSelectionAvailability Requires structural framing selection: public sealed class DbtStructuralFramingSelectionAvailability : DbtSelectionAvailability { protected override BuiltInCategory[]? RequiredCategories => new[] { BuiltInCategory.OST_StructuralFraming }; } Source: csharp/src/DBTools.App/Tools/Availability/DbtSelectionAvailability.cs:57-60 Hooks System AppHookModule The application-level hook module that registers view-activated handlers: public sealed class AppHookModule : DbtToolModule { public override void RegisterServices(IServiceCollection services, DbtToolManifest manifest) { services.AddSingleton<ViewActivatedHookHandler, ViewActivatedHookHandler>(); } public override void RegisterHooks(DbtToolRegistry registry, DbtToolManifest manifest) { registry.RegisterHook<IViewActivatedHookHandler, ViewActivatedHookHandler>(); } } Source: csharp/src/DBTools.App/Features/Hooks/AppHookModule.cs:7-22 TestApiHost Static host for test harness integration, providing API access outside Revit command context: public static class TestApiHost { public static bool IsInitialized { get; private set; } public static void Initialize(UIControlledApplication app) { // Create ExternalEvent handler and UIApplication.Idling subscription } public static Task<object?> RunAsync(Func<object, Task<object?>> work) { // Queue work and raise ExternalEvent } } Source: csharp/src/DBTools.App/Addin/TestApiHost.cs:9-123 OnStartup Sequence The complete startup flow with source references: 1. Set Revit year from VersionNumber (for per-instance log files) > Source: AddinEntry.cs:55-66 2. Initialize AppRuntime via AppRuntimeFactory.Create() > Source: AddinEntry.cs:72 3. Resolve ISafeExecutor, DbtToolRegistry, DbtHookHost > Source: AddinEntry.cs:74-76 4. Validate theme (mandatory - fails startup if broken) > Source: AddinEntry.cs:106-113 5. Detect RevitTest environment > Source: AddinEntry.cs:116, 573-629 6. Register deferred UI startup handlers (ApplicationInitialized, Idling) > Source: AddinEntry.cs:125-127 7. Execute startup task via ISafeExecutor.RunAsync: a. Try binding global window owner (may be deferred) b. Initialize DialogGuardianHook c. Initialize RevitTaskService (if not RevitTest) d. Attach DbtHookHost (if not RevitTest) e. Initialize TestApiHost (if not RevitTest) > Source: AddinEntry.cs:133-178 8. Create ribbon synchronously (Revit API requirement): a. Get Flags settings b. Create DbtRibbonComposer c. Call Compose() with registry and flags d. Publish warning changes > Source: AddinEntry.cs:217-244 9. Return Result.Succeeded > Source: AddinEntry.cs:246 Deferred UI Startup Certain operations run after ApplicationInitialized/Idling to ensure Revit is fully ready: private static Task RunDeferredUiStartupAsync(...) { return executor.RunAsync(async () => { // 1. Ensure global window owner is bound await EnsureGlobalWindowOwnerBoundAsync(logger); // 2. Apply ribbon special effects (visual styling) await RibbonSpecialEffects.ApplyAsync(logger); // 3. Show logger window if debug mode enabled loggerWindowManager.ShowIfDebugEnabled(); }, ...); } Source: csharp/src/DBTools.App/Addin/AddinEntry.cs:421-479 OnShutdown Sequence 1. Wait for startup task completion (5s timeout) > Source: AddinEntry.cs:265-274 2. Unregister deferred UI handlers > Source: AddinEntry.cs:276 3. Detach DbtHookHost > Source: AddinEntry.cs:278 4. Shutdown DialogGuardianHook > Source: AddinEntry.cs:281 5. Shutdown TestApiHost > Source: AddinEntry.cs:284 6. Dispose RevitTaskService > Source: AddinEntry.cs:287 7. Dispose DbtRibbonComposer > Source: AddinEntry.cs:292 8. Stop hosted services > Source: AddinEntry.cs:303 9. Dispose logging host > Source: AddinEntry.cs:306 Source: csharp/src/DBTools.App/Addin/AddinEntry.cs:250-325 File Linking Strategy DBTools.App compiles tool source code via MSBuild file linking. Source files remain in their respective src/Tools/ directories but are compiled into the single DBTools.dll assembly. Source File Linking <ItemGroup Label=\"Tool Source Files\"> <Compile Include=\"..\\Tools\\**\\*.cs\" Exclude=\"..\\Tools\\**\\Tests\\**\\*.cs;..\\Tools\\**\\obj\\**\\*.cs\" Link=\"Tools\\%(RecursiveDir)%(Filename)%(Extension)\" /> </ItemGroup> Source: csharp/src/DBTools.App/DBTools.App.csproj:63-67 XAML File Linking <ItemGroup Label=\"Tool XAML Files\"> <Page Include=\"..\\Tools\\**\\*.xaml\" Exclude=\"..\\Tools\\**\\obj\\**\\*.xaml;..\\Tools\\**\\Properties\\DesignTimeResources.xaml\" Link=\"Tools\\%(RecursiveDir)%(Filename)%(Extension)\" /> </ItemGroup> Source: csharp/src/DBTools.App/DBTools.App.csproj:69-73 Tool Assets (Embedded Icons) <ItemGroup Label=\"Tool Embedded Assets\"> <EmbeddedResource Include=\"..\\Tools\\**\\Assets\\*.png\" Link=\"Resources\\Icons\\%(RecursiveDir)%(Filename)%(Extension)\" /> </ItemGroup> Source: csharp/src/DBTools.App/DBTools.App.csproj:75-78 Tool Manifests (Embedded YAML) <ItemGroup> <EmbeddedResource Include=\"manifest.yml\" LogicalName=\"DBTools.ToolManifests.DBTools.AppHooks.yml\" /> <EmbeddedResource Include=\"..\\Tools\\**\\manifest.yml\" LogicalName=\"DBTools.ToolManifests.%(RecursiveDir)%(Filename)%(Extension)\" /> </ItemGroup> Source: csharp/src/DBTools.App/DBTools.App.csproj:218-222 Why File Linking? Single assembly deployment - Reduces complexity and potential conflicts IDE organization - Tools can have separate projects for development Isolated testing - Test projects reference tool projects directly XAML designer support - Individual projects can have design-time resources Tool Module Discovery Tools are discovered via embedded YAML manifests during DbtServiceBootstrapper.Build(): var rootAssembly = typeof(DbtServiceBootstrapper).Assembly; var discovery = DbtToolModuleCatalog.Discover(rootAssembly); foreach (var entry in discovery.Entries) { var module = entry.Module; module.RegisterSettings(services, configuration, entry.Manifest); module.RegisterServices(services, entry.Manifest); module.RegisterSettingsPacks(services, entry.Manifest); module.RegisterHooks(registry, entry.Manifest); RegisterRibbonToolsFromManifest(registry, rootAssembly, entry.Manifest); } Source: csharp/src/DBTools.App/Bootstrap/DbtServiceBootstrapper.cs:194-237 Manifest Structure Example tool manifest (manifest.yml): id: DBTools.GM assembly: DBTools moduleType: DBTools.GM.GmToolModule order: 0 sandboxWindows: - id: DBTools.GM.Main displayName: \"Global Mapper\" windowType: \"DBTools.GM.Shell.UI.Views.GmWindow\" tool: ribbonTools: - internalName: DBTools.GM commandType: DBTools.GM.Features.GmCommand availabilityType: DBTools.App.Tools.Availability.DbtDocumentAvailability runProfile: InlineUi displayText: \"Global Mapper\" iconBaseKey: gm tooltip: \"Open Global Mapper\" controlKind: PushButton order: 30 Source: csharp/src/Tools/Common/GM/manifest.yml:1-27 Dependencies Project References Project Purpose DBTools.Core Core infrastructure and abstractions DBTools.Themes WPF theme resources Source: csharp/src/DBTools.App/DBTools.App.csproj:57-59 NuGet Packages Package Purpose Microsoft.Extensions.DependencyInjection DI container Microsoft.Extensions.Options.ConfigurationExtensions Options pattern Microsoft.Extensions.Configuration.* Configuration binding ricaun.Revit.UI Ribbon utilities ricaun.Revit.UI.Tasks RevitTask for async CommunityToolkit.Mvvm MVVM for tools JsonDiffPatch.Net JSON diff (tools) AutoMapper Object mapping (tools) HelixToolkit.Wpf.SharpDX 3D visualization (tools) Source: csharp/src/DBTools.App/DBTools.App.csproj:27-87 Vendored Assemblies Assembly Purpose DBTools.Fluent.Ribbon Ribbon UI for tool windows DBTools.ControlzEx Window chrome and behaviors Source: csharp/src/DBTools.App/DBTools.App.csproj:89-98 Revit API References net48: <Reference Include=\"RevitAPI\"> <HintPath>$(REVIT2024_DIR)\\RevitAPI.dll</HintPath> <Private>false</Private> </Reference> Source: csharp/src/DBTools.App/DBTools.App.csproj:114-134 net8.0-windows: <Reference Include=\"RevitAPI\" Condition=\"'$(REVIT_NET8_DIR)'!=''\"> <HintPath>$(REVIT_NET8_DIR)\\RevitAPI.dll</HintPath> <Private>false</Private> </Reference> Source: csharp/src/DBTools.App/DBTools.App.csproj:143-165 Assembly Embedding All CopyLocal dependencies (except forbidden host assemblies) are embedded as resources for single-DLL deployment: <Target Name=\"DBT_EmbedCopyLocalAssemblies\" AfterTargets=\"ResolveReferences\"> <ItemGroup> <_EmbedCandidate Include=\"@(ReferenceCopyLocalPaths)\" ... /> <!-- Exclude Revit host assemblies --> <_EmbedCandidate Remove=\"...\" Condition=\"'%(Filename)%(Extension)' == 'RevitAPI.dll'\" /> <!-- Exclude WPF theme assemblies (need file Location for pack:// URIs) --> <_EmbedCandidate Remove=\"...\" Condition=\"StartsWith('DBTools.Fluent.Ribbon')\" /> </ItemGroup> <EmbeddedResource Include=\"%(_EmbedLogicalDistinct.SourcePath)\" LogicalName=\"DBTools.EmbeddedAssemblies.%(Name).dll\" /> </Target> Source: csharp/src/DBTools.App/DBTools.App.csproj:234-270 Forbidden Host Assemblies These assemblies must never be in the output (Revit provides them): <ItemGroup> <ForbiddenHostAssembly Include=\"RevitAPI.dll\" /> <ForbiddenHostAssembly Include=\"RevitAPIUI.dll\" /> <ForbiddenHostAssembly Include=\"AdWindows.dll\" /> <ForbiddenHostAssembly Include=\"UIFramework.dll\" /> <ForbiddenHostAssembly Include=\"Newtonsoft.Json.dll\" /> </ItemGroup> Source: csharp/src/DBTools.App/DBTools.App.csproj:169-177 Build Configuration Project Properties <PropertyGroup> <TargetFrameworks>$(DBT_RevitTargetFrameworks)</TargetFrameworks> <AssemblyName>DBTools</AssemblyName> <RootNamespace>DBTools.App</RootNamespace> <UseWPF>true</UseWPF> <ILRepackEnabled>false</ILRepackEnabled> </PropertyGroup> Source: csharp/src/DBTools.App/DBTools.App.csproj:2-13 InternalsVisibleTo Test assemblies can access internal types: <ItemGroup> <InternalsVisibleTo Include=\"DBTools.GM.Tests\" /> <InternalsVisibleTo Include=\"DBTools.SGT.Tests\" /> <InternalsVisibleTo Include=\"DBTools.TDV.Tests\" /> <InternalsVisibleTo Include=\"DBTools.Testing.Tests\" /> </ItemGroup> Source: csharp/src/DBTools.App/DBTools.App.csproj:15-20 Warning Suppressions Tool code suppressions consolidated from individual tool projects: <NoWarn>$(NoWarn);CS0618;CS0649;CS8600;CS8602;CS8603;CS8604;CS8619;CS8620; MA0038;MA0051;MA0048;MA0016;MA0098;MA0004;MA0008;MA0015; CA1068;CA1707;CA1716;CA1720;CA1722;CA1725;CA1822</NoWarn> Source: csharp/src/DBTools.App/DBTools.App.csproj:136-138 File Structure csharp/src/DBTools.App/ +-- DBTools.App.csproj +-- manifest.yml # AppHooks module manifest +-- GlobalUsings.cs +-- GlobalSuppressions.cs +-- AssemblyInfo.cs +-- Addin/ | +-- AddinEntry.cs # IExternalApplication entry point | +-- TestApiHost.cs # Test harness API host +-- Bootstrap/ | +-- AppRuntimeFactory.cs # Creates DiAppRuntime | +-- DiAppRuntime.cs # IAppRuntime implementation | +-- DbtServiceBootstrapper.cs # DI container builder | +-- Startup.cs # Legacy startup helper +-- Features/ | +-- Hooks/ | | +-- AppHookModule.cs # Application-level hooks | | +-- ViewActivatedHookHandler.cs | | +-- DialogGuardianHook.cs | +-- Ribbon/ | +-- DbtRibbonComposer.cs # Ribbon composition | +-- RibbonDefinition.cs # Tab/panel constants | +-- RibbonRegistry.cs # Runtime button registry | +-- RibbonSettingsListener.cs | +-- RibbonSpecialEffects.cs | +-- RevitRibbonBuilder.cs +-- Tools/ | +-- Availability/ | +-- DbtDocumentAvailability.cs | +-- DbtSelectionAvailability.cs | +-- DbtActiveViewAvailability.cs +-- Resources/ +-- (Ribbon icons - embedded resources) RevitTest Environment Detection AddinEntry detects when running under ricaun.RevitTest and adjusts behavior: private static bool DetectRevitTestEnvironment(UIControlledApplication application, ILogger logger) { bool hostBoundToRevitTest = RevitTaskAccessor.RevitTask != null; bool hasRevitTestAssembly = AppDomain.CurrentDomain.GetAssemblies() .Any(a => a.GetName().Name == \"ricaun.RevitTest.Application\" || a.GetName().Name == \"ricaun.RevitTest\"); bool isRevitTestFlag = RevitExecutionContext.IsRevitTest; return hostBoundToRevitTest || hasRevitTestAssembly || isRevitTestFlag; } Source: csharp/src/DBTools.App/Addin/AddinEntry.cs:573-629 Skipped in RevitTest: RevitTaskService initialization (test host provides its own) DbtHookHost attachment TestApiHost initialization Error Handling Startup Errors Fatal errors during startup show a message box and return Result.Failed: private static void TryShowStartupError(string message) { // Try WPF MessageBox first MessageBox.Show(message, \"DB Tools\", MessageBoxButton.OK, MessageBoxImage.Error, ...); // Fall back to Win32 MessageBoxW if WPF fails MessageBoxW(IntPtr.Zero, text, caption, MB_OK | MB_ICONERROR); } Source: csharp/src/DBTools.App/Addin/AddinEntry.cs:481-535 Theme Validation Theme validation is mandatory - if it fails, startup aborts: try { DbtThemeValidator.ValidateOrThrow(); } catch (Exception ex) { logger.LogError(ex, \"[AddinEntry] Theme validation failed; aborting add-in startup.\"); TryShowStartupError($\"DB Tools theme failed to load:\\n\\n{ex.GetBaseException().Message}\"); return Result.Failed; } Source: csharp/src/DBTools.App/Addin/AddinEntry.cs:104-113 Troubleshooting \"Theme validation failed\" Error Cause: WPF theme assemblies (Fluent.Ribbon, ControlzEx) not found. Solution: Ensure %APPDATA%/DBTools/vendor/ contains theme assemblies Or rebuild with bash csharp/build.sh --clean BuildAll Ribbon Not Appearing Possible Causes: Tool manifests not embedded (check build output) Tool command type not found (check namespace/assembly in manifest) Availability type resolution failed (check availabilityType in manifest) Diagnosis: Enable debug mode and check log file for errors during Compose(). Tools Disabled Unexpectedly Check: Availability predicate in manifest.yml Flags settings (some tools check flags.EnableTesting) IExternalCommandAvailability implementation returning false Related Documentation Architecture Overview - High-level system architecture Project References - How projects relate DBTools.Loader - Bootstrap assembly that loads DBTools.App DBTools.Core - Core infrastructure library Source Files Reviewed File Purpose csharp/src/DBTools.App/DBTools.App.csproj Project configuration csharp/src/DBTools.App/Addin/AddinEntry.cs Application entry point csharp/src/DBTools.App/Addin/TestApiHost.cs Test harness API csharp/src/DBTools.App/Bootstrap/AppRuntimeFactory.cs Runtime factory csharp/src/DBTools.App/Bootstrap/DiAppRuntime.cs DI-based runtime csharp/src/DBTools.App/Bootstrap/DbtServiceBootstrapper.cs DI container builder csharp/src/DBTools.App/Bootstrap/Startup.cs Legacy startup helper csharp/src/DBTools.App/Features/Ribbon/DbtRibbonComposer.cs Ribbon composition csharp/src/DBTools.App/Features/Ribbon/RibbonDefinition.cs Ribbon constants csharp/src/DBTools.App/Features/Hooks/AppHookModule.cs Application hooks csharp/src/DBTools.App/Tools/Availability/DbtDocumentAvailability.cs Document availability csharp/src/DBTools.App/Tools/Availability/DbtSelectionAvailability.cs Selection availability csharp/src/DBTools.App/manifest.yml AppHooks manifest csharp/src/Tools/Common/GM/manifest.yml Example tool manifest csharp/src/DBTools.Core/Tools/DbtHookHost.cs Hook coordination (Core) UNVERIFIED Items"
  },
  "developer-guide/projects/core.html": {
    "href": "developer-guide/projects/core.html",
    "title": "DBTools.Core | DB Tools",
    "summary": "DBTools.Core DBTools.Core is the foundational library providing shared infrastructure for all DBTools components. It contains Revit execution abstractions, transaction management, safe execution patterns, logging infrastructure, settings management, tool module system, and shared UI components. Overview DBTools.Core serves as the central infrastructure layer, abstracting away Revit API complexities while providing consistent patterns for error handling, logging, and dependency injection across all tools. Property Value Assembly Name DBTools.Core.dll Target Frameworks net48, net8.0-windows WPF Support Yes (UseWPF=true) Nullable Enabled Source: csharp/src/DBTools.Core/DBTools.Core.csproj:1-10 Responsibilities Revit Execution Abstraction - Thread-safe API access via call gates and run scopes Transaction Management - Unified transaction/subtransaction handling with automatic rollback Safe Execution - Centralized error handling with user notification and logging Logging Infrastructure - Serilog-based structured logging with UI sink Settings System - Type-safe options pattern with persistence and validation Tool Module System - Discovery, registration, and lifecycle management for tools Shared UI Components - Window bases, alert dialogs, progress overlays, and behaviors Key Components Revit Execution Layer IRevitCallGate The unified entry point for executing Revit API callbacks, supporting both inline (modal) and queued (modeless) execution modes. public interface IRevitCallGate { bool InGate { get; } Task<T> RunAsync<T>(Func<UIApplication, T> work, CancellationToken ct = default, RevitCallMode mode = RevitCallMode.Auto); Task RunAsync(Action<UIApplication> work, CancellationToken ct = default, RevitCallMode mode = RevitCallMode.Auto); } Source: csharp/src/DBTools.Core/Revit/Execution/IRevitCallGate.cs:8-28 Mode Description Auto Execute inline if valid context exists; otherwise queue InlineOnly Execute inline only; throw if context unavailable ForceQueue Always queue via ExternalEvent/RevitTask RequiresActiveView Require an active UIDocument before executing Source: csharp/src/DBTools.Core/Revit/Execution/IRevitCallGate.cs:30-51 IRevitRunScope Represents a single Revit run scope (command, modeless session, or test). Owns UI/document context plus call gate and transaction services. public interface IRevitRunScope { UIApplication UIApplication { get; } IRevitCallGate CallGate { get; } ITransactionRunner TransactionRunner { get; } ITransactionGroupService TransactionGroupService { get; } UIDocument GetActiveUiDocument(); Document GetActiveDocument(); Document GetLockedDocument(Document expectedDocument, string? context = null); } Source: csharp/src/DBTools.Core/Revit/Execution/IRevitRunScope.cs:11-20 Profile Use Case Implementation InlineUi Modal commands and RevitTest ModalInlineCallGate + CallGateTransactionRunner QueuedModeless Long-running/modeless tools ModelessQueuedCallGate + RevitTaskService Source: csharp/src/DBTools.Core/Revit/Execution/IRevitRunScope.cs:22-36 ModalInlineCallGate Call-gate implementation that executes delegates inline on the Revit UI thread using a supplied UIApplication. Used for modal command execution. public sealed class ModalInlineCallGate : IRevitCallGate { public ModalInlineCallGate(UIApplication uiapp) { ... } public bool InGate => _inGate.Value; public Task<T> RunAsync<T>(Func<UIApplication, T> work, ...) { ... } } Source: csharp/src/DBTools.Core/Revit/Execution/ModalInlineCallGate.cs:10-74 Transaction Management ITransactionRunner Provides a unified API for executing Revit model modifications with automatic transaction management. public interface ITransactionRunner { Task RunAsync(string name, Action action, CancellationToken ct = default); Task<T> RunAsync<T>(string name, Func<T> action, CancellationToken ct = default); Task RunAsync(string name, Action<Document> action, CancellationToken ct = default); Task<T> RunAsync<T>(string name, Func<Document, T> action, CancellationToken ct = default); // Additional overloads with UIApplication access and explicit Document } Source: csharp/src/DBTools.Core/Revit/Transactions/ITransactionRunner.cs:6-53 CallGateTransactionRunner The primary implementation that wraps all Revit API calls in properly managed transactions: Auto-selects transaction type: Uses SubTransaction if doc.IsModifiable (already in transaction), otherwise creates new Transaction Cross-document protection: Prevents starting transactions on Document B while Document A is modifiable Failure handling: Attaches SilentFailuresPreprocessor to suppress non-critical Revit warnings Source: csharp/src/DBTools.Core/Revit/Transactions/CallGateTransactionRunner.cs:9-390 Usage Example: // Basic modification with automatic transaction await _transactionRunner.RunAsync(\"Create Wall\", doc => { Wall.Create(doc, curve, levelId, false); }); // Get a result from a transaction var wallId = await _transactionRunner.RunAsync(\"Create Wall\", doc => { var wall = Wall.Create(doc, curve, levelId, false); return wall.Id; }); Source: csharp/src/DBTools.Core/Revit/Transactions/CallGateTransactionRunner.cs:64-79 ITransactionGroupService Manages transaction groups for operations requiring multiple undoable transactions to appear as a single undo item. public interface ITransactionGroupService { bool IsActive { get; } Task BeginAsync(string name, CancellationToken ct = default); Task FinalizeAsync(bool commit, CancellationToken ct = default); Task RunAsync(string name, bool commit, Func<Task> work, CancellationToken ct = default); } Source: csharp/src/DBTools.Core/Revit/Transactions/ITransactionGroupService.cs:1-14 Safe Execution ISafeExecutor The central error handling service. All tool entrypoints must execute within ISafeExecutor. public interface ISafeExecutor { Task RunAsync(Func<Task> action, ILogger logger, IErrorNotifier? notifier = null, CancellationToken ct = default); Task RunAsync(Func<Task> action, ILogger logger, IErrorNotifier? notifier, SafeExecutor.SafeExecuteOptions? opts, CancellationToken ct = default); } Source: csharp/src/DBTools.Core/Execution/ISafeExecutor.cs:6-16 SafeExecutor Implementation Provides comprehensive error handling: Correlation IDs: Each execution gets a unique GUID for log correlation Timing: Tracks elapsed milliseconds for performance analysis Exception logging: Logs full exception details including inner exceptions and XAML parse context User notification: Shows error banners via IErrorNotifier Debug mode: Automatically enables debug mode and shows logger window on fatal errors Lifecycle hooks: Optional OnSuccessAsync, OnCancelAsync, OnErrorAsync callbacks Source: csharp/src/DBTools.Core/Execution/SafeExecutor.cs:12-467 SafeExecuteOptions: public sealed class SafeExecuteOptions { public string? Name { get; set; } public bool LogStart { get; set; } = true; public bool ShowCompletionToUser { get; set; } public Guid? CorrelationId { get; set; } public Func<Task>? OnSuccessAsync { get; set; } public Func<Task>? OnCancelAsync { get; set; } public Func<Exception, Task>? OnErrorAsync { get; set; } public NotifyKindKind NotifyKind { get; set; } = NotifyKindKind.Success; } Source: csharp/src/DBTools.Core/Execution/SafeExecutor.cs:451-466 DbtToolCommand Base Class Abstract base class for Revit commands that enforces ISafeExecutor usage, run-scope creation, and centralized error notification. public abstract class DbtToolCommand : IExternalCommand { public Result Execute(ExternalCommandData commandData, ref string message, ElementSet elements) { // Wraps execution in ISafeExecutor, creates run scope } protected abstract Task RunAsync(IDbtToolContext context); // Convenience methods protected static T GetService<T>(IDbtToolContext context) where T : notnull; protected static Task<T> RunInRevitAsync<T>(IDbtToolContext context, Func<UIApplication, T> work, ...); protected static bool? ShowToolWindow<TWindow>(Func<TWindow> windowFactory) where TWindow : Window; } Source: csharp/src/DBTools.Core/Revit/Execution/DbtToolCommand.cs:35-238 Tool Context IDbtToolContext Ambient context provided to DBT tool commands, wrapping the current Revit run scope, DI scope, and shared services. public interface IDbtToolContext { ExternalCommandData CommandData { get; } UIApplication UIApplication { get; } UIDocument UIDocument { get; } Document Document { get; } IAppRunScope RunScope { get; } IRevitRunScope RevitRunScope { get; } ILogger Logger { get; } IErrorNotifier ErrorNotifier { get; } RevitRunScopeProfile RunProfile { get; } T Resolve<T>() where T : notnull; } Source: csharp/src/DBTools.Core/Revit/Execution/IDbtToolContext.cs:14-27 Runtime AppRuntime Static accessor for the application runtime. Provides global access to services when DI is not available (e.g., Revit's parameterless constructor requirement). public static class AppRuntime { public static bool IsInitialized { get; } public static void Initialize(IAppRuntime runtime); public static void InitializeIfNeeded(Func<IAppRuntime> factory); public static ILogger Logger { get; } public static ISettingsProvider Settings { get; } public static IAppRunScope CreateRunScope(UIApplication uiapp, RevitRunScopeProfile profile); public static T Resolve<T>() where T : notnull; } Source: csharp/src/DBTools.Core/Runtime/AppRuntime.cs:8-155 IAppRuntime Interface for the application runtime container. public interface IAppRuntime { ILogger Logger { get; } ISettingsProvider Settings { get; } IAppRunScope CreateRunScope(UIApplication uiapp, RevitRunScopeProfile profile); T Resolve<T>() where T : notnull; } Source: csharp/src/DBTools.Core/Runtime/IAppRuntime.cs:8-16 IAppRunScope Scoped DI container for per-command lifetimes. public interface IAppRunScope : IDisposable { T Resolve<T>() where T : notnull; } Source: csharp/src/DBTools.Core/Runtime/IAppRunScope.cs:5-8 Logging Infrastructure IDbtLoggingHost Central logging host that implements ILoggerFactory directly. public interface IDbtLoggingHost : ILoggerFactory, IDisposable { SerilogUiSink UiSink { get; } bool IsDebugMode { get; } void SetDebugMode(bool enabled); ILoggerFactory LoggerFactory { get; } string InstanceId { get; } int? RevitYear { get; } string? LogFilePath { get; } } Source: csharp/src/DBTools.Core/Logging/DbtLoggingHost.cs:21-33 DbtLoggingHost Implementation Features: Serilog integration: Uses Serilog with structured logging UI sink: Feeds log entries to the Logger Window File sink: Custom DbtTextFileSink avoids version conflicts with Serilog.Sinks.File Thread enrichment: Adds thread ID to all log entries Instance identification: Unique instance ID per Revit process Log rotation: Automatic cleanup of old log files by age, count, and total size Source: csharp/src/DBTools.Core/Logging/DbtLoggingHost.cs:35-226 Log File Naming: dbtools-{revitYear}-{instanceId}-{timestamp}-{nonce}.log Source: csharp/src/DBTools.Core/Logging/DbtLoggingHost.cs:88-100 Settings System ISettingsProvider Interface for reading and persisting settings. public interface ISettingsProvider { TSettings Get<TSettings>() where TSettings : class, new(); Task SaveAsync<TSettings>(string section, TSettings settings, CancellationToken ct = default) where TSettings : class; } Source: csharp/src/DBTools.Core/Settings/ISettingsProvider.cs:1-8 DbtSettingsRegistry Registry for settings pack definitions, enabling the Settings Window to discover and display tool-specific settings. public sealed class DbtSettingsRegistry { public IReadOnlyCollection<IDbtSettingsPackDefinition> Definitions { get; } public void Register(IDbtSettingsPackDefinition definition); public bool Unregister(string key); public IEnumerable<IDbtSettingsPackDefinition> ForPanel(string ribbonPanel); public IEnumerable<IDbtSettingsWarningDefinition> WarningDefinitions(); } Source: csharp/src/DBTools.Core/Settings/DbtSettingsRegistry.cs:8-62 DbtToolSettingsPack Generic container for tool settings with validation support. public sealed class DbtToolSettingsPack<TOptions> : IDbtToolSettingsPack { public string Key { get; } public string Title { get; } public string RibbonPanel { get; } public Type OptionsType { get; } public object Context { get; } public object CreateDefaultOptions(); public object BuildOptionsSnapshot(); public Task<DbtSettingsValidationResult> ValidateAsync(CancellationToken ct = default); public FrameworkElement View { get; } } Source: csharp/src/DBTools.Core/Settings/DbtToolSettingsPack.cs:37-85 Tool Module System DbtToolModule Base class for tool modules to contribute DI services and tool registrations. public abstract class DbtToolModule { public virtual void RegisterSettings(IServiceCollection services, IConfiguration configuration, DbtToolManifest manifest) { } public virtual void RegisterServices(IServiceCollection services, DbtToolManifest manifest) { } public virtual void RegisterSettingsPacks(IServiceCollection services, DbtToolManifest manifest) { } public virtual void RegisterHooks(DbtToolRegistry registry, DbtToolManifest manifest) { } } Source: csharp/src/DBTools.Core/Tools/DbtToolModule.cs:9-49 DbtToolRegistry Central registry for tool registrations and hook handlers. public sealed class DbtToolRegistry { public ReadOnlyCollection<DbtToolRegistration> Tools { get; } public IReadOnlyDictionary<Type, IReadOnlyCollection<Type>> HookRegistrations { get; } public void RegisterTool(DbtToolRegistration registration); public void RegisterHook<THook, TImplementation>() where THook : class where TImplementation : class, THook; public Type[] GetHookImplementations<THook>() where THook : class; } Source: csharp/src/DBTools.Core/Tools/DbtToolRegistry.cs:9-83 DbtToolRegistration Encapsulates a tool command registration with ribbon configuration. public sealed class DbtToolRegistration { public Type CommandType { get; } public Type? AvailabilityType { get; } public RevitRunScopeProfile RunProfile { get; } public DbtToolRibbonSpec Ribbon { get; } public Func<Flags, bool>? AvailabilityPredicate { get; init; } } Source: csharp/src/DBTools.Core/Tools/DbtToolRegistration.cs:8-38 DbtToolManifest YAML manifest structure for tool discovery. public sealed class DbtToolManifest { public string Id { get; set; } public string Assembly { get; set; } public string ModuleType { get; set; } public int? Order { get; set; } public List<DbtSandboxWindowManifest>? SandboxWindows { get; set; } public DbtToolMetadataManifest? Tool { get; set; } } Source: csharp/src/DBTools.Core/Tools/DbtToolManifest.cs:5-13 DbtHookHost Coordinates application-level hooks, dispatching events to registered handlers. Supported Hook Interfaces: IViewActivatedHookHandler - Called when views are activated IContextualRibbonInjector - For contextual ribbon panel initialization public sealed class DbtHookHost { public void Attach(UIControlledApplication application); public Task AttachAsync(UIControlledApplication application, CancellationToken ct); public void Detach(UIControlledApplication application); } Source: csharp/src/DBTools.Core/Tools/DbtHookHost.cs:28-244 UI Components DbtWindowBase Modal-first base window for DBT. Hosts the progress overlay and central UI error boundary. public class DbtWindowBase : Window, IWindowWithOwnerProvider, IThemeOptOut { public IWindowOwnerProvider? OwnerProvider { get; set; } public bool UseDefaultTheme { get; set; } } Source: csharp/src/DBTools.Core/UI/Windows/DbtWindowBase.cs:27-47 IAlertService Service for showing alert dialogs with various body types. public interface IAlertService { AlertResult Show(AlertRequest request); bool Confirm(string message, string title = \"DB Tools\"); T? SelectSingle<T>(IEnumerable<T> items, Func<T, string> displayFunc, ...); IReadOnlyList<T> SelectMultiple<T>(IEnumerable<T> items, Func<T, string> displayFunc, ...); } Source: csharp/src/DBTools.Core/UI/Alerts/Services/IAlertService.cs:5-26 IErrorNotifier Interface for displaying error/success banners to users. public interface IErrorNotifier { void ShowBanner(string title, string message); // Error (red) void ShowSuccessBanner(string title, string message); // Success (green) } Source: csharp/src/DBTools.Core/Execution/IErrorNotifier.cs:1-10 Dependencies NuGet Packages Package Purpose Newtonsoft.Json JSON serialization CSharpFunctionalExtensions Result types and functional patterns Ardalis.GuardClauses Argument validation AutoMapper Object mapping UnitsNet Units and measurements Serilog + extensions Structured logging Microsoft.Extensions.DependencyInjection Dependency injection Microsoft.Extensions.Configuration.* Configuration binding CommunityToolkit.Mvvm MVVM base classes DynamicData Reactive collections System.Reactive Reactive extensions Ookii.Dialogs.Wpf Native file dialogs ricaun.Revit.UI.Tasks Revit async task support Source: csharp/src/DBTools.Core/DBTools.Core.csproj:102-161 Vendored Assemblies Assembly Purpose DBTools.Fluent.Ribbon Ribbon UI for tool windows DBTools.ControlzEx Window chrome and behaviors Source: csharp/src/DBTools.Core/DBTools.Core.csproj:144-152 Project References Project Purpose DBTools.Themes WPF theme resources Source: csharp/src/DBTools.Core/DBTools.Core.csproj:165 Directory Structure DBTools.Core/ +-- Assets/ # Shared resources (icons) +-- Compat/ # Cross-framework compatibility utilities +-- Constants/ # Application-wide constants +-- Execution/ # Safe execution, error handling +-- Hosting/ # Service hosting infrastructure +-- IO/ # File system utilities +-- Logging/ # Serilog infrastructure, UI sink +-- Notifications/ # Banner notifications +-- Revit/ | +-- Context/ # Revit context accessors | +-- Execution/ # Call gates, run scopes, tool context | +-- Transactions/ # Transaction runners and groups | +-- Utilities/ # Revit helpers (RevitId, Failures, etc.) +-- Runtime/ # AppRuntime, IAppRunScope +-- Sandbox/ # Sandbox mode stubs +-- Settings/ # Settings infrastructure +-- Tools/ # Tool module system +-- UI/ +-- Alerts/ # Alert dialog system +-- Behaviors/ # WPF attached behaviors +-- Converters/ # Value converters +-- Icons/ # Icon loading +-- Progress/ # Progress overlay +-- Theming/ # Theme validation +-- Windows/ # Window base classes Public API Summary Revit Execution IRevitCallGate - Thread-safe Revit API execution IRevitRunScope - Command execution scope IRevitRunScopeFactory - Factory for run scopes DbtToolCommand - Base class for Revit commands IDbtToolContext - Command context interface Transaction Management ITransactionRunner - Transaction execution ITransactionGroupService - Transaction grouping Safe Execution ISafeExecutor - Centralized error handling IErrorNotifier - User notification Logging IDbtLoggingHost - Logging host interface ILogSink - Custom sink interface Settings ISettingsProvider - Settings access DbtSettingsRegistry - Settings pack registry IDbtToolSettingsPack - Settings pack interface Tool System DbtToolModule - Tool module base class DbtToolRegistry - Tool registration DbtToolManifest - Manifest structure DbtHookHost - Hook coordination UI DbtWindowBase - Window base class IAlertService - Alert dialogs IWindowOwnerProvider - Window ownership Usage Examples Creating a Tool Command public class MyToolCommand : DbtToolCommand { protected override async Task RunAsync(IDbtToolContext context) { var myService = context.Resolve<IMyService>(); // Execute Revit API work await context.RevitRunScope.TransactionRunner.RunAsync(\"My Operation\", doc => { // Modify document }); } } Using the Call Gate // Get element data from Revit (thread-safe) var result = await callGate.RunAsync(uiapp => { var doc = uiapp.ActiveUIDocument.Document; return doc.GetElement(elementId); }, ct, RevitCallMode.RequiresActiveView); Registering a Tool Module public class MyToolModule : DbtToolModule { public override void RegisterServices(IServiceCollection services, DbtToolManifest manifest) { services.AddSingleton<IMyService, MyService>(); } public override void RegisterHooks(DbtToolRegistry registry, DbtToolManifest manifest) { registry.RegisterHook<IViewActivatedHookHandler, MyViewHandler>(); } } Extension Points Custom Call Gates - Implement IRevitCallGate for specialized execution modes Hook Handlers - Register implementations of IViewActivatedHookHandler or IContextualRibbonInjector Settings Packs - Create DbtToolSettingsPack<T> instances for tool-specific settings UI Alert Bodies - Implement IAlertBody for custom alert dialog content Build Considerations Conditional Compilation Sandbox builds (DBT_IsSandboxBuild): Revit-dependent files excluded, sandbox stubs used Designer builds (DBT_IsDesignerBuild): Revit sources excluded for XAML designer wpftmp builds: Special handling for temporary projects during BAML compilation Source: csharp/src/DBTools.Core/DBTools.Core.csproj:12-99 InternalsVisibleTo Test projects and DBTools.App have access to internal types: DBTools.App DBTools.GM.Tests DBTools.SGT.Tests DBTools.TDV.Tests Source: csharp/src/DBTools.Core/DBTools.Core.csproj:27-32 Related Documentation Architecture Overview - System-wide architecture Project References - Inter-project dependencies DBTools.Loader - Revit entry point Verification Status Check Status Source anchors for all claims Yes UNVERIFIED markers where needed No (all verified) Cross-references added Yes Examples tested N/A No assumptions without evidence Yes Verified by: docs-run-20260124-020412 Date: 2026-01-24"
  },
  "developer-guide/projects/loader.html": {
    "href": "developer-guide/projects/loader.html",
    "title": "DBTools.Loader | DB Tools",
    "summary": "DBTools.Loader Purpose: Revit entry point assembly that bootstraps DBTools. Output: DBTools.Loader.dll Target Frameworks: net48, net8.0-windows Overview DBTools.Loader is the critical bootstrap component that Revit loads directly via the .addin manifest. Its sole responsibility is to load DBTools.dll (the main application assembly) and install the assembly resolver infrastructure that handles embedded dependencies. This project is intentionally minimal to reduce startup failure risk. All application logic lives in DBTools.App; the loader exists only to: Find and load DBTools.dll Install the EmbeddedAssemblyResolver Forward Revit lifecycle calls to DBTools.App.AddinEntry Source: csharp/src/DBTools.Loader/Addin/AddinEntry.cs:13-47 Responsibilities Responsibility Implementation Revit entry point IExternalApplication implementation with [AppLoader] attribute Load main assembly LoadMainAssembly() loads DBTools.dll from deployed directory Install assembly resolver EmbeddedAssemblyResolver.Install() handles runtime resolution Pre-load critical assemblies net48 only: Configuration and Serilog assemblies pre-loaded to beat GAC Forward lifecycle OnStartup/OnShutdown delegated to inner DBTools.App.AddinEntry Source: csharp/src/DBTools.Loader/Addin/AddinEntry.cs:17-47 Key Components AddinEntry (Revit Entry Point) The AddinEntry class is the Revit-facing entry point. It implements IExternalApplication and is decorated with [AppLoader] from ricaun.Revit.UI for enhanced loading behavior. [AppLoader] public sealed class AddinEntry : IExternalApplication { private IExternalApplication? _inner; public Result OnStartup(UIControlledApplication application) { // Bootstrap sequence here... } } Source: csharp/src/DBTools.Loader/Addin/AddinEntry.cs:12-14 Key Fields: _inner: Stores the instantiated DBTools.App.AddinEntry for forwarding lifecycle calls Source: csharp/src/DBTools.Loader/Addin/AddinEntry.cs:15 EmbeddedAssemblyResolver Static class that installs hooks into the CLR's assembly resolution mechanism. Handles loading dependencies from embedded resources within DBTools.dll. internal static class EmbeddedAssemblyResolver { private const string ResourcePrefix = \"DBTools.EmbeddedAssemblies.\"; private static int _installed; private static string? _deployedDir; public static void Install(Assembly mainAssembly, string? deployedDir = null) { // Installs AssemblyResolve (net48) or ALC.Resolving (net8) handler } } Source: csharp/src/DBTools.Loader/AssemblyResolution/EmbeddedAssemblyResolver.cs:14-38 LoaderCompat Provides cross-TFM compatibility utilities for the loader. Abstracts differences between .NET Framework and .NET 8. internal static class LoaderCompat { internal static string VendorTfm => #if NET8_0_OR_GREATER \"net8.0-windows\"; #else \"net48\"; #endif internal static Assembly LoadAssemblyFromPath(string path) { #if NET8_0_OR_GREATER return AssemblyLoadContext.Default.LoadFromAssemblyPath(path); #else return Assembly.LoadFrom(path); #endif } } Source: csharp/src/DBTools.Loader/Compat/LoaderCompat.cs:10-35 Bootstrap Sequence OnStartup Flow The complete startup sequence with line numbers: 1. Validate application parameter > Source: AddinEntry.cs:19 2. Get deployed directory (where DBTools.Loader.dll lives) > Source: AddinEntry.cs:21 3. Load DBTools.dll from deployed directory > Source: AddinEntry.cs:22 4. Verify embedded payload is present > Source: AddinEntry.cs:23 5. Install EmbeddedAssemblyResolver > Source: AddinEntry.cs:24 6. [net48 only] Pre-load Configuration assemblies > Source: AddinEntry.cs:26 7. [net48 only] Pre-load Serilog assemblies > Source: AddinEntry.cs:27 8. Resolve DBTools.App.AddinEntry type via reflection > Source: AddinEntry.cs:30-31 9. Create instance of DBTools.App.AddinEntry > Source: AddinEntry.cs:33-34 10. Store instance and forward OnStartup call > Source: AddinEntry.cs:36-37 Source: csharp/src/DBTools.Loader/Addin/AddinEntry.cs:17-38 Sequence Diagram Revit DBTools.Loader DBTools.dll (DBTools.App) | | | |--OnStartup(app)----------->| | | | | | GetDeployedDirectory() | | LoadMainAssembly() | | |--------load-------------->| | | | | EnsureEmbeddedPayloadPresent() | | EmbeddedAssemblyResolver.Install()| | | | | [net48: PreloadEmbedded*()] | | | | | Activator.CreateInstance()------->| | | | | |------OnStartup(app)------>| | | | |<-------Result.Succeeded----|<-------Result-------------| Assembly Loading Strategy net48 Strategy (ILRepack + Embedded) On .NET Framework 4.8, dependencies are handled via two mechanisms: 1. ILRepack (Merged into DBTools.dll): DBTools.Core Serilog, Microsoft.Extensions., YamlDotNet, System. polyfills These types exist directly in DBTools.dll; no resolution needed 2. Embedded Resources (for ricaun.Revit.*): Stored as DBTools.EmbeddedAssemblies.<name>.dll Loaded via Assembly.Load(byte[]) at runtime ILRepack corrupts some IL, so these stay as resources Source: csharp/src/DBTools.Loader/AssemblyResolution/EmbeddedAssemblyResolver.cs:223-263 3. Pre-loaded Assemblies: Configuration assemblies are pre-loaded before any code uses them to ensure DBTools' versions load before GAC/Revit's conflicting versions: var configAssemblies = new[] { \"Microsoft.Extensions.Primitives\", \"Microsoft.Extensions.FileProviders.Abstractions\", \"Microsoft.Extensions.FileProviders.Physical\", \"Microsoft.Extensions.Configuration.Abstractions\", \"Microsoft.Extensions.Configuration\", \"Microsoft.Extensions.Configuration.FileExtensions\", \"Microsoft.Extensions.Configuration.Json\", \"Microsoft.Extensions.Configuration.Binder\" }; Source: csharp/src/DBTools.Loader/Addin/AddinEntry.cs:111-121 Serilog assemblies are also pre-loaded in dependency order: var serilogAssemblies = new[] { \"Microsoft.Extensions.Logging.Abstractions\", \"Microsoft.Extensions.DependencyInjection.Abstractions\", \"Microsoft.Extensions.Logging\", \"Serilog\", \"Serilog.Extensions.Logging\", \"Serilog.Enrichers.Thread\", \"Serilog.Sinks.File\" }; Source: csharp/src/DBTools.Loader/Addin/AddinEntry.cs:154-170 Why Pre-load? On net48, AssemblyResolve only fires when an assembly cannot be found. If the GAC or another add-in already loaded a different version, our resolver never runs. Pre-loading ensures our versions are loaded first. Source: csharp/src/DBTools.Loader/Addin/AddinEntry.cs:104-108 net8.0-windows Strategy (All Embedded) On .NET 8, all dependencies are embedded as resources and loaded via AssemblyLoadContext: alc.Resolving += (context, name) => ResolveNet8(context, mainAssembly, name); Source: csharp/src/DBTools.Loader/AssemblyResolution/EmbeddedAssemblyResolver.cs:33-34 Resolution loads from embedded resources via stream: using var stream = mainAssembly.GetManifestResourceStream(resourceName); if (stream != null) { using var ms = new MemoryStream(); stream.CopyTo(ms); ms.Position = 0; return alc.LoadFromStream(ms); } Source: csharp/src/DBTools.Loader/AssemblyResolution/EmbeddedAssemblyResolver.cs:168-176 WPF Assembly Fallback WPF assemblies (Fluent.Ribbon, ControlzEx, HandyControl) cannot be embedded because they require Assembly.Location for pack:// URI resolution. These are loaded from files: Search Order: %APPDATA%/DBTools/vendor/<type>/<tfm>/ (traditional install) Deployed directory (next to DBTools.Loader.dll) Source: csharp/src/DBTools.Loader/AssemblyResolution/EmbeddedAssemblyResolver.cs:101-129 Vendor Type Detection: private static string? GetVendorTypeForAssembly(string requestedName) { if (requestedName.StartsWith(\"DBTools.Fluent.Ribbon\", ...)) return \"fluentribbon\"; if (requestedName.Equals(\"DBTools.ControlzEx\", ...)) return \"controlzex\"; if (requestedName.Equals(\"DBTools.HandyControl\", ...)) return \"handycontrol\"; return null; } Source: csharp/src/DBTools.Loader/AssemblyResolution/EmbeddedAssemblyResolver.cs:134-143 Duplicate Load Prevention Both resolution paths check for already-loaded assemblies first to prevent type identity mismatches: // Critical for ricaun.Revit.* which AppLoader may have already loaded var alreadyLoaded = AppDomain.CurrentDomain.GetAssemblies() .FirstOrDefault(a => string.Equals(a.GetName().Name, requestedName, ...)); if (alreadyLoaded != null) return alreadyLoaded; Source: csharp/src/DBTools.Loader/AssemblyResolution/EmbeddedAssemblyResolver.cs:50-61 Dependencies NuGet Packages Package Purpose ricaun.Revit.UI Provides [AppLoader] attribute for enhanced Revit loading Source: csharp/src/DBTools.Loader/DBTools.Loader.csproj:20 Note: ricaun.Revit.UI is a compile-time dependency that ensures ricaun is loaded EARLY when Revit loads DBTools.Loader.dll. This is required for RevitTaskService to work correctly in DBTools.App. Source: csharp/src/DBTools.Loader/DBTools.Loader.csproj:16-18 Revit API References Conditional based on target framework: net48: <Reference Include=\"RevitAPI\"> <HintPath>$(REVIT2024_DIR)\\RevitAPI.dll</HintPath> <Private>false</Private> </Reference> Source: csharp/src/DBTools.Loader/DBTools.Loader.csproj:23-34 net8.0-windows: <Reference Include=\"RevitAPI\" Condition=\"'$(REVIT_NET8_DIR)'!=''\"> <HintPath>$(REVIT_NET8_DIR)\\RevitAPI.dll</HintPath> <Private>false</Private> </Reference> Source: csharp/src/DBTools.Loader/DBTools.Loader.csproj:36-47 Runtime Dependencies DBTools.dll - Must be present in same directory as DBTools.Loader.dll Source: csharp/src/DBTools.Loader/Addin/AddinEntry.cs:67-69 Error Handling Startup Errors The loader has minimal error handling - it must either succeed or fail fast: Missing DBTools.dll: if (!File.Exists(mainPath)) throw new FileNotFoundException(\"DBTools.dll not found next to DBTools.Loader.dll.\", mainPath); Source: csharp/src/DBTools.Loader/Addin/AddinEntry.cs:68-69 Missing Embedded Payload (net8 only): var hasCore = Array.Exists(resources, r => string.Equals(r, \"DBTools.EmbeddedAssemblies.DBTools.Core.dll\", ...)); if (!hasCore) { throw new InvalidOperationException( \"DBTools.dll is missing embedded dependencies...\"); } Source: csharp/src/DBTools.Loader/Addin/AddinEntry.cs:89-96 Type Resolution Failure: var type = assembly.GetType(\"DBTools.App.AddinEntry\", throwOnError: true) ?? throw new InvalidOperationException(\"DBTools.App.AddinEntry type not found.\"); Source: csharp/src/DBTools.Loader/Addin/AddinEntry.cs:30-31 Silent Failures (Intentional) Pre-load failures during net48 startup are logged to Debug output but don't fail startup: catch (Exception ex) { // Silent continue - the EmbeddedAssemblyResolver will handle on-demand loading System.Diagnostics.Debug.WriteLine($\"[DBTools.Loader] Preload failed for {name}: {ex.Message}\"); } Source: csharp/src/DBTools.Loader/Addin/AddinEntry.cs:192-196 This is acceptable because the EmbeddedAssemblyResolver can still load these assemblies on-demand if pre-loading fails. Build Configuration Project Properties <TargetFrameworks>$(DBT_RevitTargetFrameworks)</TargetFrameworks> <AssemblyName>DBTools.Loader</AssemblyName> <RootNamespace>DBTools.Loader</RootNamespace> <CopyLocalLockFileAssemblies>true</CopyLocalLockFileAssemblies> Source: csharp/src/DBTools.Loader/DBTools.Loader.csproj:3-13 CopyLocalLockFileAssemblies: Set to true to copy NuGet dependencies (ricaun) to output for AppLoader/Debug scenarios. Source: csharp/src/DBTools.Loader/DBTools.Loader.csproj:13 Suppressed Warnings <NoWarn>$(NoWarn);MSB3277</NoWarn> MSB3277 (assembly version conflicts) is suppressed because Revit host references surface unavoidable conflicts. Source: csharp/src/DBTools.Loader/DBTools.Loader.csproj:10-11 File Structure csharp/src/DBTools.Loader/ +-- DBTools.Loader.csproj +-- Addin/ | +-- AddinEntry.cs # IExternalApplication entry point +-- AssemblyResolution/ | +-- EmbeddedAssemblyResolver.cs # Runtime assembly loading +-- Compat/ +-- LoaderCompat.cs # Cross-TFM utilities Integration with AppLoader DBTools.Loader uses ricaun's [AppLoader] attribute which provides: Automatic Revit version detection Enhanced error reporting Integration with ricaun.RevitTest for automated testing The AppLoader may have already loaded shared assemblies (like ricaun.Revit.*). The resolver explicitly checks for already-loaded assemblies to prevent duplicate loading which would cause type identity mismatches. Source: csharp/src/DBTools.Loader/AssemblyResolution/EmbeddedAssemblyResolver.cs:51-53 Troubleshooting \"DBTools.dll not found\" Error Cause: DBTools.dll is not in the same directory as DBTools.Loader.dll. Solution: Ensure the deployment copies both files together. \"Missing embedded dependencies\" Error (net8) Cause: DBTools.dll was built without the embedded assembly step. Solution: Rebuild using bash csharp/build.sh BuildAll. Source: csharp/src/DBTools.Loader/Addin/AddinEntry.cs:93-96 Assembly Resolution Failures Symptoms: FileNotFoundException or TypeLoadException for dependency types. Diagnosis: Check if the assembly is in embedded resources (DBTools.EmbeddedAssemblies.<name>.dll) For WPF assemblies, check %APPDATA%/DBTools/vendor/ or deployed directory Enable assembly binding logging (FUSLOGVW.exe) on net48 Related Documentation Architecture Overview - High-level system architecture Project References - How projects relate DBTools.Core - Core library documentation Verification Status Check Status Source anchors for all claims Yes UNVERIFIED markers where needed Yes (addin manifest) Cross-references added Yes Examples tested N/A No assumptions without evidence Yes Verified by: docs-run-20260124-020412 Date: 2026-01-24"
  },
  "developer-guide/projects/sandbox.html": {
    "href": "developer-guide/projects/sandbox.html",
    "title": "DBTools.Sandbox | DB Tools",
    "summary": "DBTools.Sandbox The DBTools.Sandbox project is a standalone WPF application that enables development, testing, and validation of DBTools UI windows without running Revit. It provides both an interactive gallery for browsing tool windows and a headless validation mode used during CI builds. Source: csharp/src/DBTools.Sandbox/DBTools.Sandbox.csproj:1-54 Overview Purpose Sandbox exists to solve a fundamental Revit development challenge: tool UI windows normally require Revit to be running, which makes iterative UI development slow and makes CI validation difficult. Sandbox provides: Interactive Development: Launch tool windows with design-time ViewModels to preview UI without Revit Build-Time Validation: Catch XAML errors, missing resources, and binding failures during CI Screenshot Capture: Generate UI screenshots for documentation or visual regression testing Key Concepts Design-Time ViewModels: Each sandbox-enabled window must provide a ViewModel that works without Revit services Sandbox Mode: A global flag (SandboxMode.IsActive) that windows check to avoid calling Revit-dependent code Dist-Driven Discovery: Sandbox loads windows from the built dist/ payload, validating the actual shipped assemblies Project Structure csharp/src/DBTools.Sandbox/ ├── App.xaml.cs # Application entry, mode switching ├── MainWindow.xaml.cs # Interactive gallery window ├── SandboxAppRuntime.cs # IAppRuntime implementation for sandbox ├── SandboxDiagnostics.cs # Logging utilities ├── SandboxSettingsProvider.cs # Settings stub for sandbox mode ├── HeadlessUiSuppression.cs # Suppresses OS dialogs in CI └── Validation/ ├── DistValidator.cs # Main validation orchestrator ├── ToolWindowValidator.cs # Tool window instantiation/layout ├── ManifestValidator.cs # Manifest schema validation ├── WindowGhostValidator.cs # WPF layout pass validation ├── MergeValidator.cs # ILRepack/embedded payload checks ├── BindingErrorListener.cs # WPF binding error capture ├── SandboxValidateOptions.cs # CLI argument parsing ├── SandboxModeActivator.cs # Cross-assembly mode activation ├── SandboxScreenshotHandler.cs # Screenshot capture mode ├── DistDirLocator.cs # Dist directory resolution ├── DistAssemblyResolver.cs # Assembly loading for dist payload ├── RevitDirLocator.cs # Revit installation discovery ├── DistValidationReflection.cs # Reflection helpers ├── AssemblyMetadataInspector.cs # PE metadata inspection └── XamlExceptionDiagnostics.cs # XAML error formatting Operating Modes Interactive Mode (Default) Launch the sandbox gallery to browse and open tool windows: # From csharp/.artifacts/sandbox/Release/net8.0-windows/ DBTools.Sandbox.exe Source: csharp/src/DBTools.Sandbox/App.xaml.cs:109-137 The interactive mode: Initializes SandboxAppRuntime for service resolution Loads DBTools.dll from the dist payload Discovers all sandboxWindows from tool manifests Displays a grouped gallery of launchable windows Headless Validation Mode Used by the build system to validate dist output: DBTools.Sandbox.exe --headless --dist-dir \"path/to/dist/Release/2026\" Source: csharp/src/DBTools.Sandbox/App.xaml.cs:45-57 Headless mode performs comprehensive validation without showing any UI: Theme resource validation Core window instantiation Tool manifest validation Tool window XAML validation WPF binding error detection Screenshot Mode Capture window screenshots for documentation: # List available tools DBTools.Sandbox.exe --screenshot --list # Capture specific tool DBTools.Sandbox.exe --screenshot --tool-id DBTools.GM.Main --output gm.png Source: csharp/src/DBTools.Sandbox/Validation/SandboxScreenshotHandler.cs:24-49 Key Components SandboxAppRuntime Minimal IAppRuntime implementation that provides essential services without Revit: internal sealed class SandboxAppRuntime : IAppRuntime, IDisposable { // Provides: ILogger, ISettingsProvider, ILoggerFactory, IAlertService public T Resolve<T>() where T : notnull { ... } } Source: csharp/src/DBTools.Sandbox/SandboxAppRuntime.cs:17-90 Services provided: IDbtLoggingHost - Real logging to %APPDATA%/DBTools/Logs/dbtools-SANDBOX-*.log ISettingsProvider - Stub implementation returning defaults ILoggerFactory - Creates category-scoped loggers IAlertService - Real alert service for error display SandboxMode Global flag that windows check to avoid Revit-dependent code paths: public static class SandboxMode { public static bool IsActive => _isActive; public static void Activate() { _isActive = true; } } Source: csharp/src/DBTools.Core/Compat/SandboxMode.cs:1-24 Windows should check this before calling Revit services: if (!SandboxMode.IsActive) { // Call Revit-dependent code } DbtSandboxCatalog Discovers sandbox windows from tool manifests: public static IReadOnlyList<DbtSandboxWindowSpec> Discover(Assembly rootAssembly) { var entries = DbtToolManifestLoader.LoadEntries(rootAssembly); // Extract sandboxWindows from each manifest } Source: csharp/src/DBTools.Core/Tools/DbtSandboxCatalog.cs:8-60 Validates that each sandbox window entry has: id - Unique identifier displayName - Human-readable name group - Category for gallery grouping windowType - Fully-qualified Window class name designTimeViewModelType - ViewModel for sandbox mode Tool Manifest Integration Tools register sandbox windows via manifest.yml: id: DBTools.GM assembly: DBTools moduleType: DBTools.GM.GmToolModule sandboxWindows: - id: DBTools.GM.Main displayName: \"Global Mapper\" group: \"Common\" windowType: \"DBTools.GM.Shell.UI.Views.GmWindow\" designTimeViewModelType: \"DBTools.GM.Shell.DesignTime.GmShellDesignTimeViewModel\" Source: csharp/src/Tools/Common/GM/manifest.yml:1-15 Schema Fields Field Required Description id Yes Unique window identifier (e.g., DBTools.GM.Main) displayName Yes Gallery display name group Yes Gallery category grouping windowType Yes Fully-qualified Window type name designTimeViewModelType Yes Design-time ViewModel type assembly No Assembly name (defaults to manifest's assembly) Source: csharp/src/DBTools.Core/Tools/DbtToolManifestLoader.cs:121-153 Validation System The validation system runs during BuildAll to catch UI issues before deployment. DistValidator (Orchestrator) Main validation entry point that coordinates all validators: internal static class DistValidator { public static int Run(SandboxValidateOptions options, ILogger? logger = null) { // 1. Validate dist layout // 2. Install assembly resolver // 3. Validate theme resources // 4. Validate core windows // 5. Validate manifests (optional) // 6. Validate tool windows (optional) } } Source: csharp/src/DBTools.Sandbox/Validation/DistValidator.cs:15-118 ToolWindowValidator Instantiates each sandbox window with its design-time ViewModel: internal static class ToolWindowValidator { public static void ValidateOrThrow(Assembly dbtoolsAssembly, ILogger? logger = null) { var specs = DiscoverSpecs(dbtoolsAssembly); foreach (var spec in specs) { // 1. Load window type from assembly // 2. Create window instance // 3. Create design-time ViewModel // 4. Set DataContext // 5. Run WindowGhostValidator // 6. Validate tab interactions // 7. Validate row expansion } } } Source: csharp/src/DBTools.Sandbox/Validation/ToolWindowValidator.cs:13-173 Additional validations performed: Tab cycling - Switches through all tabs to catch transition errors DataGrid row expansion - Toggles row details visibility Preview mode switching - Tests mode transitions (e.g., SGT preview modes) Source: csharp/src/DBTools.Sandbox/Validation/ToolWindowValidator.cs:201-368 WindowGhostValidator Forces WPF layout passes to catch XAML errors: internal static class WindowGhostValidator { public static void Validate(Window window) { // Pass 1: Fixed 800x600 size ValidateLayoutPass(window, new Size(800, 600), \"fixed size\"); // Pass 2: Infinite size (catches DesiredSize calculation errors) ValidateLayoutPass(window, new Size(PositiveInfinity, PositiveInfinity), \"infinite size\"); } } Source: csharp/src/DBTools.Sandbox/Validation/WindowGhostValidator.cs:9-129 BindingErrorListener Captures WPF binding errors that normally fail silently: internal sealed class BindingErrorListener : TraceListener { // Hooks into PresentationTraceSources.DataBindingSource // Collects \"System.Windows.Data Error:\" messages // ThrowIfErrors() fails validation if any binding errors occurred } Source: csharp/src/DBTools.Sandbox/Validation/BindingErrorListener.cs:13-118 This catches issues like: Missing StaticResource references Broken binding paths Type conversion failures MergeValidator Validates assembly merge/embedding is correct: For net48 (ILRepack): Verifies expected types exist inside DBTools.dll Ensures merged assemblies don't exist as separate files For net8 (Embedded Payload): Verifies DBTools.EmbeddedAssemblies.DBTools.Core.dll resource exists Checks resource isn't corrupted (minimum size validation) Source: csharp/src/DBTools.Sandbox/Validation/MergeValidator.cs:17-222 CLI Arguments Argument Description --headless Run validation only, no UI --screenshot Run screenshot capture mode --dist-dir <path> Path to dist directory or year folder --revit-dir <path> Override Revit installation path --validate-manifests Enable manifest validation (default: true) --skip-validate-manifests Disable manifest validation --validate-tools Enable tool window validation (default: true) --skip-validate-tools Disable tool window validation --list List available tools (screenshot mode) --tool-id <id> Tool to capture (screenshot mode) --output <path> Screenshot output path Source: csharp/src/DBTools.Sandbox/Validation/SandboxValidateOptions.cs:7-113 Build Integration The sandbox validator is invoked automatically during BuildAll: bash csharp/build.sh BuildAll # Internally runs: DBTools.Sandbox.exe --headless --dist-dir ... The build system also handles orphaned processes: static void KillOrphanedSandboxValidatorProcesses() { // Kills any lingering DBTools.Sandbox processes from previous builds } Source: csharp/build/BuildTargets.cs:1292 Creating a Sandbox-Enabled Window 1. Create Design-Time ViewModel public class MyWindowDesignTimeViewModel : INotifyPropertyChanged { public MyWindowDesignTimeViewModel() { // Initialize with sample data Items = new ObservableCollection<ItemModel> { new ItemModel { Name = \"Sample 1\" }, new ItemModel { Name = \"Sample 2\" } }; } public ObservableCollection<ItemModel> Items { get; } } 2. Add Parameterless Constructor to Window public partial class MyWindow : Window { // Required for sandbox mode public MyWindow() { InitializeComponent(); if (SandboxMode.IsActive) { // Skip Revit-dependent initialization return; } // Normal initialization... } } 3. Register in manifest.yml sandboxWindows: - id: MyTool.Main displayName: \"My Tool Window\" group: \"Common\" windowType: \"MyNamespace.UI.Views.MyWindow\" designTimeViewModelType: \"MyNamespace.DesignTime.MyWindowDesignTimeViewModel\" 4. Test Locally # Build bash csharp/build.sh BuildAll # Launch interactive sandbox csharp/.artifacts/sandbox/Release/net8.0-windows/DBTools.Sandbox.exe Multi-Framework Support Sandbox targets both net48 and net8.0-windows to validate both Revit 2024 (net48) and Revit 2025+ (net8) distributions: <TargetFrameworks>$(DBT_RevitTargetFrameworks)</TargetFrameworks> Source: csharp/src/DBTools.Sandbox/DBTools.Sandbox.csproj:3 The validator automatically selects the compatible year folder: net48 sandbox validates Revit 2024 (year <= 2024) net8 sandbox validates Revit 2025+ (year >= 2025) Source: csharp/src/DBTools.Sandbox/Validation/DistDirLocator.cs:75-80 Headless UI Suppression In CI environments, the sandbox suppresses all OS-level dialogs: SetErrorMode - Suppresses Win32 critical error dialogs WerSetFlags - Suppresses Windows Error Reporting UI Trace listeners - Disables Debug.Assert popups Source: csharp/src/DBTools.Sandbox/HeadlessUiSuppression.cs:17-120 This prevents CI builds from hanging on modal dialogs. Troubleshooting \"Dist payload not found\" The sandbox requires a built dist payload: bash csharp/build.sh BuildAll Window crashes in sandbox but works in Revit Check for Revit-dependent code not guarded by SandboxMode.IsActive: // Wrong - crashes in sandbox var doc = AppRuntime.Resolve<IRevitService>().Document; // Right - sandbox-safe if (!SandboxMode.IsActive) { var doc = AppRuntime.Resolve<IRevitService>().Document; } Binding errors in validation The BindingErrorListener will report silent WPF binding failures. Check: Missing StaticResource keys in XAML Incorrect binding paths Missing value converters \"Type not found\" during validation Ensure the window and ViewModel types: Have fully-qualified names in the manifest Are public classes Have public parameterless constructors Related Documentation Architecture: Sandbox Validator - Detailed validation architecture DBTools.App - How App discovers tools via manifests Tool Manifest Schema - Complete manifest documentation See Also DbtSandboxWindowSpec - Window specification model DbtSandboxCatalog - Window discovery from manifests DbtToolManifestLoader - Manifest parsing and validation"
  },
  "developer-guide/projects/themes.html": {
    "href": "developer-guide/projects/themes.html",
    "title": "DBTools.Themes | DB Tools",
    "summary": "DBTools.Themes The DBTools.Themes project provides a unified dark theme system for all DBTools WPF applications. It establishes design tokens, brush definitions, and control styles that ensure visual consistency across the application while avoiding conflicts with Revit's host environment. Overview DBTools.Themes solves several key challenges: Host Isolation: Revit's UI can interfere with WPF resource dictionaries. This project uses vendored, renamed libraries (e.g., DBTools.HandyControl instead of HandyControl) to prevent conflicts with pyRevit or other add-ins. Consistent Branding: Implements the DBTools brand colors (deep blue #1946B9 and golden yellow #FEC425) across all UI controls. WCAG Accessibility: Text colors are designed to meet WCAG AA contrast requirements (min 4.5:1 ratio on dark backgrounds). Template Boundary Crossing: The BrushKeys system using ComponentResourceKey allows brushes to propagate correctly across DataTemplate and ControlTemplate boundaries. Source: csharp/src/DBTools.Themes/DBTools.Themes.csproj:1-73 Project Structure DBTools.Themes/ ├── DBTools.Themes.csproj # Project configuration ├── BrushKeys.cs # ComponentResourceKey definitions ├── Assets/ │ └── db_tools_icon.png # Application icon └── Themes/ ├── App.Theme.xaml # Root dictionary (entry point) ├── App.Tokens.xaml # Design tokens (spacing, sizing) ├── App.Brushes.xaml # Color/brush definitions ├── App.Converters.xaml # Value converters ├── App.Controls.Base.xaml # Base control styles ├── App.DataGrid.xaml # DataGrid-specific styles ├── App.Menus.xaml # Menu/ContextMenu styles ├── App.Components.xaml # Higher-level component styles └── App.FluentRibbon.xaml # Fluent.Ribbon theme bridge Source: csharp/src/DBTools.Themes/DBTools.Themes.csproj:38-51 Key Files App.Theme.xaml - Root Entry Point The root resource dictionary that merges all theme components. This is what consuming projects reference. <ResourceDictionary.MergedDictionaries> <!-- HandyControl Foundation --> <ResourceDictionary Source=\"pack://application:,,,/DBTools.HandyControl;component/Themes/SkinDark.xaml\"/> <ResourceDictionary Source=\"pack://application:,,,/DBTools.HandyControl;component/Themes/Theme.xaml\"/> <!-- Fluent.Ribbon for ribbon windows --> <ResourceDictionary Source=\"pack://application:,,,/DBTools.Fluent.Ribbon;component/Themes/Generic.xaml\" /> <!-- DBTools Custom Themes --> <ResourceDictionary Source=\"App.Tokens.xaml\" /> <ResourceDictionary Source=\"App.Brushes.xaml\" /> <!-- ... additional dictionaries ... --> </ResourceDictionary.MergedDictionaries> Source: csharp/src/DBTools.Themes/Themes/App.Theme.xaml:1-22 BrushKeys.cs - ComponentResourceKey System Defines strongly-typed keys for all theme brushes. This pattern enables brushes to work correctly inside DataTemplate and ControlTemplate boundaries where DynamicResource with string keys may fail. public static class BrushKeys { public static ComponentResourceKey Primary => new(typeof(BrushKeys), \"Brush.Primary\"); public static ComponentResourceKey Secondary => new(typeof(BrushKeys), \"Brush.Secondary\"); // ... 100+ additional keys } Usage in XAML: <Border Background=\"{DynamicResource {x:Static theme:BrushKeys.Primary}}\" /> Source: csharp/src/DBTools.Themes/BrushKeys.cs:1-140 Design Tokens Design tokens provide consistent spacing, sizing, typography, and other visual constants. Spacing Tokens Token Value Usage Spacing4 4px Tight spacing (icon margins) Spacing8 8px Standard spacing Spacing12 12px Medium spacing Spacing16 16px Large spacing Spacing32 32px Section spacing Scalar variants (Spacing8.Value, etc.) are provided for properties that require Double instead of Thickness. Source: csharp/src/DBTools.Themes/Themes/App.Tokens.xaml:5-18 Padding Tokens Token Value Usage Pad4 4px uniform Compact padding Pad8 8px uniform Standard padding Pad16 16px uniform Large padding Pad8x4 8px H, 4px V Button padding Card.Padding 16px H, 12px V Card content Source: csharp/src/DBTools.Themes/Themes/App.Tokens.xaml:24-56 Gap Tokens Directional margins for layout: Token Value Description TGap8 Top 8px Top margin BGap8 Bottom 8px Bottom margin LGap8 Left 8px Left margin RGap8 Right 8px Right margin VGap8 Top/Bottom 8px Vertical margin HGap8 Left 8px Horizontal gap Source: csharp/src/DBTools.Themes/Themes/App.Tokens.xaml:30-64 Typography Tokens Token Size Usage FontSize.Caption 11px Captions, timestamps FontSize.Body.Small 12px Secondary text FontSize.Body 13px Default body text FontSize.Subtitle 14px Subtitles FontSize.Title 16px Section titles FontSize.Header 20px Page headers Source: csharp/src/DBTools.Themes/Themes/App.Tokens.xaml:66-72 Corner Radius Tokens Token Value Usage Radius4 4px Buttons, inputs Radius6 6px Cards, chips Radius8 8px Dialogs, overlays Radius12 12px Large surfaces Source: csharp/src/DBTools.Themes/Themes/App.Tokens.xaml:43-46 Control Size Tokens Token Value Usage MinHeight.Control 32px Minimum control height Size.CheckBox.Box 18px Checkbox dimensions Size.ToggleTrack.Width 44px Toggle switch track Size.DataGridRow.MinHeight 32px Grid row height Size.ScrollBar.Width 10px Scrollbar width Source: csharp/src/DBTools.Themes/Themes/App.Tokens.xaml:98-114 Color System (App.Brushes.xaml) The color system is built around the DBTools brand colors with carefully designed semantic roles. Brand Colors Key Color Description Primary #1946B9 Deep blue - primary actions PrimaryLight #3D6AD4 Hover state PrimaryDark #0D2E7A Pressed state Secondary #FEC425 Golden yellow - accents SecondaryLight #FFD54F Hover state SecondaryDark #C79100 Pressed state Source: csharp/src/DBTools.Themes/Themes/App.Brushes.xaml:14-19 Surface Colors Neutral dark palette with reduced blue tint: Key Color Description Paper #181820 Window background Surface #222228 Card/panel background SurfaceAlt #1C1C22 Alternate surface SurfaceHover #2A2A32 Hover state CardSurface #1E1E24 Card background CardSurfaceElevated #282830 Elevated cards Source: csharp/src/DBTools.Themes/Themes/App.Brushes.xaml:24-30 Text Colors (WCAG Compliant) Key Color Contrast Description Body / Text #E6E6E6 ~12:1 Primary text BodyLight / TextSecondary #BDBDBD ~9:1 Secondary text TextMuted / Muted #999999 ~7:1 Muted text OnAccent #FFFFFF - Text on colored bg OnSecondary #181820 - Text on yellow Source: csharp/src/DBTools.Themes/Themes/App.Brushes.xaml:35-44 Selection & Highlight Colors Alpha transparency reference: #33 = 20%, #44 = 27%, #55 = 33%, #66 = 40%, #99 = 60% Key Color Description Selection #441946B9 (27%) Standard selection SelectionStrong #661946B9 (40%) Strong selection SelectionGold #33FEC425 (20%) Row highlighting SelectionGoldStrong #55FEC425 (33%) Strong gold Hover #33FEC425 (20%) Hover state Source: csharp/src/DBTools.Themes/Themes/App.Brushes.xaml:59-78 Status Colors Key Color Description Success #4CAF50 Success state Warning #FFA000 Warning state Error #CF6679 Error state Info #1946B9 Informational Each status color has Light and Background variants for subtle backgrounds. Source: csharp/src/DBTools.Themes/Themes/App.Brushes.xaml:84-95 Specialized Brush Categories The brush system includes specialized categories for: DataGrid: Header, row, cell, selection colors Input Controls: Background, border, focus states Buttons: Primary, secondary, accent, danger variants Checkbox/Toggle: Box, checked, indeterminate states Tabs: Background, indicator, hover states ScrollBar/Slider: Track, thumb, hover/pressed states VTC Diff View: Add/remove/missing background colors Source: csharp/src/DBTools.Themes/Themes/App.Brushes.xaml:100-232 BrushKeys System Why ComponentResourceKey? WPF has a limitation where DynamicResource with string keys doesn't always resolve correctly inside DataTemplate or ControlTemplate boundaries. ComponentResourceKey solves this by creating type-safe keys that the resource system can resolve across template boundaries. Key Categories The BrushKeys class defines 100+ keys organized into categories: Category Example Keys Count Brand Primary, Secondary, PrimaryLight 6 Surface Paper, Surface, CardSurface 7 Text Body, Text, TextMuted 10 Border Border, Divider, BorderSubtle 4 Selection Selection, SelectionGold, Hover 12 Status Success, Warning, Error, Info 12 DataGrid DataGridHeader, DataGridRow, etc. 14 Input InputBackground, InputBorder 5 Button ButtonPrimary, ButtonDanger 10 Checkbox CheckBox, CheckChecked 6 Toggle ToggleTrackOn, ToggleThumb 7 Tab TabBackground, TabIndicator 5 ScrollBar ScrollBarTrack, ScrollBarThumb 4 Slider SliderTrack, SliderThumb 5 Progress ProgressTrack, ProgressFill 3 Toolbar ToolbarChipBackground, etc. 6 VTC Diff VtcDiffAddBackground, etc. 4 Source: csharp/src/DBTools.Themes/BrushKeys.cs:11-139 Usage Pattern In XAML: xmlns:theme=\"clr-namespace:DBTools.Themes;assembly=DBTools.Themes\" <Border Background=\"{DynamicResource {x:Static theme:BrushKeys.CardSurface}}\" BorderBrush=\"{DynamicResource {x:Static theme:BrushKeys.CardBorder}}\" /> In Code: var brush = (Brush)FindResource(BrushKeys.Primary); Control Styles Window Styles The theme provides implicit styles for DbtWindowBase and DbtRibbonWindowBase: Sets the DBTools icon Applies Paper background and Body foreground Includes progress overlay support via ProgressOverlayService Source: csharp/src/DBTools.Themes/Themes/App.Controls.Base.xaml:13-55 Base Control Styles TextBlock Foreground: Body brush TextWrapping: Wrap TextTrimming: CharacterEllipsis Button MinWidth: 88px, MinHeight: 36px Hover: SecondaryHover background, Secondary border Pressed: PrimaryHover background, Primary border TextBox Background: InputBackground Border: InputBorder (hover: Secondary, focus: FocusBorder) Validation error: Red border with tooltip ComboBox Custom dropdown template with dark popup background Drop shadow effect on dropdown Proper dark theme item highlighting CheckBox / RadioButton Custom templates with theme-consistent colors Checked: CheckChecked background Indeterminate: CheckIndeterminate fill (yellow) Source: csharp/src/DBTools.Themes/Themes/App.Controls.Base.xaml:61-449 DataGrid Styles Comprehensive DataGrid theming with: Row Features: Yellow accent stripe on left edge Gold hover highlighting (DataGridRowHover) Blue selection with yellow accent (DataGridRowSelected) Keyboard focus indicator (DataGridRowFocus) Cell Features: Focus state with primary border Edit mode with secondary border Conflict highlighting support Column Header: Hover state Sort direction indicators (yellow arrows) Resizable column grippers Source: csharp/src/DBTools.Themes/Themes/App.DataGrid.xaml:1-476 Component Styles (App.Components.xaml) Higher-level UI component styles: Style Key Target Description ToolBar ToolBar Dark themed toolbar StatusBar StatusBar Dark themed status bar ToolbarChip ToggleButton Pill-shaped filter buttons OverlayCard Border Modal dialog container Card Border Standard card surface Card.Elevated Border Card with drop shadow Dbt.Section GroupBox Section with accent stripe Dbt.Callout Border Info callout box WarningBar Border Warning message container Typography Styles: HeaderText, SubtitleText, BodyText, DescriptionText, CaptionText Source: csharp/src/DBTools.Themes/Themes/App.Components.xaml:1-414 Menu Styles Custom templates for proper dark theme rendering in Revit: ContextMenu: Dark background, rounded corners, drop shadow MenuItem: Hover highlighting, keyboard shortcut display MenuSeparator: Subtle divider Source: csharp/src/DBTools.Themes/Themes/App.Menus.xaml:1-136 Vendored Library Integration Why Vendored Libraries? Revit hosts multiple add-ins that may use conflicting versions of UI libraries like HandyControl or Fluent.Ribbon. By vendoring and renaming these libraries, DBTools avoids: Assembly version conflicts Resource dictionary collisions pyRevit theme interference Vendored Assemblies Original Vendored Purpose HandyControl DBTools.HandyControl Control library foundation Fluent.Ribbon DBTools.Fluent.Ribbon Ribbon window support ControlzEx DBTools.ControlzEx Window chrome (dependency) <Reference Include=\"DBTools.HandyControl\"> <HintPath>$(DBT_VendorArtifactsRoot)handycontrol\\$(TargetFramework)\\DBTools.HandyControl.dll</HintPath> </Reference> Source: csharp/src/DBTools.Themes/DBTools.Themes.csproj:55-71 Fluent.Ribbon Theme Bridge App.FluentRibbon.xaml provides a complete dark theme override with 196 brush key mappings to integrate Fluent.Ribbon with the DBTools color system. Key integrations: Window chrome (title bar, caption buttons) Ribbon tabs and groups All control variants (buttons, checkboxes, textboxes) Gallery and backstage views Source: csharp/src/DBTools.Themes/Themes/App.FluentRibbon.xaml:1-575 Build Configuration Target Frameworks The project multi-targets: net48 (Revit 2024 and earlier) net8.0-windows (Revit 2025+) XAML Compilation Some XAML files are kept as raw resources (not compiled to BAML) to avoid requiring a project reference to DBTools.Core: <Page Remove=\"Themes\\App.Converters.xaml\" /> <Resource Include=\"Themes\\App.Converters.xaml\" /> Source: csharp/src/DBTools.Themes/DBTools.Themes.csproj:38-46 Dependency Rules Critical: DBTools.Themes must NOT reference DBTools.Core to avoid circular dependencies. Theme dictionaries that need Core types are defined in Core and merged via pack URIs. Source: csharp/src/DBTools.Themes/DBTools.Themes.csproj:31-34 How to Extend Adding New Brushes Add the ComponentResourceKey to BrushKeys.cs: public static ComponentResourceKey MyNewBrush => new(typeof(BrushKeys), \"Brush.MyNew\"); Define the brush in App.Brushes.xaml: <SolidColorBrush x:Key=\"{x:Static theme:BrushKeys.MyNewBrush}\" Color=\"#FF123456\" /> Adding New Tokens Add to App.Tokens.xaml following existing patterns: <sys:Double x:Key=\"Size.MyNew\">24</sys:Double> <Thickness x:Key=\"Pad.MyNew\">8,4</Thickness> Creating New Control Styles For base controls, add to App.Controls.Base.xaml For higher-level components, add to App.Components.xaml Use DynamicResource with BrushKeys for all colors Use token resources for spacing/sizing Adding Converters Implement converter in DBTools.Core.UI.Converters Add resource entry in App.Converters.xaml: <conv:MyConverter x:Key=\"Converter.MyConverter\" /> Cross-References Theme System Architecture - Detailed architecture documentation DBTools.Core - Theme loading and initialization Value Converters Available converters (defined in App.Converters.xaml): Key Type Description Converter.BoolToVisibility BooleanToVisibilityConverter Standard bool-to-visibility Converter.InverseBoolToVisibility InverseBooleanToVisibilityConverter Inverted visibility Converter.NullToVisibility NullToVisibilityConverter Collapsed when not null Converter.NullToInverseVisibility NullToInverseVisibilityConverter Collapsed when null Converter.RowKindToVisibility RowKindToVisibilityConverter DataGrid row type filtering Source: csharp/src/DBTools.Themes/Themes/App.Converters.xaml:1-12"
  },
  "developer-guide/tools/common/elements-from-list-3d.html": {
    "href": "developer-guide/tools/common/elements-from-list-3d.html",
    "title": "Elements From List 3D | DB Tools",
    "summary": "Elements From List 3D Elements From List 3D is a utility tool module that provides two related commands for creating and visualizing 3D elements in Revit: placing family instances from CSV coordinate data, and creating filled regions from selected wall and caisson elements. Overview The tool module contains two ribbon commands: Command Description Availability 3D Elements From List Creates family instances at coordinates specified in a CSV file Document open Filled Regions From Elements Creates filled regions from selected walls and caissons Elements selected Source: csharp/src/Tools/Common/3DElementsFromList/manifest.yml:6-24 Features 3D Elements From List Command CSV Import: Reads coordinate data from user-selected CSV files Flexible Column Ordering: Supports any column order with case-insensitive headers Optional ID Column: Maps CSV id field to element parameter Auto-Family Loading: Automatically loads the required family if not present in project Multi-Format Support: Handles integers, decimals, negative values, and scientific notation Source: csharp/src/Tools/Common/3DElementsFromList/Features/ElementsFromList3DCommand.cs:13-72 Filled Regions From Elements Command Wall Support: Creates rectangular filled regions from wall bounding boxes Caisson Support: Creates circular filled regions from caisson diameter parameters Style Matching: Uses \"solid gray\" non-masking filled region type Invisible Lines: Applies invisible line style to region boundaries Automatic Comments: Sets \"DB Tools\" comment on created regions Source: csharp/src/Tools/Common/3DElementsFromList/Features/FilledRegionsFromElementsCommand.cs:12-62 Architecture Module Structure csharp/src/Tools/Common/3DElementsFromList/ +-- ElementsFromList3DToolModule.cs # Tool module registration +-- DBTools.ElementsFromList3D.csproj # Project file +-- manifest.yml # Tool manifest +-- Features/ | +-- ElementsFromList3DCommand.cs # CSV import command | +-- FilledRegionsFromElementsCommand.cs # Filled region command | +-- CsvCoordinateParser.cs # Pure CSV parsing logic | +-- CsvElementPlacer.cs # Element placement service | +-- FilledRegionCreator.cs # Region creation service +-- Assets/ | +-- 3d_elements_icon.png # Command icon | +-- filled_regions_icon.png # Command icon +-- Tests/ +-- CsvCoordinateParserTests.cs # Parser unit tests +-- TEST_SUMMARY.md # Test documentation Source: Directory structure of csharp/src/Tools/Common/3DElementsFromList/ Data Flow +------------------------+ | ElementsFromList3DCommand | +-----------+------------+ | (User selects CSV file) | v +------------------------+ | CsvCoordinateParser | | (Pure parsing logic) | +-----------+------------+ | (CoordinateRecords) | v +------------------------+ | CsvElementPlacer | | (Revit integration) | +-----------+------------+ | +-----------------+-----------------+ | | v v +------------------+ +-------------------+ | FamilyLoader | | Transaction | | (Load/find family)| | (Create instances)| +------------------+ +-------------------+ Separation of Concerns The tool follows a clean separation pattern: Layer Class Responsibility Command ElementsFromList3DCommand Entry point, file selection, result display Parsing CsvCoordinateParser Pure CSV logic, no Revit/file dependencies Placement CsvElementPlacer Revit API integration, transaction management Source: csharp/src/Tools/Common/3DElementsFromList/Features/CsvCoordinateParser.cs:59-63 Key Classes Entry Points Class File Purpose ElementsFromList3DToolModule ElementsFromList3DToolModule.cs:5-7 Empty tool module; uses manifest-driven registration ElementsFromList3DCommand Features/ElementsFromList3DCommand.cs:17-72 CSV import command entry point FilledRegionsFromElementsCommand Features/FilledRegionsFromElementsCommand.cs:16-62 Filled region command entry point Source: csharp/src/Tools/Common/3DElementsFromList/ElementsFromList3DToolModule.cs:5-7 Domain Types Type File Purpose CoordinateRecord Features/CsvCoordinateParser.cs:12-35 Immutable struct holding X, Y, Z, and optional ID CsvParseResult Features/CsvCoordinateParser.cs:40-57 Result type with success/failure semantics Source: csharp/src/Tools/Common/3DElementsFromList/Features/CsvCoordinateParser.cs:12-35 Services Class File Purpose CsvCoordinateParser Features/CsvCoordinateParser.cs:63-153 Static parser with Parse(), ParseContent(), ParseFile() methods CsvElementPlacer Features/CsvElementPlacer.cs:17-143 Creates family instances from coordinate records FilledRegionCreator Features/FilledRegionCreator.cs:16-248 Creates filled regions from walls and caissons Source: csharp/src/Tools/Common/3DElementsFromList/Features/CsvElementPlacer.cs:17-31 CSV Format The CSV parser accepts files with the following format: Required Columns x - X coordinate (feet in Revit internal units) y - Y coordinate (feet in Revit internal units) z - Z coordinate (feet in Revit internal units) Optional Columns id - Identifier string (written to element's \"ID\" parameter if available) Format Rules Feature Behavior Header case Case-insensitive (X, x, X all valid) Column order Any order allowed Extra columns Ignored Whitespace Trimmed from headers and values Empty rows Skipped Invalid rows Skipped (row with unparseable numbers) Number format Integer, decimal, negative, scientific notation Line endings Windows (\\r\\n), Unix (\\n), Mac (\\r) Source: csharp/src/Tools/Common/3DElementsFromList/Features/CsvCoordinateParser.cs:70-114 Example CSV id,x,y,z P001,100.5,200.25,10.0 P002,150.0,250.5,10.0 P003,200.75,300.0,10.0 Source: csharp/src/Tools/Common/3DElementsFromList/Tests/CsvCoordinateParserTests.cs:453-471 Configuration Manifest id: DBTools.ElementsFromList3D assembly: DBTools moduleType: DBTools.ElementsFromList3D.ElementsFromList3DToolModule order: 0 tool: ribbonTools: - internalName: DBTools.ElementsFromList3D commandType: DBTools.ElementsFromList3D.ElementsFromList3DCommand availabilityType: DBTools.App.Tools.Availability.DbtDocumentAvailability runProfile: InlineUi displayText: \"3D Elements\\nFrom List\" iconBaseKey: 3d_elements tooltip: \"Create 3D elements from a CSV file\" controlKind: PushButton order: 10 - internalName: DBTools.FilledRegionsFromElements commandType: DBTools.ElementsFromList3D.FilledRegionsFromElementsCommand availabilityType: DBTools.App.Tools.Availability.DbtSelectionAvailability runProfile: InlineUi displayText: \"Filled Regions\\nFrom Elements\" iconBaseKey: filled_regions tooltip: \"Create filled regions from selected elements\" controlKind: PushButton order: 11 Source: csharp/src/Tools/Common/3DElementsFromList/manifest.yml:1-24 Availability Conditions Command Availability Type Condition 3D Elements From List DbtDocumentAvailability Any document open Filled Regions From Elements DbtSelectionAvailability Elements selected Source: csharp/src/Tools/Common/3DElementsFromList/manifest.yml:9,18 Family Dependency The 3D Elements command requires a specific family: Property Value File name 3D-Elements-From-List.rfa Family name 3D-Elements-From-List Category Generic Model (OST_GenericModel) Expected parameter ID (string, for CSV ID mapping) Source: csharp/src/Tools/Common/3DElementsFromList/Features/CsvElementPlacer.cs:23-24 The placer first searches for an existing family symbol in the document, then loads from the installed family library path if not found. Source: csharp/src/Tools/Common/3DElementsFromList/Features/CsvElementPlacer.cs:113-142 Filled Region Requirements The Filled Regions command requires specific project resources: Resource Requirement Filled Region Type Name contains \"solid\" AND \"gray\", non-masking Graphics Style <Invisible lines> (exact name) Caisson Family Concrete-Caisson (family name, case-insensitive) Caisson Diameter Type parameter b (double) Source: csharp/src/Tools/Common/3DElementsFromList/Features/FilledRegionCreator.cs:111-140 API Reference CsvCoordinateParser The static parser provides three entry points: public static class CsvCoordinateParser { // Parse from string array (already split lines) public static CsvParseResult Parse(IReadOnlyList<string> lines); // Parse from content string (handles line splitting) public static CsvParseResult ParseContent(string csvContent); // Parse from file path (handles file I/O) public static CsvParseResult ParseFile(string filePath); } Source: csharp/src/Tools/Common/3DElementsFromList/Features/CsvCoordinateParser.cs:72,121,135 CoordinateRecord Immutable value type for parsed coordinates: public readonly struct CoordinateRecord : IEquatable<CoordinateRecord> { public double X { get; } public double Y { get; } public double Z { get; } public string? Id { get; } } Source: csharp/src/Tools/Common/3DElementsFromList/Features/CsvCoordinateParser.cs:12-25 CsvParseResult Result type with explicit success/failure: public sealed class CsvParseResult { public IReadOnlyList<CoordinateRecord> Records { get; } public string? Error { get; } public bool IsSuccess => Error == null; public static CsvParseResult Success(IReadOnlyList<CoordinateRecord> records); public static CsvParseResult Failure(string error); } Source: csharp/src/Tools/Common/3DElementsFromList/Features/CsvCoordinateParser.cs:40-57 CsvElementPlacer Creates elements within a transaction: public sealed class CsvElementPlacer { public CsvElementPlacer(ITransactionRunner tx, Document doc, ILogger logger); public (int CreatedCount, int FailedCount, string? ErrorMessage) Run(string csvPath); } Source: csharp/src/Tools/Common/3DElementsFromList/Features/CsvElementPlacer.cs:26-33 FilledRegionCreator Creates filled regions from selected elements: public sealed class FilledRegionCreator { public FilledRegionCreator(ITransactionRunner tx, Document doc, View activeView, ILogger logger); public (int CreatedCount, int SkippedCount) Run(ICollection<ElementId> selectedIds); } Source: csharp/src/Tools/Common/3DElementsFromList/Features/FilledRegionCreator.cs:23-31 Testing The tool includes comprehensive unit tests for the CSV parser: Test Categories Category Test Count Description Basic Success Cases 5 Valid CSV parsing scenarios Column Order Variations 4 Different header orderings Whitespace Handling 4 Trimming and empty row skipping Number Formats 6 Integer, negative, scientific notation Error Cases 6 Null, empty, missing columns Invalid Data Handling 3 Malformed rows ParseContent (String) 5 Line ending variations CoordinateRecord 5 Equality and hash code CsvParseResult 2 Success/failure factories Integration Scenarios 2 Real-world CSV examples Total: 42 tests Source: csharp/src/Tools/Common/3DElementsFromList/Tests/TEST_SUMMARY.md:14-104 Running Tests # Build test assemblies bash csharp/build.sh BuildTests # Run parser tests (headless, no Revit required) dotnet test csharp/testing/DBTools.BuildArtifacts.Tests/DBTools.BuildArtifacts.Tests.csproj \\ -c Release --filter \"FullyQualifiedName~CsvCoordinateParser\" Source: csharp/src/Tools/Common/3DElementsFromList/Tests/DBTools.ElementsFromList3D.Tests.csproj:19-20 User Workflow Creating 3D Elements Click 3D Elements From List in the ribbon Select a CSV file with x, y, z columns Tool parses CSV and validates format Family is loaded if not present Elements are created at each coordinate Summary dialog shows created/failed counts Creating Filled Regions Select wall or caisson elements in the view Click Filled Regions From Elements in the ribbon Tool identifies element types (wall vs. caisson) For walls: creates rectangular regions from bounding box For caissons: creates circular regions from diameter Summary dialog shows created/skipped counts Error Handling The tool follows DBTools error handling conventions: Error Condition Behavior CSV file not found Returns error message, no elements created Missing x/y/z columns Returns error message with column requirement Invalid number format Skips row, continues processing Family not found Attempts auto-load; fails with clear message if unavailable No levels in document Throws with descriptive message No selection (regions) Throws with user instruction No suitable region type Logs warning, returns with all skipped Source: csharp/src/Tools/Common/3DElementsFromList/Features/CsvElementPlacer.cs:36-45 All commands display results via the alert service with appropriate variant (Info/Error). Source: csharp/src/Tools/Common/3DElementsFromList/Features/ElementsFromList3DCommand.cs:49-66 Related Documentation Architecture Overview - DBTools architecture and tool discovery Global Mapper - Example of a complex tool module Source Files Reviewed File Purpose manifest.yml Tool declaration and ribbon configuration ElementsFromList3DToolModule.cs Module registration ElementsFromList3DCommand.cs CSV import command FilledRegionsFromElementsCommand.cs Filled region command CsvCoordinateParser.cs Pure CSV parsing logic CsvElementPlacer.cs Element creation service FilledRegionCreator.cs Region creation service DBTools.ElementsFromList3D.csproj Project configuration CsvCoordinateParserTests.cs Unit tests TEST_SUMMARY.md Test documentation"
  },
  "developer-guide/tools/common/elevation-tags.html": {
    "href": "developer-guide/tools/common/elevation-tags.html",
    "title": "Elevation Tags | DB Tools",
    "summary": "Elevation Tags Elevation Tags is a Revit add-in tool that automatically aligns spot elevation tags in floor and ceiling plan views, ensuring consistent text positioning relative to leader endpoints. Overview Elevation Tags provides two modes of operation: Automatic Update: Tags are aligned when activating floor/ceiling plan views Manual Update: Users can trigger alignment on-demand via the ribbon button The tool calculates precise text positioning based on: Tag type font metrics (size, width scale, font family) View scale factor Leader direction Configurable offsets and text position preferences Source: csharp/src/Tools/Common/ElevationTags/Features/ElevationTagsAutoUpdater.cs:59-91 Features Feature Description Auto-Update on View Activation Automatically aligns elevation tags when opening floor/ceiling plan views Manual Alignment Command Ribbon button to align tags in the active view on-demand Regex Tag Filtering Configure which tags to align using regex patterns (up to 3 patterns) Text Position Control Position text above or below the tag origin Offset Adjustments Fine-tune horizontal and vertical positioning with model-unit offsets Warning System Tool can be disabled via warnings, preventing accidental auto-updates Source: csharp/src/Tools/Common/ElevationTags/Settings/ElevationTagsSettings.cs:21-56 User Interface Ribbon Button The tool adds a single ribbon button: Display Text: \"Align Elevation Tags\" Tooltip: \"Align elevation tags in the active view\" Icon: align_elevation_tags_icon.png Availability: Only enabled when an active view is present Source: csharp/src/Tools/Common/ElevationTags/manifest.yml:18-26 Settings Panel The settings UI provides controls for: Auto-Update Toggle - Enable/disable automatic updates on view activation Tag Name Patterns - Regex patterns to match elevation tag names (max 3) Alignment Offsets - Horizontal and vertical offset values with spinner controls Text Position - Radio buttons for Above/Below positioning Source: csharp/src/Tools/Common/ElevationTags/Settings/ElevationTagsSettingsPackView.xaml:43-259 Architecture Module Structure csharp/src/Tools/Common/ElevationTags/ +-- DBTools.ElevationTags.csproj # Project file +-- ElevationTagsToolModule.cs # DI registration entry point +-- manifest.yml # Tool manifest +-- Assets/ | +-- align_elevation_tags_icon.png +-- Features/ | +-- AlignElevationTagsInViewCommand.cs # Ribbon command | +-- ElevationTagsAutoUpdater.cs # Core alignment logic +-- Hooks/ | +-- ElevationTagsViewActivatedTask.cs # View activation handler +-- Settings/ +-- ElevationTagsSettings.cs # Settings model +-- ElevationTagsSettingsPackContext.cs # Settings UI context +-- ElevationTagsSettingsPackView.xaml # Settings UI view +-- ElevationTagsSettingsPackView.xaml.cs Source: Directory structure of csharp/src/Tools/Common/ElevationTags/ Data Flow +---------------------------+ | View Activation / Command | +-----------+---------------+ | v +---------------------------+ | ElevationTagsViewActivated| | Task / Command | +-----------+---------------+ | | Retrieves settings, creates updater v +---------------------------+ | ElevationTagsAutoUpdater | +-----------+---------------+ | +----------------------+----------------------+ | | | v v v +--------------+ +-----------------+ +------------------+ | Collect Tags | | Compute Layout | | Update Positions | | (Regex Match)| | Inputs | | (Transaction) | +--------------+ +-----------------+ +------------------+ Key Classes Class File Purpose ElevationTagsToolModule ElevationTagsToolModule.cs:14-92 Tool module registration; registers settings, services, and settings packs AlignElevationTagsInViewCommand Features/AlignElevationTagsInViewCommand.cs:19-48 Ribbon command entry point; creates updater and runs alignment ElevationTagsAutoUpdater Features/ElevationTagsAutoUpdater.cs:15-232 Core alignment logic; computes text positions and updates spot dimensions ElevationTagsViewActivatedTask Hooks/ElevationTagsViewActivatedTask.cs:20-66 View activation hook; triggers auto-update on floor/ceiling plan views ElevationTagsSettings Settings/ElevationTagsSettings.cs:21-56 Settings model with default values ElevationTagsSettingsPackContext Settings/ElevationTagsSettingsPackContext.cs:18-242 MVVM context for settings UI with validation Source: csharp/src/Tools/Common/ElevationTags/ElevationTagsToolModule.cs:14-92 Alignment Algorithm The ElevationTagsAutoUpdater.TryUpdateSpot() method performs the alignment calculation: Extract Tag Properties Origin position, leader end position, current text position Tag type parameters (text height, width scale, font name) Elevation base setting (Project Base Point, Survey Point, Relative) Format Elevation Value Apply elevation indicator prefix/suffix Format using document unit settings Measure Text Use GDI+ to measure formatted text string Account for font size scaled to view Calculate New Position Horizontal offset based on text width and leader direction Vertical offset based on text height and position setting (Above/Below) Apply user-configured offset adjustments Update Position Only update if position changed (rounded to 2 decimal places) Set SpotDimension.TextPosition to new XYZ Source: csharp/src/Tools/Common/ElevationTags/Features/ElevationTagsAutoUpdater.cs:145-231 View Activation Hook The ElevationTagsViewActivatedTask implements ViewActivatedTaskBase<ElevationTagsSettings>: protected override Task<bool> ShouldRunInternalAsync( UIApplication uiapp, ViewActivatedEventArgs args, ElevationTagsSettings settings, CancellationToken ct) { var view = app.ActiveUIDocument?.Document?.ActiveView; if (view == null) return Task.FromResult(false); return Task.FromResult( view.ViewType == ViewType.FloorPlan || view.ViewType == ViewType.CeilingPlan); } The task only runs when: Auto-update is enabled in settings No active warning is set The activated view is a floor plan or ceiling plan Source: csharp/src/Tools/Common/ElevationTags/Hooks/ElevationTagsViewActivatedTask.cs:40-52 Settings Settings Model public sealed class ElevationTagsSettings : IAutoUpdateSettings { /// <summary>Whether auto-update on view activation is enabled.</summary> public bool AutoUpdateEnabled { get; set; } = true; /// <summary>Whether a warning has been set (disables auto-update).</summary> public bool HasWarning { get; set; } /// <summary> /// Regex patterns to match tag names. Tags matching any pattern will be aligned. /// Default pattern matches tags starting with \"DB Elevation Tag\". /// Maximum of 3 patterns. /// </summary> public List<string> TagNamePatterns { get; set; } = new() { \"^DB Elevation Tag\" }; /// <summary>Horizontal offset factor applied during text positioning (model units).</summary> public double HorizontalOffset { get; set; } /// <summary>Vertical offset factor applied during text positioning (model units).</summary> public double VerticalOffset { get; set; } /// <summary>Position of aligned text relative to the tag origin.</summary> public ElevationTextPosition TextPosition { get; set; } = ElevationTextPosition.Above; } Source: csharp/src/Tools/Common/ElevationTags/Settings/ElevationTagsSettings.cs:21-56 Text Position Enum public enum ElevationTextPosition { /// <summary>Text is positioned above the tag origin.</summary> Above = 0, /// <summary>Text is positioned below the tag origin.</summary> Below = 1 } Source: csharp/src/Tools/Common/ElevationTags/Settings/ElevationTagsSettings.cs:9-16 Default Values Setting Default Value Description AutoUpdateEnabled true Auto-update is enabled by default HasWarning false No warning set initially TagNamePatterns [\"^DB Elevation Tag\"] Matches tags starting with \"DB Elevation Tag\" HorizontalOffset 0.0 No additional horizontal offset VerticalOffset 0.0 No additional vertical offset TextPosition Above Text positioned above the tag origin Configuration Section Settings are stored under the Tools.ElevationTags configuration section. Source: csharp/src/Tools/Common/ElevationTags/manifest.yml:7 Manifest id: DBTools.ElevationTags assembly: DBTools moduleType: DBTools.ElevationTags.ElevationTagsToolModule order: 0 tool: settings: configSection: Tools.ElevationTags settingsPacks: - key: common.elevation_tags title: \"Elevation Tags\" warnings: - id: core.structural.elevation_tags title: \"Elevation Tags Disabled\" message: \"Elevation tag alignment is disabled due to a warning. Clear the warning to re-enable.\" disableTools: - DBTools.AlignElevationTagsInView ribbonTools: - internalName: DBTools.AlignElevationTagsInView commandType: DBTools.ElevationTags.AlignElevationTagsInViewCommand availabilityType: DBTools.App.Tools.Availability.DbtActiveViewAvailability runProfile: InlineUi displayText: \"Align Elevation\\nTags\" iconBaseKey: align_elevation_tags tooltip: \"Align elevation tags in the active view\" controlKind: PushButton order: 20 Source: csharp/src/Tools/Common/ElevationTags/manifest.yml:1-27 Manifest Properties Property Value Description id DBTools.ElevationTags Unique tool identifier assembly DBTools Target assembly name moduleType DBTools.ElevationTags.ElevationTagsToolModule Entry point class order 0 Load order priority configSection Tools.ElevationTags Settings configuration key runProfile InlineUi Runs on UI thread with inline modal gate availabilityType DbtActiveViewAvailability Command available when active view exists Warning System The tool defines a single warning that can disable functionality: Warning ID: core.structural.elevation_tags Title: \"Elevation Tags Disabled\" Effect: When active, disables the AlignElevationTagsInView command and auto-update When the warning is set: HasWarning becomes true AutoUpdateEnabled is forced to false The toggle in settings is disabled Source: csharp/src/Tools/Common/ElevationTags/ElevationTagsToolModule.cs:47-68 API Reference ElevationTagsAutoUpdater The main alignment class that processes spot elevation tags: public sealed class ElevationTagsAutoUpdater { public ElevationTagsAutoUpdater( ITransactionRunner tx, Document doc, View activeView, ILogger<ElevationTagsAutoUpdater> logger, ElevationTagsSettings? settings = null); /// <summary> /// Runs the alignment process and returns the count of updated tags. /// Only processes floor plan and ceiling plan views. /// </summary> public int Run(); } Source: csharp/src/Tools/Common/ElevationTags/Features/ElevationTagsAutoUpdater.cs:27-91 Filtering Logic Tags are collected using a FilteredElementCollector scoped to the active view: var tags = new FilteredElementCollector(_doc, _view.Id) .OfCategory(BuiltInCategory.OST_SpotElevations) .WhereElementIsNotElementType() .ToElements(); Each tag's name is tested against all configured regex patterns. Tags matching any pattern are included. Source: csharp/src/Tools/Common/ElevationTags/Features/ElevationTagsAutoUpdater.cs:96-122 Elevation Base Handling The tool respects the elevation base setting on tag types: Base Setting Behavior Survey Point Uses raw elevation value Project Base Point Subtracts project base point Z from elevation Relative Tag is skipped (not aligned) Source: csharp/src/Tools/Common/ElevationTags/Features/ElevationTagsAutoUpdater.cs:166-170 Troubleshooting Common Issues Issue Cause Resolution Tags not aligning No patterns match tag names Add regex pattern matching your tag family names Auto-update not running Warning is active Clear the warning in settings panel Auto-update not running Disabled in settings Enable auto-update toggle No tags in view View type not supported Only floor and ceiling plans are processed Invalid regex pattern Syntax error in pattern Check regex syntax; patterns are validated Tags with Relative base skipped By design Tags with Relative elevation base cannot be aligned Logging The tool logs diagnostic information via ILogger<ElevationTagsAutoUpdater>: Invalid regex patterns are logged as warnings Tags that fail to filter or update are logged (first occurrence only) Units format option errors are logged _logger.LogWarning(ex, \"[ElevationTags] Invalid regex pattern '{Pattern}'; skipping.\", pattern); _logger.LogWarning(\"[ElevationTags] No valid tag name patterns are configured; auto-update will be skipped.\"); _logger.LogWarning(ex, \"[ElevationTags] Some elevation tags could not be updated; continuing.\"); Source: csharp/src/Tools/Common/ElevationTags/Features/ElevationTagsAutoUpdater.cs:51-189 Related Documentation Architecture Overview - DBTools architecture fundamentals Theme System - UI theming for settings panels Source Files Reviewed File Purpose manifest.yml Tool declaration and ribbon configuration ElevationTagsToolModule.cs Module registration and DI setup AlignElevationTagsInViewCommand.cs Ribbon command entry point ElevationTagsAutoUpdater.cs Core alignment algorithm ElevationTagsViewActivatedTask.cs View activation hook ElevationTagsSettings.cs Settings model definition ElevationTagsSettingsPackContext.cs Settings UI view model ElevationTagsSettingsPackView.xaml Settings UI layout DBTools.ElevationTags.csproj Project configuration"
  },
  "developer-guide/tools/common/gm-spec.html": {
    "href": "developer-guide/tools/common/gm-spec.html",
    "title": "Global Mapper Specification | DB Tools",
    "summary": "Global Mapper Specification Version: 2.0 Last Updated: November 26, 2025 Table of Contents Part I: Foundation Overview Architectural Principles Part II: Architecture Domain Model Cache Architecture Error Handling Part III: UI/UX Window Lifecycle Duplicates Tab Progress Overlays Families Tab Line Styles / Object Styles / Materials Tabs Shared Parameters Tab Global Controls Apply & Review Workflow Performance Part IV: Features Deep Scan Type Mapping Preview Pane Sorting, Filtering, Threshold Part V: Quality & Implementation Known Issues & Roadmap Quality Acceptance Criteria Part I: Foundation 1. Overview 1.1 Purpose and Scope This specification defines the complete behavioral, architectural, and quality requirements for the Global Mapper (GM) tool. It serves as the authoritative reference for: Developers: Implementation guidance with detailed behavioral specifications QA/Testers: Acceptance criteria and validation requirements Product Owners: Feature completeness and user experience standards AI Agents: Context for code generation and refactoring decisions 1.2 Tool Overview Global Mapper is an advanced Revit plugin that enables bulk mapping and migration of: Families → Families (with type, parameter, material, object style mappings) Line Styles → Line Styles Object Styles → Object Styles Materials → Materials Shared Parameters → Project parameters or embedded family parameters The tool provides similarity-based matching, manual overrides, deep scanning for detailed family analysis, and atomic apply/rollback workflows. 2. Architectural Principles These are the foundational, non-negotiable constraints that govern all GM code. 2.1 Core Invariants Kernel-Only, Ids-Only Data Model All domain data is stored as Revit element IDs only (integers) No names or descriptive strings in core data structures Names are resolved only when visible in UI, never during render loops Data is section-gated: families, usage (line/object styles, materials), shared_params Fail-Fast, No Fallbacks, No Silent Failures No fallback logic anywhere in codebase No broad exception catches (typed exceptions only at narrow boundaries) No defensive defaults to hide incorrect state Fix root causes, never add wrappers or UI patches Surface all errors via overlays, banners, or typed exceptions // WRONG - swallows exception try { File.Delete(file); } catch { } // CORRECT - logs and propagates try { File.Delete(file); } catch (Exception ex) { _logger.LogError(ex, \"Failed to delete cache file: {Path}\", file); throw; } Section-Gated Loading Data is built in sections: families, usage, shared_params Sections load lazily on first tab visit (not all at startup) Never return placeholder/fallback content if section is missing Throw explicit error or build section exactly once Always-Fresh Cache Architecture Families, types, materials, usage, shared parameters are always queried fresh from Revit No snapshot caching of live data Deep scan cache only (global, name-keyed, cross-document portable) UI state persistence is separate from data (tab, search, scroll, filters) DDD Layering (Domain → Application → Infrastructure) Domain layer: pure entities, value objects, no Revit types Application layer: orchestrators, lifecycle, queries, read models Infrastructure layer: Revit adapters, persistence repositories UI layer: binds only to Application interfaces DBTools.GM.App/Domain/* DBTools.GM.App/Application/* DBTools.GM.App/Infrastructure/* DBTools.UI/ViewModels/GM/* (consumes Application only) Roslyn analyzers prevent forbidden cross-namespace usage. First Paint, Then Work; Single Overlay Paradigm Window renders immediately (first paint) without running collectors After paint, initial work runs via dispatcher under progress overlay with cancellation Never double-overlay (only overlay long work) Commands disabled while busy (IsBusy affects CanExecute) 2.2 Data Model Constraints Ids-Only Persistence All persisted data uses element IDs (integers) Names/descriptors are UI-time hydration only Deep scan cache uses name/signature composite keys for portability Hydration on Demand Resolve names only for visible rows Target option lists are pre-built for current category only Nested details remain lazy (never pre-built) Write Policy UI state writes only on window close (no mid-session writes) Deep scan cache writes immediately on scan completion No resume JSON during session (always-fresh eliminates need) 2.3 Error Handling Philosophy Typed Exceptions at Boundaries // Domain exceptions GmKernelError (base) ├── GmSnapshotLoadError (snapshot parse/version mismatch) ├── GmCollectionError (adapter failures during bulk reads) ├── GmInvalidMappingError (invalid/unsupported plan operations) └── GmApplyStageError (with Stage name and inner failure aggregation) SafeExecute Boundary Pattern All top-level UI entrypoints execute under ISafeExecutor: // Entrypoint wrapper csharp/DBTools.Core/Execution/SafeExecutor.cs:10-29 // Used by ViewModels csharp/DBTools.UI/ViewModels/GM/GlobalMapperViewModel.cs:185,238,265,314,336 Error Surfaces Notification Banner — Single-instance manager, fade in/out, auto-close Progress Overlay Errors — Overlay shows during long ops, surfaces errors inline Output Window — Live window with search, copy/clear/export, level filters, duplicate grouping Error Boundary (Window-Level) — UnobservedTaskException handling, banner on background failures Part II: Architecture 3. Domain Model 3.1 GMProjectState (Root Aggregate) The kernel is the single source of truth for all domain data during a session. namespace DBTools.GM.App.Kernel public sealed class GMProjectState { // Snapshot reference (for resume) public GMSourceSnapshot SourceSnapshot { get; init; } // Families by ID public IReadOnlyDictionary<int, GMFamilyRecord> Families { get; init; } // Usage indices (materials, line styles, object styles) public GMUsageIndex Usage { get; init; } // Shared parameter ledger public GMSharedParameterLedger SharedParameters { get; init; } // Tab UI state public GMTabStateCollection Tabs { get; init; } } 3.2 GMFamilyRecord public sealed class GMFamilyRecord { public int ElementId { get; init; } // FamilyId public int? CategoryId { get; init; } // Optional category public string? Name { get; init; } // Lazy via names service; UI-only cache public int InstanceCount { get; init; } // Child entities public IReadOnlyDictionary<int, GMTypeRecord> Types { get; init; } // By SymbolId // Usage references public IReadOnlyCollection<int> Materials { get; init; } public IReadOnlyCollection<int> ObjectStyles { get; init; } public IReadOnlyCollection<int> LineStyles { get; init; } // Parameters (name → descriptor) public IReadOnlyDictionary<string, GMParameterDescriptor> Parameters { get; init; } // Deep scan state public GMDeepScanState DeepScanState { get; init; } } Parameter Inclusion Rules: Parameters are filtered programmatically (no curated name lists). Include parameter if ALL of these are true: Definition is InternalDefinition (not ExternalDefinition/shared) BuiltInParameter == INVALID Parameter.IsReadOnly == False Definition.UserModifiable == True De-duplicate by name across instance/type scopes Annotate scope as Instance, Type, or Instance+Type 3.3 GMTypeRecord public sealed class GMTypeRecord { public int SymbolId { get; init; } public int FamilyId { get; init; } // Usage for this type public GMTypeUsage Usage { get; init; } // Materials/styles referenced // Sampled parameter values (for SP mapping UI) public IReadOnlyDictionary<string, string?> ParameterValues { get; init; } // Deep scan payload public GMTypeDeepScan DeepScanPayload { get; init; } } 3.4 GMUsageIndex public sealed class GMUsageIndex { public IReadOnlyDictionary<int, GMUsageRecord> LineStyles { get; init; } public IReadOnlyDictionary<int, GMUsageRecord> ObjectStyles { get; init; } public IReadOnlyDictionary<int, GMUsageRecord> Materials { get; init; } } public sealed class GMUsageRecord { public int ElementId { get; init; } // Style or material ID public IReadOnlyCollection<int> Families { get; init; } // Family IDs referencing this element } Canonical Uniqueness: One row per style/object style/material from usage section No duplicates (duplicates indicate hydration or binding bugs) Built once per session, cached in kernel 3.5 GMDeepScanState public sealed class GMDeepScanState { public bool IsDeepScanned { get; init; } public IReadOnlyList<int> SampleInstanceIds { get; init; } public IReadOnlyList<string> ParameterNames { get; init; } public IReadOnlyCollection<int> StyleRefs { get; init; } public IReadOnlyCollection<int> MaterialRefs { get; init; } } Deep Scan Augmentation: Families discovered only via deep scan appear in usage lists with DS badge Usage count remains 0 if no instances in project DS badge distinguishes deep-scan-only from in-project usage 3.6 Section Gating Rules Families Section: Built on initial load for default curated category Rebuilt on category change Never contains all categories at once (lazy per category) Usage Section: Built on first visit to Line Styles, Object Styles, or Materials tab Split into line vs object styles using IStyleService Cached for session (reused across tabs) Shared Parameters Section: Built on first visit to SP tab Curated groups only (hard-coded list) Cached for session Lazy Loading Policy: Tabs other than active: lazily loaded on first visit (overlay if needed) Families and SP: reload on category change (overlay if needed) Expanded row details: always lazy (on \"+\" and/or after \"Scan Family\") 3.7 Element Uniqueness Guarantees Families: One GMFamilyRecord per unique FamilyId in selected category Types: One GMTypeRecord per SymbolId under each family Usage: One GMUsageRecord per unique line style / object style / material ID No duplicates across tabs (line styles ≠ object styles ≠ materials) Shared Parameters: One group per SharedParameterFile group One definition per SP within group Violation Handling: Duplicates indicate collector or hydration bug Must throw GmCollectionError with details Never silently dedupe or use fallback 4. Cache Architecture 4.1 Always-Fresh Data Model Live Data (Always Fresh from Revit): Families (for current category) Types (for loaded families) Materials (project + linked) Line Styles (project + linked) Object Styles (project + linked) Shared Parameters (from SharedParameterFile) Querying: Every tab load queries Revit API fresh Session in-memory cache for instant tab switching within session No staleness verification needed (data is current by definition) 4.2 Deep Scan Cache (Global, Name-Keyed) Persistence: File: .deepscans in GM cache directory (global, NOT document-specific) Format: JSON with composite keys Composite Key: public sealed class DeepScanCacheKey { public string FamilyName { get; init; } public int TypeCount { get; init; } public string ParameterSignature { get; init; } // Hash of parameter names } Payload: public sealed class DeepScanCache { public DeepScanCacheKey Key { get; init; } public IReadOnlyList<string> ParameterNames { get; init; } public IReadOnlyList<int> InstanceCounts { get; init; } public IReadOnlyCollection<int> NestedFamilyIds { get; init; } public DateTime CachedAt { get; init; } } Write Semantics: Deep scan completion writes immediately to .deepscans file Enables cross-session and cross-document reuse Rationale: Name-based keys portable across documents Enables global cache (not doc-specific) Staleness detection via signature comparison (shown to user) 4.3 Staleness Indicators When Deep Scan Cache Might Be Stale: Family renamed in external project Types added/removed (TypeCount mismatch) Parameters added/removed (ParameterSignature mismatch) UI Behavior: Show staleness indicator badge in UI (\"⚠ May be outdated\") Tooltip: \"Deep scan data may be stale. Re-scan for latest.\" User can trigger re-scan manually Never use stale data silently without indicator 4.4 UI State Cache (Document-Scoped) Persistence: File: .gmstate_{documentKey}.json per document Format: JSON with UI preferences Content: public sealed class GmUiState { public string DocumentKey { get; init; } public int Version { get; init; } = 1; // Strict version checking // Tab state public int SelectedTabIndex { get; init; } public int? SelectedCategoryId { get; init; } // Filters public bool FilterUnused { get; init; } public bool FilterApplied { get; init; } public bool FilterUnscanned { get; init; } public string? SearchText { get; init; } public int SimilarityThreshold { get; init; } public string SortMode { get; init; } // \"Similarity\" | \"Alphabetical\" // Scroll positions public double? FamiliesScrollOffset { get; init; } public double? StylesScrollOffset { get; init; } public double? MaterialsScrollOffset { get; init; } public double? SPTypesScrollOffset { get; init; } public double? SPParamsScrollOffset { get; init; } // Expanded state public IReadOnlyList<int> ExpandedFamilies { get; init; } public int? SelectedSPTypeSymbolId { get; init; } // SP selections public IReadOnlyList<SPSelection> SPSelections { get; init; } } public sealed class SPSelection { public int SymbolId { get; init; } public IReadOnlyList<SPParamSelection> Params { get; init; } } public sealed class SPParamSelection { public string Name { get; init; } public bool Apply { get; init; } public bool IsHostLevel { get; init; } public bool? IsTypeBinding { get; init; } public string? MapFromName { get; init; } } Write Policy: Only on window close (no mid-session writes) Exception: User-initiated \"Save Now\" if added (explicit, not automatic) Version Checking: CurrentVersion = 1 (increment on schema change) On load, if version mismatch → throw GmSnapshotLoadException UI proceeds with fresh state (no fallback to old schema) 5. Error Handling 5.1 No Fallbacks Policy Absolute Prohibitions: No fallback logic anywhere in codebase // WRONG var names = _kernel?.FamilyNames ?? new Dictionary<int, string>(); // CORRECT if (_kernel == null) throw new InvalidOperationException(\"Kernel must be initialized before building plan context.\"); var names = _kernel.FamilyNames; No broad catches — typed exceptions only // WRONG try { ... } catch (Exception) { /* silent */ } // CORRECT try { ... } catch (GmCollectionError ex) { _logger.LogError(ex, \"Failed to collect families for category {CategoryId}\", categoryId); throw; } No silent failures — user must see what went wrong // WRONG try { File.Delete(file); } catch { } // CORRECT try { File.Delete(file); } catch (Exception ex) { _logger.LogError(ex, \"Failed to delete cache file: {Path}\", file); throw; } No defensive defaults — fix root causes No wrapper shortcuts — address problems at source 5.2 Typed Exceptions Exception Types (standalone, no inheritance required): Each exception type is a standalone sealed class with an error code for programmatic handling. See GmKernelExceptions.cs for complete implementation. namespace DBTools.GM.Kernel; // Error codes for kernel exceptions (1xxx=Build, 2xxx=Mapping, 3xxx=Invariant, 4xxx=Snapshot, 5xxx=Collection/Apply) public enum GmKernelErrorCode { ... } // Kernel build failures (name resolution, nesting index, etc.) public sealed class GmKernelBuildException : Exception { public GmKernelErrorCode Code { get; } } // Invalid mapping operations public sealed class GmInvalidMappingException : Exception { public GmKernelErrorCode Code { get; } } // Snapshot load failures public sealed class GmSnapshotLoadException : Exception { public GmKernelErrorCode Code { get; } } // Invariant violations (invalid IDs, negative counts) public sealed class GmInvariantViolationException : Exception { public GmKernelErrorCode Code { get; } } // Adapter/collection failures when retrieving data from Revit public sealed class GmCollectionError : Exception { public GmKernelErrorCode Code { get; } public string CollectorName { get; } } // Apply stage failures with aggregated inner exceptions public sealed class GmApplyStageError : Exception { public GmKernelErrorCode Code { get; } public string StageName { get; } public IReadOnlyList<Exception> InnerFailures { get; } } 5.3 SafeExecute Integration Pattern: // All top-level UI entrypoints execute under ISafeExecutor await _runner.RunAsync(\"GM Apply - Full Plan\", async () => { // ... application logic that may throw typed exceptions }); Behavior: Catches all exceptions from inner lambda Logs to centralized logger Shows banner notification to user Never masks or silently swallows 5.4 Overlay Error Surfacing When Used: Initial tab load after paint Category change (Families, SP) Deep scan Refresh/rebuild operations Behavior: Shows titled steps with ticks Throttled progress updates Cancel button sets cancel_requested (collectors honor it) On error: show error message in overlay, do NOT close window Never: Double-overlay (check IsBusy before showing) Close window on error (surface via overlay, let user decide) Part III: UI/UX 6. Window Lifecycle 6.1 Entry and First Paint Behavior: Entry: Global Mapper button clicked → window opens (modal) First Paint: Show window immediately WITHOUT running collectors Loaded Event: Restore UI state from .gmstate file (tab, search, sort, threshold, filters, scroll offsets) Use dispatcher to start initial loads AFTER paint completes Critical: Window renders before any data collection begins. 6.2 Initial Load Sequence After First Paint: Dispatcher-posted initial work under progress overlay: \"Loading Families...\" \"Building usage indices...\" \"Resolving names...\" Default tab (or restored tab from UI state) loads first Other tabs lazy-loaded on first visit _initial_load_complete flag set when default tab ready Gating: SelectionChanged events ignored until _initial_load_complete = true Commands disabled while IsBusy = true 6.3 Tab Lazy Loading Policy: Families Tab: Load on first visit (or immediately if default tab) Line Styles / Object Styles / Materials: Build usage section on first visit, then cache Shared Parameters: Build SP ledger on first visit, then cache Category Change: Families tab: Reload families for new category (show overlay) SP tab: Reload family/type tree for new category (show overlay) Never: Reload tabs on revisit (data cached in session) Show overlay on tab switch if data already cached 6.4 Close Behavior On Window Close: Deep scan cache: Already written mid-session (global .deepscans file) UI state: Write .gmstate_{documentKey}.json with all UI preferences Session cache: Cleared (in-memory only, not persisted) No mid-session writes for UI state. 7. Duplicates Tab The Duplicates tab is the FIRST tab in the Global Mapper window. 7.1 Purpose Identifies potential duplicate families, styles, materials, and shared parameters in the project using similarity algorithms. Users can accept suggested consolidations which become mappings applied during the Apply workflow. 7.2 Detection Service Trigger: Runs on tab activation or manual \"Run Scan\" button Configurable similarity threshold (slider in tab header) Categories Analyzed: Families — Name similarity + parameter overlap Line Styles — Weight, color, pattern comparison Object Styles — Weight, color, pattern comparison Materials — ARGB, transparency, name comparison Shared Parameters — Parameter key overlap (Jaccard index) Output: Grouped duplicate candidates with scores (0-100) and rationale text Each group has a source and multiple potential targets 7.3 Similarity Algorithms Naming Similarity (INamingSimilarityService): double Similarity(string a, string b); // Returns 0.0-1.0 string Normalize(string name); // Case-insensitive, trim whitespace bool TryGetNumericSuffixPair(string a, string b, out int aSuffix, out int bSuffix); Algorithm: Numeric suffix priority: \"Type 1\" vs \"Type 2\" → high similarity (common duplicate pattern) Dice coefficient (bigram) fallback: General string similarity for non-numeric names Normalization: Case-insensitive, whitespace-trimmed comparison Parameter Similarity (IParameterSimilarityService): int ComputeScore(IReadOnlyDictionary<string, string> left, IReadOnlyDictionary<string, string> right); Algorithm: Jaccard index for parameter key overlap Ignores Revit built-in parameters Used for Families and Shared Parameters categories Visual Property Similarity (Styles/Materials): Line Styles: Line weight, color RGB, line pattern Object Styles: Same as Line Styles Materials: ARGB values, transparency percentage, name similarity 7.4 UI Structure Main Grid (DuplicateGroupRow): Column Description Kind Category (Families, LineStyles, etc.) Source Source element name Suggestions Count of potential targets Highest Score Best match percentage Actions Accept All, Expand/Collapse Row Expansion (DuplicatePairRow): Column Description Apply Checkbox (enables this pair for mapping) Score Similarity percentage (0-100) Target Dropdown with target options Rationale Explanation of match reason Badges Lock (\uD83D\uDD12) and DS indicators 7.5 Commands Run Scan: Triggers detection for all categories Shows overlay: \"Detecting duplicates...\" Populates DuplicateGroups collection Accept: Converts selected pair to mapping rule Applies row locks to affected rows on other tabs Updates _successMappings dictionary Ignore: Sets Apply = false on pair Records in _duplicateSelections for persistence Accept All in Group: Batch accept for all Apply = true pairs in a group Single transaction for efficiency 7.6 Row Locking When a duplicate mapping is accepted: Source row on the target tab is locked (IsLocked = true) Checkbox disabled with tooltip: \"Locked by Duplicates tab (change there)\" User must change or remove mapping on Duplicates tab to unlock Lock Sources: Families tab selections (existing) Duplicates tab accepted mappings (this feature) Locking is ROW-level only. There is no tab-level locking. 7.7 Persistence Resume Snapshot Includes: public IDictionary<string, int[]>? DuplicateGroupMembers { get; set; } // key: kind:sourceId public double? DuplicatesScrollOffset { get; set; } public int? DuplicatesSimilarityThreshold { get; set; } Write Policy: Persisted on window close only (single JSON) No mid-session writes Restore Behavior: Rehydrate DuplicateSelections and group states Invalid group entries dropped with warning log No silent fallbacks 8. Progress Overlays 8.1 When Shown Always Show Overlay: Initial tab load after first paint Category change (Families, SP) Deep scan Apply plan execution Any \"long\" collector (>500ms expected) Never Show Overlay: Tab switch if data already cached Name resolution for visible rows (fast lookup) Search/filter/sort (instant, no API calls) 8.2 Behavior Display: Titled steps with tick marks Progress text: \"Loading Families...\" → \"Resolving names...\" → \"Complete\" Throttled updates (avoid UI spam) Cancellation: Cancel button sets cancel_requested flag Collectors honor flag and exit gracefully Partial results discarded (fail-fast, no half-loaded state) Error Handling: On error: show error message in overlay (do NOT close window) \"Retry\" button if operation is idempotent \"Close\" button dismisses overlay and returns to main UI 8.3 Never Double-Overlay Rule: Only ONE overlay at a time Enforcement: Check IsBusy flag before showing overlay If already busy, queue operation or reject with message Commands disabled via CanExecute while IsBusy = true 8.4 Throttled Progress Updates Pattern: // Update progress every N items or 200ms, whichever comes first var progress = new Progress<string>(msg => BusyText = msg); foreach (var chunk in items.Chunk(100)) { // Process chunk ((IProgress<string>)progress).Report($\"Processing {processedCount}/{totalCount}...\"); } Rationale: Avoid overwhelming UI thread with rapid updates. 9. Families Tab 9.1 Category Dropdown Data Source: Hard-coded curated category list (single source of truth) Exactly as currently implemented (no dynamic expansion) Mapped to actual Revit CategoryId via Category.GetCategory or Settings.Categories Implementation: csharp/DBTools.RevitAdapter/GM/Services/CategoryService.cs:17 Default Selection: Visual default: \"Annotation Symbols\" (first curated label) Never blank when rows are loaded 9.2 Loading Behaviors Initial Load: After first paint, load families for default curated category (\"Annotation Symbols\") Show overlay with steps: \"Collecting families...\" \"Counting instances...\" \"Resolving names...\" Results appear with dropdown visually selected Category Change: User selects different category from dropdown Show overlay (lazy load is acceptable) Reload families for selected category only Pre-build target option lists for current category 9.3 Row Structure Columns: Expand (+ icon) — Shows details (Types, Object Styles, Materials, Parameters) Quantity — instance_count for family ID (0 if no instances) Apply — Checkbox (enables this family for mapping plan) Saved — Badge (if mapping preference saved for this family) Deep Scan Badge — DS icon if family has been deep scanned Source — Family name (resolved from kernel name cache) Target — Combobox with scored options (identity excluded) Search/Sort/Filters — Applied across all rows 9.4 Target Combobox Behaviors Options Source: Built from peer families in same category (identity excluded) Pre-built at tab load for current category (cached for session) Switching into combobox should be instant (no delay) Similarity Mode: Each option shows colored label (green → orange → red) Similarity percentage appended: \"Target Family Name (85%)\" Sorted high → low by score Threshold influences default selection only (never override manual selection) Alphabetical Mode: Options sorted alphabetically No similarity colors/scores (default styling) No threshold filtering Manual Selection Preservation: Manual selection is sticky across re-sorts and threshold changes Only reset if target disappears from options (e.g., family deleted) 9.5 Unscanned Family Demotion Unscanned families appear beneath horizontal separator in target combobox: Greyed out and disabled until scanned Above separator: Ready options (selectable, colored in similarity mode) Below separator: Unscanned options (disabled, requires deep scan) After Scan: Move to above separator Enable selection Apply normal scoring/coloring 9.6 Expand Details With Instances (quantity > 0): Shows: Types (from symbol_ids in kernel) Object Styles (from usage indices) Materials (from usage indices) Parameter Names ONLY (not values) Built WITHOUT deep scan — kernel indices provide enough data for in-project families. Zero-Qty Gating (quantity = 0): Shows: \"Scan Family\" button Hint text: \"This family has no instances. Deep scan required to view details.\" Details panel disabled until scan completes After scan: Details unlock Types, Object Styles, Materials, Parameters appear DS badge added to top-level row 9.7 Nested Target Comboboxes Child grids within expanded family rows have target comboboxes: Types: Options from target family's symbols Same sort/threshold semantics as top-level Object Styles: Options from full universe of object styles Identity excluded Materials: Options from full universe of materials Identity excluded Parameters: Options from target family's deep scan parameter names First option: <Do Not Map> sentinel Deep scan required for parameter list (gated if not scanned) Lazy Loading: Do NOT pre-build nested options (only top-level pre-built) Build on expand or target change 9.8 Parameter Pruning Rules Include parameter if ALL of these are true: Definition is InternalDefinition (NOT ExternalDefinition or shared) BuiltInParameter == INVALID Parameter.IsReadOnly == False Definition.UserModifiable == True De-duplication: De-duplicate by name across instance/type scopes Annotate scope: Instance, Type, or Instance+Type No curated name lists (programmatic filters only). 9.9 Cross-Tab Apply Lock When Families tab sets Apply on Object Style or Material mapping: Corresponding top-level row on Object Styles or Materials tab reflects this Row is locked (Apply checkbox disabled with \"F\" badge) Un-apply ONLY from Families tab (not from locked tab) Visual Indicator: Blue \"F\" badge next to Apply checkbox Tooltip: \"Locked by Families tab mapping\" 9.10 Preview Pane Toggle Within expanded family details, when selecting: Object Style row → Show/hide preview pane (swatch + style line) Material row → Show/hide preview pane (color swatch + properties) Behavior: Preview appears on right side of window Toggle via checkbox or auto-show on selection 9.11 Instance Navigation Families tab does NOT have instance navigation. Instance cycling is SP-only feature Families tab shows quantity and \"Views Containing\" list Double-click view navigates, but no prev/next cycling within tab 9.12 Quantity vs Views Containing Pane Quantity Column: Reflects instance_count from kernel 0 means no instances in project Views Containing Selected Family (Right Pane): Populated ONLY when quantity > 0 Shows all views containing selected family instances (EXCLUDES templates) Double-click view → navigates and zooms to instance Consistency Rule: If quantity = 0 → pane should be EMPTY If quantity > 0 but pane empty → bug (count miscalculation) 10. Line Styles / Object Styles / Materials Tabs 10.1 Row Sources Data: One row per style/object style/material from usage section of kernel Canonical uniqueness: NO duplicates (violation = hydration bug) Quantity: Line Styles: Usage count (number of families using this style) Object Styles: Families count (number of families using this object style) Materials: Families count (number of families using this material) Zero Quantities: Visible (not filtered out) Deep-scan-only families may contribute to usage with 0-qty (DS badge shown) 10.2 Target Options Options Source: Peer rows in current tab (identity excluded) Same universe as source rows Similarity Mode: Colored labels (green → orange → red) Similarity percentages: \"Target Name (92%)\" Sorted high → low Alphabetical Mode: Default styling (no colors) No percentages Sorted lexicographically Threshold: Influences default selection only Never overrides manual selection Materials/Styles rows are NOT filtered by threshold (only option selection affected) 10.3 Validation (No Duplicates) Enforcement: Collector source must provide unique IDs Hydration/binding must not duplicate rows Violation Handling: If duplicates detected → throw GmCollectionError Never silently dedupe 10.4 Sorting Modes Similarity: Rows sorted by highest similarity to target (if target selected) Or by usage count descending Alphabetical: Rows sorted by source name A-Z Threshold ignored Threshold Influence: Threshold slider affects option list default selection only Row visibility unaffected (all rows shown regardless of threshold) 10.5 Preview and Usage Lists Selection Behavior: Line Styles: Select row → preview updates (swatch and style line rendering) No \"Families Using This ...\" pane (line styles are host-document-only) Object Styles: Select row → preview updates (swatch and style line rendering) \"Families Using This Object Style\" pane populates with family names Double-click family → navigate to view and show instance Materials: Select row → preview updates (color swatch, texture, properties) \"Families Using This Material\" list populates Double-click family → navigate to view and show instance 10.6 DS Badges When Shown: Row has any DS-scanned families in usage list Badge: \"DS\" icon or text Tooltip: \"Includes deep-scanned families\" Deep Scan Augmentation: Families discovered ONLY via deep scan appear in \"Families Using This ...\" lists (Object Styles, Materials) DS badge distinguishes them Usage count remains accurate (0 if no instances) 11. Shared Parameters Tab 11.1 Layout Left Panel: Groups from SharedParameterFile Definitions within selected group Browse-only (no mutations) Right Panel (Main Grid): Families → Types → Parameters tree for selected curated category Single-selection semantics (only one type expanded at a time) 11.2 Group and Category Dropdowns Group Dropdown: Populated from SharedParameterFile (or pre-collected snapshot) Default: First group alphabetically Never blank Category Dropdown: Hard-coded curated category labels (e.g., Walls, Doors, Mechanical Equipment, Windows) No dynamic expansion Default: First curated category Never blank Loading: After selecting group and category, main grid updates Shows families/types for curated category with SP inventory 11.3 Main Grid Scoping Data Sources: shared_params section: powers left panel (groups/definitions) families section: powers family/type tree (right grid) for selected category Scoping: Grid shows ONLY families in selected curated category Each row: Family → Types → Parameters Empty Grid: If no families in curated category → show clear banner \"No eligible families in selected category\" Keep categories curated (do NOT expand dynamically) 11.4 Type Details Expansion Header: Instance Navigator: Left/right arrows (cycles instances) Instance Count: \"Instance 3 of 27\" Zoom to Instance Button: Navigates and highlights current instance Compact Summary: Current instance name and ElementId Parameter Grid (below header): Section 1: Existing Parameters Type and instance parameters for selected type Current values from sampled instances (sampling cap applies) NOT editable (read-only display) Separator Section 2: Shared Parameters from Selected Group Each SP row: Apply Checkbox: Enables mapping End-State Toggle: Host-level vs Embed-in-family Map From Dropdown: Existing parameters with values (scored by name similarity + coverage) Current Value: From visible instance Proposed Value: From \"Map From\" parameter Diff Styling: Old struck-through, new in red/bold when different 11.5 Instance Navigation Instance navigation is available on the Shared Parameters tab only. Behavior: Navigator appears inside SP type rows when instances sampled Prev/Next arrows cycle through instances Current and Proposed values update live on cycle Proposed turns red/bold when different from Current Families Tab: Does NOT have instance navigation Shows quantity and \"Views Containing\" list only 11.6 Scoring and Defaults for \"Map From\" Algorithm: Combine name similarity (same as Families tab matching) with value coverage Coverage = % of sampled instances with non-empty values Highest combined score preselected Manual Override: User can change \"Map From\" selection Selection preserved across refreshes 11.7 Visual Indicators Badges: Host-level bound: Badge if SP already exists as project parameter Embedded: Badge if SP already embedded in family Deep Scan: DS badge if deep scan data available for this family Gating Label: \"Deep Scan required\" shown when reading embedded schema needed (e.g., unplaced types) 11.8 Apply Semantics Host-Level: Bind SP to Category (Type or Instance per SP definition) Copy values from selected \"Map From\" parameter Batch operation (all checked SPs in one transaction) Embed-in-Family: Open family in background Add SP per definition (Type or Instance) Set default values Reload family Copy values from \"Map From\" parameter No \"Remove Source\" Option: Source parameter retained after copy User must manually delete if desired 11.9 Persistence On Close (UI State): Selected SP type (SelectedSPTypeSymbolId) SP Types and Parameters scroll offsets Per-type parameter selections: Apply checkbox state Host-level vs Embed toggle \"Map From\" selection by name NOT Persisted: Nested scroll positions inside type details Sampled instance values (always fresh on load) 12. Global Controls 12.1 Sort Mode Options: Similarity: Colored labels with percentages, sorted high→low, threshold-aware Alphabetical: Default styling, lexicographic sort, threshold ignored Applies To: ALL target option lists (top-level and nested) Families, Line Styles, Object Styles, Materials tabs Behavior: Switching mode updates ALL visible comboboxes instantly Manual selections preserved (only re-sorted, not cleared) 12.2 Threshold Slider Purpose: In similarity mode: influences default selection only Options below threshold NOT auto-selected Manual selections NEVER overridden by threshold change Range: 0-100 (similarity percentage) Debounced: 200ms debounce to avoid UI spam Applies To: Families, Line Styles, Object Styles, Materials tabs Top-level AND nested target option lists Does NOT Apply To: Row visibility (all rows shown regardless of threshold) Alphabetical mode (threshold ignored) 12.3 Search Behavior: Filters SourceName for active tab Case-insensitive substring match Real-time (no debounce needed for simple string filter) Applies To: Families, Line Styles, Object Styles, Materials, SP tabs 12.4 Filters Available Filters: Hide Unscanned (Families only) Hides families without deep scan data Checkbox toggle Show Applied Only Shows only rows with Apply checkbox checked Applies to all tabs Persistence: Filter states saved in UI state cache Restored on window reopen 12.5 Clear Scans Purpose: Clears global .deepscans cache file Forces re-scan of all families When to Use: User knows families have changed significantly Staleness indicator suggests outdated deep scan data Behavior: Deletes .deepscans file DS badges removed from all rows Next deep scan rebuilds cache 12.6 Clear Preferences Purpose: Clears saved mapping preferences (Apply states, target selections) Behavior: Resets all Apply checkboxes to unchecked Clears target selections to defaults Shows banner: \"Mapping preferences cleared\" Does NOT Clear: Deep scan cache UI state (tab, search, filters) 13. Apply & Review Workflow 13.1 Plan Construction User selections are tracked in live dictionaries throughout the session. When the user clicks \"Apply\": BuildPlanAsync() normalizes all checked rows into categorized operations Plan operations are grouped by category and validated Plan Categories: Category Description Parameters Parameter value migrations TypeCreation New types to create (ghost types) HostReplacements Host-level element replacements NestedFamilies Nested family swaps TypeReplacements Family type replacements StyleReplacements Line/Object style replacements MaterialReplacements Material replacements SharedParameters SP bindings and value copies Validation: Self-maps rejected (source == target) Zero/negative IDs rejected Invalid operations throw GmInvalidMappingError 13.2 Review Window (Mapping Report) Before execution, the Mapping Report window displays the plan for user review. Display Content: Operation breakdown by category with counts Affected element counts per operation Normalized details showing from → to mappings Error indicators for any validation failures User Actions: Commit: Proceeds with execution Cancel: Returns to main window without changes Implementation: csharp/DBTools.GM/UI/ViewModels/MappingReportViewModel.cs csharp/DBTools.GM/Services/Planning/GmPlanningService.cs 13.3 Execution Order Operations execute in strict order within a transaction group: Parameters — Copy parameter values first (source data preserved) Create Types — Duplicate symbols for ghost types Host Replacements — Replace host-level elements Nested Families — Swap nested family references Type Replacements — Replace family instances by type Style/Material Replacements — Apply style and material mappings Shared Parameters — Bind SPs and copy values Transaction Management: All operations wrapped in single transaction group Fail-fast: first error aborts entire transaction Rollback on failure (atomic) Progress Overlay: Shows current step name Throttled progress updates Cancel button sets cancel_requested flag 13.4 Row Locking Individual rows are locked when their target is involved in another mapping. Lock Sources: Families Tab: When a family row's nested mapping (Object Style, Material) is set to Apply, the corresponding row on the Object Styles or Materials tab is locked Duplicates Tab: When a duplicate mapping is accepted, the source row on the target tab is locked Lock Behavior: IsLocked = true on affected row Apply checkbox disabled Tooltip explains lock source: \"Locked by Families tab (change there)\" or \"Locked by Duplicates tab (change there)\" Implementation: // ApplyRowLocks() at GmWindowViewModel.MappingInitAndInfrastructure.cs private void ApplyRowLocks() { // Families-derived locks // Duplicates-derived locks // Sets IsLocked and LockTooltip on individual rows } Critical: Locking is ROW-level only. There is no tab-level locking. 13.5 Error Handling Typed Exceptions: GmInvalidMappingError — Invalid plan operations GmApplyStageError — Execution failures with stage name and inner failures Error Surfaces: Mapping Report shows validation errors before commit Progress overlay shows execution errors with details Notification banner summarizes outcome Fail-Fast: First error aborts transaction User sees error message with option to retry or cancel Partial changes rolled back 14. Performance 14.1 Virtualization Requirement: DataGrids use virtualization for large row counts (1000+ rows) TextBlock (read-only) shown by default while scrolling Switches to ComboBox when cell enters edit mode Rationale: Avoids UI hangs during scrolling with large datasets Pre-building comboboxes for all rows is prohibitively expensive Example (WPF): <DataGridTemplateColumn> <DataGridTemplateColumn.CellTemplate> <TextBlock Text=\"{Binding TargetName}\" /> </DataGridTemplateColumn.CellTemplate> <DataGridTemplateColumn.CellEditingTemplate> <ComboBox ItemsSource=\"{Binding TargetOptions}\" ... /> </DataGridTemplateColumn.CellEditingTemplate> </DataGridTemplateColumn> 14.2 Pre-building Target Options Policy: Pre-built: Top-level target option lists for current category only (fast startup priority, <1000 families) Families tab: when category selected, pre-build options for all families in that category Materials/Styles tabs: pre-build on first visit NOT Pre-built: Nested detail options (Types, Parameters, Styles within expanded family rows) Other curated categories (lazy load on category change) Rationale: Balances startup time with responsiveness Pre-building ALL categories would be memory-intensive and slow Background Pre-warming: Background pre-warming on idle thread is not feasible due to Revit API UI thread constraint First category switch warms cache; subsequent switches are instant This is an accepted trade-off for correctness and architectural cleanliness 14.3 Lazy Loading Policy Section Gating: Families Section: Built on first Families tab visit (or immediately if default tab) Rebuilt on category change Usage Section: Built on first visit to Line Styles, Object Styles, or Materials tab Cached for session (reused across these three tabs) Shared Parameters Section: Built on first visit to SP tab Cached for session Expanded Row Details: Always lazy (never pre-built) Build on \"+\" expand or \"Scan Family\" button Nested target options built on target change 14.4 Option List Caching Session Cache: Target option lists cached in memory for session Instant tab switching (no re-query) Cleared on window close Invalidation: Category change: rebuild options for new category Clear Scans: rebuild options affected by deep scan data 14.5 Visible-Row-Only Name Resolution Strategy: Resolve names for top N visible rows immediately (batch: 250 IDs) Additional rows resolve as they scroll into view (if hooked to scroll event) Or use id fallback text until explicit \"Resolve All Names\" action Implementation: // Batch resolution (limit 250) csharp/DBTools.UI/ViewModels/GM/GlobalMapperViewModel.cs ResolveNamesAsync, EnsureNamesForIdsAsync RebuildMaterialStyleViews, RebuildTypeRows, RebuildFamilyList // Scroll handlers csharp/DBTools.UI/Views/GM/GlobalMapperWindow.xaml(.cs) OnFamiliesScrollChanged, OnStylesScrollChanged, etc. 14.6 Throttling Overlay Updates: Progress steps tick at chunk boundaries Throttled to ~200ms minimum between updates Avoid UI spam Threshold Debounce: Threshold slider debounced 200ms Avoid rebuilding options on every pixel drag Part IV: Features 15. Deep Scan 15.1 Trigger Policy Manual Only: Never auto-triggered User clicks \"Scan Family\" button or \"Deep Scan\" from context menu/toolbar Rationale: Deep scan opens family in background (expensive operation) User should control when this happens 15.2 Execution Flow Steps: Show overlay: \"Preparing scan...\" Open family via EditFamily (Revit API call) Collect: Type IDs and names Parameter names (all instance/type parameters) Material IDs used in family document Object Style IDs (GraphicsStyle.Id of subcategories) Nested family IDs Close family document Update kernel GMDeepScanState Write to .deepscans cache file (mid-session write) Update UI: badges, details unlock, augment usage lists Cancellation: User can cancel during scan Partial results discarded 15.3 Cache Persistence File: .deepscans (global, NOT document-specific) Key (Composite): { \"FamilyName\": \"Wall-Basic\", \"TypeCount\": 5, \"ParameterSignature\": \"abc123def456\" } Payload: { \"ParameterNames\": [\"Width\", \"Height\", \"Material\", ...], \"InstanceCounts\": [10, 5, 0, ...], \"NestedFamilyIds\": [123, 456, ...], \"MaterialRefs\": [789, 101], \"ObjectStyleRefs\": [111, 222], \"CachedAt\": \"2025-11-21T10:30:00Z\" } Write Timing: Immediately on scan completion (mid-session write) Cross-Session Reuse: Name-based keys enable global cache Different documents can share deep scan data for same family 15.4 Staleness Detection Indicators: TypeCount mismatch → \"⚠ Type count changed, re-scan recommended\" ParameterSignature mismatch → \"⚠ Parameters may have changed, re-scan recommended\" UI Display: Staleness badge next to DS badge Tooltip with details User can re-scan to refresh Never Use Stale Data Silently: Always show indicator if staleness detected Never fall back to stale data without warning user 15.5 Badge Indicators DS Icon: Shown on top-level family row when deep scan completed Tooltip: \"Deep scanned on {date}\" Staleness Indicator: \"⚠\" icon if cache key mismatch detected Tooltip: \"Deep scan data may be outdated. Click to re-scan.\" 15.6 Augmentation of Usage Lists Families discovered ONLY via deep scan (no instances in project) appear in: \"Families Using This Object Style\" lists \"Families Using This Material\" lists Styling: DS badge distinguishes deep-scan-only families Usage count remains 0 (not inflated) 16. Type Mapping 16.1 Create New Type UI: \"New Type\" button in Type Mappings expander header Acts on selected family row Shown only when expander expanded AND target family selected Behavior: Click \"New Type\" → creates ghost type entry in grid Ghost type has inline TextBox for name User enters name → Apply checkbox auto-checked Type marked with \"New\" badge (blue) 16.2 Inline Rename UI: TextBox shown for ghost types (IsGhost = true) Editable name field Behavior: User edits name inline Name stored in MatchedOption.SourceTypeName Planning uses this name for create_type_host operation Visual Indicators: Created types: Highlighted (background color) Renamed types: Bold font 16.3 Plan/Apply/Review Integration Planning: MatchedOption.SourceTypeName used for create operation Operation kind: GmOperationKind.CreateType Apply: Transaction: new Transaction(doc, \"Create Type\") FamilySymbol.Duplicate(name) → returns ElementId Must call doc.GetElement(id) to get symbol Review: Created types shown in Mapping Report with \"New\" indicator Count included in summary: \"5 types created\" 17. Preview Pane 17.1 Toggle Behavior Within expanded family details: Selecting Object Style row → show preview (swatch + style line) Selecting Material row → show preview (color swatch + texture) Toggle: Checkbox or auto-show on selection Positioned on right side of window 17.2 Preview Content Object Styles: Swatch (color/pattern) Line weight Line pattern Sample line rendering Materials: Color swatch Texture preview (if applicable) Shininess, transparency properties Sample material rendering 18. Sorting, Filtering, Threshold 18.1 Similarity Mode Visual Styling: Colored labels: Green (high similarity) → Orange (medium) → Red (low) Percentages appended: \"Target Name (92%)\" Sorted high → low by score Threshold Behavior: Options below threshold NOT auto-selected Manual selections NEVER overridden Lowering threshold can clear auto-matches (NOT manual selections) Applies To: ALL target comboboxes (top-level and nested) Families, Line Styles, Object Styles, Materials tabs 18.2 Alphabetical Mode Visual Styling: Default styling (no colored labels) NO percentages appended Sorted lexicographically A-Z Threshold Behavior: Threshold slider has NO effect (ignored) All options visible regardless of score Applies To: ALL target comboboxes (top-level and nested) 18.3 Manual Selection Preservation Critical Rule: Manual selections are sticky across: Sort mode changes (Similarity ↔ Alphabetical) Threshold changes Refresh operations Only Reset If: Target disappears from options (e.g., family deleted, category changed) Visual Marking: Manual selections visually distinguished (bold or icon) Auto-selections use default styling 18.4 Nested Target List Behaviors Nested target comboboxes (Types, Parameters, Styles, Materials within expanded family rows) must: Respect Sort Mode: Similarity: colored labels, percentages, high→low Alphabetical: default styling, A-Z, no scores Respect Threshold: Similarity mode: threshold affects default selection Alphabetical mode: threshold ignored Preserve User Selections: Sticky across sort/threshold changes Update on Target Change: When top-level target family changes, rebuild nested options from new target Part V: Quality & Implementation 19. Known Issues & Roadmap 19.1 Completed Features The following features are fully implemented: Families Parameter Pruning — Programmatic filters in RevitCompat.IsUserMappable Nested Target Comboboxes — Four nested collection types (Types, Parameters, Materials, Object Styles) Unscanned Family Demotion — MatchingOption.Separator with greyed-out styling Deep-Scan Augmentation of Usage Lists — DS-only families merged with \"(DS)\" badge Cross-Tab Apply Lock — ApplyRowLocks() with IsLocked property Create New Type + Inline Rename — CreateNewType, NewTypeName properties with GmTypeCreationService Parameter Mapping <Do Not Map> Sentinel — MatchingOption.DoNotMap as first option Nested List Sorting/Threshold — Debounced refresh with selection preservation Deep Scan Overlay Bug Fix — !IsBusy check prevents double overlay 19.2 Remaining Implementation Tasks HIGH PRIORITY: Deep Scan Global Cache Status: Spec describes global .deepscans file; implementation uses document-specific snapshots only Impact: Deep scan results cannot be reused across documents Files to create: DBTools.GM.App/Infrastructure/Caching/DeepScanCache.cs DBTools.GM.App/Infrastructure/Caching/DeepScanCacheStrategy.cs Line Styles Tab Stability Issue: Selecting Line Styles can error and close window Likely causes: SelectionChanged executing before initial load, missing descriptor, VM contract violations Tasks: Gate SelectionChanged until _initial_load_complete AND sender is real row Enforce VM contract post-enrichment; surface failures via overlay Validate descriptor presence at collection time MEDIUM PRIORITY: Preview Pane Toggle Status: Preview panels exist but are always visible when data available Task: Add user-controlled toggle button/checkbox in family details SP Grid Empty State Status: Generic \"wrong category\" banner exists Task: Add specific \"No shared parameters\" banner Broad Exception Cleanup Task: Remove or narrow broad try/except to typed, narrow boundaries Task: Verify no residual legacy module references LOW PRIORITY: Families Details Must Stay Linked Task: Wire nested child grids to current target Task: Refresh all nested target lists on family-level target change Nested Threshold Verification Task: Document whether threshold applies to nested Type comboboxes 19.3 Implementation Roadmap Phase 1: Foundation Add Application-layer query wrappers Refactor PlanningOrchestrator to accept IGmPlanningService dependency Repository hardening: Add SnapshotVersion, strict parsing Phase 2: UI Refactor UI refactor (GmWindowViewModel): Constructor: accept only Application services Remove adapter/service deps Use kernel for families, usage, styles, materials Report window: consume IMappingExecutionService from main VM Phase 3: DI and Cleanup DI consolidation in shell: compose adapters → Application services → VM Clean deletions: remove UI callsites referencing Infrastructure/Services Phase 4: Validation Build solution; verify no UI project references Infrastructure namespaces Manual sanity pass: Families tab, Usage tabs, Deep scan, SP authoring, Mapping report 20. Quality Acceptance Criteria 20.1 Perfection Standards Core Philosophy: \"Deliver a near-perfect, clean, spec-compliant GM codebase that we could ship to 1,000,000,000 users with confidence.\" What \"Perfection\" Means: Spec → Code Traceability: Every clause maps to concrete code One Way to Do a Thing: Canonical, testable paths (no duplicate logic) Clean Layering: Collectors produce unique sets; controllers bind once Readable, Minimal, Modular: No dead blocks or drift Zero Tolerance for Silent Failures: All errors surfaced explicitly 20.2 Green Checks Only Acceptance Policy: ALL of the following must be true before merge: All tests pass (no warnings) No duplicate curated lists outside single source No duplicate top-level rows Revisit any tab → no overlay reload Sort-mode switch updates Display/brush across all visible rows Families details: Types/OS/Materials/Parameter Names without DS when Qty>0 SP tab: group default = first alphabetical; category = first curated 20.3 Behavioral Validation Manual Testing Scenarios: Kernel Determinism: Given same Revit document and filters → two builds produce identical kernel Changing category filter only replaces Families (preserves Usage) No Duplicate Reads Per Tab: Navigate between tabs → verify no additional adapter calls beyond name previews Use adapter call counters Mapping Planning Correctness: Self-maps and zero/negative IDs rejected with GmInvalidMappingError Parameter copies precede type/style/material replacements Placement Taxonomy: Adapter placements normalize into { NotHosted, FaceBased, WorkPlaneBased } only Snapshot Round-Trip: Save → close → reopen → verify UI state restored (category, filters, scroll, kernel snapshot) Corrupt snapshot throws GmSnapshotLoadException, UI proceeds with fresh build Deep Scan UX Integration: Run deep scan → badges update, availability changes, no usage indices re-read END OF SPECIFICATION"
  },
  "developer-guide/tools/common/gm.html": {
    "href": "developer-guide/tools/common/gm.html",
    "title": "Global Mapper (GM) | DB Tools",
    "summary": "Global Mapper (GM) Global Mapper is a comprehensive Revit type-mapping tool that enables users to detect, plan, and apply bulk element replacements across families, types, materials, line styles, object styles, and shared parameters. See also: Specification (Internal) Overview Global Mapper provides a unified interface for: Family/Type Mapping: Replace family instances with equivalent types from other families Duplicate Detection: Identify potential duplicate elements using similarity analysis Usage Analysis: Understand material, line style, and object style usage across families Deep Scan: Analyze family document contents to extract parameter names, style refs, and material refs Shared Parameter Authoring: Bind and embed shared parameters to families/categories Source: csharp/src/Tools/Common/GM/manifest.yml:1-26 Features Feature Description Duplicates Tab Detects potential duplicate families, materials, styles, and shared parameters using weighted similarity scoring Families Tab Browse families by category, select target mappings, and configure type replacements Line Styles Tab View and map line style usage with visual preview Object Styles Tab View and map object style usage with visual preview Materials Tab View and map material usage with color preview Shared Parameters Tab Manage shared parameter bindings across categories and families Deep Scan Analyze family documents to extract embedded parameter names, style references, and material references Mapping Persistence Save and restore mapping preferences per-project Conflict Detection Identify conflicting mappings before applying changes Source: csharp/src/Tools/Common/GM/Shell/UI/Views/GmWindow.xaml:293-361 (Ribbon tab definitions) User Interface The GM window uses a Fluent Ribbon with six main tabs: Duplicates (Index 0) - Duplicate detection and resolution Families (Index 1) - Family/type mapping with category filtering Line Styles (Index 2) - Line style replacement with preview Object Styles (Index 3) - Object style replacement with preview Materials (Index 4) - Material replacement with color preview Shared Parameters (Index 5) - Parameter binding and authoring Each tab provides: A main DataGrid with source items and target selection dropdowns Row expansion for nested details (types within families, pairs within duplicate groups) Visual previews where applicable (color swatches, style weights) Action buttons for applying changes Source: csharp/src/Tools/Common/GM/Shell/UI/Views/GmWindow.xaml:365-576 Global Header Controls The header bar provides cross-tab controls: Search: Filter visible items by name Threshold Slider: Adjust similarity scoring threshold (0-100%) Sort Mode: Toggle between Similarity and Alphabetical ordering Filters: Hide Unused, Hide Unscanned, Applied Only Source: csharp/src/Tools/Common/GM/Shell/UI/Views/GmWindow.xaml:179-288 Architecture Module Structure csharp/src/Tools/Common/GM/ +-- GmToolModule.cs # DI registration entry point +-- Bootstrap/ | +-- GmServiceExtensions.cs # Services.AddGmServices() wrapper +-- Features/ | +-- GmCommand.cs # Ribbon command entry point | +-- Duplicates/ # Duplicate detection feature | +-- Families/ # Family/type mapping feature | +-- Mapping/ # Apply/verify mapping logic | +-- SavedMappings/ # Persistence layer | +-- SharedParameters/ # SP authoring feature | +-- Similarity/ # Name and parameter similarity | +-- Usage/ # Usage index building | +-- DeepScan/ # Family document analysis +-- Shell/ | +-- GmShellLauncher.cs # Window construction | +-- DI/Services.cs # Full DI registration | +-- UI/Views/ # WPF windows and XAML | +-- UI/ViewModels/ # MVVM view models | +-- DesignTime/ # Design-time view models +-- Shared/ | +-- Kernel/ # Domain state (GmProjectState) | +-- Planning/ # Mapping plan generation | +-- Contracts/ # Service interfaces | +-- Caching/ # Cache strategies | +-- Context/ # Planning context | +-- Project/ # Project lifecycle +-- Tests/ # Unit and integration tests Source: Directory structure of csharp/src/Tools/Common/GM/ Data Flow +------------------+ | GmCommand | +--------+---------+ | Resolves services via DI v +------------------+ | GmShellLauncher | +--------+---------+ | Creates window + ViewModel v +-------------------+ | GmShellViewModel | +--------+----------+ | +------------+------------+------------+------------+ | | | | | v v v v v +----------+ +----------+ +---------+ +----------+ +---------+ | Families | | Usage | | Mapping | | Planning | | Kernel | | Pane VM | | Pane VM | | Service | | Service | | State | +----------+ +----------+ +---------+ +----------+ +---------+ Kernel Architecture The GmProjectState is the Single Source of Truth (SSOT) for GM domain state. It holds IDs only - no Revit types leak into the kernel. public sealed class GmProjectState { public long Version { get; set; } public GmSourceSnapshot? SourceSnapshot { get; set; } public Dictionary<int, GmFamilyRecord> Families { get; set; } public GmUsageIndex Usage { get; set; } public GmSharedParameterLedger SharedParameters { get; set; } public GmTabStateSet Tabs { get; set; } public Dictionary<int, string> FamilyNames { get; set; } public Dictionary<int, string> SymbolNames { get; set; } public Dictionary<int, IReadOnlyCollection<(string, string, int)>> NestedOwnerNameIndex { get; set; } } Source: csharp/src/Tools/Common/GM/Shared/Kernel/State/GmProjectState.cs:1-32 The GmKernelMapper provides read-only projections of kernel data for UI consumption: GetLineStyleFamilyCounts() - Style usage counts GetDeepScanStyleRefsByFamily() - DS style references GetDeepScanMaterialRefsByFamily() - DS material references GetDeepScanParamNamesByFamily() - DS parameter names Source: csharp/src/Tools/Common/GM/Shared/Kernel/State/GmKernelMapper.cs:53-264 Key Classes Entry Points Class File Purpose GmToolModule GmToolModule.cs:10-18 Tool module registration; calls AddGmServices() GmCommand Features/GmCommand.cs:31-145 Ribbon command entry point; resolves all services and launches UI GmShellLauncher Shell/GmShellLauncher.cs:35-117 Static launcher creating GmWindow and GmShellViewModel Source: csharp/src/Tools/Common/GM/GmToolModule.cs:10-18 View Models Class File Purpose GmShellViewModel Shell/UI/ViewModels/GmShellViewModel.*.cs Main shell view model (split across partials) FamiliesPaneViewModel Features/Families/FamiliesPaneViewModel.cs:9-36 Families tab state UsagePaneViewModel Features/Usage/UsagePaneViewModel.cs Usage tabs (styles, materials) state DuplicatesPaneViewModel Features/Duplicates/DuplicatesPaneViewModel.cs Duplicates tab state SharedParametersPaneViewModel Features/SharedParameters/SharedParametersPaneViewModel.cs SP tab state Source: csharp/src/Tools/Common/GM/Features/Families/FamiliesPaneViewModel.cs:9-36 Core Services Interface Implementation Purpose IProjectLifecycleService ProjectLifecycleService Build kernel from Revit document IGmPlanningService GmPlanningService Generate normalized mapping plans IGmMappingService GmMappingService Apply plans to Revit document IDuplicateDetectionService DuplicateDetectionService Detect duplicate elements INamingSimilarityService NamingSimilarityService Name-based similarity scoring IParameterSimilarityService ParameterSimilarityService Parameter overlap scoring Source: csharp/src/Tools/Common/GM/Shell/DI/Services.cs:33-106 Revit Adapters Interface Implementation Purpose ITypeChangeService TypeChangeService Replace type on instances IStyleChangeService StyleChangeService Replace line style on curves IMaterialChangeService MaterialChangeServiceWriter Replace material parameters IParameterChangeService ParameterChangeService Copy type parameters IHostChangeService HostChangeService Handle host/placement changes INestingChangeService NestingChangeService Replace nested families by name ITypeCreationService TypeCreationService Create new type symbols IDeepScanService DeepScanServiceAdapter Deep scan family documents Source: csharp/src/Tools/Common/GM/Shell/DI/Services.cs:66-86 Configuration Manifest id: DBTools.GM assembly: DBTools moduleType: DBTools.GM.GmToolModule order: 0 sandboxWindows: - id: DBTools.GM.Main displayName: \"Global Mapper\" group: \"Common\" windowType: \"DBTools.GM.Shell.UI.Views.GmWindow\" designTimeViewModelType: \"DBTools.GM.Shell.DesignTime.GmShellDesignTimeViewModel\" - id: DBTools.GM.MappingReport displayName: \"Global Mapper - Mapping Report\" group: \"Common\" windowType: \"DBTools.GM.Features.Mapping.UI.Views.GmMappingReportWindow\" tool: ribbonTools: - internalName: DBTools.GM commandType: DBTools.GM.Features.GmCommand availabilityType: DBTools.App.Tools.Availability.DbtDocumentAvailability runProfile: InlineUi displayText: \"Global Mapper\" iconBaseKey: gm tooltip: \"Open Global Mapper\" controlKind: PushButton order: 30 Source: csharp/src/Tools/Common/GM/manifest.yml:1-27 Caching GM uses project-scoped caching strategies: Cache Strategy Purpose Deep Scan DeepScanCacheStrategy Cache family document scan results UI State UiStateStrategy Persist UI selections between sessions Saved Mappings SavedMappingService Store user mapping preferences Cache files are stored under %LocalAppData%/DBTools/GM/. Source: csharp/src/Tools/Common/GM/Shell/DI/Services.cs:97-105 API Reference Planning Service The IGmPlanningService generates normalized mapping plans: public interface IGmPlanningService { Task<GmPlanningResult> BuildPlanAsync( IReadOnlyDictionary<int, int> typeMappings, IReadOnlyDictionary<int, int> materialMappings, IReadOnlyDictionary<int, int> styleMappings, CancellationToken ct = default); Task<GmPlanningResult> BuildPlanAsync( IReadOnlyDictionary<int, int> typeMappings, IReadOnlyDictionary<int, int> materialMappings, IReadOnlyDictionary<int, int> styleMappings, IReadOnlyDictionary<int, int> paramMappings, IReadOnlyCollection<(int sourceId, string? newName)> createType, IGmContext? context, CancellationToken ct = default); } Source: csharp/src/Tools/Common/GM/Shared/Planning/IGmPlanningService.cs:8-28 Operation Kinds Plans contain operations of these types: public enum GmOperationKind { ReplaceType, // Replace type on family instances ReplaceMaterial, // Replace material parameters ReplaceStyle, // Replace line/object styles MapParameter, // Copy parameter values between types AddNestedFamily, // Add nested family replacement (by name) ReplaceHost, // Handle host/placement mismatches CreateType, // Create new type symbol BindSharedParameter, // Bind SP at host level EmbedSharedParameter // Embed SP in family document } Source: csharp/src/Tools/Common/GM/Shared/Planning/GmOperationKind.cs:3-14 Mapping Service The IGmMappingService applies plans to the Revit document: public interface IGmMappingService { Task ImportAsync(string path, CancellationToken ct = default); Task ExportAsync(string path, CancellationToken ct = default); Task ImportSimpleAsync(string path, CancellationToken ct = default); Task ExportSimpleAsync(string path, CancellationToken ct = default); Task<GmMappingValidationResult> ValidateAsync(CancellationToken ct = default); Task<GmMappingApplyResult> ApplyAsync(CancellationToken ct = default); Task<GmMappingApplyResult> ApplyPlanAsync(GmPlanningResult plan, IProgress<string>? progress = null, CancellationToken ct = default); Task<GmMappingVerifyResult> VerifyAsync(GmPlanningResult plan, CancellationToken ct = default); Task AddDuplicateMappingsAsync(GmDuplicateApplyBatch batch, CancellationToken ct = default); } Source: csharp/src/Tools/Common/GM/Features/Mapping/IGmMappingService.cs:12-27 Duplicate Detection The IDuplicateDetectionService analyzes the kernel for potential duplicates: public interface IDuplicateDetectionService { Task<DuplicateDetectionResult> DetectAsync(GmProjectState kernel, CancellationToken ct = default); } Detection uses: Families: 70% name similarity + 30% parameter overlap (when DS data available) Styles: Preview signature matching (color, weight, pattern) Materials: Preview + name similarity Shared Parameters: Type display + normalized name Source: csharp/src/Tools/Common/GM/Features/Duplicates/Logic/DuplicateDetectionService.cs:43-98 Testing GM tests use a shared fixture that opens a dedicated test model: [NonParallelizable] public abstract class GmTestFixture { protected const string GmModelFileName = \"gm_test_model.rvt\"; protected UIApplication UiApp { get; private set; } protected Document? Doc { get; private set; } protected IRevitCallGate? Gate { get; private set; } protected ITransactionRunner? TxRunner { get; private set; } } Source: csharp/src/Tools/Common/GM/Tests/GMTestFixture.cs:20-53 Test Categories Test Class Purpose GM_PlanningServiceTests Planning result validation GM_MappingServiceTests Apply/verify cycle testing GM_MappingApplyPlanTests End-to-end plan application DuplicateDetectionServiceTests Duplicate detection accuracy GmKernelMapperTests Kernel projection correctness GmWindowViewModel_*Tests ViewModel behavior tests Running Tests # Build test assemblies bash csharp/build.sh BuildTests # Run via Revit test runner bash csharp/invoke-revit-tests.sh --smart --tool GM -y 2025 Troubleshooting Common Issues Issue Cause Resolution \"No families found\" Category filter too restrictive Select a different category or clear filters Empty duplicate groups Similarity threshold too high Lower the threshold slider Deep scan incomplete Family document errors Check Revit error log; try manual deep scan Mapping not applied Target type not available Verify target family is loaded in project Conflict panel showing Multiple sources map to same target Resolve conflicts in conflict panel Logging GM logs diagnostic information via ILogger. Enable debug logging to see: Kernel build timing Cache hit/miss statistics Plan operation details Apply stage progress _logger.LogDebug(\"GM: scanned {Count} families for categoryId={CategoryId}\", families.Count, SelectedCategory?.Id); Source: csharp/src/Tools/Common/GM/Shell/UI/ViewModels/GmShellViewModel.CoreAndCommands.cs:1043-1045 Related Documentation Architecture Overview - DBTools architecture DBTools.Core - Core infrastructure Test Pipeline - Test infrastructure Verification Status Check Status Source anchors for all claims Yes UNVERIFIED markers where needed No (all verified) Cross-references added Yes Examples tested N/A No assumptions without evidence Yes Verified by: docs-run-20260124-020412 Date: 2026-01-24"
  },
  "developer-guide/tools/common/tdv.html": {
    "href": "developer-guide/tools/common/tdv.html",
    "title": "TDV - Transfer Drafting Views | DB Tools",
    "summary": "TDV - Transfer Drafting Views TDV (Transfer Drafting Views) is a tool for importing and exporting drafting views between Revit documents and a central library. It enables teams to maintain a shared collection of standard drafting views that can be distributed across projects. Source: csharp/src/Tools/Common/TDV/manifest.yml:1-45 Overview TDV provides two primary operations: Export to Library - Copy drafting views from the active document to a central library file Import from Library - Copy drafting views from a library file to the active document The tool handles worksharing, creates local copies for edits, and synchronizes changes back to the central library file after export operations. Source: csharp/src/Tools/Common/TDV/Features/TdvExportCommand.cs:18-27 Features Core Capabilities Bi-directional transfer - Import and export drafting views between documents View type mapping - Map source view types to destination view types, or retain original type Conflict detection - Real-time detection of naming conflicts with existing views Replace mode - Option to replace existing views with the same name Preview panel - Live preview of selected drafting views with pan/zoom support Batch transfer - Transfer multiple views in a single operation Transaction grouping - All transfers wrapped in a transaction group for atomicity Progress tracking - Per-view progress feedback during transfer operations Source: csharp/src/Tools/Common/TDV/Revit/Services/TdvService.cs:106-291 Library Management Multiple library files - Configure multiple library files with fallback paths Path validation - Automatic validation of library file accessibility Local copy workflow - Creates local copies from central files for worksharing Automatic sync - Syncs changes back to central after export with detailed comments Source: csharp/src/Tools/Common/TDV/Revit/Services/TdvDocumentService.cs:26-126 View Transfer Details When transferring views, TDV: Creates or prepares the destination view with the selected view type Copies the view scale and description parameters Copies all elements from the source view (excluding viewports, title blocks, schedules, etc.) Copies element graphic overrides from source to destination Source: csharp/src/Tools/Common/TDV/Revit/Services/TdvOps.cs:145-189 Architecture TDV follows the MVVM pattern with a clean separation between UI, business logic, and Revit API operations. Project Structure csharp/src/Tools/Common/TDV/ ├── Bootstrap/ # DI registration ├── Contracts/ # Interfaces and DTOs ├── DesignTime/ # Design-time view models ├── Features/ # Command implementations ├── Properties/ # Design-time resources ├── Revit/Services/ # Revit API operations ├── Settings/ # Configuration models ├── Tests/ # Unit tests └── UI/ ├── ViewModels/ # MVVM view models └── Views/ # WPF views Service Registration Services are registered as scoped to properly handle Revit's run-scope dependencies: Source: csharp/src/Tools/Common/TDV/Bootstrap/TdvServiceExtensions.cs:11-33 services.AddScoped<ITdvTransferService>(sp => new TdvService(gate, tx, groups, logger)); services.AddScoped<ITdvLibraryService, TdvLibraryService>(); services.AddScoped<ITdvDocumentService, TdvDocumentService>(); Key Interfaces Interface Implementation Purpose ITdvTransferService TdvService Core transfer operations ITdvLibraryService TdvLibraryService Library path management ITdvDocumentService TdvDocumentService Document open/close/sync ITdvContext TdvService.RevitTdvContext Abstraction over Revit Document Source: csharp/src/Tools/Common/TDV/Contracts/ITdvTransferService.cs:1-23 Transfer Service Operations The ITdvTransferService interface defines: Method Description BuildViewItemsAsync Collects drafting views from source document ApplySelectionAsync Executes the transfer operation WouldConflictAsync Checks for naming conflicts ExportPreviewAsync Generates preview image for a view Source: csharp/src/Tools/Common/TDV/Contracts/ITdvTransferService.cs:6-22 UI Components Main Window (TdvWindow) The main transfer window provides: Filter controls - Filter by view type and search by name Data grid - Lists all drafting views with transfer options Preview panel - Shows selected view with pan/zoom Status bar - Displays selection counts and transfer results Source: csharp/src/Tools/Common/TDV/UI/Views/TdvWindow.xaml:1-537 ViewModel (TdvWindowViewModel) Key properties and commands: Property Type Description Items ObservableCollection<TdvViewItem> Filtered list of views Search string Search filter text SelectedViewTypeFilter string View type filter SelectedItem TdvViewItem Currently selected view PreviewSource ImageSource Preview image HasAnyConflict bool Indicates naming conflicts Status string Status bar text Command Description ApplySelectionCommand Executes the transfer ClearSelectedCommand Clears all selections ClearSearchCommand Clears search filter Source: csharp/src/Tools/Common/TDV/UI/ViewModels/TdvWindowViewModel.cs:22-409 View Item (TdvViewItem) Represents a single drafting view in the UI: Property Type Description SourceViewId int Revit element ID ViewName string Editable view name ViewType string Selected destination type ViewTypeName string Original source type name Checked bool Selected for transfer Replace bool Replace if exists HasConflict bool Has naming conflict HasTypeWarning bool Source type unavailable RowState string Transfer status (pending/success/failure) Source: csharp/src/Tools/Common/TDV/UI/ViewModels/TdvViewItem.cs:9-106 Preview Features The preview panel supports: Debounced loading - 200ms debounce prevents excessive exports LRU cache - Caches up to 32 preview images Pan and zoom - Interactive image manipulation via ImagePanZoomBehavior Dark theme background - Consistent preview appearance (RGB: 43, 44, 61) Source: csharp/src/Tools/Common/TDV/UI/ViewModels/TdvWindowViewModel.cs:74-81 Source: csharp/src/Tools/Common/TDV/Revit/Services/TdvOps.cs:19-28 Settings Configuration Library Settings TDV uses the MasterLibrarySettings class to store library file configurations: public sealed class MasterLibrarySettings { public IList<LibraryFileEntry> Files { get; set; } public bool HasWarnings { get; set; } } public sealed class LibraryFileEntry { public string? MainPath { get; set; } public string? FallbackPath { get; set; } } Source: csharp/src/Tools/Common/TDV/Settings/MasterLibrarySettings.cs:1-8 Source: csharp/src/Tools/Common/TDV/Settings/LibraryFileEntry.cs:1-8 Each library entry supports: Main path - Primary path to the library RVT file Fallback path - Alternative path (e.g., for different network locations) Settings Pack The LibrarySettingsPackContext provides the settings UI with: Tree-based library file management Add/remove library files Add/remove fallback paths Real-time path validation Pending changes tracking Source: csharp/src/Tools/Common/TDV/Settings/LibrarySettingsPackContext.cs:19-352 Path Validation Library paths are validated for: File existence .rvt extension Accessibility Invalid paths trigger a settings warning that disables the import/export commands. Source: csharp/src/Tools/Common/TDV/Revit/Services/TdvLibraryService.cs:100-141 Manifest Configuration The tool is configured via manifest.yml: id: DBTools.TDV assembly: DBTools moduleType: DBTools.TDV.TdvToolModule order: 0 sandboxWindows: - id: DBTools.TDV.Main displayName: \"Transfer Drafting Views\" group: \"Common\" windowType: \"DBTools.TDV.UI.Views.TdvWindow\" tool: settings: configSection: Core.MasterLibrary settingsPacks: - key: core.library title: \"Library Files\" warnings: - id: core.library.invalid title: \"Library Paths Invalid\" message: \"One or more library file paths are invalid...\" disableTools: - DBTools.ExportToLibrary - DBTools.ImportFromLibrary ribbonTools: - internalName: DBTools.ExportToLibrary commandType: DBTools.TDV.Features.TdvExportCommand availabilityType: DBTools.App.Tools.Availability.DbtDocumentAvailability runProfile: InlineUi displayText: \"Export\\nTo Library\" iconBaseKey: export tooltip: \"Export drafting views to the library\" controlKind: StackedButtonItem splitGroup: library_transfer - internalName: DBTools.ImportFromLibrary commandType: DBTools.TDV.Features.TdvImportCommand availabilityType: DBTools.App.Tools.Availability.DbtDocumentAvailability runProfile: InlineUi displayText: \"Import\\nFrom Library\" iconBaseKey: import tooltip: \"Import drafting views from the library\" controlKind: StackedButtonItem splitGroup: library_transfer Source: csharp/src/Tools/Common/TDV/manifest.yml:1-45 Ribbon Configuration Property Export Import Internal Name DBTools.ExportToLibrary DBTools.ImportFromLibrary Command TdvExportCommand TdvImportCommand Run Profile InlineUi InlineUi Icon export import Control Kind StackedButtonItem StackedButtonItem Split Group library_transfer library_transfer Error Handling Per-View Error Codes Transfer failures are categorized by error code: Code Description Unknown Unspecified error DestinationTypeMissing Target view type not found SourceTypeNameUnavailable Cannot read source view type CreateViewFailed Failed to create destination view CopyElementsFailed Failed to copy view elements OverridesFailed Failed to copy graphic overrides Source: csharp/src/Tools/Common/TDV/Contracts/TdvPerViewErrorCode.cs:1-12 Error Reporting After transfer, errors are displayed in a detailed alert dialog with: Summary counts (added, replaced, skipped) Error details table with source info and error messages Copy to clipboard functionality Source: csharp/src/Tools/Common/TDV/UI/Views/TdvWindow.xaml.cs:111-186 Revit API Operations Getting Drafting Views new FilteredElementCollector(doc) .OfClass(typeof(View)) .WhereElementIsNotElementType() .Cast<View>() .Where(v => v.ViewType == ViewType.DraftingView && !v.IsTemplate) Source: csharp/src/Tools/Common/TDV/Revit/Services/TdvOps.cs:30-39 Copying View Contents Elements are copied using ElementTransformUtils.CopyElements with a custom IDuplicateTypeNamesHandler that uses destination types when duplicates are found. Source: csharp/src/Tools/Common/TDV/Revit/Services/TdvOps.cs:145-162 Skipped Categories The following categories are excluded from copy operations: Title Blocks Viewports Views Schedules Guide Grids Source: csharp/src/Tools/Common/TDV/Revit/Services/TdvOps.cs:13-16 Command Reference Export Command Flow Validate library paths are configured Prompt user to select a library file Create local copy of central library file Open library document Show TdvWindow for view selection Execute transfer to library Sync changes to central with comment Close library and reactivate original document Source: csharp/src/Tools/Common/TDV/Features/TdvExportCommand.cs:31-137 Import Command Flow Validate library paths are configured Prompt user to select a library file Create local copy of central library file Open library document Show TdvWindow for view selection Execute transfer to active document Close library (no sync needed) Source: csharp/src/Tools/Common/TDV/Features/TdvImportCommand.cs:27-107 Cross-References Architecture Overview - Application architecture patterns App Project - Main application and tool hosting Testing TDV includes unit tests for: TdvViewItem - View model behavior TdvLibraryService - Path validation and library management TdvAdapter - Service adapter tests Source: csharp/src/Tools/Common/TDV/Tests/ Last updated: January 2026"
  },
  "developer-guide/tools/structural/analytical-snap.html": {
    "href": "developer-guide/tools/structural/analytical-snap.html",
    "title": "Analytical Snap To Level | DB Tools",
    "summary": "Analytical Snap To Level Analytical Snap To Level is a Revit tool that snaps selected analytical model elements (beams and columns) to a user-specified level elevation. Overview This tool provides a streamlined workflow for aligning analytical model geometry to structural levels. It supports two structural roles with role-specific snapping behavior: Beams: Both endpoints are moved to the target level elevation Columns: Only the endpoint closest to the target level is moved, preserving the other endpoint's position Source: csharp/src/Tools/Structural/AnalyticalSnapToLevel/Features/AnalyticalLevelSnapper.cs:88-119 Features Feature Description Selection-Based Operates on pre-selected analytical elements Level Picker Interactive dialog to choose target level Role-Aware Snapping Different snap behavior for beams vs columns Batch Processing Processes multiple elements in a single transaction Summary Report Displays processed/skipped counts after execution Source: csharp/src/Tools/Structural/AnalyticalSnapToLevel/Features/AnalyticalSnapToLevelCommand.cs:19-70 Workflow Select Elements: Pre-select analytical members in the Revit view Launch Tool: Click \"Analytical Snap To Level\" button on the ribbon Pick Level: Select target level from the level picker dialog Review Results: View summary showing processed and skipped element counts Supported Elements The tool only processes elements that meet these criteria: Category: OST_AnalyticalMember Type: Must be castable to AnalyticalMember Structural Role: \"Beam\" or \"Column\" (other roles are skipped) Geometry: Must have a valid curve Source: csharp/src/Tools/Structural/AnalyticalSnapToLevel/Features/AnalyticalLevelSnapper.cs:55-81 Snapping Behavior Beams Beams are horizontal members. Both endpoints are moved to the target elevation while preserving X and Y coordinates: Original: Start(X1, Y1, Z1) ---- End(X2, Y2, Z2) Snapped: Start(X1, Y1, TargetElev) ---- End(X2, Y2, TargetElev) Source: csharp/src/Tools/Structural/AnalyticalSnapToLevel/Features/AnalyticalLevelSnapper.cs:88-93 Columns Columns are vertical members. Only the endpoint closest to the target level is moved: Original: Top(X, Y, 20) | Bottom(X, Y, 10) Target at 12: Top(X, Y, 20) | Bottom(X, Y, 12) [bottom was closer] Source: csharp/src/Tools/Structural/AnalyticalSnapToLevel/Features/AnalyticalLevelSnapper.cs:95-112 Architecture Module Structure csharp/src/Tools/Structural/AnalyticalSnapToLevel/ +-- manifest.yml # Tool declaration +-- AnalyticalSnapToLevelToolModule.cs # DI module registration +-- DBTools.Structural.AnalyticalSnapToLevel.csproj # Project file +-- Features/ | +-- AnalyticalSnapToLevelCommand.cs # Ribbon command entry point | +-- AnalyticalLevelSnapper.cs # Core snapping logic +-- Assets/ +-- analytical_snap_icon.png # Ribbon icon Source: Directory structure of csharp/src/Tools/Structural/AnalyticalSnapToLevel/ Key Classes Class File Purpose AnalyticalSnapToLevelToolModule AnalyticalSnapToLevelToolModule.cs:5-7 Empty tool module for registration AnalyticalSnapToLevelCommand Features/AnalyticalSnapToLevelCommand.cs:17-71 Command entry point; orchestrates workflow AnalyticalLevelSnapper Features/AnalyticalLevelSnapper.cs:16-135 Core snapping service Source: csharp/src/Tools/Structural/AnalyticalSnapToLevel/AnalyticalSnapToLevelToolModule.cs:5-7 Data Flow +----------------------------+ | AnalyticalSnapToLevelCommand| +-------------+--------------+ | | 1. Get selected element IDs | 2. Show level picker v +-------------------+ | LevelPickerHelper | (from DBTools.Core) +-------------------+ | | Returns selected Level v +----------------------------+ | AnalyticalLevelSnapper | +-------------+--------------+ | | 3. Iterate selected IDs | 4. Filter to AnalyticalMember | 5. Check structural role | 6. Compute new curve | 7. SetCurve on member v +----------------------------+ | Summary Alert | +----------------------------+ Dependencies The tool depends on these core services: Service Source Purpose IAlertService DBTools.Core Show level picker and summary dialogs LevelPickerHelper DBTools.Core Utility for level selection UI ITransactionRunner DBTools.Core Transaction execution via call gate ILogger Microsoft.Extensions.Logging Debug logging Source: csharp/src/Tools/Structural/AnalyticalSnapToLevel/Features/AnalyticalSnapToLevelCommand.cs:35-46 Settings This tool has no persistent settings. All configuration is provided at runtime via: Element Selection: User pre-selects elements before invoking the command Target Level: User picks from level dialog at runtime Manifest id: DBTools.Structural.AnalyticalSnapToLevel assembly: DBTools moduleType: DBTools.Structural.AnalyticalSnapToLevel.AnalyticalSnapToLevelToolModule order: 0 tool: ribbonTools: - internalName: DBTools.AnalyticalSnapToLevel commandType: DBTools.Structural.AnalyticalSnapToLevel.AnalyticalSnapToLevelCommand availabilityType: DBTools.App.Tools.Availability.DbtSelectionAvailability runProfile: InlineUi displayText: \"Analytical Snap\\nTo Level\" iconBaseKey: analytical_snap tooltip: \"Snap analytical model elements to specified level\" controlKind: PushButton order: 20 Source: csharp/src/Tools/Structural/AnalyticalSnapToLevel/manifest.yml:1-15 Manifest Properties Property Value Description id DBTools.Structural.AnalyticalSnapToLevel Unique tool identifier availabilityType DbtSelectionAvailability Button enabled when elements are selected runProfile InlineUi Runs with inline UI support controlKind PushButton Standard push button control order 20 Position in ribbon panel Availability The command uses DbtSelectionAvailability, which enables the ribbon button when at least one element is selected: public class DbtSelectionAvailability : IExternalCommandAvailability { public bool IsCommandAvailable(UIApplication applicationData, CategorySet selectedCategories) { var selection = uidoc.Selection?.GetElementIds(); if (selection == null || selection.Count == 0) return false; // ... return selection.Any(id => /* element matches */); } } Source: csharp/src/DBTools.App/Tools/Availability/DbtSelectionAvailability.cs:13-51 Error Handling The tool handles errors at multiple levels: Command Level Throws InvalidOperationException if no elements are selected Throws InvalidOperationException if no target level is selected Source: csharp/src/Tools/Structural/AnalyticalSnapToLevel/Features/AnalyticalSnapToLevelCommand.cs:29-40 Snapper Level Elements are silently skipped (with debug logging) when: Element is null Element category is not OST_AnalyticalMember Element cannot be cast to AnalyticalMember Element has no curve geometry Structural role is not \"Beam\" or \"Column\" Any exception occurs during curve modification Source: csharp/src/Tools/Structural/AnalyticalSnapToLevel/Features/AnalyticalLevelSnapper.cs:46-129 Logging The tool logs debug information via ILogger: // Target level selection logger.LogDebug(\"[AnalyticalSnap] Target level: {LevelName} (Elev: {Elevation})\", targetLevel.Name, targetLevel.Elevation); // Skip reasons _logger.LogDebug(\"[AnalyticalSnap] Skipping element {ElementId} - not an analytical member.\", RevitId.ToInt(elementId)); // Success _logger.LogDebug(\"[AnalyticalSnap] Snapped {Role} {ElementId} to level {LevelName}.\", role, RevitId.ToInt(elementId), level.Name); // Summary logger.LogDebug(\"[AnalyticalSnap] Processed {Processed}; skipped {Skipped}.\", processed, skipped); Source: csharp/src/Tools/Structural/AnalyticalSnapToLevel/Features/AnalyticalSnapToLevelCommand.cs:42-52 API Reference AnalyticalLevelSnapper The core snapping service: public sealed class AnalyticalLevelSnapper { public AnalyticalLevelSnapper(ITransactionRunner tx, Document doc, ILogger logger); public (int ProcessedCount, int SkippedCount) Run( ICollection<ElementId> selectedIds, Level targetLevel); } Parameters Parameter Type Description tx ITransactionRunner Transaction runner for Revit operations doc Document Active Revit document logger ILogger Logger for debug output Return Value Returns a tuple with: ProcessedCount: Number of elements successfully snapped SkippedCount: Number of elements skipped (invalid category, role, or errors) Source: csharp/src/Tools/Structural/AnalyticalSnapToLevel/Features/AnalyticalLevelSnapper.cs:22-29 Troubleshooting Issue Cause Resolution Button disabled No elements selected Select analytical elements before clicking \"No elements selected\" error Selection cleared before command ran Re-select elements and try again High skip count Non-analytical elements in selection Select only analytical members Elements not moving Role is not \"Beam\" or \"Column\" Check element's Structural Role parameter Partial success Some elements have errors Check debug log for skip reasons Related Documentation SGT Tool - Structural Grid Tool (uses similar snapping concepts) Framing Joins - Related structural framing tool Source Files Reviewed File Purpose manifest.yml Tool declaration AnalyticalSnapToLevelToolModule.cs Module registration AnalyticalSnapToLevelCommand.cs Command entry point AnalyticalLevelSnapper.cs Core snapping logic DBTools.Structural.AnalyticalSnapToLevel.csproj Project configuration DbtSelectionAvailability.cs Availability predicate LevelPickerHelper.cs Level picker utility"
  },
  "developer-guide/tools/structural/foundation-tags.html": {
    "href": "developer-guide/tools/structural/foundation-tags.html",
    "title": "Foundation Tags | DB Tools",
    "summary": "Foundation Tags Overview The Foundation Tags tool automates the management and positioning of combined foundation tags in Revit structural documentation. It provides two main capabilities: updating parameter values on foundation elements based on pier associations, and moving tags to consistent corner positions on their tagged footings. Source: csharp/src/Tools/Structural/FoundationTags/manifest.yml:1-4 Location: csharp/src/Tools/Structural/FoundationTags/ Tool ID: DBTools.Structural.FoundationTags Ribbon Location: Structural group, split button foundation_tags Features Core Functionality Feature Description Update Combined Tags Updates pier-footing associations and elevation parameters Move Combined Tags Moves tags to corner positions on footings Auto-Update on View Automatically updates tags when activating floor/ceiling plans Linked Element Support Processes tags on footings in linked Revit models Selection Sets Creates timestamped selection sets for modified/skipped elements Source: csharp/src/Tools/Structural/FoundationTags/manifest.yml:19-39 Ribbon Commands Update Combined Foundation Tags Updates parameter values on piers and footings in the current view: Pier Processing: Calculates Foundation Pier Top elevation from Top Level + Top Offset Footing Processing: Associates each footing with its nearest pier (within 2-foot threshold) Parameter Updates: Sets Associated Pier (type mark) and Associated Pier Elevation on footings Source: csharp/src/Tools/Structural/FoundationTags/Features/CombinedFoundationTagsUpdater.cs:68-267 Command: DBTools.UpdateCombinedFoundationTags Display Text: \"Update Combined Foundation Tags\" Run Profile: InlineUi Source: csharp/src/Tools/Structural/FoundationTags/manifest.yml:20-29 Move Combined Foundation Tags Repositions foundation tags to specific corners of their tagged footings: Tag Collection: Finds structural foundation tags matching configured family patterns Footing Resolution: Retrieves tagged footing (host or linked) Corner Calculation: Computes footing corners using geometry tessellation Position Assignment: Moves tag to the corner specified by the tag name/type Source: csharp/src/Tools/Structural/FoundationTags/Features/CombinedFoundationTagsMover.cs:58-116 Command: DBTools.MoveCombinedFoundationTags Display Text: \"Move Combined Tags\" Run Profile: InlineUi Source: csharp/src/Tools/Structural/FoundationTags/manifest.yml:30-39 View-Activated Auto-Update When enabled, the tool automatically runs the Update Combined Tags operation when activating floor or ceiling plan views. Source: csharp/src/Tools/Structural/FoundationTags/Hooks/CombinedTagsViewActivatedTask.cs:37-49 Supported View Types: FloorPlan CeilingPlan Source: csharp/src/Tools/Structural/FoundationTags/Hooks/CombinedTagsViewActivatedTask.cs:48 Architecture Directory Structure csharp/src/Tools/Structural/FoundationTags/ +-- Features/ # Core feature implementations | +-- CombinedFoundationTagsUpdater.cs # Update logic | +-- CombinedFoundationTagsMover.cs # Move logic | +-- FoundationTagsGeometry.cs # Pure geometry calculations | +-- UpdateCombinedFoundationTagsCommand.cs | +-- MoveCombinedFoundationTagsCommand.cs +-- Hooks/ # Event handlers | +-- CombinedTagsViewActivatedTask.cs # Auto-update on view activation +-- Settings/ # Configuration | +-- FoundationTagsSettings.cs | +-- FoundationTagsSettingsPackContext.cs | +-- FoundationTagsSettingsPackView.xaml +-- Tests/ # Unit tests | +-- FoundationTagsGeometryTests.cs +-- FoundationTagsToolModule.cs # DI registration +-- manifest.yml # Tool manifest Key Components FoundationTagsToolModule The module class registers settings, services, and settings packs with the dependency injection container. Source: csharp/src/Tools/Structural/FoundationTags/FoundationTagsToolModule.cs:14-91 Registration Points: RegisterSettings: Binds FoundationTagsSettings to configuration section Tools.FoundationTags RegisterServices: Registers CombinedTagsViewActivatedTask as IViewActivatedTask RegisterSettingsPacks: Creates settings UI with warning definitions Source: csharp/src/Tools/Structural/FoundationTags/FoundationTagsToolModule.cs:16-81 CombinedFoundationTagsUpdater The core service that updates pier and footing parameters. Source: csharp/src/Tools/Structural/FoundationTags/Features/CombinedFoundationTagsUpdater.cs:16-275 Processing Flow: Collect piers matching configured family patterns Collect footings matching configured family patterns For each pier: calculate and set Foundation Pier Top For each footing: find nearest pier and set association parameters Create selection sets for modified and skipped elements Pier-Footing Association: Uses 2D distance (X, Y only) to find nearest pier Maximum distance threshold: 2 feet (squared distance = 4.0) Clears association if no pier found within threshold Source: csharp/src/Tools/Structural/FoundationTags/Features/CombinedFoundationTagsUpdater.cs:167 CombinedFoundationTagsMover The service that repositions tags to footing corners. Source: csharp/src/Tools/Structural/FoundationTags/Features/CombinedFoundationTagsMover.cs:18-376 Corner Selection Algorithm: Extract footing geometry points via tessellation Project corners onto view coordinate system (right/up axes) Select corner based on tag name using dot product projection Supported Corner Names: \"Top Right\" \"Top Left\" \"Bottom Right\" \"Bottom Left\" Source: csharp/src/Tools/Structural/FoundationTags/Features/FoundationTagsGeometry.cs:142-149 FoundationTagsGeometry A pure, testable geometry module with no Revit dependencies. Source: csharp/src/Tools/Structural/FoundationTags/Features/FoundationTagsGeometry.cs:112-250 Functions: Function Purpose SelectCornerByViewOrientation Selects corner based on view direction vectors FindNearestPoint2D Finds nearest candidate point within threshold IsValidCornerName Validates corner name strings Source: csharp/src/Tools/Structural/FoundationTags/Features/FoundationTagsGeometry.cs:123-249 Data Types: Type Description Point2D 2D point for distance calculations Point3D 3D point/vector for projections FootingCornerPoints Four corners of a rectangular footing NearestPointResult Result of nearest point search Source: csharp/src/Tools/Structural/FoundationTags/Features/FoundationTagsGeometry.cs:11-106 Settings Configuration Section Path: Tools.FoundationTags Source: csharp/src/Tools/Structural/FoundationTags/manifest.yml:7 FoundationTagsSettings Settings class implementing IAutoUpdateSettings. Source: csharp/src/Tools/Structural/FoundationTags/Settings/FoundationTagsSettings.cs:9-50 Property Type Default Description AutoUpdateEnabled bool true Enable auto-update on view activation HasWarning bool false Warning state (disables auto-update) TagFamilyPatterns List<string> See below Regex patterns for tag families PierFamilyPatterns List<string> See below Regex patterns for pier families FootingFamilyPatterns List<string> See below Regex patterns for footing families Source: csharp/src/Tools/Structural/FoundationTags/Settings/FoundationTagsSettings.cs:14-49 Default Patterns Tag Family Patterns (Move Combined Tags): ^Combined Foundation Tag ^DB Foundation Tag Source: csharp/src/Tools/Structural/FoundationTags/Settings/FoundationTagsSettings.cs:26-30 Pier Family Patterns (Update Combined Tags): ^Foundation Pier Source: csharp/src/Tools/Structural/FoundationTags/Settings/FoundationTagsSettings.cs:36-39 Footing Family Patterns (Update Combined Tags): ^Footing-Rectangular$ ^Pile Cap-Rectangular$ Source: csharp/src/Tools/Structural/FoundationTags/Settings/FoundationTagsSettings.cs:45-49 Settings UI The settings pack provides a configuration panel with: Auto-Update Toggle: Enable/disable automatic tag updates Tag Family Patterns: Up to 3 regex patterns for matching tag families Pier Family Patterns: Up to 3 regex patterns for matching pier families Footing Family Patterns: Up to 3 regex patterns for matching footing families Source: csharp/src/Tools/Structural/FoundationTags/Settings/FoundationTagsSettingsPackContext.cs:35-48 UI Features: Pattern validation with regex syntax checking Add/remove pattern buttons (max 3 per group) Warning state management with clear action Pending changes detection Source: csharp/src/Tools/Structural/FoundationTags/Settings/FoundationTagsSettingsPackContext.cs:132-166 Warning System The tool uses a warning system to disable functionality when issues occur. Warning Definition: ID: core.structural.combined_tags Title: \"Combined Foundation Tags Disabled\" Message: \"Combined foundation tag updates are disabled due to a warning. Clear the warning to re-enable.\" Source: csharp/src/Tools/Structural/FoundationTags/manifest.yml:12-18 Disabled Tools When Warning Active: DBTools.UpdateCombinedFoundationTags DBTools.MoveCombinedFoundationTags DBTools.OrganizeFoundationTypes Source: csharp/src/Tools/Structural/FoundationTags/manifest.yml:15-18 Manifest id: DBTools.Structural.FoundationTags assembly: DBTools moduleType: DBTools.Structural.FoundationTags.FoundationTagsToolModule order: 0 tool: settings: configSection: Tools.FoundationTags settingsPacks: - key: structural.foundation_tags title: \"Combined Foundation Tags\" warnings: - id: core.structural.combined_tags title: \"Combined Foundation Tags Disabled\" message: \"Combined foundation tag updates are disabled due to a warning. Clear the warning to re-enable.\" disableTools: - DBTools.UpdateCombinedFoundationTags - DBTools.MoveCombinedFoundationTags - DBTools.OrganizeFoundationTypes ribbonTools: - internalName: DBTools.UpdateCombinedFoundationTags commandType: DBTools.Structural.FoundationTags.UpdateCombinedFoundationTagsCommand availabilityType: DBTools.App.Tools.Availability.DbtActiveViewAvailability runProfile: InlineUi displayText: \"Update Combined\\nFoundation Tags\" iconBaseKey: update_combined tooltip: \"Update combined foundation tag instances\" controlKind: SplitButtonItem splitGroup: foundation_tags order: 0 - internalName: DBTools.MoveCombinedFoundationTags commandType: DBTools.Structural.FoundationTags.MoveCombinedFoundationTagsCommand availabilityType: DBTools.App.Tools.Availability.DbtActiveViewAvailability runProfile: InlineUi displayText: \"Move Combined Tags\" iconBaseKey: move_combined tooltip: \"Move combined foundation tags to corner positions\" controlKind: SplitButtonItem splitGroup: foundation_tags order: 1 Source: csharp/src/Tools/Structural/FoundationTags/manifest.yml:1-39 Integration Points Revit API Integration The tool interacts with Revit through standard API patterns: FilteredElementCollector: Queries piers, footings, and tags FamilyInstance.Location: Extracts element positions Parameter.Set/ClearValue: Updates element parameters IndependentTag.TagHeadPosition: Repositions tags SelectionFilterElement: Creates selection sets for results RevitLinkInstance: Supports linked model elements Source: csharp/src/Tools/Structural/FoundationTags/Features/CombinedFoundationTagsMover.cs:67-189 Transaction Management Operations use the ITransactionRunner interface for transaction management: _tx.RunAsync(_doc, \"DB Tools - Update Combined Foundation Tags...\", doc => { // Parameter updates }); Source: csharp/src/Tools/Structural/FoundationTags/Features/CombinedFoundationTagsUpdater.cs:96-222 Related Documentation System Architecture - Overall system design Organize Foundation Types - Related foundation tool Testing The tool includes unit tests for the geometry module: Test File: FoundationTagsGeometryTests.cs Source: csharp/src/Tools/Structural/FoundationTags/Tests/FoundationTagsGeometryTests.cs:12 Test Categories: Corner selection by view orientation Rotated view handling Case-insensitive corner name matching Invalid input handling Nearest point 2D search Corner name validation Source: csharp/src/Tools/Structural/FoundationTags/Tests/FoundationTagsGeometryTests.cs:24-432 Run headless tests: dotnet test csharp/src/Tools/Structural/FoundationTags/Tests/DBTools.Structural.FoundationTags.Tests.csproj -c Release Documentation Status: Complete Last Updated: 2026-01-24 Source Review: Verified against source files in csharp/src/Tools/Structural/FoundationTags/"
  },
  "developer-guide/tools/structural/framing-joins.html": {
    "href": "developer-guide/tools/structural/framing-joins.html",
    "title": "Framing Joins | DB Tools",
    "summary": "Framing Joins Control structural framing join behavior at beam endpoints with bulk operations on selected elements. Overview The Framing Joins tool provides two commands for managing structural framing joins in Revit: Allow Join - Enables joins at both ends of selected structural framing elements Disallow Join - Disables joins at both ends of selected structural framing elements These commands operate on the current selection and modify the join behavior using Revit's StructuralFramingUtils API. Source: csharp/src/Tools/Structural/FramingJoins/manifest.yml:1-26 Features Allow Join Selected Allows structural framing joins at both endpoints (index 0 and 1) of all selected framing elements. Source: csharp/src/Tools/Structural/FramingJoins/Features/AllowJoinSelectedCommand.cs:16-18 Behavior: Retrieves the current selection from the active document Filters to only FamilyInstance elements in the OST_StructuralFraming category For each valid element, calls StructuralFramingUtils.AllowJoinAtEnd() for both endpoints Displays a summary alert showing the number of modified elements Source: csharp/src/Tools/Structural/FramingJoins/Features/AllowJoinSelectedCommand.cs:29-84 Disallow Join Selected Disallows structural framing joins at both endpoints (index 0 and 1) of all selected framing elements. Source: csharp/src/Tools/Structural/FramingJoins/Features/DisallowJoinSelectedCommand.cs:16-18 Behavior: Retrieves the current selection from the active document Filters to only FamilyInstance elements in the OST_StructuralFraming category For each valid element, calls StructuralFramingUtils.DisallowJoinAtEnd() for both endpoints Displays a summary alert showing the number of modified elements Source: csharp/src/Tools/Structural/FramingJoins/Features/DisallowJoinSelectedCommand.cs:29-84 Architecture Project Structure FramingJoins/ ├── DBTools.Structural.FramingJoins.csproj ├── FramingJoinsToolModule.cs ├── manifest.yml ├── Assets/ │ ├── allow_join_icon.png │ └── disallow_join_icon.png └── Features/ ├── AllowJoinSelectedCommand.cs └── DisallowJoinSelectedCommand.cs Module Registration The tool module is a simple marker class that inherits from DbtToolModule: public sealed class FramingJoinsToolModule : DbtToolModule { } Source: csharp/src/Tools/Structural/FramingJoins/FramingJoinsToolModule.cs:1-8 Command Availability Both commands use the DbtStructuralFramingSelectionAvailability predicate, which requires at least one element from the OST_StructuralFraming category to be selected: public sealed class DbtStructuralFramingSelectionAvailability : DbtSelectionAvailability { protected override BuiltInCategory[]? RequiredCategories => new[] { BuiltInCategory.OST_StructuralFraming }; } Source: csharp/src/DBTools.App/Tools/Availability/DbtSelectionAvailability.cs:57-60 Transaction Handling Both commands use CallGateTransactionRunner with ModalInlineCallGate for transaction execution: var gate = new ModalInlineCallGate(context.UIApplication); var tx = new DBTools.Core.Revit.Transactions.CallGateTransactionRunner(gate); await tx.RunAsync(doc, \"DB Tools - Allow Join Selected\", d => { ... }); Source: csharp/src/Tools/Structural/FramingJoins/Features/AllowJoinSelectedCommand.cs:48-67 Error Handling Individual element failures are caught and logged without stopping the batch operation: catch (Exception ex) { logger.LogDebug(\"[AllowJoin] Failed for element {ElementId}: {Message}\", RevitId.ToInt(elem.Id), ex.Message); } Source: csharp/src/Tools/Structural/FramingJoins/Features/AllowJoinSelectedCommand.cs:62-65 Settings This tool has no configurable settings. It operates directly on the current selection. Manifest id: DBTools.Structural.FramingJoins assembly: DBTools moduleType: DBTools.Structural.FramingJoins.FramingJoinsToolModule order: 0 tool: ribbonTools: - internalName: DBTools.AllowJoinSelected commandType: DBTools.Structural.FramingJoins.AllowJoinSelectedCommand availabilityType: DBTools.App.Tools.Availability.DbtStructuralFramingSelectionAvailability runProfile: InlineUi displayText: \"Allow Join\" iconBaseKey: allow_join tooltip: \"Allow structural framing joins for selected elements\" controlKind: SplitButtonItem splitGroup: framing_joins order: 0 - internalName: DBTools.DisallowJoinSelected commandType: DBTools.Structural.FramingJoins.DisallowJoinSelectedCommand availabilityType: DBTools.App.Tools.Availability.DbtStructuralFramingSelectionAvailability runProfile: InlineUi displayText: \"Disallow Join\" iconBaseKey: disallow_join tooltip: \"Disallow structural framing joins for selected elements\" controlKind: SplitButtonItem splitGroup: framing_joins order: 1 Source: csharp/src/Tools/Structural/FramingJoins/manifest.yml:1-26 Manifest Properties Property Value Description id DBTools.Structural.FramingJoins Unique tool identifier assembly DBTools Target assembly (merged into main DBTools assembly) moduleType FramingJoinsToolModule DI module registration class runProfile InlineUi Runs inline with UI context controlKind SplitButtonItem Ribbon control type splitGroup framing_joins Groups both commands under a single split button Usage Select one or more structural framing elements (beams, braces, etc.) Click Allow Join or Disallow Join from the ribbon Review the summary dialog showing the number of modified elements Dependencies DBTools.Core - Core infrastructure, transactions, and UI services ricaun.Revit.UI.Tasks - Async task execution in Revit context Revit API (RevitAPI.dll, RevitAPIUI.dll) Source: csharp/src/Tools/Structural/FramingJoins/DBTools.Structural.FramingJoins.csproj:35-44"
  },
  "developer-guide/tools/structural/joist-girder-weight.html": {
    "href": "developer-guide/tools/structural/joist-girder-weight.html",
    "title": "Joist Girder Weight Tool | DB Tools",
    "summary": "Joist Girder Weight Tool Automatically estimates and updates weight parameters for joist girder elements in Revit structural models. Overview The Joist Girder Weight tool provides automated weight estimation for steel joist girders using moment-based structural engineering calculations. It calculates weight per linear foot based on the number of joists, point loads, span length, and girder depth, then writes the result to the element's Wt parameter. Source: csharp/src/Tools/Structural/JoistGirderWeight/Features/JoistGirderWeightCalculator.cs:9-74 The tool operates in two modes: Manual - User-initiated command via ribbon button Automatic - Triggered on view activation when auto-update is enabled Features Weight Calculation The calculator uses moment-based weight estimation derived from structural engineering principles: Panel Spacing Calculation - Girder length divided by number of joists Maximum Moment Calculation - Based on total reaction and span, with adjustments for even/odd panel counts Section Modulus Estimation - Uses engineering constants for chord and web member sizing Weight Aggregation - Combines top chord, bottom chord, and web weights Source: csharp/src/Tools/Structural/JoistGirderWeight/Features/JoistGirderWeightCalculator.cs:20-74 Engineering Constants The calculation employs the following constants: Constant Value Description Allowable Stress 50.0 ksi Design stress limit Section Modulus Factor 0.28356 Geometric section factor Depth Efficiency Factor 0.95 Effective depth ratio Top Chord Factor 1.06 Top chord sizing multiplier Bottom Chord Factor 1.13 Bottom chord sizing multiplier Web Member Factor 0.7 Web element sizing multiplier Connection Factor 0.6 Joint efficiency factor Source: csharp/src/Tools/Structural/JoistGirderWeight/Features/JoistGirderWeightCalculator.cs:51-58 Multi-Parameter Support The estimator supports multiple parameter naming conventions to handle legacy family definitions: Input Group Supported Parameter Names Number of Joists Number of Joists, SpaceNum, Number of Equal Spaces Point Load Panel Point Load, Point Load - User Defined, Point Load, Total Load - User Defined, Total Load, Joist Load Length Length Depth Depth Output Wt (required, writable) Parameters are resolved in priority order - the first match in each list wins. Both instance and type parameters are checked. Source: csharp/src/Tools/Structural/JoistGirderWeight/Features/JoistGirderWeightEstimator.cs:19-25 Element Filtering The tool targets structural framing elements where the family name or type name contains \"joist girder\" (case-insensitive): girders = collector .OfCategory(BuiltInCategory.OST_StructuralFraming) .WhereElementIsNotElementType() .Where(e => familyName.Contains(\"joist girder\", StringComparison.OrdinalIgnoreCase) || typeName.Contains(\"joist girder\", StringComparison.OrdinalIgnoreCase)); Source: csharp/src/Tools/Structural/JoistGirderWeight/Features/JoistGirderWeightEstimator.cs:36-48 Auto-Update on View Activation When enabled, the tool automatically updates joist girder weights whenever a view is activated. This is controlled by the AutoUpdateEnabled setting. Source: csharp/src/Tools/Structural/JoistGirderWeight/Hooks/JoistGirderViewActivatedTask.cs:19-44 Architecture Component Structure JoistGirderWeight/ ├── Features/ │ ├── JoistGirderWeightCalculator.cs # Pure calculation logic (no Revit dependencies) │ ├── JoistGirderWeightEstimator.cs # Revit integration and parameter handling │ └── UpdateJoistGirderWeightsCommand.cs # Ribbon command implementation ├── Hooks/ │ └── JoistGirderViewActivatedTask.cs # Auto-update on view change ├── Settings/ │ └── JoistGirderWeightSettings.cs # Configuration model ├── Assets/ │ └── joist_girder_icon.png # Ribbon button icon ├── JoistGirderWeightToolModule.cs # DI and module registration └── manifest.yml # Tool manifest Key Classes JoistGirderWeightCalculator Pure static calculation class with no Revit dependencies, enabling unit testing without Revit runtime. public static class JoistGirderWeightCalculator { public static double EstimateWeight( double numberOfJoists, double pointLoad, double lengthFeet, double depthFeet); public static bool ValidateInputs( double numberOfJoists, double pointLoad, double lengthFeet, double depthFeet); } Source: csharp/src/Tools/Structural/JoistGirderWeight/Features/JoistGirderWeightCalculator.cs:9-92 JoistGirderWeightEstimator Orchestrates the update process: Collects joist girder elements from the document Validates parameters and computes weights (outside transaction) Applies updates within a single transaction Reports success/failure counts Source: csharp/src/Tools/Structural/JoistGirderWeight/Features/JoistGirderWeightEstimator.cs:13-111 UpdateJoistGirderWeightsCommand The ribbon command entry point. Displays an alert with the update count upon completion. Source: csharp/src/Tools/Structural/JoistGirderWeight/Features/UpdateJoistGirderWeightsCommand.cs:15-42 Error Handling The tool follows the no-fallback, no-silent-failure principle: Pre-validation: All elements are validated before the transaction starts Partial updates: If some elements fail validation, valid ones are updated and a warning is logged Complete failure: If no elements can be updated, an InvalidOperationException is thrown with a sample error Source: csharp/src/Tools/Structural/JoistGirderWeight/Features/JoistGirderWeightEstimator.cs:84-97 Settings Configuration Schema # tools.json or per-user settings Tools: JoistGirderWeight: AutoUpdateEnabled: true # Enable/disable auto-update on view activation HasWarning: false # Warning state flag Source: csharp/src/Tools/Structural/JoistGirderWeight/Settings/JoistGirderWeightSettings.cs:5-10 Settings Properties Property Type Default Description AutoUpdateEnabled bool true Whether to auto-update weights on view activation HasWarning bool false Warning state - when true, disables auto-update Warning System When a warning is active: HasWarning is set to true AutoUpdateEnabled is forced to false The UpdateJoistGirderWeights command is disabled in the ribbon Source: csharp/src/Tools/Structural/JoistGirderWeight/JoistGirderWeightToolModule.cs:49-68 Manifest id: DBTools.Structural.JoistGirderWeight assembly: DBTools moduleType: DBTools.Structural.JoistGirderWeight.JoistGirderWeightToolModule order: 0 tool: settings: configSection: Tools.JoistGirderWeight settingsPacks: - key: structural.joist_girder_weight title: \"Joist Girder Weights\" warnings: - id: core.structural.joist_girder title: \"Joist Girder Weights Disabled\" message: \"Joist girder weight updates are disabled due to a warning...\" disableTools: - DBTools.UpdateJoistGirderWeights ribbonTools: - internalName: DBTools.UpdateJoistGirderWeights commandType: DBTools.Structural.JoistGirderWeight.UpdateJoistGirderWeightsCommand availabilityType: DBTools.App.Tools.Availability.DbtDocumentAvailability runProfile: InlineUi displayText: \"Update Joist\\nGirder Weights\" iconBaseKey: joist_girder tooltip: \"Update joist girder weights\" controlKind: PushButton order: 30 Source: csharp/src/Tools/Structural/JoistGirderWeight/manifest.yml:1-27 Ribbon Configuration Property Value Display Text \"Update Joist\\nGirder Weights\" Icon Key joist_girder Availability Document-dependent Run Profile InlineUi Order 30 Input Validation Required Constraints Parameter Constraint Rationale Number of Joists > 1 At least 2 joists required to create panel points Point Load >= 0 Negative loads are physically invalid Length > 0 Zero/negative span is invalid Depth > 0 Zero/negative depth is invalid Source: csharp/src/Tools/Structural/JoistGirderWeight/Features/JoistGirderWeightCalculator.cs:84-91 Validation Methods // Throws ArgumentOutOfRangeException for invalid inputs double weight = JoistGirderWeightCalculator.EstimateWeight(n, load, length, depth); // Returns bool for pre-validation bool isValid = JoistGirderWeightCalculator.ValidateInputs(n, load, length, depth); Testing The calculator has comprehensive unit test coverage (56 tests) covering: Valid input scenarios Scaling behavior (load, length, depth relationships) Invalid input handling Edge cases (overflow, underflow, fractional values) Input validation Determinism/consistency Source: csharp/src/Tools/Structural/JoistGirderWeight/Tests/JoistGirderWeightCalculatorTests.cs Running Tests # Build tests bash csharp/build.sh BuildTests # Run calculator tests (headless, no Revit required) dotnet test csharp/testing/DBTools.BuildArtifacts.Tests \\ --filter \"FullyQualifiedName~JoistGirderWeightCalculator\" Usage Notes Family Requirements For the tool to work correctly, joist girder families must: Belong to the Structural Framing category Have \"joist girder\" in the family name or type name Include at least one parameter from each input group Have a writable Wt parameter (Double storage type) Known Limitations Estimation only: Results are engineering estimates, not certified designs Single formula: Uses one calculation method regardless of manufacturer specifications No SJI validation: Does not validate against Steel Joist Institute load tables"
  },
  "developer-guide/tools/structural/organize-foundation.html": {
    "href": "developer-guide/tools/structural/organize-foundation.html",
    "title": "Organize Foundation Types | DB Tools",
    "summary": "Organize Foundation Types The Organize Foundation Types tool standardizes naming conventions and type marks for structural foundation elements. It processes pier and footing family types to ensure consistent naming patterns and eliminates duplicate types by merging instances. Source: csharp/src/Tools/Structural/OrganizeFoundationTypes/Features/OrganizeFoundationTypesCommand.cs:12-57 Overview This tool automates the tedious process of organizing foundation type names and type marks in Revit models. It: Renames types using standardized dimension-based naming (e.g., 3'-0\"x3'-0\" (P-1)) Assigns type marks with prefixes specific to each foundation category Merges duplicate types that have identical dimensions, consolidating instances Source: csharp/src/Tools/Structural/OrganizeFoundationTypes/Features/FoundationTypeOrganizer.cs:12-14 Supported Foundation Categories The tool processes four categories of foundation elements: Category Family Name Revit Category Type Mark Prefix Sort Criteria Foundation Piers Foundation Pier Structural Columns P Section area (b x h) Round Piers Foundation Pier - Round Structural Columns RP Diameter (d) Rectangular Footings Footing-Rectangular Structural Foundation F Width, Length, Thickness Pile Caps Pile Cap-Rectangular Structural Foundation CAP Width, Length, Thickness Source: csharp/src/Tools/Structural/OrganizeFoundationTypes/Features/FoundationTypeOrganizer.cs:39-42 Features Type Mark Generation Type marks are generated with predictable formats that support efficient scheduling and tagging: Pier/Round Pier Format: {PREFIX}-{counter} Examples: P-1, P-2, RP-1, RP-2 Footing/Pile Cap Format: {PREFIX}-{widthFeet}.{counter} Examples: F-3.0, F-3.1, CAP-4.0, CAP-4.1 The generator automatically finds the next available mark, filling gaps in sequences when possible. Source: csharp/src/Tools/Structural/OrganizeFoundationTypes/Features/TypeMarkGenerator.cs:22-64 Type Naming Conventions After processing, types are renamed to include dimensions and type mark: Foundation Type Naming Pattern Example Foundation Pier {b}x{h} ({mark}) 2'-6\"x2'-6\" (P-1) Round Pier {d} DIA. ({mark}) 2'-0\" DIA. (RP-1) Footing / Pile Cap {width}x{length}x{thickness} ({mark}) 3'-0\"x3'-0\"x1'-0\" (F-3.0) Source: csharp/src/Tools/Structural/OrganizeFoundationTypes/Features/FoundationTypeOrganizer.cs:127-129,197-198,276 Duplicate Type Merging When multiple types share identical dimensions, the tool: Identifies duplicate types based on dimension parameters Moves all instances from duplicate types to the primary type Deletes the now-empty duplicate types This reduces model clutter and ensures consistent type usage. Source: csharp/src/Tools/Structural/OrganizeFoundationTypes/Features/FoundationTypeOrganizer.cs:96-107,170-179,243-254 Overwrite Protection On execution, users are prompted whether to overwrite existing type marks: Yes: All type marks are regenerated, ensuring consistent sequential numbering No: Existing type marks are preserved; only types without marks receive new ones Source: csharp/src/Tools/Structural/OrganizeFoundationTypes/Features/OrganizeFoundationTypesCommand.cs:26-29 Architecture Component Structure OrganizeFoundationTypes/ Features/ OrganizeFoundationTypesCommand.cs -- Revit external command entry point FoundationTypeOrganizer.cs -- Core processing logic TypeMarkGenerator.cs -- Type mark generation (pure logic, testable) OrganizeFoundationTypesToolModule.cs -- DI module registration manifest.yml -- Ribbon and command configuration Class Responsibilities Class Responsibility OrganizeFoundationTypesCommand Entry point; prompts user, invokes organizer, displays results FoundationTypeOrganizer Collects types, processes each category, merges duplicates TypeMarkGenerator Pure static logic for generating unique type marks Source: csharp/src/Tools/Structural/OrganizeFoundationTypes/Features/OrganizeFoundationTypesCommand.cs:16, csharp/src/Tools/Structural/OrganizeFoundationTypes/Features/FoundationTypeOrganizer.cs:15, csharp/src/Tools/Structural/OrganizeFoundationTypes/Features/TypeMarkGenerator.cs:11 Transaction Strategy The organizer runs multiple transactions to isolate changes by category: DB Tools - Organize Foundation Pier Types (rectangular piers) DB Tools - Organize Round Pier Types (round piers) DB Tools - Organize Footing Types (footings and pile caps) Source: csharp/src/Tools/Structural/OrganizeFoundationTypes/Features/FoundationTypeOrganizer.cs:48-62 Dependencies DBTools.Core - Base infrastructure, transactions, logging, alerts ricaun.Revit.UI.Tasks - Async UI task handling Source: csharp/src/Tools/Structural/OrganizeFoundationTypes/DBTools.Structural.OrganizeFoundationTypes.csproj:35-44 Manifest Configuration id: DBTools.Structural.OrganizeFoundationTypes assembly: DBTools moduleType: DBTools.Structural.OrganizeFoundationTypes.OrganizeFoundationTypesToolModule order: 0 tool: ribbonTools: - internalName: DBTools.OrganizeFoundationTypes commandType: DBTools.Structural.OrganizeFoundationTypes.OrganizeFoundationTypesCommand availabilityType: DBTools.App.Tools.Availability.DbtDocumentAvailability runProfile: InlineUi displayText: \"Organize Foundation\\nTypes\" iconBaseKey: organize_types tooltip: \"Organize foundation types for tagging\" controlKind: SplitButtonItem splitGroup: foundation_tags order: 2 Source: csharp/src/Tools/Structural/OrganizeFoundationTypes/manifest.yml:1-16 Ribbon Placement The tool appears in the Foundation Tags split button group alongside: Order Tool Description 0 Update Combined Foundation Tags Updates tag instances 1 Move Combined Foundation Tags Repositions tags 2 Organize Foundation Types This tool Source: csharp/src/Tools/Structural/FoundationTags/manifest.yml:20-39, csharp/src/Tools/Structural/OrganizeFoundationTypes/manifest.yml:14-16 Availability Availability Class: DbtDocumentAvailability Requirement: An open Revit document (no active view requirement) Settings This tool has no configurable settings. All behavior is determined by the dimension parameters of the foundation types in the model. Parameter Requirements The tool reads specific parameters from each family type: Foundation Pier (Foundation Pier) Parameter Type Description b Length Pier width dimension h Length Pier depth dimension Type Mark Text Assigned type mark Round Pier (Foundation Pier - Round) Parameter Type Description d Length Pier diameter Type Mark Text Assigned type mark Footing / Pile Cap Parameter Type Description Width Length Footing width Length Length Footing length Foundation Thickness Length Footing depth Type Mark Text Assigned type mark Source: csharp/src/Tools/Structural/OrganizeFoundationTypes/Features/FoundationTypeOrganizer.cs:92-93,167,238-240 Processing Logic Pier Types (Rectangular) Collect all FamilySymbol instances from OST_StructuralColumns where family name is Foundation Pier Sort by section area (ascending) For each type: Check for duplicate (same b and h values) If duplicate found: merge instances to existing type, mark for deletion Otherwise: assign type mark (respecting overwrite setting), rename type Delete merged duplicate types Source: csharp/src/Tools/Structural/OrganizeFoundationTypes/Features/FoundationTypeOrganizer.cs:79-151 Round Pier Types Collect all FamilySymbol instances from OST_StructuralColumns where family name is Foundation Pier - Round Sort by diameter (ascending) For each type: Check for duplicate (same d value) If duplicate found: merge instances, mark for deletion Otherwise: assign type mark, rename with {d} DIA. ({mark}) format Delete merged duplicate types Source: csharp/src/Tools/Structural/OrganizeFoundationTypes/Features/FoundationTypeOrganizer.cs:154-218 Footing and Pile Cap Types Collect all FamilySymbol instances from OST_StructuralFoundation where family name matches Sort by Width, then Length, then Foundation Thickness (ascending) For each type: Check for duplicate (same Width, Length, and Foundation Thickness) If duplicate found: merge instances, mark for deletion Otherwise: assign footing-format type mark, rename with dimensions Delete merged duplicate types (best-effort, silently continues on failure) Source: csharp/src/Tools/Structural/OrganizeFoundationTypes/Features/FoundationTypeOrganizer.cs:221-293 Error Handling Individual type processing failures are logged at DEBUG level and skipped Type deletion failures are logged at WARNING or ERROR level Footing type deletions use best-effort (silently continue if deletion fails, as type may be in use elsewhere) The command displays a summary dialog showing counts of renamed and merged types Source: csharp/src/Tools/Structural/OrganizeFoundationTypes/Features/FoundationTypeOrganizer.cs:132-136,146-150,203-205,214-217,279-282,289-291 Testing Unit tests for the TypeMarkGenerator class verify: Sequential mark generation (P-1, P-2, P-3...) Gap filling in mark sequences Width-based footing mark format (F-3.0, F-3.1...) Null/invalid input handling Multiple prefix independence Source: csharp/src/Tools/Structural/OrganizeFoundationTypes/Tests/TypeMarkGeneratorTests.cs:1-346 Integration with Foundation Tags This tool is designed to work with the Combined Foundation Tags workflow: Run Organize Foundation Types to standardize type names and marks Use Update Combined Foundation Tags to update tag values Use Move Combined Foundation Tags to position tags The tools share a common warning system - if a warning is active on the structural.foundation_tags settings pack, all three tools are disabled until the warning is cleared. Source: csharp/src/Tools/Structural/FoundationTags/manifest.yml:12-18"
  },
  "developer-guide/tools/structural/sgt-spec.html": {
    "href": "developer-guide/tools/structural/sgt-spec.html",
    "title": "Super Girt Tool (SGT) — Comprehensive Specification | DB Tools",
    "summary": "Super Girt Tool (SGT) — Comprehensive Specification Version: 1.0 (Merged) Date: 2025-11-25 Supersedes: SGT Spec-Lock v13, SGT_Specification_2025-11-9_v6 Status: Normative This document consolidates all historical guidance, current specifications, and implementation requirements into a single, authoritative Super Girt Tool specification. It merges content from 15 historical documents and 4 current spec files. Part 1: Core Principles 1.1 Single Strict Path Pipeline: Analyze → Configure (UI) → Preview → Plan → Write No fallbacks, no silent failures, no vague heuristics Fail fast and loud with typed exceptions and overlays Catch only typed, expected errors at narrow boundaries; otherwise surface errors and stop 1.2 Preview Purity Preview never mutates the document Temporary instances for analysis/diagnostics are allowed Preview reflects actual placement parameters 1.3 Transactional Commit Batch writes, isolate per-girt failures Emit precise summary Single metadata write at commit 1.4 Spec-Lock Supremacy Orientation, rotation, offsets, joins, end-gaps, tolerance gates, and view contracts are judged by the Spec-Lock rules When in doubt, enforce the Spec-Lock constraints 1.5 AGENTS.md Compliance No fallback routes No silent failures No stubs/placeholders in production paths Delete dead code Centralized error handling Part 2: Wall-Anchored Frame 2.1 Right-Handed Coordinate System The tool uses a single, unified right-handed wall frame throughout all services. No service may define its own coordinate system. Frame Definition (matches WallFrame.cs): Origin: Location curve start point − (bottom offset × BasisZ) BasisX: Along wall (tangent to location curve, typically horizontal) BasisY: Exterior normal (perpendicular to wall, pointing outward from interior, from Wall.Orientation) BasisZ: Vertical (building up, parallel to Revit world Z-axis) Right-Hand Verification: BasisZ = BasisX × BasisY Orthonormality Checks: |dot(X,Y)|, |dot(X,Z)|, |dot(Y,Z)| ≤ 1e-6 (BasisX × BasisY) · BasisZ ≥ 0.9999 NO OTHER coordinate systems should exist in SGT codebase. This frame is used for: Family calibration (face classification) Orientation analysis (placement, seating checks) Preview generation (geometry transforms) All wall-relative computations 2.2 Linked Wall Handling For linked walls: Read the linked wall's Orientation property and location curve endpoints Apply RevitLinkInstance.GetTotalTransform() to transform into host-document coordinate space The transformed orientation is guaranteed to be the normal vector from the target exterior plane Store the transformation in the wall's domain object 2.3 Single Frame Enforcement CRITICAL: The right-handed wall frame computed in §2.1 is the only transformation used throughout the entire tool. Any code that previously used a different coordinate system frame must be refactored to use this single transformation. Part 3: Services Architecture 3.1 Coordinate System Service Single Source of Truth for wall coordinate system. Responsibilities: Accept linked or host foundation wall element ID (from user selection or test function) Read wall's Orientation property and location curve endpoints Transform into host-document coordinate space Compute and store the right-handed wall frame (Origin + BasisX/Y/Z) Provide the Revit Transform object for use by all other services 3.2 Wall Layer Service Responsibilities: Examine target wall for compound structure Select target layer using fallback logic: Primary: Most-exterior core layer with \"Structural\" checkbox enabled Fallback 1: Thickest layer Fallback 2: If multiple layers have same thickness, use most-exterior Store selected layer in wall domain object Compute \"target layer offset\" — the offset from wall center (location curve) to exterior side of target layer Populate UI layer dropdown with all layers, defaulting to selected layer 3.3 Target Exterior Plane Service Responsibilities: Create Revit Plane object representing the Final Target Exterior Plane Construct Frame() object with: Origin: Wall frame origin + target layer offset + UI layer offset value (defaults to 0) Basis Vectors: From Coordinate System Service Keep plane updated when: UI target layer combobox changes UI layer offset textbox changes Create new / delete old plane as needed 3.4 Calibration Service Single Source of Truth for identifying web and flange faces per family. High-Level Process: Place temporary instance on target plane (arbitrary length/direction) Extract geometry using GetInstanceGeometry() with Medium detail level Strip end cap faces (faces perpendicular to member length) Group remaining faces by area into bins: Larger area bin → \"likely web faces\" Smaller area bin → \"likely flange faces\" Within each bin, filter by normal vector orientation: Discard faces whose normals aren't multiples of 90° from wall frame Select largest area face per orientation bin Store face IDs in family domain object Delete temp instance and rollback transaction Notes: Calibration runs once per family (not per type) Type selection: prefer \"middle\" type if multiple exist Face IDs are stable across instances of the same family 3.5 Orientation Analysis Service Single Source of Truth for determining placement settings per family per role. Process (per family, per role): Place temp instance on target plane with role-appropriate direction: Girts/Heads/Sills: horizontal Jambs: vertical Retrieve calibrated faces from Calibration Service Find correct rotation by testing web face normal against expected direction Identify correct flange face by checking normal matches exterior plane normal Test Y justification options against flange gate OR web gate: Flange gate: BasisY distance from flange face point to target exterior plane ≈ 0 Web gate (horizontal): BasisZ distance from web face point to location curve ≈ 0 Web gate (jambs): BasisX distance from web face point to location curve ≈ 0 Test Z justification for remaining gate Store solved settings (rotation, Y-just, Z-just) in family domain object Constraints: Z-shapes: Only analyze for Girt role (hard block for opening roles) Analysis runs per-family, per-role, but only one type per family Part 4: Role Contracts 4.1 Role Axis Alignment Role Length (L) Depth (d) Width/Flange (bf) Flange Direction Girt +BasisX ±BasisY +BasisZ Up Head +BasisX ±BasisY +BasisZ Up (away from opening) Sill +BasisX ±BasisY −BasisZ Down (away from opening) Jamb_Left +BasisZ ±BasisY −BasisX Away from opening Jamb_Right +BasisZ ±BasisY +BasisX Away from opening 4.2 Seating Requirements (All Roles) Exterior flange: Seats on the exterior wall plane (BasisY direction) Web seating by role: Girt: Web on assigned elevation plane (horizontal) Head: Web on opening top plane (horizontal) Sill: Web on opening bottom plane (horizontal) Jambs: Web on opening side planes (vertical left/right) 4.3 Corner Alignment Corner = intersection of correct flange face and correct web face Achieved automatically when both flange gate and web gate pass No separate corner gate implementation needed 4.4 Pointing Requirements Girts/Heads: Point UP (web face normal points down) Sills: Point DOWN (web face normal points up) Jambs: Point AWAY from opening center (web face normal points toward opening) 4.5 Special Shape Handling Z-Shapes: Valid only for Girt role Exterior flange down, interior side flange up Hard block for opening roles (heads/sills/jambs) HSS Squares: Width == depth degeneracy allowed Alignment accepts symmetric case Seating/pointing gates still apply 4.6 Solid Geometry Placement ALL elements must have their solid geometry placed on the interior side of the target exterior wall plane. Part 5: Rotation & Justification 5.1 Cross-Section Rotation Also known as \"Structural Bend Dir Angle\" Angle about member length axis (L) Constrained to k×90° within tolerance (mod 90° ≤ 1e-6°) Non-multiple-of-90° rotations fail immediately 5.2 Y/Z Justification Y Justification: Controls lateral positioning (Left, Center, Right, Origin) Z Justification: Controls vertical positioning (Top, Middle, Bottom, Origin) Family-dependent labels; validity determined by seating/corner gate outcomes Labels are for UI display; actual values are numeric 5.3 Zero Offsets Policy Hard Gate: Y/Z justification offset values = 0.000 ft Any non-zero offset fails with [SpecFail/Offsets/NonZero] Clarification: \"Wall Offset\" (depth plane choice in UI) is independent and allowed Wall Offset translates the placement plane along wall depth direction Instance Y/Z justification offsets must remain exactly 0.0 5.4 Parameter Update Ordering Per element, in order: Place instance Set Disallow Join at both ends Apply negative Start/End Extensions for gaps Validate spans (> 6\") Commit Part 6: UI/UX Flow 6.1 Entry Points New Flow: \"Super Girt Tool\" ribbon button in DB Tools tab Edit Flow: Contextual button in \"Modify — Structural Framing\" tab when SGT metadata detected 6.2 New Flow (Single Basis Wall) Basis wall is singular. All analysis, seeding, previews, openings, and placement are anchored to one basis wall. Launch & Prompt: Yellow warning banner appears on launch Prompt user to select either a linked model wall or a host foundation wall Enforce single selection; reject multiple selections and non-wall types Progress Overlay (4 Steps): Step 1: Calibration (0% → 100%) Calibrate all structural framing families Identify web faces and flange faces Step 2: Orientation Analysis (0% → 100%) Analyze each family for each role Z-shapes only for Girt role Step 3: 2D Profile Loop Extraction (0% → 100%) Extract Medium-detail geometry loops Sanitize (ordering, closure, tolerance-clean) Step 4: Initial UI Seeding (0% → 100%) Default family: \"C Shapes\" / \"C10X15.3\" Seed girt rows at ≤ 5'-0\" spacing Seed opening rows from detected openings (Linked) or empty (Foundation) Auto-Seeding: Girts: ≤ 5'-0\" spacing with orientation-analyzed defaults Openings (Linked): One row per detected opening; default enabled roles are computed from opening bounds vs wall bounds (no fixed \"Sill off\" default) Manual Openings: Available via \"Add Opening\" action Plan Validity: Plans may be openings-only (0 girts but ≥1 enabled opening role) Place/Update are disabled only when the plan would place nothing Reveal: When analysis and seeding complete, overlay closes to reveal pre-populated grids and live previews. 6.3 Edit Flow (Selection-Aware) SelectionChanged Observer: Monitor Revit selection for Structural Framing with SGT schema Show \"Edit SGT Wall\" button on contextual tab when detected Launch: If multiple SystemIds present, open picker Otherwise use single system Rehydrate: Run auto-analysis at open Rehydrate UI from existing SGT System Initial seeding rules do NOT apply in Edit 6.4 Foundation Mode Seeding Window: From TOP of basis foundation wall upward 20'-0\" Standard ≤ 5'-0\" spacing within this band Openings: NOT auto-seeded in Foundation Mode Manual rows preview and place with full contracts Height Above Top: Acts as vertical reference when enabled 6.5 Window Structure Left Pane — Scope & Config: Exterior Plane & Compound Layers (Linked Mode) Wall Offset (depth-plane selection) Foundation Mode + Height Above Top Visibility by Flow: New: Place visible; Update/Remove hidden Edit: Place hidden; Update/Remove visible Part 7: Preview System 7.1 Common Contracts All three previews (Elevation, Section, 3D) derive from the same canonical, Revit-accurate element data Elevation and Section are projections of the canonical data used by 3D Previews stay synchronized with grids and UI state at all times 7.2 Elevation Preview Coordinate System: u = +BasisX (along wall) v = +BasisZ (vertical) Rendering: Draw bf-thickness bands from loop v-extents along L Use trimmed L-span (grids/openings) Enforce end gaps via negative extensions after Disallow Join Horizontals must not intrude into jamb bf Show grid extents overlay Acceptance Gates: bf-thickness bands correct Horizontals segmented at openings 1/2\" end gaps at jamb interfaces Disallow Join at both ends Zero offsets 7.3 Section Preview Coordinate System: u = +BasisY (depth / exterior normal) v = +BasisZ (vertical) Rendering: Render Medium loops with EvenOdd fill Anchor at L-axis ∩ section plane (or closest point if parallel) No L-extrusion Stroke presentation is guidance Acceptance Gates: Medium-detail loops rendered with EvenOdd Oriented per (d, bf) No L-extrusion Strict axis-alignment by role 7.4 3D Preview Rendering: Mesh from canonical 3D element data Two directional lights + ambient Fixed 6\" (0.5 ft) floor plane Role palette visible Overlay legend Interactive orbit/pan/zoom Acceptance Gates: No extra gates; 3D renders exactly the snapshot data Issues are visually obvious Part 8: Endpoint Association System 8.1 EndpointAssociation Value Object Every segment endpoint must have an association that tracks what it connects to. Association Types: Type Description Required Fields WallStart Wall start (t=0) None WallEnd Wall end (t=1) None Grid Grid intersection GridName, GridOffset OpeningEdge Opening edge OpeningId, EdgeSide, EdgeOffset FreeAlong Free distance from wall start AlongDistance OpeningEdgeSide Values: Left Right Top Bottom 8.2 Association Rules All girt segments must have start and end associations defined All opening elements must have endpoint associations Associations drive: Segment trimming calculations Preview rendering coordinates Placement coordinate determination Part 9: Elevation Preview Snapping 9.1 ElevationSnapIndex Spatial index for O(log n) nearest-neighbor queries on snap targets. Indexed Targets: Grids (sorted by t-parameter) Opening edges (left/right, sorted by t-parameter) Rebuild: Called once per preview refresh Before drag operations 9.2 IElevationSnapService Service for computing snap targets during drag operations. SnapInput Parameters: Target t-parameter (0.0 to 1.0) Pixels per unit t Cursor position (X, Y in pixels) DPI scale factor Wall length in feet Available grids and edges AllowFreeAlong flag ShiftStep flag (fine quantization) SnapResult: Snapped (bool): True if snapped to grid/edge Kind: \"Grid\", \"Edge\", or \"Along\" Name: Grid name or opening key Side: Edge side (Left/Right) T: Snapped t-parameter DxPx: Pixel distance to snap target AlongLabel: Label for free-along mode 9.3 Snapping Behavior Priority: Grid snapping (highest priority on ties) Edge snapping FreeAlong quantized snapping (fallback) Thresholds: Hit radius: 10px at 96 DPI baseline (DPI-scaled) Snap threshold: 12px to commit to anchor Epsilon for t-value comparisons: 1e-9 Quantization (FreeAlong mode): Default step: 1/4\" (0.25/12 ft) Fine step (Shift held): 1/8\" (0.125/12 ft) Tie-Breakers: Prefer grids over edges Prefer smaller t on exact ties Part 10: Placement System 10.1 Disallow Join Must be set at both ends for all members (all roles) Set before applying end extensions 10.2 End Extensions Along-L edits are via Start/End Extensions only Use negative values to shorten (not cutbacks) Required 1/2\" end gaps at horizontal–jamb interfaces Order: Set Disallow Join → Apply −1/2\" extensions 10.3 Minimum Segment Length Girt segments must be > 6\" (0.5 ft) Otherwise fail with [SpecFail/Extents/TooShort] 10.4 Opening Segmentation Horizontal members segment at openings Compute intervals by subtracting opening spans from row extent Gate by vertical intersection (row elevation vs opening height window) Apply 1/2\" gaps at opening edges 10.5 Placement Order Per element: Place instance(s) Disallow Join at both ends Apply negative Start/End Extensions for 1/2\" gaps at true intersections only Validate minimum segment length Commit 10.6 Zero Offsets Enforcement Location curve represents logical L-span Shortening via negative extensions only No cutbacks Hand/Face flips allowed if seating/axis outcomes remain valid Part 11: Metadata & Storage 11.1 Extensible Storage Schema All SGT instances carry schema fields: Field Description Tag \"SGT\" SystemId GUID string ConfigJson Role, vertical location, along-wall location, depth plane, etc. WallCurveHash Robust matching (1e-5 ft rounding, includes wall ID) WallOffset Depth offset value Timestamp Creation/modification time Version Schema version (\"13\") 11.2 Edit Round-Trip Metadata enables: Selection-based detection Edit launch Reconciliation when host or openings change Note: Initial seeding does NOT apply in Edit; system rehydrates from stored configuration. Openings-only: A stored system may have 0 girt rows as long as it has ≥1 enabled opening role; Edit/Update must still work end-to-end. 11.3 Remove System Flow VM Command: RemoveSystemCommand Implementation: Show overlay \"Removing…\" Call writer API to delete only elements tagged with current SystemId Delete girts and all opening roles Remove stored config from SgtConfigStore (host) and SgtLinkedConfigStore (linked) Update overlay with result Close window on success Constraint: Does NOT affect other SGT systems; scoped deletion only. Part 12: Error Handling 12.1 SpecFail Tags Recommended for logs/exceptions: Tag Description [SpecFail/RoleAxes/Mapping] Axis alignment failure [SpecFail/Offsets/NonZero] Non-zero Y/Z offset detected [SpecFail/Extents/TooShort] Segment < 6\" [SpecFail/Writer/Acceptance] No valid rotation/justification combination [SpecFail/Writer/Basis] Cannot determine flange face [SpecFail/RightHand] Non-right-handed rotation delta 12.2 Tolerances Check Tolerance Alignment (dot product) ≥ 0.9999 Seating ≤ 1e-3 ft Corner ≤ 1e-4 ft Rotation k×90° within 1e-6° Minimum girt length > 6\" (0.5 ft) T-parameter epsilon 1e-9 Distance epsilon (feet) 1e-6 12.3 Logging Requirements No silent failures All errors surface via banner/overlay Centralized error boundaries No broad catch(Exception) unless at narrow per-element boundary with explicit message propagation Part 13: Window Initialization & Progress Overlay 13.1 Overlay Display On each window paint, display a 4-step progress overlay that shows completion percentage for each step. 13.2 Step 1: Calibration (0% → 100%) Enumerate all structural framing families in document For each family: Place temporary instance Extract geometry and identify web/flange faces Store face IDs in family domain object Delete temp instance Progress: (completed families / total families) × 100% 13.3 Step 2: Orientation Analysis (0% → 100%) For each calibrated family: For each applicable role (Girt, Head, Sill, JambLeft, JambRight): Skip opening roles for Z-shapes Place temp instance with role-appropriate direction Test rotation/justification combinations Store solved settings Progress: (completed family-role pairs / total pairs) × 100% 13.4 Step 3: 2D Profile Loop Extraction (0% → 100%) For each calibrated family: Extract Medium-detail geometry loops Sanitize loops (ordering, closure, tolerance) Cache for preview rendering Progress: (completed families / total families) × 100% 13.5 Step 4: Initial UI Seeding (0% → 100%) Default Family/Type: Family: \"C Shapes\" Type: \"C10X15.3\" (Hardcoded for initial implementation) Girt Seeding: Calculate wall vertical extent Seed rows at ≤ 5'-0\" spacing Apply orientation analysis results for default family Opening Seeding: Linked Mode: One row per detected opening, with default enabled roles computed from opening bounds vs wall bounds: Left/Right jambs enabled when the opening is not at the wall ends (tolerance-gated) Header enabled when the opening top is below the vertical max (tolerance-gated) Sill enabled when the opening bottom is above the base reference (tolerance-gated) Foundation Mode: Empty (manual add only) Progress: Based on seeding completion Part 14: Smart Family Change Updates 14.1 Trigger Condition When a UI element (girt OR opening element) changes its family selection to a different family. 14.2 Update Behavior Look up orientation analysis results for: New family ID Current role (Girt, Head, Sill, JambLeft, JambRight) Auto-populate UI fields: Rotation Y Justification Z Justification (HandFlip defaults to false) UI controls update in lock-step with domain object 14.3 User Override User can manually change rotation/justification after auto-population Manual changes are preserved until next family change On placement, use currently configured UI settings (not analysis defaults) 14.4 Service Implementation SgtSmartDefaultsService: ApplySmartDefaultsForGirt(row, symbolId) → Sets rotation, Y-just, Z-just from orientation analysis TryApplySmartDefaultsForOpeningRole(row, role) → Handles LeftJamb, RightJamb, Header, Sill 14.5 Justification Display UI displays human-readable labels: \"Left\", \"Center\", \"Right\", \"Top\", \"Bottom\", etc. Values convert to/from Revit API integers via JustificationConverter Rotation displays as degrees (0/90/180/270) but may be stored as radians for API Part 15: Grid Extents UI 15.1 Detection Find host and link grid lines intersecting the basis wall; show as Elevation overlay. 15.2 Per-Row UI Two comboboxes per girt row: Left Extent Right Extent Default: \"Full Length\" (bounded by wall edges) 15.3 Rules Grid Count Behavior 0 grids Both comboboxes disabled 1 grid Picking it on one side disables the other (remains \"Full Length\") 2+ grids Both enabled; forbid same-grid at both ends; forbid inversions (Right < Left) 15.4 Endpoint Computation Snap to selected grid planes ∩ wall plane Set Disallow Join at both ends Apply −1/2\" Start/End Extensions Enforce > 6\" minimum length Part 16: Combination Freedom Any parameter combination (rotation/flip hand/face/Y-just/Z-just) is valid if and only if all acceptance gates are satisfied: k×90° rotation Strict axis alignment Exterior flange seating + role web seating Zero offsets Required 1/2\" end gaps via negative extensions Disallow Join at both ends Minimum length > 6\" Grid ordering rules Hybrid axes asserts pass The spec prescribes outcomes, not a single parameter recipe. No heuristic search is required if the outcome is known. Part 17: Future Considerations 17.1 SgtMember Role-Agnostic Approach Current implementation uses \"SgtGirt\" with separate handling for opening components. Future intent is to consolidate to a unified \"SgtMember\" class that is role-agnostic: Single class handles all roles: Girt, Head, Sill, JambLeft, JambRight Role property determines behavior and validation rules No axis-specific restrictions 17.2 Z-Shape Opening Role Relaxation Currently Z-shapes are hard-blocked for opening roles. If user demand exists, this could be relaxed to a warning with override capability. Appendix A: File References Core Domain DBTools.Core/Domain/SGT/ValueObjects/EndpointAssociation.cs DBTools.Core/Domain/SGT/ValueObjects/GirtSegment.cs DBTools.Core/Domain/SGT/Rules/MemberRules.cs Services DBTools.UI/Services/Snapping/IElevationSnapService.cs DBTools.UI/Services/Snapping/ElevationSnapIndex.cs DBTools.UI/Services/Snapping/SnappingConstants.cs DBTools.UI/Services/Defaults/SgtSmartDefaultsService.cs Adapters DBTools.RevitAdapter/SGT/Analysis/SgtOrientationAnalyzer.cs DBTools.RevitAdapter/SGT/Analysis/SgtSymbolCalibrationService.cs DBTools.RevitAdapter/SGT/Analysis/SgtFaceSelectors.cs DBTools.RevitAdapter/SGT/Analysis/SgtFrameBuilder.cs DBTools.RevitAdapter/SGT/Services/SgtDomainWriter.cs UI DBTools.UI/ViewModels/SGT/SgtWindowViewModel.*.cs DBTools.UI/Views/SGT/SgtWindow.xaml Appendix B: Change Log Version 1.0 (2025-11-25) Initial merged specification Consolidated 15 historical documents + 4 current specs Added endpoint association system (Part 8) Added elevation snapping specification (Part 9) Added 4-step progress overlay specification (Part 13) Added smart family change updates (Part 14) Adopted strict single wall frame mandate Specified Z-shape hard block for opening roles Added future considerations for SgtMember consolidation"
  },
  "developer-guide/tools/structural/sgt.html": {
    "href": "developer-guide/tools/structural/sgt.html",
    "title": "SGT (Super Girt Tool) | DB Tools",
    "summary": "SGT (Super Girt Tool) Overview The Super Girt Tool (SGT) is a Revit add-in for placing and managing structural steel girts and opening framing members (jambs, headers, sills) on foundation walls. It supports both host document walls and walls in linked Revit models. See also: Specification (Internal) Source: csharp/src/Tools/Structural/SGT/manifest.yml:7-8 Location: csharp/src/Tools/Structural/SGT/ Tool ID: DBTools.SGT Ribbon Location: Structural group, order 40 Features Core Functionality Feature Description Wall Selection Select linked walls or host foundation walls for girt placement Girt Placement Auto-seed girts at configurable elevations with smart spacing Opening Framing Automatic detection and framing of openings (jambs, headers, sills) Live Preview Real-time 2D elevation and 3D preview of proposed framing Extent Control Configure girt extents by wall length, grids, openings, or manual distances Edit Mode Modify previously placed SGT systems with host-change reconciliation Source: csharp/src/Tools/Structural/SGT/Features/Commands/SgtNewCommand.cs:36-39 Supported Wall Types Linked Walls: Walls from Revit link instances (any function) Host Foundation Walls: Foundation walls in the host document (WallFunction.Foundation) Source: csharp/src/Tools/Structural/SGT/Features/Commands/SgtNewCommand.cs:96-99 Supported Framing Types The tool supports structural framing families filtered by shape: Shape Category Girts Opening Members Notes C Shapes Yes Yes Default: C10X15.3 MC Shapes Yes Yes Miscellaneous channels Z Shapes Yes No Intentionally excluded for openings HSS (Tube) Yes Yes Hollow structural sections Source: csharp/src/Tools/Structural/SGT/Common/Domain/SgtPlan.cs:137-144 Architecture SGT follows a domain-driven MVVM architecture with clear separation between UI, domain logic, and Revit API interactions. csharp/src/Tools/Structural/SGT/ +-- Common/ # Shared utilities, models, domain objects | +-- Domain/ # Core domain entities (SgtPlan, SgtWall, etc.) | +-- Models/ # UI-bound row items (SgtGirtRowItem, etc.) | +-- Units/ # Unit conversion service +-- Features/ # Feature-specific code | +-- Commands/ # Revit external commands | +-- Girts/ # Girt management services | +-- Openings/ # Opening detection | +-- Orientation/ # Family orientation analysis | +-- Place/ # Placement orchestration | +-- Preview/ # 2D/3D preview rendering | +-- Reconcile/ # Host-change reconciliation +-- Shell/ # UI layer | +-- Composition/ # DI registration | +-- DesignTime/ # Design-time ViewModels | +-- UI/ # Views and ViewModels +-- Shared/ # Cross-feature services +-- Contracts/ # Interfaces and DTOs +-- Extents/ # Extent resolution +-- Hydration/ # Domain hydration +-- Kernel/ # Validation, logging Key Design Patterns Single Source of Truth (SSOT) The SgtPlan object serves as the single source of truth for all SGT operations. It contains: Wall geometry and context (host/linked) Girt row configurations Opening row configurations Eligible framing types Pre-computed orientation data Grid positions Source: csharp/src/Tools/Structural/SGT/Common/Domain/SgtPlan.cs:12-17 Plan Store Pattern The ISgtPlanStore interface provides centralized plan state management with change notifications: public interface ISgtPlanStore { SgtPlan? Plan { get; } event EventHandler<PlanChangedEventArgs>? PlanChanged; void SetPlan(SgtPlan plan); void Clear(); } Source: csharp/src/Tools/Structural/SGT/Shared/Contracts/ISgtPlanStore.cs Orchestrator Pattern The SgtOrchestrator coordinates validation, domain object creation, and placement/update operations: Validate - Check plan integrity and extent resolution Build Domain - Create SgtWall with SgtMember and SgtOpening aggregates Hydrate - Resolve segments and connectivity Persist - Write to Revit document via ISgtDomainWriter Source: csharp/src/Tools/Structural/SGT/Features/Place/Logic/SgtOrchestrator.cs:17-40 UI Components Main Window Class: SgtWindow (WPF Window) ViewModel: SgtWindowViewModel Source: csharp/src/Tools/Structural/SGT/Shell/UI/Views/SgtWindow.xaml:2 The main window is a 1600x850 modal dialog with three main regions: Left Panel: Configuration Scope controls (wall offset, layer selection) Girts expander with DataGrid Openings expander with DataGrid Bulk edit flyout Center Splitter: Resizable divider Right Panel: Preview 2D elevation view 3D view (using HelixToolkit) Preview mode toggle Source: csharp/src/Tools/Structural/SGT/Shell/UI/Views/SgtWindow.xaml:243-255 Girt Grid Columns Column Property Description Elevation ElevationText Vertical position (feet-inches format) Girt Type GirtTypeId Family type selection Rotation Rotation Cross-section rotation (0/90/180/270) Y Justification YJustification Lateral positioning Z Justification ZJustification Vertical positioning Flip FlipHand Mirror orientation Source: csharp/src/Tools/Structural/SGT/Shell/UI/Views/SgtWindow.xaml:402-517 Opening Grid Columns Each opening row supports four framing roles with independent configuration: Left Jamb: Vertical member at opening left edge Right Jamb: Vertical member at opening right edge Header: Horizontal member at opening top Sill: Horizontal member at opening bottom (optional) Source: csharp/src/Tools/Structural/SGT/Common/Domain/OpeningRoleRules.cs Preview Modes Mode Description Elevation 2D front elevation view with girts and openings 3D Interactive 3D view with wall layers and framing Source: csharp/src/Tools/Structural/SGT/Features/Preview/Logic/Models/PreviewMode.cs:4-9 Services Dependency Injection All SGT services are registered via SgtServiceCollectionExtensions.AddSgt(): Source: csharp/src/Tools/Structural/SGT/Shell/Composition/SgtServiceCollectionExtensions.cs:29-83 Core Services Service Lifetime Purpose ISgtPlanStore Singleton Plan state management IUnitService Singleton Unit conversion SgtValidationService Singleton Plan validation ISgtSystemRepository Scoped Extensible storage access SgtPersistenceService Scoped Plan persistence Feature Services Service Lifetime Purpose RevitOpeningQuery Scoped Opening detection from walls FamilyCalibrationService Scoped Family profile extraction WallGeometryService Scoped Wall geometry analysis SgtOrientationAdapter Scoped Family orientation computation IExtentResolver Singleton Extent position resolution SegmentResolutionService Singleton Girt segment computation SgtAutoSeedingService Singleton Initial girt elevation seeding Placement Services Service Lifetime Purpose ISgtPlanBuilder Transient Build plan from wall context ISgtDomainWriter Transient Write domain objects to Revit SgtOrchestrator Transient Coordinate placement flow Smart Defaults Service The SgtSmartDefaultsService applies automatic orientation defaults based on family analysis: // For girts SgtSmartDefaultsService.ApplySmartDefaultsForGirt(row, plan); // For opening roles SgtSmartDefaultsService.TryApplySmartDefaultsForOpeningRole(row, role, plan); Source: csharp/src/Tools/Structural/SGT/Features/Girts/Services/SgtSmartDefaultsService.cs:43-70 Host Change Reconciliation When editing an existing SGT system, the tool detects changes to the host wall: Diff Detection: Compare stored vs current wall geometry Missing Wall Handling: Options for re-link or delete Geometry Mismatch: Options for scale, shift, or ignore Opening Changes: Sync manual openings to real elements Source: csharp/src/Tools/Structural/SGT/Features/Reconcile/SgtHostChangeReconciliationService.cs Configuration Manifest id: DBTools.SGT assembly: DBTools moduleType: DBTools.SGT.SgtToolModule order: 0 sandboxWindows: - id: DBTools.SGT.Main displayName: \"Super Girt Tool\" group: \"Structural\" windowType: \"DBTools.SGT.Shell.UI.Views.SgtWindow\" designTimeViewModelType: \"DBTools.SGT.Shell.DesignTime.SgtWindowDesignTimeViewModel\" tool: ribbonTools: - internalName: DBTools.SGT commandType: DBTools.SGT.Features.Commands.SgtNewCommand availabilityType: DBTools.App.Tools.Availability.DbtDocumentAvailability runProfile: InlineUi displayText: \"Super Girt Tool\" iconBaseKey: sgt tooltip: \"Launch Super Girt Tool\" controlKind: PushButton order: 40 Source: csharp/src/Tools/Structural/SGT/manifest.yml:1-21 UI State Persistence The ISgtUiStateStore persists user preferences: Expander states (Girts, Openings) Preview mode selection Column visibility Source: csharp/src/Tools/Structural/SGT/Shell/UI/Settings/ISgtUiStateStore.cs Domain Model Key Domain Entities SgtPlan The central data structure containing all configuration: public sealed class SgtPlan { // Wall context public int? HostWallId { get; init; } public int? LinkedWallId { get; init; } public int? LinkInstanceId { get; init; } public WallGeometry? WallGeometry { get; set; } // Girt configuration public List<SgtGirtRow> GirtRows { get; init; } public int SelectedGirtTypeId { get; set; } // Opening configuration public List<SgtOpeningRow> OpeningRows { get; set; } public IReadOnlyList<OpeningDetectionData> DetectedOpenings { get; set; } // Options public int DepthPlaneLayerIndex { get; set; } public double WallOffsetFeet { get; set; } public bool FoundationMode { get; set; } } Source: csharp/src/Tools/Structural/SGT/Common/Domain/SgtPlan.cs:16-193 Extent Types Girts support multiple extent modes: Extent Type Description FullLengthExtent Wall start to wall end AlongExtent Fixed distances from wall start GridExtent Between named grid lines with offsets OpeningEdgeExtent Relative to opening edges DualOpeningEdgeExtent Between two opening edges Source: csharp/src/Tools/Structural/SGT/Common/Domain/ (multiple files) Integration Points Revit API Integration SGT interacts with Revit through adapter services: WallGeometryService: Extract wall curves, layers, dimensions RevitOpeningQuery: Detect doors, windows, and openings in walls SgtDomainWriter: Create structural framing instances SgtSystemRepository: Store/retrieve SGT configurations in extensible storage Related Documentation System Architecture - Overall system design Application Host - How tools are loaded and hosted Tool Manifest Format - Manifest schema reference Testing SGT includes comprehensive tests: csharp/src/Tools/Structural/SGT/Tests/ +-- SgtAdapterTests.cs +-- SgtFrameBuilderTests.cs +-- SgtConfigHydratorTests.cs +-- SgtValidationServiceTests.cs +-- SgtOrchestratorExtentTests.cs +-- SgtHostChangeDiffServiceTests.cs +-- ... (additional test files) Source: csharp/src/Tools/Structural/SGT/Tests/DBTools.SGT.Tests.csproj Run tests via the Revit test runner: bash csharp/invoke-revit-tests.sh --smart --tool SGT Documentation Status: Complete Last Updated: 2026-01-24 Source Review: Verified against source files in csharp/src/Tools/Structural/SGT/"
  },
  "developer-guide/tools/testing/erft-spec.html": {
    "href": "developer-guide/tools/testing/erft-spec.html",
    "title": "Extreme Roof Framing Tool (ERFT) - Complete Technical Specification | DB Tools",
    "summary": "Extreme Roof Framing Tool (ERFT) - Complete Technical Specification Overview ERFT is a Revit add-in that adjusts structural columns and beams to match the slope of a target floor or roof element. Users select a target element (floor/roof from host or linked model), then select source framing elements (columns/beams from host document). The tool analyzes the framing hierarchy, computes required vertical adjustments based on closest-point projection to the target surface, and applies offset parameter changes with configurable rounding tolerance. Tool Location: csharp/src/Tools/Testing/ERFT/ Ribbon Location: DB Tools > Testing > ERFT Table of Contents Core Concepts User Workflow Data Models Architecture Selection & Validation Geometry Analysis Framing Hierarchy Detection Adjustment Algorithm 3D Preview System UI Components ExtensibleStorage Schema Contextual Ribbon Integration Error Handling Test Strategy Implementation Phases 1. Core Concepts 1.1 Purpose ERFT solves the problem of manually adjusting structural framing to follow sloped roofs or floors. Instead of tediously calculating and applying offsets to each element, users: Select the target slope surface (floor/roof) Select the framing elements to adjust (columns and beams) Configure rounding tolerance (e.g., nearest 1/4\") Preview the adjustments in 3D with status highlighting Apply changes atomically with a single click 1.2 Key Principles Offset-Only Adjustments: Never modify Level parameters; only adjust offset values Closest-Point Projection: Each endpoint is projected to the nearest point on the target surface Auto-Detect Hierarchy: Automatically determine which beams frame to columns vs. other beams Cascading Adjustments: Columns first → beams-to-columns → beams-to-beams SSOT Pattern: Single ErftPlan object holds all state; UI mutates it; Apply reads it 1.3 Workflow Stages ┌─────────────────┐ ┌─────────────────┐ ┌─────────────────┐ ┌─────────────────┐ │ 1. PICK TARGET │───>│ 2. PICK SOURCE │───>│ 3. CONFIGURE │───>│ 4. APPLY │ │ - Floor/Roof │ │ - Columns │ │ - Preview 3D │ │ - Adjust cols │ │ - Host/Linked │ │ - Beams │ │ - Tolerance │ │ - Adjust beams │ └─────────────────┘ └─────────────────┘ │ - Round up/dn │ │ - Tag elements │ └─────────────────┘ └─────────────────┘ 2. User Workflow 2.1 Initial Flow (New) User clicks \"ERFT\" ribbon button Status bar: \"Pick target floor or roof (ESC to cancel)\" User picks floor/roof from host or linked model Status bar: \"Pick columns and beams to adjust (Finish to continue)\" User picks multiple columns/beams, clicks Finish Validation: Must have at least 1 column OR 1 beam framing to a column Progress overlay appears: \"Analyzing geometry...\" Pre-analysis runs: Extract target surface geometry (mesh + slope data) Analyze source element positions Detect framing hierarchy (what frames to what) Warm profile loops for 3D preview Compute initial adjustment deltas UI window opens with: 3D preview showing target surface + framing Tolerance controls (presets + custom) Round up/down toggle Element list with status indicators User adjusts tolerance as needed Preview updates in real-time User clicks \"Apply\" Transaction group commits all changes ExtensibleStorage tags applied to modified elements 2.2 Edit Flow (via Contextual Ribbon) User selects elements with ERFT ExtensibleStorage data Contextual \"Edit ERFT\" button appears in Modify tab User clicks button System loads stored plan from DataStorage UI opens with previous settings populated User can: Re-pick target floor/roof Adjust tolerances Re-apply changes Apply overwrites previous offsets (not cumulative) 3. Data Models 3.1 ErftPlan (Single Source of Truth) /// <summary> /// Central domain model holding all ERFT state. /// UI binds to this; Apply reads from it. /// </summary> public sealed class ErftPlan { // === TARGET CONTEXT === public int? HostTargetId { get; set; } // Floor/Roof in host doc public int? LinkedTargetId { get; set; } // Floor/Roof in linked doc public int? LinkInstanceId { get; set; } // RevitLinkInstance if linked public TargetSurfaceGeometry? TargetGeometry { get; set; } // === SOURCE ELEMENTS === public List<ErftColumnItem> Columns { get; init; } = new(); public List<ErftBeamItem> Beams { get; init; } = new(); // === FRAMING HIERARCHY === public ErftFramingGraph FramingGraph { get; set; } = new(); // === TOLERANCE SETTINGS === public double ToleranceFeet { get; set; } = 1.0 / 48.0; // 1/4\" default public RoundingMode RoundingMode { get; set; } = RoundingMode.Nearest; // === PREVIEW STATE === public IReadOnlyDictionary<int, MemberProfileLoops> ProfilesByTypeId { get; set; } // === METADATA === public string SystemId { get; set; } = Guid.NewGuid().ToString(); public int Version { get; set; } = 1; } 3.2 ErftColumnItem /// <summary> /// Represents a structural column in the adjustment plan. /// </summary> public sealed class ErftColumnItem { public int ElementId { get; init; } public int TypeId { get; init; } public string TypeName { get; init; } = string.Empty; // Original state (read from Revit) public Vector3 TopPoint { get; init; } // Current top coordinate public double OriginalTopOffsetFeet { get; init; } // Current Top Offset parameter public int TopLevelId { get; init; } // Top Level (never changed) // Computed adjustment public double TargetElevationFeet { get; set; } // Z of closest point on target public double DeltaFeet { get; set; } // Raw delta (target - current) public double RoundedDeltaFeet { get; set; } // After tolerance rounding public double NewTopOffsetFeet { get; set; } // Original + RoundedDelta // Status public AdjustmentStatus Status { get; set; } } 3.3 ErftBeamItem /// <summary> /// Represents a structural beam in the adjustment plan. /// </summary> public sealed class ErftBeamItem { public int ElementId { get; init; } public int TypeId { get; init; } public string TypeName { get; init; } = string.Empty; // Original state public Vector3 StartPoint { get; init; } public Vector3 EndPoint { get; init; } public double OriginalStartOffsetFeet { get; init; } public double OriginalEndOffsetFeet { get; init; } public int ReferenceLevelId { get; init; } // Connection classification public BeamEndConnection StartConnection { get; set; } // Column, Beam, or Free public BeamEndConnection EndConnection { get; set; } public int? StartConnectionElementId { get; set; } // Column or Beam it connects to public int? EndConnectionElementId { get; set; } // Computed adjustment public double StartTargetElevationFeet { get; set; } public double EndTargetElevationFeet { get; set; } public double StartDeltaFeet { get; set; } public double EndDeltaFeet { get; set; } public double RoundedStartDeltaFeet { get; set; } public double RoundedEndDeltaFeet { get; set; } public double NewStartOffsetFeet { get; set; } public double NewEndOffsetFeet { get; set; } // Status public AdjustmentStatus Status { get; set; } } 3.4 Supporting Types public enum BeamEndConnection { Free, // Endpoint not connected to anything in selection ToColumn, // Frames into a column top ToBeam // Frames into another beam's location line } public enum AdjustmentStatus { Pending, // Will be modified NoChangeNeeded, // Already at correct elevation (within tolerance) Error // Cannot compute adjustment (missing geometry, etc.) } public enum RoundingMode { Nearest, // Round to nearest increment Up, // Always round up (toward target) Down // Always round down (away from target) } /// <summary> /// Extracted geometry of the target floor/roof surface. /// </summary> public sealed class TargetSurfaceGeometry { public IReadOnlyList<Vector3> Vertices { get; init; } public IReadOnlyList<int> TriangleIndices { get; init; } public BoundingBox Bounds { get; init; } public Transform? LinkTransform { get; init; } // null if host element } /// <summary> /// Graph representing framing connectivity. /// </summary> public sealed class ErftFramingGraph { public IReadOnlyDictionary<int, List<int>> ColumnToBeams { get; set; } // columnId → beamIds framing to it public IReadOnlyDictionary<int, List<int>> BeamToBeams { get; set; } // beamId → beamIds framing to it public IReadOnlyList<int> ProcessingOrder { get; set; } // Topological sort for cascading } 4. Architecture 4.1 Folder Structure csharp/src/Tools/Testing/ERFT/ ├── Assets/ │ └── erft_icon.png # 32x32 tool icon ├── Common/ │ ├── Domain/ │ │ ├── ErftPlan.cs # SSOT plan object │ │ ├── ErftColumnItem.cs # Column data │ │ ├── ErftBeamItem.cs # Beam data │ │ ├── TargetSurfaceGeometry.cs # Mesh representation │ │ ├── ErftFramingGraph.cs # Connectivity graph │ │ ├── ErftStoredPlan.cs # Serialization snapshot │ │ ├── Vector3.cs # (reuse from SGT or create) │ │ └── MemberProfileLoops.cs # (reuse from SGT) │ ├── Models/ │ │ ├── ErftSchemaDefinition.cs # ExtensibleStorage constants │ │ └── TolerancePreset.cs # Rounding preset options │ ├── Revit/ │ │ └── ErftSystemRepository.cs # ExtensibleStorage CRUD │ └── State/ │ └── ErftPlanStore.cs # Thread-safe plan holder ├── Features/ │ ├── Commands/ │ │ ├── ErftNewCommand.cs # Ribbon entry point │ │ ├── ErftRunner.cs # Modal flow orchestration │ │ ├── ErftContextualRibbonInjector.cs # Edit button injection │ │ └── ErftMode.cs # New/Edit enum │ ├── Analysis/ │ │ ├── Logic/ │ │ │ ├── TargetSurfaceAnalyzer.cs # Extract mesh from floor/roof │ │ │ ├── FramingHierarchyBuilder.cs # Build connectivity graph │ │ │ └── AdjustmentCalculator.cs # Compute deltas │ │ └── Revit/ │ │ ├── FloorRoofGeometryService.cs # Revit API geometry extraction │ │ ├── ColumnQueryService.cs # Read column properties │ │ └── BeamQueryService.cs # Read beam properties │ ├── Apply/ │ │ ├── Logic/ │ │ │ └── ErftOrchestrator.cs # Apply orchestration │ │ └── Revit/ │ │ ├── ErftDomainWriter.cs # Write offset parameters │ │ └── ErftStorageMapper.cs # JSON serialization │ └── Preview/ │ ├── Logic/ │ │ └── ErftPreviewSceneBuilder.cs # Build 3D meshes │ └── UI/ │ └── ErftPreview3DRenderer.cs # HelixToolkit rendering ├── Shell/ │ ├── Composition/ │ │ └── ErftServiceCollectionExtensions.cs # DI registration │ ├── Revit/ │ │ ├── ErftTargetSelectionFilter.cs # Floor/Roof picker filter │ │ └── ErftSourceSelectionFilter.cs # Column/Beam picker filter │ ├── Services/ │ │ └── DialogService.cs # (reuse pattern from SGT) │ └── UI/ │ ├── ViewModels/ │ │ └── ErftWindowViewModel.cs # Main VM │ └── Views/ │ └── ErftWindow.xaml[.cs] # Main UI window ├── Shared/ │ ├── Contracts/ │ │ ├── IErftPlanStore.cs │ │ ├── ITargetSurfaceAnalyzer.cs │ │ └── IFramingHierarchyBuilder.cs │ └── Geometry/ │ └── ClosestPointService.cs # Point-to-mesh projection ├── Tests/ │ ├── ClosestPointServiceTests.cs │ ├── FramingHierarchyBuilderTests.cs │ ├── AdjustmentCalculatorTests.cs │ ├── ErftStorageMapperTests.cs │ └── ErftPreviewSceneBuilderTests.cs ├── ErftToolModule.cs # Tool registration + hooks ├── ErftServiceExtensions.cs # Bootstrap ├── manifest.yml # Tool manifest ├── DBTools.ERFT.csproj # Project file └── GlobalSuppressions.cs # Analyzer suppressions 4.2 Dependencies HelixToolkit.SharpDX.Core.Wpf - 3D preview rendering (already in repo) CSharpFunctionalExtensions - Result<T,E> pattern (already in repo) System.Text.Json - Serialization (already in repo) 5. Selection & Validation 5.1 Target Selection Filter /// <summary> /// ISelectionFilter for picking floor/roof from host or linked models. /// </summary> public sealed class ErftTargetSelectionFilter : ISelectionFilter { private readonly Document _doc; public bool AllowElement(Element elem) { // Allow RevitLinkInstance (for linked targets) if (elem is RevitLinkInstance) return true; // Allow host Floor or Roof return elem is Floor || elem is RoofBase; } public bool AllowReference(Reference reference, XYZ position) { if (reference == null) return false; // Check if it's a linked element var hostElem = _doc.GetElement(reference.ElementId); if (hostElem is RevitLinkInstance link) { var linkDoc = link.GetLinkDocument(); var linked = linkDoc?.GetElement(reference.LinkedElementId); return linked is Floor || linked is RoofBase; } // Host element return hostElem is Floor || hostElem is RoofBase; } } 5.2 Source Selection Filter /// <summary> /// ISelectionFilter for picking structural columns and beams from host document. /// </summary> public sealed class ErftSourceSelectionFilter : ISelectionFilter { public bool AllowElement(Element elem) { if (elem is not FamilyInstance fi) return false; var cat = elem.Category?.BuiltInCategory; return cat == BuiltInCategory.OST_StructuralColumns || cat == BuiltInCategory.OST_StructuralFraming; } public bool AllowReference(Reference reference, XYZ position) { return false; // No linked sources allowed } } 5.3 Validation Rules After source selection completes, validate: At least one column must be selected, OR At least one beam must frame directly to a column (detected via proximity) If only beams are selected with no columns, show error: \"Select at least one column or beams that frame to columns\" 6. Geometry Analysis 6.1 Target Surface Extraction /// <summary> /// Extracts triangulated mesh from Floor or RoofBase bottom face. /// </summary> public sealed class FloorRoofGeometryService { /// <summary> /// Gets the bottom face geometry of a floor or roof, transformed to host coordinates if linked. /// </summary> public Result<TargetSurfaceGeometry, string> ExtractBottomSurface( Element target, RevitLinkInstance? link) { var options = new Options { ComputeReferences = false, DetailLevel = ViewDetailLevel.Medium }; var geomElem = target.get_Geometry(options); // Find bottom-facing planar faces and non-planar faces // Triangulate using Revit's Tessellate() method // Transform vertices if link != null: link.GetTotalTransform() return new TargetSurfaceGeometry { Vertices = vertices, TriangleIndices = indices, Bounds = bounds, LinkTransform = link?.GetTotalTransform() }; } } 6.2 Closest Point Projection /// <summary> /// Projects a point to the closest point on a triangulated mesh. /// Used to find target elevation for each framing endpoint. /// </summary> public sealed class ClosestPointService { /// <summary> /// Finds the closest point on the target mesh (bottom face of floor/roof) /// to the given query point. Returns Z coordinate for elevation. /// </summary> public Result<double, string> ProjectToSurface( Vector3 queryPoint, TargetSurfaceGeometry surface) { // For each triangle in the mesh: // 1. Project query point onto triangle plane // 2. Clamp to triangle if outside // 3. Track closest distance // Return Z of closest point } } Algorithm Notes: For simple single-slope surfaces (common case), this is fast For hip roofs or warped slabs, may need spatial acceleration (octree) for large meshes Initial implementation: brute-force iterate triangles; optimize later if needed 7. Framing Hierarchy Detection 7.1 Overview The algorithm must determine: Which beams frame INTO columns (endpoint within tolerance of column top) Which beams frame INTO other beams (endpoint on another beam's location line) Processing order: Columns → Beams-to-Columns → Beams-to-Beams (cascading) 7.2 Detection Algorithm /// <summary> /// Builds the framing connectivity graph from selected elements. /// </summary> public sealed class FramingHierarchyBuilder { private const double ConnectionToleranceFeet = 0.5 / 12.0; // 1/2\" tolerance public ErftFramingGraph BuildGraph( IReadOnlyList<ErftColumnItem> columns, IReadOnlyList<ErftBeamItem> beams) { var columnToBeams = new Dictionary<int, List<int>>(); var beamToBeams = new Dictionary<int, List<int>>(); // Phase 1: Detect beam-to-column connections foreach (var beam in beams) { foreach (var col in columns) { // Check if beam start or end is within tolerance of column top if (IsWithinTolerance(beam.StartPoint, col.TopPoint)) { beam.StartConnection = BeamEndConnection.ToColumn; beam.StartConnectionElementId = col.ElementId; columnToBeams.GetOrAdd(col.ElementId).Add(beam.ElementId); } if (IsWithinTolerance(beam.EndPoint, col.TopPoint)) { beam.EndConnection = BeamEndConnection.ToColumn; beam.EndConnectionElementId = col.ElementId; columnToBeams.GetOrAdd(col.ElementId).Add(beam.ElementId); } } } // Phase 2: Detect beam-to-beam connections foreach (var beam in beams) { if (beam.StartConnection == BeamEndConnection.Free) { var supporting = FindSupportingBeam(beam.StartPoint, beams, beam.ElementId); if (supporting != null) { beam.StartConnection = BeamEndConnection.ToBeam; beam.StartConnectionElementId = supporting.ElementId; beamToBeams.GetOrAdd(supporting.ElementId).Add(beam.ElementId); } } // Same for EndPoint... } // Phase 3: Build topological processing order var order = TopologicalSort(columns, beams, columnToBeams, beamToBeams); return new ErftFramingGraph { ... }; } private ErftBeamItem? FindSupportingBeam(Vector3 point, IReadOnlyList<ErftBeamItem> beams, int excludeId) { // Find beam whose location line is closest to point // Return beam where point projects onto line segment within tolerance } } 7.3 Hybrid Beams (Column + Beam) Beams can have one end framing to a column and the other end framing to another beam. The algorithm handles this naturally: Each endpoint is classified independently Start might be ToColumn, End might be ToBeam Processing order ensures columns are adjusted first, then beams-to-columns, then dependent beams 8. Adjustment Algorithm 8.1 Processing Order 1. Adjust all COLUMNS: - Project top point to target surface - Compute delta = (target_Z - current_top_Z) - Apply rounding tolerance - New Top Offset = Original Top Offset + rounded_delta 2. doc.Regenerate() if needed 3. Adjust all BEAMS framing to COLUMNS: - For endpoints connected to columns: inherit column's new top elevation - For endpoints connected to target surface: project to surface - Apply rounding - New Start/End Offset = Original + rounded_delta 4. doc.Regenerate() if needed 5. Adjust remaining BEAMS (framing to other beams): - Use Revit's equivalent of \"shift-drag snap to beam location line\" - Project endpoint onto supporting beam's (now sloped) location line - Compute elevation at intersection point - Apply rounding 8.2 Rounding Logic public static class RoundingHelper { /// <summary> /// Rounds a delta value according to tolerance and mode. /// </summary> public static double ApplyRounding(double deltaFeet, double toleranceFeet, RoundingMode mode) { if (toleranceFeet <= 0) return deltaFeet; return mode switch { RoundingMode.Nearest => Math.Round(deltaFeet / toleranceFeet) * toleranceFeet, RoundingMode.Up => Math.Ceiling(deltaFeet / toleranceFeet) * toleranceFeet, RoundingMode.Down => Math.Floor(deltaFeet / toleranceFeet) * toleranceFeet, _ => deltaFeet }; } } 8.3 Beam-to-Beam Snap (API Equivalent) The manual workflow is: hold Shift, drag beam endpoint onto supporting beam's location line until it highlights, then release. Revit API Equivalent: /// <summary> /// Computes the elevation where a point intersects a sloped beam's location line. /// </summary> public static double ComputeElevationOnBeamLocationLine( Vector3 queryPoint, Vector3 beamStart, Vector3 beamEnd) { // 1. Project queryPoint onto the 3D line defined by beamStart→beamEnd var lineDir = (beamEnd - beamStart).Normalized(); var t = Vector3.Dot(queryPoint - beamStart, lineDir); var closestOnLine = beamStart + lineDir * t; // 2. Return Z coordinate of the closest point return closestOnLine.Z; } 9. 3D Preview System 9.1 Scene Components Component Color (Hex) Opacity Description Target surface #4080C0 0.3 Semi-transparent floor/roof mesh Column (pending) #00CC00 1.0 Will be adjusted (green) Column (no change) #808080 0.7 Already correct (gray) Column (error) #CC0000 1.0 Cannot compute (red) Beam (pending) #00CC00 1.0 Will be adjusted (green) Beam (no change) #808080 0.7 Already correct (gray) Beam (error) #CC0000 1.0 Cannot compute (red) 9.2 Profile Warming Reuse SGT's pattern for extracting 2D profile loops from structural framing: Create temp placement of each unique type Extract end face geometry Store as MemberProfileLoops Use for extrusion in preview 9.3 Scene Builder public sealed class ErftPreviewSceneBuilder { public PreviewScene3D Build( ErftPlan plan, IReadOnlyDictionary<int, MemberProfileLoops> profiles) { var meshes = new List<MeshData>(); // 1. Build target surface mesh BuildTargetMesh(plan.TargetGeometry, meshes); // 2. Build column meshes (show NEW position after adjustment) foreach (var col in plan.Columns) BuildColumnMesh(col, profiles, meshes); // 3. Build beam meshes (show NEW position after adjustment) foreach (var beam in plan.Beams) BuildBeamMesh(beam, profiles, meshes); return new PreviewScene3D { Meshes = meshes, ... }; } } 10. UI Components 10.1 Main Window Layout ┌─────────────────────────────────────────────────────────────────┐ │ Extreme Roof Framing Tool [X] │ ├─────────────────────────────────────────────────────────────────┤ │ ┌─────────────────────────────────────────────────────────────┐ │ │ │ │ │ │ │ 3D PREVIEW VIEWPORT │ │ │ │ (HelixToolkit) │ │ │ │ │ │ │ └─────────────────────────────────────────────────────────────┘ │ ├─────────────────────────────────────────────────────────────────┤ │ Target: [Floor 123 (Linked: Arch Model)] [Re-pick] │ ├─────────────────────────────────────────────────────────────────┤ │ Rounding Tolerance: [1/4\" ▼] [○ Nearest ● Up ○ Down] │ ├─────────────────────────────────────────────────────────────────┤ │ Summary: │ │ Columns: 12 pending, 2 no change │ │ Beams: 45 pending, 5 no change, 1 error │ ├─────────────────────────────────────────────────────────────────┤ │ [Cancel] [Apply] │ └─────────────────────────────────────────────────────────────────┘ 10.2 Tolerance Presets public static readonly TolerancePreset[] Presets = new[] { new TolerancePreset(\"1/16\\\"\", 1.0 / 192.0), // 0.0625\" new TolerancePreset(\"1/8\\\"\", 1.0 / 96.0), // 0.125\" new TolerancePreset(\"1/4\\\"\", 1.0 / 48.0), // 0.25\" (default) new TolerancePreset(\"1/2\\\"\", 1.0 / 24.0), // 0.5\" new TolerancePreset(\"1\\\"\", 1.0 / 12.0), // 1.0\" new TolerancePreset(\"Custom\", -1), // Triggers custom input }; 10.3 Re-pick Target Button Clicking \"Re-pick\" closes the window temporarily, returns to pick mode, then re-opens with new target and re-computed adjustments. 11. ExtensibleStorage Schema 11.1 Element Tagging Schema public static class ErftSchemaDefinition { public const string Name = \"DBTools_ERFT\"; public const string Vendor = \"DBTools\"; public static readonly Guid Id = new(\"B2C3D4E5-F6A7-4B8C-9D0E-1F2A3B4C5D6E\"); public const string FieldTag = \"Tag\"; // \"ERFT\" public const string FieldSystemId = \"SystemId\"; // GUID linking related elements public const string FieldRole = \"Role\"; // \"Column\" or \"Beam\" public const string FieldOriginalOffset = \"OriginalOffset\"; // Pre-adjustment value public const string FieldTimestamp = \"Timestamp\"; // ISO 8601 public const string FieldVersion = \"Version\"; // Schema version public const string SchemaVersion = \"1\"; } 11.2 System Repository Store full plan in DataStorage element for Edit mode restoration: public sealed class ErftSystemRepository { private const string SystemSchemaName = \"DBTools_ERFT_System\"; public void Save(Guid systemId, ErftStoredPlan plan, CancellationToken ct); public Result<ErftStoredPlan, string> Load(Guid systemId, CancellationToken ct); public void Delete(Guid systemId, CancellationToken ct); } 12. Contextual Ribbon Integration 12.1 Selection Changed Handler public sealed class ErftContextualRibbonInjector : IContextualRibbonInjector { public Task InitializeAsync(UIControlledApplication application, CancellationToken ct) { application.SelectionChanged += OnSelectionChanged; EnsureInjected(application); return Task.CompletedTask; } private void OnSelectionChanged(object? sender, SelectionChangedEventArgs e) { // Check if selection contains elements with ERFT ES data // Toggle Edit button visibility } } 12.2 Contextual Tab Detection Look for: \"Modify | Structural Columns\" \"Modify | Structural Framing\" \"Modify | Multi-Select\" (when mixed selection) Inject \"Edit ERFT\" button when ERFT-tagged elements are selected. 13. Error Handling 13.1 Spec Fail Tags All errors use traceable spec tags: Tag Description [SpecFail/Target/NoGeometry] Cannot extract mesh from target [SpecFail/Target/NotFloorOrRoof] Selected element is not Floor/Roof [SpecFail/Source/NoValidElements] No columns or valid beams selected [SpecFail/Source/NoColumnOrHierarchy] No columns and no beams frame to columns [SpecFail/Projection/NoIntersection] Point cannot project to target surface [SpecFail/Hierarchy/CycleDetected] Circular beam dependencies [SpecFail/Storage/SerializationError] JSON serialization failed [SpecFail/Apply/ParameterReadOnly] Offset parameter is read-only 13.2 ISafeExecutor Wrapping All entrypoints wrapped: public Result Execute(ExternalCommandData commandData, ...) { return _safeExecutor.Execute(() => { // Command implementation }); } 14. Test Strategy 14.1 Test Categories (per test-audit skill) Legitimate stubs (Revit API externals): Document, Element, FamilyInstance FilteredElementCollector Parameter get/set Transaction Pure logic tests (no stubs): ClosestPointServiceTests - geometry math FramingHierarchyBuilderTests - graph construction AdjustmentCalculatorTests - delta/rounding math ErftStorageMapperTests - JSON round-trip ErftPreviewSceneBuilderTests - mesh generation 14.2 Planned Test Cases // ClosestPointServiceTests.cs [Test] public void ProjectToSurface_SingleTriangle_ReturnsCorrectZ(); [Test] public void ProjectToSurface_PointAboveTriangle_ReturnsTrianglePlaneZ(); [Test] public void ProjectToSurface_PointOutsideTriangle_ReturnsEdgeProjection(); [Test] public void ProjectToSurface_MultipleFaces_ReturnsClosest(); // FramingHierarchyBuilderTests.cs [Test] public void BuildGraph_ColumnAndBeamTouchingTop_CreatesConnection(); [Test] public void BuildGraph_BeamToBeam_DetectsSecondaryFraming(); [Test] public void BuildGraph_HybridBeam_ClassifiesBothEndpoints(); [Test] public void BuildGraph_NoDependencies_ReturnsEmptyGraph(); // AdjustmentCalculatorTests.cs [Test] public void ApplyRounding_NearestQuarterInch_RoundsCorrectly(); [Test] public void ApplyRounding_UpMode_AlwaysRoundsUp(); [Test] public void ComputeElevationOnBeamLine_MidpointQuery_InterpolatesZ(); // ErftStorageMapperTests.cs [Test] public void SerializeDeserialize_RoundTrips(); [Test] public void Deserialize_MissingField_ReturnsFailure(); 15. Implementation Phases Phase 1: Foundation (Estimated: 2-3 days) Files to create: DBTools.ERFT.csproj - project file manifest.yml - tool manifest ErftToolModule.cs - registration ErftServiceExtensions.cs - bootstrap Common/Domain/*.cs - all domain models Common/Models/ErftSchemaDefinition.cs Shared/Contracts/*.cs - interfaces Icon: Assets/erft_icon.png Verification: Project builds, tool appears in ribbon (does nothing yet) Phase 2: Selection & Analysis (Estimated: 2-3 days) Files to create: Shell/Revit/ErftTargetSelectionFilter.cs Shell/Revit/ErftSourceSelectionFilter.cs Features/Commands/ErftNewCommand.cs Features/Commands/ErftMode.cs Features/Analysis/Revit/FloorRoofGeometryService.cs Features/Analysis/Revit/ColumnQueryService.cs Features/Analysis/Revit/BeamQueryService.cs Features/Analysis/Logic/TargetSurfaceAnalyzer.cs Verification: Can pick target and sources, extracts geometry Phase 3: Hierarchy & Calculation (Estimated: 2-3 days) Files to create: Features/Analysis/Logic/FramingHierarchyBuilder.cs Shared/Geometry/ClosestPointService.cs Features/Analysis/Logic/AdjustmentCalculator.cs Common/State/ErftPlanStore.cs Tests to create: Tests/ClosestPointServiceTests.cs Tests/FramingHierarchyBuilderTests.cs Tests/AdjustmentCalculatorTests.cs Verification: Computes correct deltas for sample scenarios Phase 4: UI & Preview (Estimated: 3-4 days) Files to create: Shell/UI/Views/ErftWindow.xaml Shell/UI/Views/ErftWindow.xaml.cs Shell/UI/ViewModels/ErftWindowViewModel.cs Features/Preview/Logic/ErftPreviewSceneBuilder.cs Features/Preview/UI/ErftPreview3DRenderer.cs Features/Commands/ErftRunner.cs Shell/Composition/ErftServiceCollectionExtensions.cs Verification: UI opens, 3D preview renders, tolerance controls work Phase 5: Apply & Persistence (Estimated: 2-3 days) Files to create: Features/Apply/Logic/ErftOrchestrator.cs Features/Apply/Revit/ErftDomainWriter.cs Features/Apply/Revit/ErftStorageMapper.cs Common/Revit/ErftSystemRepository.cs Common/Domain/ErftStoredPlan.cs Tests to create: Tests/ErftStorageMapperTests.cs Verification: Apply modifies elements, ES data persisted Phase 6: Edit Mode & Ribbon (Estimated: 1-2 days) Files to create: Features/Commands/ErftContextualRibbonInjector.cs Verification: Edit button appears, loads stored plan, re-applies Phase 7: Polish & Documentation (Estimated: 1 day) XML doc comments for all public members Edge case handling Final test coverage review Session log Total Estimated: 13-19 days Appendix A: Icon Recommendations The icon should convey \"structural framing + sloped surface\". Options: Steel beam with angled line - similar to existing structural icons Column with sloped roof outline - clearly shows the concept Grid pattern with slope indicator - abstract but clear For now, use a placeholder 32x32 PNG with similar styling to existing icons. Appendix B: XML Documentation Example /// <summary> /// Computes the vertical adjustment delta for a column based on closest-point projection /// to the target floor/roof surface. /// </summary> /// <param name=\"column\">The column item containing current position data.</param> /// <param name=\"surface\">The triangulated target surface geometry.</param> /// <param name=\"tolerance\">Rounding tolerance in feet.</param> /// <param name=\"mode\">Rounding direction (nearest, up, or down).</param> /// <returns> /// A <see cref=\"Result{T,E}\"/> containing the computed adjustment or an error message /// if projection fails. /// </returns> /// <exception cref=\"ArgumentNullException\"> /// Thrown when <paramref name=\"column\"/> or <paramref name=\"surface\"/> is null. /// </exception> /// <remarks> /// The algorithm projects the column's current top point vertically to find the closest /// point on the target surface's bottom face. The delta is then rounded according to /// the specified tolerance and mode. /// </remarks> public Result<ColumnAdjustment, string> ComputeColumnAdjustment( ErftColumnItem column, TargetSurfaceGeometry surface, double tolerance, RoundingMode mode) Appendix C: Key Decisions Summary Decision Choice Rationale Target source Host + Linked Maximum flexibility for coordination workflows Source scope Host only Can only modify elements in editable document Slope handling Closest point projection Handles complex geometry (hip roofs, warped slabs) Beam-to-column tracking Auto-track Reduces manual work after column adjustments Beam-to-beam connection Location line snap Matches Revit's native shift-drag behavior Hybrid beams (col+beam) Independent endpoints Natural handling in hierarchy algorithm Undo strategy Revit native Transaction group provides atomic undo Rounding UI Presets + custom Balance of convenience and flexibility Preview style Semi-transparent mesh Clear spatial context with status colors Relationship detection Auto-detect Reduces user configuration burden Multi-level Allowed Offset-only adjustments work across levels Edit mode Full re-target Maximum flexibility for iterative workflows Column adjustment Offset only Preserves level associations Modification report Silent apply Reduces friction; Revit audit available"
  },
  "developer-guide/tools/testing/erft.html": {
    "href": "developer-guide/tools/testing/erft.html",
    "title": "Extreme Roof Framing Tool (ERFT) | DB Tools",
    "summary": "Extreme Roof Framing Tool (ERFT) ERFT is a Testing-category tool that adjusts structural columns and beams to match the slope of a selected floor/roof target. It supports selecting targets from the host model or a linked model, computes vertical deltas via closest-point projection, and applies parameter offsets with user-configurable rounding. See also: Technical Specification (Internal) Source Location Tool code: csharp/src/Tools/Testing/ERFT/ Manifest: csharp/src/Tools/Testing/ERFT/manifest.yml Key Concepts Target surface mesh extraction (floor/roof) Framing hierarchy (beam-to-column / beam-to-beam dependencies) Adjustment calculation + rounding tolerance Apply workflow (write offsets + persist plan snapshot)"
  },
  "developer-guide/tools/testing/recordset-spec.html": {
    "href": "developer-guide/tools/testing/recordset-spec.html",
    "title": "Record Set Tool - Complete Technical Specification | DB Tools",
    "summary": "Record Set Tool - Complete Technical Specification Overview The Record Set tool is a comprehensive multi-file copy and repath system designed for managing Revit project packages. It enables users to collect a set of Revit host models along with their linked files (RVT, DWG, and other external references), copy them to a new target folder structure organized by discipline and building, and automatically update all internal link references to point to the new file locations. Legacy Python Location (pre-C# port): ./DB Tools/DB Tools.extension/DB Tools.tab/DB Tools Testing.panel/Record Set.pushbutton/ Table of Contents Core Concepts Data Models Complete File Lifecycle UI Components Operations Layer Services Layer CAD Xref Handling Safety System Error Handling Configuration LISP Scripts Functional Requirements Non-Functional Requirements UI Control Reference Interaction Scenarios 1. Core Concepts 1.1 Purpose Record Set solves the problem of creating portable, self-contained Revit project packages. When Revit models reference external files (linked RVTs, DWGs), those references use absolute paths. Moving files breaks these references. Record Set: Collects all host files and their dependencies Copies everything to a structured target folder Remaps all internal references to use the new locations Handles CAD files with special Xref processing (discovery, binding, or relative pathing) 1.2 Workflow Stages ┌─────────────────┐ ┌─────────────────┐ ┌─────────────────┐ │ 1. SELECT │───>│ 2. PREVIEW │───>│ 3. EXECUTE │ │ - Host RVTs │ │ - Build plan │ │ - Copy files │ │ - Target dir │ │ - Show tree │ │ - Repath refs │ │ - CAD modes │ │ - Validate │ │ - CAD process │ └─────────────────┘ └─────────────────┘ └─────────────────┘ 1.3 Preview-Execute Pattern All operations are planned before execution: Preview phase: Analyze files, discover links, compute new paths, validate constraints Execute phase: Execute the plan atomically with progress tracking and cancellation support 2. Data Models 2.1 RecordSetFile Represents a single file (host RVT or linked file) in the record set. RecordSetFile ├── name: string # Filename (e.g., \"Model.rvt\") ├── path: string # Absolute path to source file ├── discipline: string # Category (e.g., \"Structural\", \"MEP\") - empty string allowed ├── building: string # Building name (e.g., \"Building A\") - \"-\" for none ├── link_id: object|null # Revit ElementId of link (for linked files) ├── link_type: LinkType # RVT | DWG | OTHER ├── is_common: bool # True if shared across multiple hosts ├── new_path: string|null # Computed destination path (set during preview) ├── cad_mode: CadHandlingMode # INHERIT | ADD_XREFS | BIND_ALL ├── bind_type: BindType # BIND (0) | INSERT (1) └── children_manual: List<RecordSetFile> # Manually added Xrefs (DWG only) 2.2 LinkType Enumeration LinkType ├── RVT = \"rvt\" # Revit model link ├── DWG = \"dwg\" # AutoCAD drawing link └── OTHER = \"other\" # Any other external file (IFC, DGN, etc.) 2.3 CadHandlingMode Enumeration Controls how DWG files are processed: CadHandlingMode ├── INHERIT = \"inherit\" # Use parent/global setting ├── ADD_XREFS = \"add_xrefs\" # Discover and copy Xrefs, update paths └── BIND_ALL = \"bind_all\" # Bind all Xrefs into the DWG 2.4 BindType Enumeration When binding Xrefs: BindType ├── BIND = 0 # Prefix layer/block names with Xref name (preserves uniqueness) └── INSERT = 1 # Merge without prefix (may cause name conflicts) 2.5 CadRef Represents an AutoCAD Xref with hierarchical structure: CadRef ├── host_path: string # Path to host DWG containing this Xref ├── xref_path: string # Path to the Xref file ├── xref_name: string # Block name of the Xref ├── overlay: bool # True if overlay attachment (vs. attachment) └── children: List<CadRef> # Nested Xrefs within this Xref 2.6 PlanItem Single action in the execution plan: PlanItem ├── action: string # Action type (see Action Types below) └── payload: Dict<string,any> # Parameters for the action Action Payload Keys Description fs_create_dir path Create directory fs_copy src, dst Copy file or directory cad_copy src, dst Copy CAD file cad_repath host, new_root Repath Xrefs to relative paths cad_bind_all host, bindtype Bind all Xrefs into DWG revit_repath host, mapping Update Revit TransmissionData ui_warn msg Display warning message ui_info msg Display info message 2.7 RecordSetPlan Complete execution blueprint: RecordSetPlan ├── items: List<PlanItem> # Ordered list of actions ├── total_bytes: int # Total size of files to copy └── summary: Dict # Statistics (counts, sizes, etc.) 2.8 Context Execution context container: Context ├── target_folder: string # Destination root path ├── selected_hosts: List<RecordSetFile> # Selected host RVT files ├── ui_flags: Dict # UI configuration flags │ ├── auto_discover_cad_xrefs: bool (default: True) │ └── allow_cad_repath: bool (default: True) ├── all_links: List<RecordSetFile> # All discovered links (built during preview) ├── common_links: Set<Tuple> # Set of (name, link_type) for shared links ├── preview_copy_bytes: int # Estimated copy size └── preview_predicted_output_bytes: int # Estimated output size 2.9 Config (Constants) Global configuration constants: Config ├── COMMON_LINKS_FOLDER = \"Common Linked Files\" ├── MAX_TOTAL_BYTES = 80 GB # Size limit ├── MAX_TOTAL_ITEMS = 10,000 # Item count limit ├── AUTO_DISCOVER_CAD_XREFS = True # Default flag ├── ALLOW_CAD_REPATH = True # Default flag ├── CAD_FALLBACK_DEPTH = 1 # Fallback scan depth ├── CAD_SIBLING_DIRNAMES = (\"xrefs\", \"xref\", \"refs\", \"ref\", \"external\", \"dwg\", \"cad\") └── ACCORECONSOLE_HINTS = List of paths to search for AutoCAD Core Console 2.10 SafetyPolicy Runtime safety constraints (loaded from JSON): SafetyPolicy ├── allowed_target_roots: List<string> # Whitelisted target directories ├── delete_mode: string # \"quarantine\" or \"delete\" ├── require_sentinel_for_delete: bool # Require sentinel file ├── verify_after_copy: bool # Checksum verification ├── min_free_bytes: int # Minimum free space (default: 10 GB) ├── allowed_extensions: List<string>|null # Whitelist extensions ├── denied_extensions: List<string>|null # Blacklist extensions ├── deny_globs: List<string> # Glob patterns to deny └── paths: Dict └── enable_long_paths: bool # Windows long path support 2.11 SafetyRuntime Per-execution metadata: SafetyRuntime ├── target_root: string # Target folder path ├── run_id: string # Format: YYYYMMDD-HHMMSS-XXXX (XXXX = random hex) ├── fingerprint: string # SHA256[:16] of plan ├── lock_path: string # {target}/.recordset.lock ├── sentinel: string # {target}/.recordset_sentinel ├── trash_root: string # {target}/_RS_TRASH/{run_id} ├── manifest_dir: string # {target}/_recordset_manifests └── manifest_path: string # {manifest_dir}/{run_id}.json 2.12 CancelToken User cancellation signal: CancelToken ├── _cancelled: bool = False ├── cancel() -> void # Sets _cancelled = True └── is_cancelled() -> bool # Returns _cancelled 3. Complete File Lifecycle 3.1 Phase 1: Initialization 1. User clicks \"Record Set\" button on ribbon └──> pyRevit executes Record Set_script.py └──> Imports and calls _rs_entry.run() 2. run() function: └──> Calls _prechecks() - validation stub returning True └──> Creates _MainCtl instance └──> Loads RecordSetForm.xaml via DBToolsWindow base class └──> Initializes empty state: - services = Services(app=None) - ctx = None - plan = None - selected_hosts = [] - target_folder = None - ui_flags = {auto_discover_cad_xrefs: True, allow_cad_repath: True} └──> Calls ShowDialog() (modal) 3.2 Phase 2: Host File Selection 1. User clicks \"Add Host...\" button └──> add_file() handler 2. add_file(): └──> _pick_rvt() opens Windows file picker for .rvt files └──> Creates RecordSetFile: - name = filename - path = os.path.normcase(os.path.abspath(selected_path)) - discipline = \"\" - building = \"-\" - link_type = LinkType.RVT └──> Calls services.scan_links_for_host(host) └──> RevitOps.read_external_refs(host.path) └──> Opens TransmissionData from RVT file └──> Iterates ExternalFileReferences └──> For each ref: - Extracts absolute path - Determines link_type (rvt/dwg/other) from extension or type - Creates RecordSetFile for link └──> Returns list of RecordSetFile links └──> Stores links in host.links_to_keep └──> Appends host to selected_hosts[] └──> Logs action └──> Does NOT auto-sync (user must click \"Sync Preview\") 3.3 Phase 3: Target Folder Selection 1. User clicks \"Target Folder...\" button └──> choose_target_folder() handler 2. choose_target_folder(): └──> Opens folder picker dialog └──> Normalizes path: os.path.normcase(os.path.abspath(...)) └──> Updates target_folder attribute └──> Updates target_tb.Text display 3.4 Phase 4: Preview/Plan Generation 1. User clicks \"Sync Preview\" button └──> sync_tree() handler 2. sync_tree(): └──> VALIDATION: - If target_folder is None: show error, return └──> READ UI FLAGS: - auto_discover = auto_cad_xref_cb.IsChecked - ui_flags[\"auto_discover_cad_xrefs\"] = auto_discover └──> BUILD CONTEXT: └──> services.build_context(target_folder, selected_hosts, ui_flags) └──> Creates Context object └──> Calls _mark_common_links(): - Counts (name, link_type) pairs across all hosts - For links appearing in 2+ hosts: - Sets link.is_common = True - Adds to ctx.common_links set └──> Returns ctx └──> GENERATE PLAN: └──> services.preview_plan(ctx) └──> Creates RecordSetPlan() └──> FOR EACH HOST: - new_path = compute_host_target_path(target_root, host) Formula: {target}/{building}/{discipline}/{name} Or if building == \"-\": {target}/{discipline}/{name} - Add: fs_create_dir(dirname(new_path)) - Add: fs_copy(src=host.path, dst=new_path) └──> FOR EACH LINK IN HOST: - new_path = compute_link_target_path(target_root, link, is_common) If is_common: {target}/Common Linked Files/{name} Else if building == \"-\": {target}/{discipline}/Linked Files/{name} Else: {target}/{building}/{discipline}/Linked Files/{name} - Add: fs_create_dir(dirname(new_path)) - If NOT DWG: Add: fs_copy(src, dst) - If DWG: Defer to CAD planning └──> CAD PLANNING (for each host): └──> _build_cad_plan_for_host(ctx, plan, host) └──> Find accore = CadXrefOps.find_core_console() └──> FOR EACH DWG LINK: - Add: fs_create_dir(dirname(new_path)) - Add: cad_copy(src, dst) └──> IF cad_mode == BIND_ALL: - Add: cad_bind_all(host=new_path, bindtype=link.bind_type) - CONTINUE (skip Xref discovery) └──> IF auto_discover AND accore exists: TRY: - tree = CadXrefOps.scan_xref_tree(accore, dwg, lsp_dir) - copy_pairs = CadXrefOps.expand_tree_to_plan(tree) - For each Xref path (skip host itself): - Add: fs_create_dir + cad_copy - If allow_cad_repath: - Add: cad_repath(host=new_path, new_root=target_root) EXCEPT: - Add: ui_warn(error message) - Fallback to _fallback_cad_copy() └──> ELSE (no accore): - Add: ui_info(\"AutoCAD Core Console not found\") - Fallback to _fallback_cad_copy() └──> _fallback_cad_copy(plan, dwg): - Heuristic: copy sibling directories named \"xrefs\", \"xref\", etc. - For each CAD_SIBLING_DIRNAME: - If exists: Add fs_create_dir + fs_copy for directory └──> REVIT REPATH (for each host): - Build mapping: {old_link_path: new_link_path} for all links - Add: revit_repath(host=new_host_path, mapping=mapping) └──> CALCULATE SIZES: - total_bytes = sum of all source file sizes - predicted_output = total_bytes + bind expansion estimates └──> VALIDATION: - If total_bytes > MAX_TOTAL_BYTES: Add ui_warn - If item_count > MAX_TOTAL_ITEMS: Add ui_warn └──> _prevent_name_collisions(plan): - Track all destination paths - If collision (same dst, different src): - Rename to: name (2).ext, name (3).ext, etc. - Add: ui_warn(\"Renamed due to collision\") └──> Return (plan, messages) └──> DISPLAY PLAN: └──> Show messages in plan_msgs_ic ItemsControl └──> Show AutoCAD Core Console status in accore_tb TextBlock └──> _render_tree(): - Clear links_tv TreeView - For each host: - Create TreeViewItem \"Host: {name}\" - For each link: - Create child TreeViewItem \"{link_type}: {name}\" - If DWG with manual children: - Create grandchild TreeViewItems - Set Tag property on each item for object reference └──> COMPUTE FINGERPRINT: └──> _fingerprint(plan): - Concatenate: action + sorted(payload.items()) - SHA256[:16] of concatenation └──> Store in plan_fingerprint 3.5 Phase 5: CAD Mode Configuration (Optional) 1. User selects DWG node in TreeView └──> UI enables CAD handling panel 2. User clicks \"Keep/Add Xrefs\" radio button: └──> checked_addxrefs(): - node = _selected_cad_node() - services.set_cad_mode(ctx, node, CadHandlingMode.ADD_XREFS) - _set_cad_panel_enabled(addxrefs=True, bindall=False) - sync_tree() // Re-plan 3. User clicks \"Bind all Xrefs\" radio button: └──> checked_bindall(): - node = _selected_cad_node() - services.set_cad_mode(ctx, node, CadHandlingMode.BIND_ALL) - Clear node.children_manual[] - _set_cad_panel_enabled(addxrefs=False, bindall=True) - sync_tree() // Re-plan 4. User selects BindType (BIND vs INSERT): └──> bindtype_changed(): - services.set_cad_mode(..., bindtype=selected_value) 5. User clicks \"Add CAD Xref...\" button: └──> add_cad_xref(): - parent = _selected_cad_node() - _pick_dwg() opens file picker - services.add_manual_cad_xref(ctx, parent, dwg_path) - sync_tree() // Re-plan 3.6 Phase 6: Execution 1. User clicks \"Process\" button └──> process_files() handler 2. process_files(): └──> VALIDATION: - If plan is None: show error, return └──> CREATE PROGRESS UI: - cancel_token = CancelToken() - progress_ctl = _ProgressCtl() - progress_ctl.cancel_token = cancel_token - progress_ctl.show() // Non-modal - Define log_cb = lambda msg: progress_ctl.log(msg) - Define progress_cb = lambda pct: progress_ctl.set_progress(pct) └──> EXECUTE: └──> services.execute(ctx, plan, progress_cb, log_cb, cancel_token) └──> SETUP: - Create Progress tracker with action weights - policy = _load_policy(target_root, log_cb) - Load recordset_policy.json - Return SafetyPolicy object - run_id = _make_run_id() // YYYYMMDD-HHMMSS-XXXX - fingerprint = _fingerprint_plan(plan) - rt = SafetyRuntime(target_root, run_id, fingerprint) └──> VALIDATE: - If target_root not in policy.allowed_target_roots: - Raise Exception(\"Target not in allowed roots\") - If free_space < policy.min_free_bytes + plan.total_bytes: - Raise Exception(\"Insufficient disk space\") └──> ACQUIRE LOCK: └──> SafeFsOps.acquire_lock(rt, log_cb): - Create rt.lock_path file with content: run_id + fingerprint - If file already exists: Raise Exception(\"Concurrent execution\") └──> WRITE SENTINEL: - SafeFsOps.write_sentinel(rt, log_cb) - Touch file at rt.sentinel └──> TRY: └──> FOR EACH PLAN ITEM: - Check cancel_token.is_cancelled(): break if True └──> DISPATCH BY ACTION: fs_create_dir: FsOps.make_dir(payload[\"path\"]) fs_copy: FsOps.copy_file(payload[\"src\"], payload[\"dst\"], log_cb) - If src is directory: recursive copy via os.walk() - If src is file: shutil.copy2() (preserves metadata) cad_copy: FsOps.copy_file(payload[\"src\"], payload[\"dst\"], log_cb) cad_repath: accore = CadXrefOps.find_core_console() CadXrefOps.repath_xrefs_relative( accore, payload[\"host\"], lsp_dir, payload[\"new_root\"]) - Runs rs_repath_xrefs.lsp via accoreconsole - Converts Xref paths to relative under new_root cad_bind_all: accore = CadXrefOps.find_core_console() CadXrefOps.bind_all( accore, payload[\"host\"], lsp_dir, payload[\"bindtype\"]) - Runs rs_bind_all_xrefs.lsp via accoreconsole - Binds all Xrefs with specified BindType - Purges unused 3x - Quick-saves revit_repath: RevitOps.write_transmission( payload[\"host\"], payload[\"mapping\"]) - Read TransmissionData from RVT - For each external reference: - old_path = ext_ref.GetPath() or GetAbsolutePath() - new_path = mapping.get(normalize(old_path)) - If found: ext_ref.SetDesiredReferenceData(new_path) - Write TransmissionData back if changed ui_warn: log_cb(\"[WARNING] \" + payload[\"msg\"]) ui_info: log_cb(\"[INFO] \" + payload[\"msg\"]) - progress.step(action_weight) └──> WRITE MANIFEST (success): - SafeFsOps.write_manifest(rt, plan.summary, \"ok\", log_cb) - JSON at rt.manifest_path: { \"run_id\": \"...\", \"fingerprint\": \"...\", \"target_root\": \"...\", \"utc\": \"2025-01-13T...\", \"summary\": plan.summary, \"status\": \"ok\" } └──> EXCEPT Exception as e: - SafeFsOps.write_manifest(rt, plan.summary, f\"failed:{e}\", log_cb) - Re-raise exception └──> FINALLY: - SafeFsOps.release_lock(rt, log_cb) - Delete rt.lock_path file └──> COMPLETION: - progress_ctl.enable_close() - User can now close progress window 3.7 Phase 7: Completion 1. Execution completes (success or failure) └──> Progress window remains open with logs 2. User interactions: └──> \"Copy logs\" button: Copies step_tb.Text to clipboard └──> \"Close\" button: Closes window (only enabled after completion) 3. Output folder structure: {target_folder}/ ├── {Building}/ │ └── {Discipline}/ │ ├── Host.rvt │ └── Linked Files/ │ ├── Link1.rvt │ └── Link2.dwg ├── Common Linked Files/ │ ├── SharedLink1.rvt │ └── SharedLink2.dwg ├── _recordset_manifests/ │ └── {run_id}.json └── .recordset_sentinel 4. UI Components 4.1 Main Window (RecordSetForm.xaml) Window Properties: Title: \"Record Set\" Size: 1100 x 720 pixels Resizable, centered on screen Modal display via ShowDialog() Not shown in taskbar Layout Structure: ┌────────────────────────────────────────────────────────────────────┐ │ [Wizard Bar: 1-Select | 2-Preview | 3-Execute] │ ├────────────────────────────────────────────────────────────────────┤ │ [Policy Status: Allowed Root | Free Space | AutoCAD | Sentinel] │ ├──────────────────────────────────────────┬─────────────────────────┤ │ [Control Bar] │ [Target Folder: ____] │ │ [Manage Disciplines] [Manage Buildings] │ [Sync Preview] [Process]│ │ [Add Host] [Remove Selected] │ │ │ [x] Auto-discover nested CAD Xrefs │ │ ├──────────────────────────────────────────┴─────────────────────────┤ │ [Plan Messages: ItemsControl with warnings/info] │ ├────────────────────────────────┬───────────────────────────────────┤ │ [Files DataGrid] │ [CAD Panel] │ │ ┌─────────────────────────┐ │ ┌─────────────────────────────┐ │ │ │ Host File | Disc | Bldg │ │ │ ( ) Keep/Add Xrefs │ │ │ ├─────────────────────────┤ │ │ ( ) Bind all Xrefs │ │ │ │ Model.rvt | STR | Bld1 │ │ │ [BindType: v] [Add Xref...] │ │ │ │ MEP.rvt | MEP | Bld1 │ │ └─────────────────────────────┘ │ │ └─────────────────────────┘ │ [Links TreeView] │ │ │ ├── Host: Model.rvt │ │ │ │ ├── rvt: Linked.rvt │ │ │ │ └── dwg: CAD.dwg │ │ │ │ └── dwg: Xref1.dwg │ │ │ └── Host: MEP.rvt │ │ │ └── ... │ └────────────────────────────────┴───────────────────────────────────┘ 4.2 Manage Dialog (RecordSetFormManage.xaml) Window Properties: Title: \"Record Set - Manage\" Size: 520 x 420 pixels Resizable with grip Modal display Layout: ┌────────────────────────────────────────┐ │ [Add...] [Rename] [Delete] │ │ Double-click item to rename │ ├────────────────────────────────────────┤ │ [ListBox: items] │ │ ┌──────────────────────────────────┐ │ │ │ Structural │ │ │ │ MEP │ │ │ │ Architectural │ │ │ └──────────────────────────────────┘ │ ├────────────────────────────────────────┤ │ [Close] │ └────────────────────────────────────────┘ Functionality: Add: Prompts for name, appends to list Rename: Prompts for new name, updates in-place Delete: Removes selected item 4.3 Progress Window (RecordSetFormProgress.xaml) Window Properties: Title: \"Record Set - Progress\" Size: 820 x 520 pixels Resizable with grip Non-modal display initially Close prevented until execution completes Layout: ┌────────────────────────────────────────────────────────────────────┐ │ [████████████████████░░░░░░░░░░░░░░░░░░░] 65% │ ├────────────────────────────────────────────────────────────────────┤ │ [Scrollable Log TextBox] │ │ ┌──────────────────────────────────────────────────────────────┐ │ │ │ Creating directory: C:\\Output\\Structural │ │ │ │ Copying: Model.rvt -> C:\\Output\\Structural\\Model.rvt │ │ │ │ Copying: Link.rvt -> C:\\Output\\Structural\\Linked Files\\... │ │ │ │ Processing CAD Xrefs for CAD.dwg... │ │ │ │ Updating link references in Model.rvt... │ │ │ └──────────────────────────────────────────────────────────────┘ │ ├────────────────────────────────────────────────────────────────────┤ │ [Recap Panel - collapsed until complete] │ │ Copy size: 2.5 GB | Output size: 2.8 GB | Duration: 3m 42s │ │ Manifest: C:\\Output\\_recordset_manifests\\20250113-154200-a1b2.json│ ├────────────────────────────────────────────────────────────────────┤ │ [Copy logs] [Cancel] [Close] │ └────────────────────────────────────────────────────────────────────┘ Functionality: Progress bar: 0-100 with percentage text Log area: Scrolling TextBox with auto-scroll Copy logs: Copies log text to clipboard Cancel: Signals cancel_token.cancel() Close: Disabled until execution completes 5. Operations Layer 5.1 FsOps (Filesystem Operations) Basic filesystem operations without safety validation: Method Parameters Behavior make_dir path, log Creates directory if not exists (os.makedirs) copy_file src, dst, log If directory: recursive copy via os.walk(). If file: shutil.copy2() remove_path path, log Removes file or directory tree (shutil.rmtree) calc_size_bytes path Recursively sums file sizes 5.2 SafeFsOps (Safety-Enhanced Operations) Hardened operations with policy enforcement: Method Parameters Behavior _is_under root, path Returns True if path is under root acquire_lock rt, log Creates exclusive lock file with run_id/fingerprint release_lock rt, log Removes lock file write_sentinel rt, log Touches sentinel file make_dir rt, pol, path, log Delegates to FsOps.make_dir() copy_file rt, pol, src, dst, log Delegates to FsOps.copy_file() write_manifest rt, summary, status, log Writes JSON manifest file 5.3 RevitOps (Revit Document Operations) Revit API operations for document manipulation: Method Parameters Behavior open_doc app, path, workshared, detach_preserve Opens RVT with OpenAllWorksets, DetachFromCentral close_doc doc, save, new_path Closes document, optionally saves to new path purge_unused doc Stub (not implemented) delete_views doc, view_ids Transaction: deletes specified views delete_links doc, link_ids Transaction: deletes specified links read_external_refs rvt_path Reads TransmissionData, returns list of (abs_path, kind) write_transmission rvt_path, mapping Updates link paths in TransmissionData 5.4 CadXrefOps (AutoCAD Core Console Operations) CAD operations via AutoCAD Core Console: Method Parameters Behavior find_core_console - Searches for accoreconsole.exe scan_xref_tree accore, host_dwg, lsp_dir Returns JSON tree of Xrefs repath_xrefs_relative accore, host, lsp_dir, new_root Converts Xref paths to relative bind_all accore, host, lsp_dir, bindtype Binds all Xrefs with purge expand_tree_to_plan tree_json, copy_pairs Extracts all unique paths from tree 6. Services Layer 6.1 Context Management Method Parameters Behavior build_context target_folder, selected_hosts, ui_flags Creates Context, marks common links set_cad_mode ctx, parent_dwg, mode, bindtype Sets CAD handling mode for DWG add_manual_cad_xref ctx, parent_link, dwg_path Adds manual Xref to DWG 6.2 Link Discovery Method Parameters Behavior scan_links_for_host host Reads TransmissionData, creates RecordSetFile for each link _mark_common_links ctx Identifies links shared across multiple hosts 6.3 Plan Generation Method Parameters Behavior preview_plan ctx Generates complete execution plan with validation _build_cad_plan_for_host ctx, plan, host Generates CAD-specific plan items _fallback_cad_copy plan, dwg Heuristic copy of sibling CAD directories _prevent_name_collisions plan Renames duplicate destinations 6.4 Execution Method Parameters Behavior execute ctx, plan, progress_cb, log_cb, cancel_token Executes plan with progress tracking 7. CAD Xref Handling 7.1 CAD Handling Modes INHERIT: Uses parent/global setting Default mode for newly discovered DWGs ADD_XREFS (Keep/Add Xrefs): Discover Xref tree via AutoCAD Core Console (rs_list_xrefs.lsp) Copy host DWG and all discovered Xrefs to target Repath Xrefs to use relative paths (rs_repath_xrefs.lsp) Allow manual addition of extra Xrefs BIND_ALL: Copy host DWG to target Bind all Xrefs into the DWG (rs_bind_all_xrefs.lsp) Purge unused content (3x) Result: Self-contained DWG with no external dependencies 7.2 BindType Options BIND (0): Prefixes layer/block names with Xref name Example: \"0\" layer becomes \"XrefName$0$0\" Preserves uniqueness, avoids conflicts INSERT (1): Merges layers/blocks without prefix Example: \"0\" layer merges with existing \"0\" May cause naming conflicts, but cleaner result 7.3 Fallback Behavior When AutoCAD Core Console is not available: Log info message about missing accore Heuristically copy sibling directories with known CAD names: xrefs, xref, refs, ref, external, dwg, cad No path repathing (Xrefs may still break) 8. Safety System 8.1 Lock File Mechanism Prevents concurrent execution: File: {target}/.recordset.lock Content: {run_id}\\n{fingerprint} Created at execution start Deleted at execution end (finally block) If exists when starting: throw exception 8.2 Sentinel File Marks target as managed by Record Set: File: {target}/.recordset_sentinel Content: (empty - just touched) Created/touched at execution start Required before any delete operations (configurable) Never deleted 8.3 Manifest Files Execution audit trail: File: {target}/_recordset_manifests/{run_id}.json Content: { \"run_id\": \"20250113-154200-a1b2\", \"fingerprint\": \"abc123def456...\", \"target_root\": \"C:\\\\Output\", \"utc\": \"2025-01-13T15:42:00Z\", \"summary\": { ... }, \"status\": \"ok\" | \"failed:...\" } 8.4 Safety Policy Configurable constraints in recordset_policy.json: allowed_target_roots: Whitelist of valid target directories min_free_bytes: Minimum free disk space (default: 10 GB) denied_extensions: File types to skip (.dwl, .dwl2, .tmp, .bak, .lnk, .exe) deny_globs: Patterns to skip (backup.rvt, .old, ~$) 9. Error Handling 9.1 Error Scenarios Scenario Handling No target folder selected UI error message, abort preview Target not in allowed roots Exception during execute Insufficient disk space Exception during execute Lock file exists Exception during execute File copy fails Exception propagates, manifest written with failure status CAD Core Console not found Fallback to heuristic copy, continue CAD script fails Warning logged, continue with partial plan TransmissionData read fails Empty link list returned, continue User cancels Break execution loop, release lock, exit 9.2 Recovery Lock file: Manually delete .recordset.lock if stale Failed execution: Check manifest for failure status and details Partial copy: Target folder may contain incomplete files; re-run after cleanup 10. Configuration 10.1 recordset_policy.json Default location: Same directory as script { \"allowed_target_roots\": [ \"\\\\\\\\fileserver\\\\Projects\" ], \"delete_mode\": \"quarantine\", \"require_sentinel_for_delete\": true, \"verify_after_copy\": false, \"min_free_bytes\": 10737418240, \"denied_extensions\": [\".dwl\", \".dwl2\", \".tmp\", \".bak\", \".lnk\", \".exe\"], \"deny_globs\": [\"*backup*.rvt\", \"*.old\", \"~$*\"], \"paths\": { \"enable_long_paths\": false } } 10.2 Config Constants Hardcoded in _rs_models.py: Constant Value Description COMMON_LINKS_FOLDER \"Common Linked Files\" Folder name for shared links MAX_TOTAL_BYTES 80 GB Maximum total copy size MAX_TOTAL_ITEMS 10,000 Maximum item count CAD_SIBLING_DIRNAMES (\"xrefs\", \"xref\", ...) Fallback CAD directory names ACCORECONSOLE_HINTS [...paths...] AutoCAD Core Console search paths 11. LISP Scripts 11.1 rs_list_xrefs.lsp Purpose: Discover Xref tree for a DWG Input: Drawing path (via accoreconsole /i flag) Output: JSON structure: { \"host\": \"path/to/drawing.dwg\", \"xrefs\": [ { \"name\": \"xref_name\", \"path\": \"path/to/xref.dwg\", \"overlay\": false, \"children\": [...] } ] } Algorithm: Open drawing (context from accoreconsole) Iterate Blocks collection For each Xref block: Extract name and path Recursively open child and scan Build nested structure Output JSON to stdout 11.2 rs_repath_xrefs.lsp Purpose: Convert Xref paths to relative Input: \"host.dwg|target_root\" (pipe-separated) Output: {\"ok\":true} Algorithm: Parse argument For each Xref: If path starts with target_root: strip root, make relative Save drawing 11.3 rs_bind_all_xrefs.lsp Purpose: Bind all Xrefs into DWG Input: \"BIND|host.dwg\" or \"INSERT|host.dwg\" Output: {\"ok\":true} Algorithm: Parse mode (BIND=0, INSERT=1) Set BINDTYPE variable Execute: -xref bind * Execute: -purge a * n (3x) Execute: _.qsave 12. Functional Requirements 12.1 Host File Management ID Requirement FR-1.1 Add host RVT files via file picker FR-1.2 Remove selected host files FR-1.3 Automatically scan host for linked files FR-1.4 Assign discipline to host files FR-1.5 Assign building to host files FR-1.6 Display host files in editable DataGrid 12.2 Target Folder Management ID Requirement FR-2.1 Select target folder via folder picker FR-2.2 Display selected target folder path FR-2.3 Validate target folder against allowed roots 12.3 Preview System ID Requirement FR-3.1 Generate execution plan on demand FR-3.2 Display file hierarchy in TreeView FR-3.3 Show validation warnings/info messages FR-3.4 Detect and report name collisions FR-3.5 Calculate and display total copy size FR-3.6 Compute plan fingerprint for verification 12.4 CAD Handling ID Requirement FR-4.1 Support ADD_XREFS mode (discover + copy + repath) FR-4.2 Support BIND_ALL mode (bind into single DWG) FR-4.3 Support BIND vs INSERT bind types FR-4.4 Allow manual Xref addition for DWGs FR-4.5 Auto-discover nested Xrefs via AutoCAD Core Console FR-4.6 Fallback to heuristic copy when accore unavailable 12.5 Execution ID Requirement FR-5.1 Copy all files to target folder FR-5.2 Create organized folder structure FR-5.3 Update Revit TransmissionData for all hosts FR-5.4 Process CAD files according to mode FR-5.5 Display real-time progress FR-5.6 Support user cancellation FR-5.7 Generate execution manifest 12.6 Safety ID Requirement FR-6.1 Enforce allowed target roots FR-6.2 Check minimum free disk space FR-6.3 Prevent concurrent execution via lock file FR-6.4 Create sentinel file for managed folders FR-6.5 Filter denied file extensions FR-6.6 Filter denied glob patterns 13. Non-Functional Requirements 13.1 Performance ID Requirement NFR-1.1 Handle projects up to 80 GB total size NFR-1.2 Support up to 10,000 items in plan NFR-1.3 Provide responsive UI during execution NFR-1.4 Weighted progress tracking for accurate estimates 13.2 Reliability ID Requirement NFR-2.1 Atomic execution with lock file NFR-2.2 Manifest generation for audit trail NFR-2.3 Graceful handling of missing AutoCAD NFR-2.4 Error recovery via manifest status 13.3 Usability ID Requirement NFR-3.1 Three-step wizard workflow NFR-3.2 Real-time log display NFR-3.3 Copy logs to clipboard NFR-3.4 Clear validation messages 13.4 Security ID Requirement NFR-4.1 Policy-based target root restriction NFR-4.2 Extension and glob filtering NFR-4.3 Sentinel requirement for destructive operations 14. UI Control Reference 14.1 Main Window Controls Control Name Type Binding/Handler Purpose target_tb TextBox Read-only display Shows selected target folder auto_cad_xref_cb CheckBox ui_flags Toggle auto CAD Xref discovery files_dg DataGrid selected_hosts Host file list with discipline/building links_tv TreeView plan hierarchy Host/link hierarchy display plan_msgs_ic ItemsControl plan messages Validation warnings/info accore_tb TextBlock display AutoCAD Core Console path rb_addxrefs RadioButton checked_addxrefs Select ADD_XREFS mode rb_bindall RadioButton checked_bindall Select BIND_ALL mode bindtype_cb ComboBox bindtype_changed BIND vs INSERT selection add_cad_xref_b Button add_cad_xref Add manual Xref button 14.2 Manage Dialog Controls Control Name Type Handler Purpose list_lb ListBox items binding Display discipline/building list Add button Button button_add Add new item Rename button Button button_rename Rename selected item Delete button Button button_del Delete selected item 14.3 Progress Window Controls Control Name Type Binding/Handler Purpose overall_pb ProgressBar set_progress Visual progress (0-100) progress_tb TextBlock set_progress Percentage text step_tb TextBox log Scrolling log output step_sv ScrollViewer auto-scroll Log container Copy logs button Button button_copylogs Copy log to clipboard Cancel button Button button_cancel Cancel execution Close button Button button_close Close window 15. Interaction Scenarios 15.1 Basic Workflow User opens Record Set tool Clicks \"Add Host...\" and selects Model.rvt System scans links, finds Link.rvt and CAD.dwg User assigns discipline \"Structural\" in DataGrid User clicks \"Target Folder...\" and selects C:\\Output User clicks \"Sync Preview\" System shows tree: Host: Model.rvt -> Link.rvt, CAD.dwg User clicks \"Process\" Progress window shows copying progress Files copied, links repathed User closes progress window 15.2 CAD Bind Scenario User adds host with DWG links User syncs preview (auto-discovers Xrefs) User selects CAD.dwg in TreeView User clicks \"Bind all Xrefs\" radio button User selects \"Insert (merge names)\" in BindType dropdown User syncs preview again Plan now shows cad_bind_all action instead of cad_copy + cad_repath User executes CAD.dwg is copied, all Xrefs bound and purged 15.3 Manual Xref Addition User adds host with DWG link User syncs preview User selects CAD.dwg in TreeView Ensures \"Keep/Add Xrefs\" is selected User clicks \"Add CAD Xref...\" Selects additional DWG file New Xref appears as child of CAD.dwg in TreeView User syncs preview New Xref included in plan User executes 15.4 Policy Violation Handling User adds hosts and selects target folder Target folder is NOT in allowed_target_roots User clicks \"Process\" System throws exception: \"Target not in allowed roots\" User updates target to allowed location User re-executes successfully 15.5 Cancellation Scenario User starts execution Progress shows 30% complete User clicks \"Cancel\" button cancel_token.cancel() called Current action completes Loop breaks on next iteration Lock released, manifest written with partial status User can close window Appendix A: Python File Summary File Lines Purpose Record Set_script.py 6 Entry point _rs_entry.py 448 UI controllers (3 window classes) _rs_models.py 115 Data models and enums _rs_ops.py 388 Operations layer (Fs, Safe, Revit, CAD) _rs_services.py 422 Services layer (orchestration) _rs_utils.py 68 Utility functions RecordSetForm.xaml 98 Main window UI RecordSetFormManage.xaml 23 Manage dialog UI RecordSetFormProgress.xaml 48 Progress window UI rs_list_xrefs.lsp 56 LISP: Xref discovery rs_repath_xrefs.lsp 32 LISP: Xref repathing rs_bind_all_xrefs.lsp 17 LISP: Xref binding Total Python Lines: ~1,447 Total XAML Lines: ~169 Total LISP Lines: ~105 Appendix B: Path Computation Formulas compute_host_target_path(target_root, host) IF host.building IN (\"-\", \"\"): RETURN {target_root}/{host.discipline}/{host.name} ELSE: RETURN {target_root}/{host.building}/{host.discipline}/{host.name} compute_link_target_path(target_root, link, is_common) IF is_common: RETURN {target_root}/Common Linked Files/{link.name} ELSE IF link.building IN (\"-\", \"\"): RETURN {target_root}/{link.discipline}/Linked Files/{link.name} ELSE: RETURN {target_root}/{link.building}/{link.discipline}/Linked Files/{link.name} Appendix C: Fingerprint Algorithm def _fingerprint(plan): parts = [] for item in plan.items: parts.append(item.action) for k, v in sorted(item.payload.items()): parts.append(f\"{k}={v}\") content = \"|\".join(parts) return hashlib.sha256(content.encode()).hexdigest()[:16] Document Version: 1.0 Generated: 2026-01-14 Source: Python Record Set tool analysis"
  },
  "developer-guide/tools/testing/recordset.html": {
    "href": "developer-guide/tools/testing/recordset.html",
    "title": "Record Set | DB Tools",
    "summary": "Record Set Record Set is a Testing-category tool for packaging Revit models and their external references (RVT links, DWGs, and CAD xrefs) into a safe, policy-controlled copy operation. It builds a plan (what will be copied/repathed), validates safety constraints, executes file operations, and updates internal references. See also: Technical Specification (Internal) Source Location Tool code: csharp/src/Tools/Testing/RecordSet/ Manifest: csharp/src/Tools/Testing/RecordSet/manifest.yml Key Concepts Plan building vs plan execution (preview/verify before acting) Safety policy filtering + target root validation CAD xref discovery/repath via console + LISP scripts"
  },
  "developer-guide/tools/testing/vtc-spec.html": {
    "href": "developer-guide/tools/testing/vtc-spec.html",
    "title": "VTC (View Template Comparer) Enhanced Design Document | DB Tools",
    "summary": "VTC (View Template Comparer) Enhanced Design Document Overview This document outlines the enhanced design for the VTC tool based on stakeholder feedback. The tool enables comparison, selective merging, and conflict resolution of Revit view template settings with a UI that mirrors Revit's native Visibility/Graphics dialog organization. 1. Category Organization - Revit VG Tab Structure Design Decision Category organization will exactly mimic Revit's Visibility/Graphics dialog tabs. Tab Structure Tab CategoryType Filter Notes Model Categories CategoryType.Model Exclude imported categories (Id > 0 with no BuiltInCategory) Annotation Categories CategoryType.Annotation Tags, dimensions, text, symbols Analytical Model Categories CategoryType.AnalyticalModel Structural analytical elements Imported Categories CategoryType.Model Where Category.Id.IntegerValue > 0 and no valid BuiltInCategory Filters N/A View filters (ParameterFilterElement) Revit Links N/A Linked RVT files - spawns child window Worksets N/A Conditional - only if model uses worksets Design Options N/A Conditional - only if design options exist Implementation public enum VtcCategoryTab { ModelCategories, AnnotationCategories, AnalyticalModelCategories, ImportedCategories, Filters, RevitLinks, Worksets, DesignOptions } public static class VtcCategoryClassifier { public static VtcCategoryTab GetTab(Category category) { // Check for imported category first (Model type but not built-in) if (category.CategoryType == CategoryType.Model) { var idValue = ElementIdCompat.GetValue(category.Id); if (idValue > 0 && !IsBuiltInCategory(idValue)) return VtcCategoryTab.ImportedCategories; return VtcCategoryTab.ModelCategories; } return category.CategoryType switch { CategoryType.Annotation => VtcCategoryTab.AnnotationCategories, CategoryType.AnalyticalModel => VtcCategoryTab.AnalyticalModelCategories, _ => VtcCategoryTab.ModelCategories // Fallback }; } private static bool IsBuiltInCategory(long categoryId) { return Enum.IsDefined(typeof(BuiltInCategory), (int)categoryId); } } Data Model Changes // Enhanced category data with tab classification public sealed record VtcCategoryGraphicsData( long CategoryId, string Name, bool IsVisible, VtcOverrideGraphicsData Overrides, VtcCategoryTab Tab); // NEW: Tab classification // Enhanced tree node with tab grouping public enum VtcDiffNodeType { Root, // Top-level root Tab, // NEW: VG Tab (Model Categories, Annotation, etc.) CategoryGroup, // Parent category with subcategories Setting // Leaf node with actual value } 2. Containerized Diff View Component Design Decision The diff view will be containerized as a reusable UserControl so it can be embedded in: The main VTC window Child windows for Linked File overrides Future comparison contexts Architecture VtcDiffViewControl (UserControl) ├── CategoryTabControl (TabControl) │ ├── Model Categories Tab │ ├── Annotation Categories Tab │ ├── Analytical Model Categories Tab │ ├── Imported Categories Tab │ └── Filters Tab ├── Side-by-side TreeViews (Left/Right) ├── Selection Controls └── Action Bar (Apply/Merge buttons) Child Window Pattern for Linked Files public sealed class VtcLinkedFileWindow : DbtWindowBase { // Reuses the same VtcDiffViewControl public VtcLinkedFileWindow( RevitLinkInstance linkInstance, VtcTemplateSettingsModel leftTemplate, VtcTemplateSettingsModel rightTemplate) { Title = $\"Linked File Overrides: {linkInstance.Name}\"; Content = new VtcDiffViewControl { DataContext = new VtcLinkedFileDiffViewModel( linkInstance, leftTemplate, rightTemplate) }; } } Component Interface public interface IVtcDiffViewHost { /// <summary> /// The comparison result to display. /// </summary> VtcComparisonResult Comparison { get; } /// <summary> /// Tree roots organized by VG tab structure. /// </summary> ObservableCollection<VtcDiffTreeNode> DiffTreeRoots { get; } /// <summary> /// Currently selected tab. /// </summary> VtcCategoryTab SelectedTab { get; set; } /// <summary> /// Collect all current selections. /// </summary> IReadOnlyCollection<VtcSelection> CollectSelections(); /// <summary> /// Apply selections and return conflict report. /// </summary> VtcApplyResult ApplySelections(VtcTemplateSide targetSide); } 3. Selection UI - Single and Nested Selection Design Decision Provide dual-action selection controls for both single-item and cascading (single + all nested) selection/deselection. UI Pattern: Dual Checkbox Column ┌─────────────────────────────────────────────────────────────────┐ │ Setting │ Sel │ All │ Value (Template A) │ ├─────────────────────────────────────────────────────────────────┤ │ ▼ Structural Framing │ [☑] │ [☑] │ │ │ ├─ Visibility │ [☑] │ │ Visible │ │ ├─ Line Color │ [☑] │ │ RGB(0,0,255) │ │ └─ Line Weight │ [ ] │ │ 3 │ │ ▼ Walls │ [ ] │ [ ] │ │ │ ├─ Visibility │ [ ] │ │ Visible │ │ └─ Cut Pattern │ [ ] │ │ Solid Fill │ └─────────────────────────────────────────────────────────────────┘ Legend: [Sel] = Select this single item only [All] = Select this item AND all nested children (only shown for parent nodes) Data Model Extension public sealed class VtcDiffTreeNode : INotifyPropertyChanged { // Existing properties... /// <summary> /// Select/deselect this single node only. /// </summary> public bool SelectLeft { get; set; } public bool SelectRight { get; set; } /// <summary> /// Select/deselect this node AND all descendants. /// Only applicable to non-leaf nodes (Root, Tab, CategoryGroup). /// </summary> public bool SelectLeftWithChildren { get => _selectLeftWithChildren; set { _selectLeftWithChildren = value; if (value) PropagateSelectionToChildren(VtcTemplateSide.Left, true); OnPropertyChanged(); } } public bool SelectRightWithChildren { get => _selectRightWithChildren; set { _selectRightWithChildren = value; if (value) PropagateSelectionToChildren(VtcTemplateSide.Right, true); OnPropertyChanged(); } } /// <summary> /// Shows whether this node can cascade selection (has children). /// </summary> public bool CanCascadeSelection => Children.Count > 0; private void PropagateSelectionToChildren(VtcTemplateSide side, bool selected) { foreach (var child in Children) { if (side == VtcTemplateSide.Left) child.SelectLeft = selected; else child.SelectRight = selected; child.PropagateSelectionToChildren(side, selected); } } } Alternative UI Consideration: Context Menu For cleaner UI, offer right-click context menu: Right-click on \"Structural Framing\" → ┌─────────────────────────────────┐ │ ☑ Select (Template A) │ │ ☐ Select (Template B) │ ├─────────────────────────────────┤ │ ☑ Select All Nested (A) │ │ ☐ Select All Nested (B) │ ├─────────────────────────────────┤ │ Clear Selection │ │ Clear All Nested │ └─────────────────────────────────┘ Recommended Approach: Split Button A split button provides the cleanest UX: ┌───────────────────────────────────────────────────────────────────┐ │ Setting │ Use A │ Value │ ├───────────────────────────────────────────────────────────────────┤ │ ▼ Structural Framing │ [☑ ▾] │ │ │ │ ├─ Select │ │ │ │ └─ Select All │ │ └───────────────────────────────────────────────────────────────────┘ The checkbox selects the single item; clicking the dropdown arrow shows \"Select\" / \"Select All Children\" options. 4. Merge Strategy - Disk-Based Workflow Design Decision Option A: Write changes to disk (JSON snapshots) Create merged templates as new elements Update existing templates based on selected properties Workflow ┌─────────────────────────────────────────────────────────────────┐ │ MERGE WORKFLOW │ ├─────────────────────────────────────────────────────────────────┤ │ │ │ 1. COMPARE │ │ ├─ Extract Template A settings → VtcTemplateSettingsModel │ │ ├─ Extract Template B settings → VtcTemplateSettingsModel │ │ └─ Generate diff tree with tab organization │ │ │ │ 2. SELECT │ │ ├─ User picks settings from A or B per property │ │ ├─ Single or cascading selection │ │ └─ Selections stored in VtcSelection list │ │ │ │ 3. PREVIEW (Optional) │ │ └─ Show merged result before applying │ │ │ │ 4. APPLY │ │ ├─ Option: Apply to Template A (in-place update) │ │ ├─ Option: Apply to Template B (in-place update) │ │ └─ Option: Create New Template (merged copy) │ │ │ │ 5. PERSIST (Optional) │ │ ├─ Save merged template snapshot to JSON │ │ └─ Store in Template Library for future use │ │ │ └─────────────────────────────────────────────────────────────────┘ Merge Operation Types public enum VtcMergeOperation { /// <summary> /// Update Template A with selected settings from comparison. /// </summary> ApplyToLeft, /// <summary> /// Update Template B with selected settings from comparison. /// </summary> ApplyToRight, /// <summary> /// Create a new template by duplicating base and applying selections. /// </summary> CreateMerged, /// <summary> /// Export merged settings to JSON file (no Revit changes). /// </summary> ExportToJson } 5. Conflict Handling and Apply Workflow Design Decision Attempt all selected changes Report conflicts after apply attempt Retain selections (don't clear on partial failure) Highlight problematic selections Filter control to show/hide conflicts (hidden until apply attempted) Conflict Types public enum VtcConflictType { /// <summary> /// No conflict - change applied successfully. /// </summary> None, /// <summary> /// Category/Filter doesn't exist in target document. /// </summary> ElementNotFound, /// <summary> /// Parameter is read-only or controlled by another template. /// </summary> ReadOnlyParameter, /// <summary> /// Value format incompatible (e.g., pattern ID doesn't exist). /// </summary> IncompatibleValue, /// <summary> /// Revit API threw an exception during apply. /// </summary> ApiError } public sealed record VtcConflictInfo( string SettingKey, VtcConflictType ConflictType, string Message, Exception? Exception); public sealed record VtcApplyResult( int TotalAttempted, int SuccessCount, int FailedCount, IReadOnlyList<VtcConflictInfo> Conflicts); Enhanced Tree Node with Conflict State public sealed class VtcDiffTreeNode : INotifyPropertyChanged { // Existing properties... /// <summary> /// Conflict information after apply attempt. Null if not yet attempted or no conflict. /// </summary> public VtcConflictInfo? Conflict { get; set; } /// <summary> /// Whether this node has a conflict after apply. /// </summary> public bool HasConflict => Conflict != null; /// <summary> /// Whether apply has been attempted on this node. /// </summary> public bool ApplyAttempted { get; set; } } UI State Machine ┌─────────────────────────────────────────────────────────────────┐ │ UI STATE MACHINE │ ├─────────────────────────────────────────────────────────────────┤ │ │ │ State: INITIAL │ │ ├─ Conflict filter: HIDDEN │ │ ├─ Apply button: ENABLED │ │ └─ Conflict highlights: NONE │ │ │ │ ──[User clicks Apply]──────────────────────────────────────────│ │ │ │ State: APPLYING │ │ ├─ Conflict filter: HIDDEN │ │ ├─ Apply button: DISABLED (with spinner) │ │ └─ Progress indicator shown │ │ │ │ ──[Apply completes]────────────────────────────────────────────│ │ │ │ State: POST_APPLY (if any conflicts) │ │ ├─ Conflict filter: VISIBLE │ │ │ ├─ [Show All] │ │ │ ├─ [Show Conflicts Only] │ │ │ └─ [Hide Conflicts] │ │ ├─ Apply button: ENABLED (for retry) │ │ ├─ Conflict highlights: ACTIVE │ │ │ ├─ Red border on conflicting rows │ │ │ ├─ Warning icon with tooltip │ │ │ └─ Conflict count badge │ │ └─ Selections: RETAINED (user can modify and retry) │ │ │ │ State: POST_APPLY (no conflicts) │ │ ├─ Conflict filter: HIDDEN │ │ ├─ Success message shown │ │ └─ Selections: CLEARED or RETAINED (configurable) │ │ │ └─────────────────────────────────────────────────────────────────┘ Conflict Filter Control <!-- Only visible after apply has been attempted AND conflicts exist --> <StackPanel Orientation=\"Horizontal\" Visibility=\"{Binding ShowConflictFilter, Converter={StaticResource BoolToVisibility}}\"> <TextBlock Text=\"Filter:\" Margin=\"0,0,8,0\" VerticalAlignment=\"Center\" /> <RadioButton Content=\"All\" IsChecked=\"{Binding ConflictFilter, Converter={StaticResource EnumToBool}, ConverterParameter=All}\" GroupName=\"ConflictFilter\" /> <RadioButton Content=\"Conflicts Only\" IsChecked=\"{Binding ConflictFilter, Converter={StaticResource EnumToBool}, ConverterParameter=ConflictsOnly}\" GroupName=\"ConflictFilter\" /> <RadioButton Content=\"Successful Only\" IsChecked=\"{Binding ConflictFilter, Converter={StaticResource EnumToBool}, ConverterParameter=SuccessfulOnly}\" GroupName=\"ConflictFilter\" /> <!-- Conflict count badge --> <Border Background=\"{DynamicResource Error}\" CornerRadius=\"10\" Padding=\"6,2\" Margin=\"12,0,0,0\" Visibility=\"{Binding HasConflicts, Converter={StaticResource BoolToVisibility}}\"> <TextBlock Text=\"{Binding ConflictCount, StringFormat='{0} conflicts'}\" Foreground=\"White\" FontSize=\"11\" /> </Border> </StackPanel> Conflict Highlighting in TreeView <!-- Enhanced tree node template with conflict indication --> <Style x:Key=\"Vtc.ConflictBorder\" TargetType=\"Border\"> <Style.Triggers> <DataTrigger Binding=\"{Binding HasConflict}\" Value=\"True\"> <Setter Property=\"BorderBrush\" Value=\"{DynamicResource Error}\" /> <Setter Property=\"BorderThickness\" Value=\"2\" /> <Setter Property=\"Background\" Value=\"{DynamicResource ErrorBackground}\" /> </DataTrigger> </Style.Triggers> </Style> <!-- Conflict warning icon --> <TextBlock x:Name=\"ConflictIcon\" FontFamily=\"Segoe MDL2 Assets\" Text=\"&#xE7BA;\" Foreground=\"{DynamicResource Error}\" ToolTip=\"{Binding Conflict.Message}\" Visibility=\"{Binding HasConflict, Converter={StaticResource BoolToVisibility}}\" /> 6. Complete ViewModel Structure public sealed partial class VtcWindowViewModel : ObservableObject, IVtcDiffViewHost { // Template selection [ObservableProperty] private VtcTemplateOption? _selectedLeft; [ObservableProperty] private VtcTemplateOption? _selectedRight; // Tab navigation (mirrors Revit VG tabs) [ObservableProperty] private VtcCategoryTab _selectedTab = VtcCategoryTab.ModelCategories; public ObservableCollection<VtcCategoryTab> AvailableTabs { get; } // Diff tree organized by tabs public ObservableCollection<VtcDiffTreeNode> DiffTreeRoots { get; } // Conflict management (hidden until apply attempted) [ObservableProperty] private bool _applyAttempted; [ObservableProperty] private VtcConflictFilter _conflictFilter = VtcConflictFilter.All; [ObservableProperty] private VtcApplyResult? _lastApplyResult; public bool ShowConflictFilter => ApplyAttempted && (LastApplyResult?.FailedCount ?? 0) > 0; public bool HasConflicts => (LastApplyResult?.FailedCount ?? 0) > 0; public int ConflictCount => LastApplyResult?.FailedCount ?? 0; // Linked files (spawns child windows) public ObservableCollection<VtcLinkedFileInfo> LinkedFiles { get; } // Commands [RelayCommand] private void ApplyToLeft() => ApplyWithConflictHandling(VtcTemplateSide.Left); [RelayCommand] private void ApplyToRight() => ApplyWithConflictHandling(VtcTemplateSide.Right); [RelayCommand] private void OpenLinkedFileOverrides(VtcLinkedFileInfo link) => SpawnLinkedFileWindow(link); [RelayCommand] private void SelectAllInTab() => SelectAllNodesInCurrentTab(true); [RelayCommand] private void DeselectAllInTab() => SelectAllNodesInCurrentTab(false); private void ApplyWithConflictHandling(VtcTemplateSide targetSide) { var selections = CollectSelections(); var result = _comparer.ApplySelectionsWithReport(target, _comparison!, selections); ApplyAttempted = true; LastApplyResult = result; // Update tree nodes with conflict info foreach (var conflict in result.Conflicts) { var node = FindNodeByKey(conflict.SettingKey); if (node != null) { node.Conflict = conflict; node.ApplyAttempted = true; } } // Mark successful nodes foreach (var selection in selections) { if (!result.Conflicts.Any(c => c.SettingKey == selection.Key)) { var node = FindNodeByKey(selection.Key); if (node != null) { node.Conflict = null; node.ApplyAttempted = true; } } } OnPropertyChanged(nameof(ShowConflictFilter)); OnPropertyChanged(nameof(HasConflicts)); OnPropertyChanged(nameof(ConflictCount)); ShowApplyResultSummary(result); } } public enum VtcConflictFilter { All, ConflictsOnly, SuccessfulOnly } 7. File Structure After Implementation VTC/ ├── Documentation/ │ └── VTC_Enhanced_Design.md # This document ├── Contracts/ │ ├── VtcDataModels.cs # Enhanced with Tab classification │ ├── VtcEnums.cs # Add VtcCategoryTab, VtcConflictType │ ├── IVtcComparisonService.cs # Add ApplySelectionsWithReport │ └── VtcConflictModels.cs # NEW: Conflict handling types ├── UI/ │ ├── Controls/ │ │ └── VtcDiffViewControl.xaml # NEW: Reusable diff view control │ ├── ViewModels/ │ │ ├── VtcWindowViewModel.cs # Enhanced with conflict handling │ │ ├── VtcDiffTreeNode.cs # Enhanced with conflict state │ │ ├── VtcDiffTreeBuilder.cs # Enhanced with tab organization │ │ ├── VtcLinkedFileDiffViewModel.cs # NEW: For child windows │ │ └── VtcCategoryClassifier.cs # NEW: Tab classification logic │ ├── Views/ │ │ ├── VtcWindow.xaml # Main window (uses VtcDiffViewControl) │ │ └── VtcLinkedFileWindow.xaml # NEW: Child window for linked files │ ├── Converters/ │ │ ├── VtcDiffBackgroundConverter.cs │ │ ├── VtcConflictToVisibilityConverter.cs # NEW │ │ └── VtcCategoryTabToIconConverter.cs # NEW │ └── Behaviors/ │ └── ScrollSyncBehavior.cs ├── Revit/ │ └── Services/ │ ├── VtcComparisonService.cs # Enhanced with conflict reporting │ └── VtcCategoryClassifier.cs # NEW: Revit-specific classification └── Services/ └── VtcTemplateStorageService.cs 8. Implementation Priority Priority Feature Complexity Dependencies 1 Tab-based category organization Medium VtcCategoryClassifier 2 Dual selection (single/nested) Medium VtcDiffTreeNode changes 3 Conflict handling workflow High Apply result reporting 4 Containerized diff view control Medium Extract from VtcWindow 5 Linked file child windows Medium VtcDiffViewControl 6 Conflict filter UI Low After conflict handling 9. Linked File Extraction (RevitLinkType Overrides) Design Decision Extract and display RevitLinkType visibility overrides from view templates, enabling full comparison and merging of linked file settings. Revit API Integration /// <summary> /// Data model for linked file visibility overrides within a view template. /// </summary> public sealed record VtcLinkedFileOverrideData( long LinkTypeId, string LinkName, string FilePath, bool IsVisible, VtcLinkedFileVisibility LinkedViewId, // None, ByHostView, or specific view ID IReadOnlyList<VtcCategoryGraphicsData> CategoryOverrides); public enum VtcLinkedFileVisibility { None, // Link hidden ByHostView, // Use host view's VG settings Custom // Uses stored view ID for overrides } Extraction Implementation public List<VtcLinkedFileOverrideData> ExtractLinkedFileOverrides(View template) { var results = new List<VtcLinkedFileOverrideData>(); // Get all RevitLinkType elements in the document var linkTypes = new FilteredElementCollector(_document) .OfClass(typeof(RevitLinkType)) .Cast<RevitLinkType>(); foreach (var linkType in linkTypes) { var linkId = linkType.Id; // Get visibility state from template var isVisible = !template.GetCategoryHidden(linkId); // Get linked view override (determines how link displays) var linkedViewId = template.GetLinkedOverrideViewId(linkId); var visibility = linkedViewId == ElementId.InvalidElementId ? VtcLinkedFileVisibility.ByHostView : VtcLinkedFileVisibility.Custom; // Extract category-level overrides for this link var categoryOverrides = ExtractLinkedCategoryOverrides(template, linkType); results.Add(new VtcLinkedFileOverrideData( ElementIdCompat.GetValue(linkId), linkType.Name, linkType.GetExternalResourceReference()?.GetReferenceInformation()?.GetPath() ?? string.Empty, isVisible, visibility, categoryOverrides)); } return results; } 10. Worksets & Design Options Support Design Decision Conditionally display Worksets and Design Options tabs when the model contains these features. Detection Logic public bool HasWorksets(Document doc) => doc.IsWorkshared; public bool HasDesignOptions(Document doc) { return new FilteredElementCollector(doc) .OfClass(typeof(DesignOption)) .Any(); } Data Models /// <summary> /// Workset visibility override data. /// </summary> public sealed record VtcWorksetOverrideData( long WorksetId, string Name, WorksetVisibility Visibility); // Visible, Hidden, UseGlobalSetting /// <summary> /// Design option visibility override data. /// </summary> public sealed record VtcDesignOptionOverrideData( long DesignOptionId, string Name, string SetName, // Parent design option set bool IsActive); Tab Visibility Control // In VtcWindowViewModel public bool ShowWorksetsTab => _hasWorksets; public bool ShowDesignOptionsTab => _hasDesignOptions; // Initialize during comparison private void CheckConditionalTabs() { _hasWorksets = _documentInfo.IsWorkshared; _hasDesignOptions = new FilteredElementCollector(_document) .OfClass(typeof(DesignOption)) .Any(); OnPropertyChanged(nameof(ShowWorksetsTab)); OnPropertyChanged(nameof(ShowDesignOptionsTab)); } 11. Search/Filter by Name Design Decision Provide a text search box that filters settings by name across all categories in real-time. UI Layout ┌─────────────────────────────────────────────────────────────────┐ │ [\uD83D\uDD0D] Search settings... [Clear] [×] │ ├─────────────────────────────────────────────────────────────────┤ │ ▼ Model Categories (3 matches) │ │ ├─ Structural Framing [☑] Visible [☐] Hidden │ │ └─ Structural Columns [☑] Visible [☐] Hidden │ │ ▼ Annotation Categories (1 match) │ │ └─ Structural Framing Tags [☑] Visible [☐] Visible │ └─────────────────────────────────────────────────────────────────┘ Implementation [ObservableProperty] [NotifyPropertyChangedFor(nameof(FilteredDiffTreeRoots))] private string _searchText = string.Empty; public IEnumerable<VtcDiffTreeNode> FilteredDiffTreeRoots { get { var roots = GetConflictFilteredRoots(); if (string.IsNullOrWhiteSpace(SearchText)) return roots; return roots .Select(root => FilterNodeBySearch(root, SearchText)) .Where(node => node != null)!; } } private static VtcDiffTreeNode? FilterNodeBySearch(VtcDiffTreeNode node, string searchText) { // Check if this node's name matches var nameMatches = node.DisplayName.Contains(searchText, StringComparison.OrdinalIgnoreCase); // Filter children recursively var filteredChildren = node.Children .Select(c => FilterNodeBySearch(c, searchText)) .Where(c => c != null) .ToList(); // Include node if name matches OR has matching children if (!nameMatches && filteredChildren.Count == 0) return null; // Create filtered copy var filteredNode = new VtcDiffTreeNode(node.DisplayName, node.NodeType) { Change = node.Change, CategoryTab = node.CategoryTab }; foreach (var child in filteredChildren) filteredNode.Children.Add(child!); filteredNode.IsExpanded = true; // Auto-expand when filtering return filteredNode; } [RelayCommand] private void ClearSearch() => SearchText = string.Empty; 12. Copy Linked File Overrides Design Decision Enable copying visibility overrides from one linked file to another within the same view template. Workflow ┌─────────────────────────────────────────────────────────────────┐ │ Copy Linked File Overrides │ ├─────────────────────────────────────────────────────────────────┤ │ │ │ Source Link: [▼ Architectural.rvt ] │ │ │ │ Target Link: [▼ Structural.rvt ] │ │ │ │ Options: │ │ [☑] Copy visibility state │ │ [☑] Copy category overrides │ │ [☑] Copy linked view reference │ │ │ │ [Cancel] [Copy Overrides] │ └─────────────────────────────────────────────────────────────────┘ Implementation public sealed record VtcCopyLinkedOverridesOptions( long SourceLinkTypeId, long TargetLinkTypeId, bool CopyVisibility, bool CopyCategoryOverrides, bool CopyLinkedViewReference); public void CopyLinkedFileOverrides(View template, VtcCopyLinkedOverridesOptions options) { var sourceId = new ElementId(options.SourceLinkTypeId); var targetId = new ElementId(options.TargetLinkTypeId); using var tx = new Transaction(_document, \"Copy Linked File Overrides\"); tx.Start(); if (options.CopyVisibility) { var isHidden = template.GetCategoryHidden(sourceId); template.SetCategoryHidden(targetId, isHidden); } if (options.CopyCategoryOverrides) { var ogs = template.GetCategoryOverrides(sourceId); template.SetCategoryOverrides(targetId, ogs); } if (options.CopyLinkedViewReference) { var linkedViewId = template.GetLinkedOverrideViewId(sourceId); template.SetLinkedOverrideViewId(targetId, linkedViewId); } tx.Commit(); } 13. Interactive Diff View with Inline Override Controls Design Decision Mirror Revit's Visibility/Graphics dialog by providing inline controls for each category row, allowing direct editing of override settings. Row Control Layout ┌─────────────────────────────────────────────────────────────────────────────────┐ │ Category Name │ Projection/Surface │ Cut │ HT │ Detail │ │ │ [Lines] [Patterns] [Trans] │ [Lines] [Pat] │ [☐]│ [▼ Fine ] │ ├─────────────────────────────────────────────────────────────────────────────────┤ │ Structural │ [⚫] [◻] [50% ] │ [⚫] [◻] │ [☐]│ [▼ Med ] │ │ Framing │ │ │ │ │ └─────────────────────────────────────────────────────────────────────────────────┘ Legend: [⚫] = Lines button (opens Line Settings dialog) [◻] = Patterns button (opens Fill Pattern dialog) [50%] = Transparency button (opens Transparency slider dialog) [☐] = Halftone checkbox (direct toggle) [▼] = Detail Level dropdown (Coarse/Medium/Fine) Control Types Control Type Dialog Projection Lines Button Line Settings Dialog Projection Patterns Button Fill Pattern Dialog Transparency Button Transparency Slider Dialog Cut Lines Button Line Settings Dialog Cut Patterns Button Fill Pattern Dialog Halftone Checkbox Inline (no dialog) Detail Level ComboBox Inline dropdown 14. Override Editing Dialogs 14.1 Line Settings Dialog A compact modal for configuring line overrides. ┌─────────────────────────────────────────────────┐ │ Line Settings [×] │ ├─────────────────────────────────────────────────┤ │ │ │ Preview: ──────────────────────── │ │ (live preview of current settings) │ │ │ │ Weight: [▼ 3 ] │ │ │ │ Color: [■ Blue ] [\uD83C\uDFA8] │ │ │ │ Pattern: [▼ Solid ] │ │ │ │ [Reset to Default] │ │ │ │ [Cancel] [Apply] │ └─────────────────────────────────────────────────┘ Data Model: public sealed record VtcLineSettingsData { public int? LineWeight { get; init; } public VtcColorData? LineColor { get; init; } public long? LinePatternId { get; init; } public string? LinePatternName { get; init; } // For display } 14.2 Fill Pattern Dialog A compact modal for configuring foreground/background fill patterns. ┌─────────────────────────────────────────────────┐ │ Fill Pattern Settings [×] │ ├─────────────────────────────────────────────────┤ │ │ │ Preview: ┌──────────────────┐ │ │ │▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒│ │ │ │▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒│ │ │ └──────────────────┘ │ │ │ │ ─── Foreground ─── │ │ [☑] Visible │ │ Pattern: [▼ Crosshatch ] │ │ Color: [■ Gray ] [\uD83C\uDFA8] │ │ │ │ ─── Background ─── │ │ [☑] Visible │ │ Pattern: [▼ Solid Fill ] │ │ Color: [■ White ] [\uD83C\uDFA8] │ │ │ │ [Reset to Default] │ │ │ │ [Cancel] [Apply] │ └─────────────────────────────────────────────────┘ Data Model: public sealed record VtcFillPatternData { public bool ForegroundVisible { get; init; } public long? ForegroundPatternId { get; init; } public string? ForegroundPatternName { get; init; } public VtcColorData? ForegroundColor { get; init; } public bool BackgroundVisible { get; init; } public long? BackgroundPatternId { get; init; } public string? BackgroundPatternName { get; init; } public VtcColorData? BackgroundColor { get; init; } } 14.3 Transparency Dialog A minimal modal with just a slider control. ┌─────────────────────────────────────────────────┐ │ Transparency [×] │ ├─────────────────────────────────────────────────┤ │ │ │ Preview: [░░░░░░░░░░░░░░░░] 50% │ │ │ │ [────────────●────────────] 0 50 100 │ │ │ │ [Cancel] [Apply] │ └─────────────────────────────────────────────────┘ Data Model: public sealed record VtcTransparencyData(int Transparency); // 0-100 15. Dialog Implementation with AlertService Common Dialog Pattern public sealed class VtcLineSettingsBodyViewModel : ObservableObject, IAlertBody { private int? _lineWeight; private VtcColorData? _lineColor; private long? _linePatternId; public VtcLineSettingsBodyViewModel( VtcLineSettingsData initialData, IReadOnlyList<VtcLinePatternInfo> availablePatterns, IReadOnlyList<int> availableWeights) { _lineWeight = initialData?.LineWeight; _lineColor = initialData?.LineColor; _linePatternId = initialData?.LinePatternId; AvailablePatterns = availablePatterns; AvailableWeights = availableWeights; } public int? LineWeight { get => _lineWeight; set => SetProperty(ref _lineWeight, value); } public VtcColorData? LineColor { get => _lineColor; set => SetProperty(ref _lineColor, value); } public long? LinePatternId { get => _linePatternId; set => SetProperty(ref _linePatternId, value); } public IReadOnlyList<VtcLinePatternInfo> AvailablePatterns { get; } public IReadOnlyList<int> AvailableWeights { get; } // IAlertBody implementation public bool IsValid => true; // Always valid, changes are optional public event EventHandler? ValidityChanged; public object? GetResult() => new VtcLineSettingsData { LineWeight = LineWeight, LineColor = LineColor, LinePatternId = LinePatternId }; } Dialog Invocation public VtcLineSettingsData? ShowLineSettingsDialog( VtcLineSettingsData? current, string settingName) { var body = new VtcLineSettingsBodyViewModel( current, GetAvailableLinePatterns(), GetAvailableLineWeights()); var request = new AlertRequest($\"Line Settings: {settingName}\", body) { Variant = AlertVariant.Info, Options = new AlertWindowOptions { Width = 350, Height = 280, MinWidth = 300, MinHeight = 250 }, Buttons = new[] { new AlertButtonSpec(\"cancel\", \"Cancel\") { IsCancel = true }, new AlertButtonSpec(\"apply\", \"Apply\") { IsDefault = true, SetDialogResult = true } } }; var result = _alerts.Show(request); return result.ClickedButtonId == \"apply\" ? result.Payload as VtcLineSettingsData : null; } 16. Visual Preview Components Line Preview Control <!-- Preview showing line weight, color, and pattern --> <Canvas Height=\"20\" Width=\"200\" ClipToBounds=\"True\"> <Line X1=\"10\" Y1=\"10\" X2=\"190\" Y2=\"10\" Stroke=\"{Binding PreviewBrush}\" StrokeThickness=\"{Binding LineWeight}\" StrokeDashArray=\"{Binding PatternDashes}\" /> </Canvas> Fill Pattern Preview Control <!-- Preview showing foreground over background pattern --> <Grid Width=\"100\" Height=\"60\"> <!-- Background pattern --> <Rectangle Fill=\"{Binding BackgroundBrush}\" Visibility=\"{Binding BackgroundVisible, Converter={StaticResource BoolToVis}}\" /> <!-- Foreground pattern overlay --> <Rectangle Fill=\"{Binding ForegroundBrush}\" Visibility=\"{Binding ForegroundVisible, Converter={StaticResource BoolToVis}}\" /> </Grid> Transparency Preview Control <!-- Checkerboard background with semi-transparent overlay --> <Grid Width=\"100\" Height=\"30\"> <Rectangle> <Rectangle.Fill> <DrawingBrush TileMode=\"Tile\" Viewport=\"0,0,10,10\" ViewportUnits=\"Absolute\"> <DrawingBrush.Drawing> <GeometryDrawing Brush=\"LightGray\"> <GeometryDrawing.Geometry> <GeometryGroup> <RectangleGeometry Rect=\"0,0,5,5\" /> <RectangleGeometry Rect=\"5,5,5,5\" /> </GeometryGroup> </GeometryDrawing.Geometry> </GeometryDrawing> </DrawingBrush.Drawing> </DrawingBrush> </Rectangle.Fill> </Rectangle> <Rectangle Fill=\"{DynamicResource Primary}\" Opacity=\"{Binding TransparencyDecimal}\" /> </Grid> 17. Updated File Structure VTC/ ├── Documentation/ │ └── VTC_Enhanced_Design.md # This document ├── Contracts/ │ ├── VtcDataModels.cs # Enhanced with linked files, worksets, design options │ ├── VtcEnums.cs # Add VtcLinkedFileVisibility │ ├── IVtcComparisonService.cs │ └── VtcOverrideEditingModels.cs # NEW: Line, pattern, transparency data ├── UI/ │ ├── Controls/ │ │ ├── VtcDiffViewControl.xaml # Enhanced with search and inline controls │ │ ├── VtcLinePreviewControl.xaml # NEW: Line preview │ │ ├── VtcPatternPreviewControl.xaml # NEW: Pattern preview │ │ └── VtcTransparencyPreviewControl.xaml # NEW: Transparency preview │ ├── ViewModels/ │ │ ├── VtcWindowViewModel.cs # Enhanced with search, conditional tabs │ │ ├── VtcDiffTreeNode.cs # Enhanced with edit commands │ │ ├── VtcDiffTreeBuilder.cs # Enhanced with linked files, worksets │ │ ├── VtcLinkedFileDiffViewModel.cs │ │ ├── VtcLineSettingsBodyViewModel.cs # NEW: Line dialog body │ │ ├── VtcFillPatternBodyViewModel.cs # NEW: Pattern dialog body │ │ └── VtcTransparencyBodyViewModel.cs # NEW: Transparency dialog body │ ├── Views/ │ │ ├── VtcWindow.xaml # Main window with search │ │ ├── VtcLinkedFileWindow.xaml │ │ └── VtcCopyLinkedOverridesWindow.xaml # NEW: Copy dialog │ ├── Converters/ │ │ ├── VtcDiffBackgroundConverter.cs │ │ ├── VtcEnumToBoolConverter.cs │ │ └── VtcPatternToBrushConverter.cs # NEW: Pattern preview │ └── Behaviors/ │ └── ScrollSyncBehavior.cs ├── Revit/ │ └── Services/ │ ├── VtcComparisonService.cs # Enhanced with linked files, worksets, design options │ └── VtcCategoryClassifier.cs └── Services/ └── VtcTemplateStorageService.cs 18. Implementation Priority (Updated) Priority Feature Complexity Dependencies 1 Search/Filter by Name Low None 2 Linked File Extraction High Revit API integration 3 Worksets & Design Options Medium Conditional tab visibility 4 Copy Linked File Overrides Medium Linked file extraction 5 Inline Override Controls High All dialogs 6 Line Settings Dialog Medium Preview controls 7 Fill Pattern Dialog Medium Preview controls 8 Transparency Dialog Low Preview control References Revit Visibility/Graphics Documentation Revit API BuiltInCategory Enumeration Revit Category Management"
  },
  "developer-guide/tools/testing/vtc.html": {
    "href": "developer-guide/tools/testing/vtc.html",
    "title": "View Template Comparer (VTC) | DB Tools",
    "summary": "View Template Comparer (VTC) The View Template Comparer (VTC) is a Testing category tool that enables side-by-side comparison of Revit view templates, allowing users to identify differences, selectively merge settings, and create new templates from combined configurations. See also: Enhanced Design (Internal) Source: csharp/src/Tools/Testing/VTC/manifest.yml:1-21 Overview VTC provides a comprehensive solution for managing view template settings across Revit projects. The tool extracts complete template configurations including display settings, template parameter includes, category overrides, and filter overrides, presenting them in a hierarchical diff view for easy comparison and selective merging. Key Capabilities Side-by-side comparison of two view templates with visual diff highlighting Selective merging - choose individual settings from either template Apply to existing - update Template A or B with selected settings Create merged template - generate a new template combining selections from both sources JSON export/import - serialize template settings for cross-document transfer Template library - save and load configurations to local cache Text dump - export human-readable settings reports Source: csharp/src/Tools/Testing/VTC/Features/VtcCommand.cs:24-28 Features Template Selection The tool automatically loads all view templates from the active document, sorted alphabetically. Users select two templates for comparison: Template A (blue indicator) - the left/source template Template B (gold indicator) - the right/target template Templates can be swapped using the swap button for quick side-reversal. Source: csharp/src/Tools/Testing/VTC/Features/VtcCommand.cs:37-43 Settings Comparison VTC compares four categories of template settings: Category Description Display Properties Detail Level, Display Style, Parts Visibility, Discipline, Show Hidden Lines Template Parameters Which parameters are included/controlled by the template Category Overrides Visibility and graphics overrides per category and subcategory Filter Overrides Applied filters with visibility and graphics settings Source: csharp/src/Tools/Testing/VTC/Contracts/VtcEnums.cs:13-21 Each setting shows one of four difference states: State Meaning Same Values match in both templates Different Values differ between templates LeftMissing Setting exists only in Template B RightMissing Setting exists only in Template A Source: csharp/src/Tools/Testing/VTC/Contracts/VtcEnums.cs:38-44 Merge Operations Apply to Template A/B Applies selected settings to an existing template. The tool: Collects all user-selected settings from the diff tree Opens a Revit transaction Applies each selected value to the target template Updates non-controlled parameter list as needed Source: csharp/src/Tools/Testing/VTC/UI/ViewModels/VtcWindowViewModel.cs:198-226 Create Merged Template Creates a new view template combining settings from both sources: Duplicates the base template (user-selectable: Template A or B) Renames to user-specified name Applies all user-selected settings Commits the new template to the document Source: csharp/src/Tools/Testing/VTC/UI/ViewModels/VtcWindowViewModel.cs:228-275 Export/Import JSON Export Exports complete template settings to a JSON file containing: Template ID and name Display settings (detail level, discipline, etc.) Template parameter includes list Category graphics data (visibility, line colors, patterns, weights) Filter graphics data Source: csharp/src/Tools/Testing/VTC/Revit/Services/VtcSerializationService.cs:34-44 JSON Import Imports settings from a JSON file and applies them to the selected template. The import supports cross-document transfer by resolving elements by name when IDs don't match. Source: csharp/src/Tools/Testing/VTC/Revit/Services/VtcComparisonService.cs:236-270 Template Library VTC maintains a local cache of saved template configurations in %APPDATA%/DBTools/Cache/VTC/. Features include: Save - Store current template configuration with custom name Load - Apply saved configuration to Template A or B Delete - Remove saved configurations Refresh - Update the saved templates list Source: csharp/src/Tools/Testing/VTC/Services/VtcTemplateStorageService.cs:14-15 Text Dump Exports a human-readable text report of template settings including: Template name and view type All included parameters Display settings with current values Category visibility and graphics overrides Filter visibility and graphics overrides Output is written to a user-selected folder as {TemplateName}_template_dump.txt. Source: csharp/src/Tools/Testing/VTC/Revit/Services/VtcDumpService.cs:52-179 Architecture Module Structure DBTools.VTC/ +-- Bootstrap/ | +-- VtcServiceExtensions.cs # DI registration +-- Contracts/ | +-- IVtcComparisonService.cs # Comparison/merge interface | +-- IVtcDumpService.cs # Text export interface | +-- IVtcSerializationService.cs # JSON serialization interface | +-- VtcDataModels.cs # Data transfer objects | +-- VtcEnums.cs # Enumerations +-- Features/ | +-- VtcCommand.cs # Main command entry point +-- Revit/ | +-- Compat/ | | +-- ElementIdCompat.cs # ElementId compatibility layer | +-- Services/ | +-- VtcComparisonService.cs # Revit comparison implementation | +-- VtcDumpService.cs # Revit dump implementation | +-- VtcSerializationService.cs # Revit serialization implementation +-- Services/ | +-- VtcTemplateStorageService.cs # Local cache storage +-- UI/ | +-- Behaviors/ | | +-- ScrollSyncBehavior.cs # Synchronized scrolling | +-- Converters/ | | +-- VtcDiffBackgroundConverter.cs # Diff color converter | +-- ViewModels/ | | +-- VtcDiffNodeType.cs # Tree node types | | +-- VtcDiffTreeBuilder.cs # Tree construction | | +-- VtcDiffTreeNode.cs # Tree node model | | +-- VtcTemplateOption.cs # Dropdown item model | | +-- VtcWindowViewModel.cs # Main window ViewModel | +-- Views/ | +-- VtcWindow.xaml(.cs) # Main window +-- DesignTime/ | +-- VtcWindowDesignTimeViewModel.cs # XAML designer support +-- VtcToolModule.cs # Tool module registration +-- manifest.yml # Tool manifest Source: csharp/src/Tools/Testing/VTC/ Service Contracts IVtcComparisonService Core comparison and merge operations: public interface IVtcComparisonService { VtcTemplateSettingsModel Extract(object templateObject); VtcComparisonResult Compare(VtcTemplateSettingsModel left, VtcTemplateSettingsModel right); void ApplySelections(object target, VtcComparisonResult comparison, IReadOnlyCollection<VtcSelection> selections); void ApplySnapshot(object target, VtcTemplateSettingsModel source); } Source: csharp/src/Tools/Testing/VTC/Contracts/IVtcComparisonService.cs:8-29 IVtcSerializationService JSON import/export and template creation: public interface IVtcSerializationService { string Export(object templateObject, string path); VtcTemplateSettingsModel Import(string path); object CreateTemplateFromModel(object baseTemplate, VtcTemplateSettingsModel model, string newName); void ApplyModel(object targetTemplate, VtcTemplateSettingsModel model); } Source: csharp/src/Tools/Testing/VTC/Contracts/IVtcSerializationService.cs:6-27 IVtcDumpService Text report generation: public interface IVtcDumpService { (bool Success, string OutputPath) Run(object templateObject, string outputFolder); } Source: csharp/src/Tools/Testing/VTC/Contracts/IVtcDumpService.cs:6-12 Data Models VtcTemplateSettingsModel Complete template configuration for serialization: public sealed record VtcTemplateSettingsModel { public long TemplateId { get; init; } public string Name { get; init; } public VtcDisplaySettings Display { get; init; } public IReadOnlyList<VtcTemplateIncludeData> Includes { get; init; } public IReadOnlyList<VtcCategoryGraphicsData> Categories { get; init; } public IReadOnlyList<VtcFilterGraphicsData> Filters { get; init; } } Source: csharp/src/Tools/Testing/VTC/Contracts/VtcDataModels.cs:64-72 VtcSettingChange Represents a single difference between templates: public sealed record VtcSettingChange { public string Key { get; init; } public string DisplayName { get; init; } public VtcSettingType SettingType { get; init; } public VtcDisplayPropertyKind? DisplayProperty { get; init; } public VtcDifferenceKind DifferenceKind { get; init; } public string LeftDisplay { get; init; } public string RightDisplay { get; init; } public object? LeftValue { get; init; } public object? RightValue { get; init; } } Source: csharp/src/Tools/Testing/VTC/Contracts/VtcDataModels.cs:77-88 UI Components Hierarchical Diff Tree The comparison view uses a hierarchical TreeView with synchronized scrolling between left and right panels. The tree structure groups settings by type: Display Settings +-- Detail Level +-- Display Style +-- ... Template Parameters +-- Parameter 1 +-- Parameter 2 +-- ... Category Overrides +-- Walls | +-- Hidden Lines | +-- Surface Pattern +-- Structural Framing +-- ... Filter Overrides +-- Filter 1 +-- Filter 2 Source: csharp/src/Tools/Testing/VTC/UI/ViewModels/VtcDiffTreeBuilder.cs:17-43 Node types in the tree: Type Purpose Root Top-level category (Display Settings, Categories, etc.) CategoryGroup Parent category containing subcategories Setting Leaf node with actual values and selection checkboxes Source: csharp/src/Tools/Testing/VTC/UI/ViewModels/VtcDiffNodeType.cs:6-22 Settings VTC currently has no persistent user settings. All configuration is session-based through the UI. Cache Location Saved templates are stored in the user's local application data: %APPDATA%/DBTools/Cache/VTC/ Each saved template is stored as a JSON file with sanitized filename. Source: csharp/src/Tools/Testing/VTC/Services/VtcTemplateStorageService.cs:34 Manifest id: DBTools.VTC assembly: DBTools moduleType: DBTools.VTC.VtcToolModule order: 0 sandboxWindows: - id: DBTools.VTC.Main displayName: \"View Template Comparer\" group: \"Testing\" windowType: \"DBTools.VTC.UI.Views.VtcWindow\" designTimeViewModelType: \"DBTools.VTC.DesignTime.VtcWindowDesignTimeViewModel\" tool: ribbonTools: - internalName: DBTools.ViewTemplateComparer commandType: DBTools.VTC.Features.VtcCommand availabilityType: DBTools.App.Tools.Availability.DbtDocumentAvailability runProfile: InlineUi displayText: \"View Template\\nComparer\" iconBaseKey: vtc tooltip: \"Compare and merge view template settings\" controlKind: PushButton order: 50 Source: csharp/src/Tools/Testing/VTC/manifest.yml:1-21 Manifest Properties Property Value Description id DBTools.VTC Unique tool identifier moduleType DBTools.VTC.VtcToolModule Tool module class group Testing Ribbon panel group runProfile InlineUi Shows modeless window within Revit availabilityType DbtDocumentAvailability Requires active document controlKind PushButton Standard ribbon button Cross-Document Import VTC supports importing template settings from JSON files created in different Revit documents. When element IDs don't match (common across documents), the service falls back to name-based resolution: Parameters Searches ParameterElement and GlobalParameter types by name. Source: csharp/src/Tools/Testing/VTC/Revit/Services/VtcComparisonService.cs:239-270 Categories Handles both top-level and subcategories using \"Parent : Subcategory\" naming convention. Source: csharp/src/Tools/Testing/VTC/Revit/Services/VtcComparisonService.cs:296-340 Filters Searches ParameterFilterElement instances by name. Source: csharp/src/Tools/Testing/VTC/Revit/Services/VtcComparisonService.cs:398-415 Graphics Override Data VTC captures comprehensive graphics override settings for categories and filters: public sealed record VtcOverrideGraphicsData { public VtcColorData? ProjectionLineColor { get; init; } public long? ProjectionLinePatternId { get; init; } public int? ProjectionLineWeight { get; init; } public int? Transparency { get; init; } public int? CutLineWeight { get; init; } public VtcColorData? CutLineColor { get; init; } public long? CutLinePatternId { get; init; } public long? CutForegroundPatternId { get; init; } public VtcColorData? CutForegroundPatternColor { get; init; } } Source: csharp/src/Tools/Testing/VTC/Contracts/VtcDataModels.cs:17-28 Error Handling VTC uses the standard DBTools alert service for user notifications. The ViewModel provides centralized error and success messaging: No templates found - Warning shown if document contains no view templates Template not found - Error if selected template cannot be resolved No selections - Error if merge attempted without any settings selected Duplicate name - Error if new template name already exists Source: csharp/src/Tools/Testing/VTC/UI/ViewModels/VtcWindowViewModel.cs:472-488 Testing VTC includes unit tests for core logic that doesn't require Revit: VtcTemplateStorageServiceTests.cs - File I/O operations VtcDiffTreeNodeTests.cs - Tree node behavior VtcDiffTreeBuilderTests.cs - Tree construction from change lists Source: csharp/src/Tools/Testing/VTC/Tests/ Tests are located in csharp/src/Tools/Testing/VTC/Tests/ and run via the standard test runner without requiring Revit."
  },
  "developer-guide/troubleshooting.html": {
    "href": "developer-guide/troubleshooting.html",
    "title": "Troubleshooting Guide | DB Tools",
    "summary": "Troubleshooting Guide This guide covers common issues encountered when building, running, and debugging DBTools. Build Issues MSBuild Errors Error: DBT0001 - Build must be run through build.sh Symptom: error DBT0001: Raw 'dotnet build' from CLI is not supported. Use bash csharp/build.sh instead. Cause: The build system enforces that all builds go through the repository's build entrypoint to ensure proper configuration, vendored dependency staging, and multi-year target handling. Solution: Always use the build script: # Standard incremental build bash csharp/build.sh # Clean and rebuild bash csharp/build.sh --clean # Build specific Revit year bash csharp/build.sh -y 2025 BuildAll # Build only the app bash csharp/build.sh BuildApp Error: Windows dotnet.exe not found Symptom: Windows dotnet.exe not found at: /mnt/c/Program Files/dotnet/dotnet.exe Cause: The build script runs Windows dotnet.exe from WSL. The .NET SDK must be installed on the Windows host. Solution: Install .NET 8 SDK on Windows from dotnet.microsoft.com Verify installation: \"/mnt/c/Program Files/dotnet/dotnet.exe\" --version If installed to a non-default location, set the path in build.sh Missing Dependencies Vendored UI Assemblies Missing Symptom: Vendored UI assemblies missing under csharp/.artifacts/vendor; building them now... Or build failures referencing DBTools.HandyControl, DBTools.ControlzEx, or DBTools.Fluent.Ribbon. Cause: The vendored UI libraries (HandyControl, ControlzEx, FluentRibbon) must be built with custom namespaces before the main build. Solution: # Automatic (build.sh runs this if needed) bash csharp/build.sh # Manual rebuild of vendored deps bash csharp/build-vendored-deps.sh Expected output location: csharp/.artifacts/vendor/ handycontrol/net48/DBTools.HandyControl.dll handycontrol/net8.0-windows/DBTools.HandyControl.dll controlzex/net48/DBTools.ControlzEx.dll fluentribbon/net48/DBTools.Fluent.Ribbon.dll Assembly Load Failures Symptom: InvalidOperationException: Failed to load tool assembly 'DBTools.GM'. Cause: With file-linking architecture, tool assemblies (GM, TDV, SGT, VTC) are compiled into DBTools.dll. This error indicates the main assembly wasn't built correctly. Solution: Run a clean build: bash csharp/build.sh --clean Verify build output exists in csharp/.artifacts/bin/ Check that the Revit add-in is loading the correct version Source: DbtToolAssemblyLoader.cs:10 Runtime Issues Theme Validation Failures Theme validation runs at startup to catch XAML resource issues early. Failures here indicate broken theme dictionaries or missing resources. Theme Dictionary Merge Failed Symptom: InvalidOperationException: Theme dictionary merge failed at 'pack://application:,,,/DBTools.Themes;component/Themes/App.Brushes.xaml'. Cause: A XAML resource dictionary failed to load. Common causes: Missing assembly reference Broken StaticResource chain Syntax error in XAML Solution: Verify DBTools.Themes.dll exists alongside DBTools.dll Check build output for XAML compilation errors If modifying themes, validate XAML syntax in Visual Studio Source: DbtThemeValidator.cs:69 Theme Resource Freeze Failed Symptom: InvalidOperationException: Theme resource freeze failed for key 'PrimaryBrush' in 'App.Brushes.xaml'. Cause: A Freezable resource (brush, geometry) could not be frozen. This typically indicates the resource has unresolved bindings or dynamic references. Solution: Check the resource definition in the XAML file Ensure all referenced colors/values are static Remove any bindings from Freezable resources Source: DbtThemeValidator.cs:161 Theme Contract Mismatch Symptom: InvalidOperationException: Theme merged dictionary contract mismatch: expected 11 dictionaries but found 10 in 'App.Theme.xaml'. Cause: The theme root dictionary doesn't match the expected structure. This catches accidental removal or reordering of theme dictionaries. Expected merged dictionaries (in order): DBTools.HandyControl/Themes/SkinDark.xaml DBTools.HandyControl/Themes/Theme.xaml DBTools.Fluent.Ribbon/Themes/Generic.xaml DBTools.Themes/Themes/App.Tokens.xaml DBTools.Themes/Themes/App.Brushes.xaml DBTools.Themes/Themes/App.Converters.xaml DBTools.Themes/Themes/App.Controls.Base.xaml DBTools.Themes/Themes/App.DataGrid.xaml DBTools.Themes/Themes/App.Menus.xaml DBTools.Themes/Themes/App.Components.xaml DBTools.Themes/Themes/App.FluentRibbon.xaml Solution: Ensure App.Theme.xaml contains all dictionaries in the correct order. Source: DbtThemeValidator.cs:191 Revit API Errors RevitContextUnavailableException Symptom: RevitContextUnavailableException: No UIApplication in current gate scope. Or: RevitContextUnavailableException: ActiveUIDocument is required but was not available. Cause: Code attempted to access Revit API objects outside of a valid Revit context. This happens when: A modeless window tries to access Revit without using the call gate An async operation continues after the document was closed Code runs during Revit shutdown Solution: Ensure Revit API calls are wrapped in IRevitCallGate.RunAsync() Check for document availability before operations Handle cancellation when documents close Source: RevitContextUnavailableException.cs:6 WPF Dispatcher Issues Symptom: InvalidOperationException: No WPF Dispatcher is available (Application.Current is null and no Revit window dispatcher could be resolved). Or: InvalidOperationException: WPF Dispatcher is shutting down. Cause: WPF UI operations attempted when no dispatcher is available, typically during early startup or late shutdown. Solution: Use WpfUiThread.TryGetDispatcher() and check for null Check dispatcher.HasShutdownStarted before operations Use BeginInvoke instead of Invoke for non-blocking operations Source: WpfUiThread.cs:21 Tool-Specific Issues Generic Model Tool (GM) GmKernelBuildException Error Code Message Solution 1001 Failed to resolve family or type names Check that all referenced families exist in the project 1002 Failed to build nesting index Verify nested family relationships are valid 1003 Shared parameter deserialization failed Check shared parameter file integrity 1004 Usage data collection failed Ensure document is fully loaded before scanning Source: GmKernelExceptions.cs:6 GmInvalidMappingException Error Code Message Solution 2001 Operation metadata missing Ensure mapping configuration is complete 2002 Target type creation failed Check family loading and type creation permissions 2003 Shared parameter bind failed Verify parameter definitions exist 2004 Shared parameter embed failed Check parameter embedding permissions 2005 Replacement operation failed Validate replacement targets exist GmSnapshotLoadException Error Code Message Solution 4001 Snapshot deserialization failed Re-export snapshot; file may be corrupt 4002 Snapshot checksum mismatch Re-export snapshot; data integrity issue Transfer Drafting Views Tool (TDV) Error Code Message Solution DestinationTypeMissing Destination view type not found Create matching view type in destination SourceTypeNameUnavailable Source view type name not available Check source view is a valid drafting view CreateViewFailed Failed to create destination view Verify write permissions and view limits CopyElementsFailed Failed to copy view elements Check element validity and target view OverridesFailed Failed to copy view overrides Some overrides may not be transferable Source: TdvPerViewErrorCode.cs:3 Debugging Enabling Debug Mode Debug mode provides detailed logging and surfaces the logger window on errors. Methods to enable: Programmatically: debugModeService.SetEnabled(true) On error: Debug mode auto-enables when ISafeExecutor catches an exception Via Logger Window: Toggle the debug checkbox in the logger window toolbar Effects of debug mode: Log level changes from Information to Debug Logger window becomes visible More detailed stack traces in logs Faster log buffer flush (120ms vs 600ms) Log File Locations Log files are written to the user's local app data directory: %LOCALAPPDATA%\\DBTools\\Logs\\ Log file naming pattern: dbtools-{RevitYear}-{InstanceId}-{Timestamp}-{Nonce}.log Example: dbtools-2025-ABC123-20260124-143022345-a1b2c3d4.log Log retention policy: Maximum 50 files across all instances Maximum 14 days retention Maximum 100 MB total size Automatic cleanup on startup Source: LoggingConstants.cs:119 Using the Logger Window The logger window provides real-time log viewing with filtering capabilities. Features: Level filtering: Toggle INFO, WARN, ERROR, DEBUG visibility Search: Filter logs by text content Export: Save filtered logs to a file Auto-scroll: Automatically scroll to new entries Correlation IDs: Track related log entries across operations Window title format: DB Tools Log - Revit {Year} [{InstanceId}] Opening the logger window: Automatically opens when debug mode is enabled Automatically opens when an unhandled error occurs Can be opened via tools menu (if available) Understanding Correlation IDs Every operation executed through ISafeExecutor is assigned a correlation ID (GUID). This ID appears in all related log entries: [Start] GM Apply starting (CorrelationId=abc123...) ... operation logs ... [Complete] GM Apply completed in 1234ms (CorrelationId=abc123...) Use the correlation ID to: Filter related log entries Track operation duration Correlate errors with their triggering operations Common Error Messages Quick Reference Table Error Message Category Solution DBT0001: Raw 'dotnet build' not supported Build Use bash csharp/build.sh Theme dictionary merge failed Theme Rebuild themes, check XAML syntax Theme resource freeze failed Theme Remove bindings from Freezable resources Failed to load tool assembly Assembly Clean rebuild: build.sh --clean No UIApplication in current gate scope Revit API Wrap calls in IRevitCallGate.RunAsync() ActiveUIDocument is required Revit API Check document is open before operations WPF Dispatcher is shutting down UI Check dispatcher state before UI operations AppRuntime not initialized Runtime Ensure add-in is fully loaded Manifest missing required field Manifest Check tool manifest YAML syntax Tool module type not found Assembly Verify assembly name in manifest ISafeExecutor Error Phases All tool entrypoints run through ISafeExecutor, which logs structured execution phases: Phase Log Level Meaning [Start] Info Operation beginning [Complete] Info Operation finished successfully [Cancel] Warning Operation was cancelled [Error] Error Operation failed with exception Source: SafeExecutor.cs:12 Getting Help Diagnostic Information to Collect When reporting issues, gather: Log file from %LOCALAPPDATA%\\DBTools\\Logs\\ Revit version (year and build number) DBTools version (from add-in manifest) Correlation ID from the error log Steps to reproduce the issue Screenshot of any error dialogs Log Export Use the logger window's export feature to save filtered logs: Open logger window (enable debug mode if needed) Apply any relevant filters Click Export button Save to file with timestamp Export filename pattern: DBToolsLog_{Timestamp}.txt"
  },
  "index.html": {
    "href": "index.html",
    "title": "DB Tools Documentation | DB Tools",
    "summary": "DB Tools Documentation Welcome to the DB Tools documentation. DB Tools is a comprehensive toolkit of productivity tools for Autodesk Revit, designed to streamline structural engineering workflows. Choose Your Path User Guide For Revit users who want to learn how to use DB Tools effectively. Installation Getting Started Tool Guides Developer Guide For developers working on the DB Tools codebase or building integrations. Architecture Creating New Tools API Reference What is DB Tools? DB Tools provides automation for common Revit tasks: Tool Description Global Mapper Batch parameter mapping between elements Super Girt Tool Automated girt placement and management Foundation Tags Smart tagging for foundation elements Transfer Drafting Views Import/export drafting views between projects View Template Comparer Compare and merge view templates And more... See the full tool list Quick Links Resource Description Installation How to install DB Tools Troubleshooting Common issues and solutions API Reference Auto-generated API documentation Documentation Roadmap Planned documentation work System Requirements Revit: 2024, 2025, or 2026 Windows: 10 or 11 (64-bit) Permissions: Standard user (admin not required for most features) Architecture at a Glance ┌─────────────────────────────────────────────────────────────┐ │ Revit │ ├─────────────────────────────────────────────────────────────┤ │ DBTools.Loader │ │ (Revit Add-in Entry Point) │ ├─────────────────────────────────────────────────────────────┤ │ DBTools.App │ │ (Application Shell, Ribbon UI) │ ├──────────────┬──────────────┬──────────────┬────────────────┤ │ GM Tool │ SGT Tool │ Other Tools │ Settings │ ├──────────────┴──────────────┴──────────────┴────────────────┤ │ DBTools.Core │ │ (Shared Infrastructure, Transactions, UI) │ ├─────────────────────────────────────────────────────────────┤ │ DBTools.Themes │ │ (UI Theming System) │ └─────────────────────────────────────────────────────────────┘ Documentation Status Area Documents Status User Guide 13 In Progress Developer Guide 26 Complete API Reference Auto-generated Partial See DOCUMENTATION_ROADMAP.md for the full roadmap. Get Started Install DB Tools First Steps Learn More Architecture Tool Development Get Help Troubleshooting GitHub Issues"
  },
  "user-guide/getting-started.html": {
    "href": "user-guide/getting-started.html",
    "title": "Getting Started | DB Tools",
    "summary": "Getting Started This guide will help you get up and running with DBTools quickly. First Launch After installing DBTools: Open Revit - Launch any supported Revit version (2024-2026) Find the DB Tools Tab - Look for \"DB Tools\" in the Revit ribbon Explore the Tools - Hover over buttons to see tooltips The DB Tools Ribbon The DB Tools ribbon tab contains panels organized by category: ┌──────────────────────────────────────────────────────────────────┐ │ DB Tools │ ├─────────────┬──────────────┬──────────────────┬─────────────────┤ │ Settings │ Common │ Structural │ Testing │ ├─────────────┼──────────────┼──────────────────┼─────────────────┤ │ [Settings] │ [GM] [TDV] │ [SGT] [F.Tags] │ [VTC] │ │ [Debug] │ [Elev Tags] │ [A.Snap] [Joins] │ │ │ │ [3D List] │ [JGW] [Org.Fnd] │ │ └─────────────┴──────────────┴──────────────────┴─────────────────┘ Panel Overview Panel Purpose Settings Application settings and debug mode Common General-purpose tools for any project Structural Tools specific to structural engineering Testing Development and testing utilities Your First Task Let's try a simple workflow to get familiar with DBTools. Example: Using Global Mapper The Global Mapper (GM) tool helps you map parameter values between elements. Scenario: Copy the \"Mark\" value from one element to another. Open a Project - Open any Revit project with elements Click \"Global Mapper\" - In the Common panel Select Source Element - Pick the element to copy from Select Target Elements - Pick elements to copy to Choose Parameter - Select \"Mark\" from the list Apply - Click the apply button The parameter values are now copied! Understanding Tool Windows Most DBTools tools use consistent UI patterns: Ribbon Windows Some tools (like GM and SGT) open a ribbon-style window: ┌─────────────────────────────────────────────────────────┐ │ [Tab 1] [Tab 2] [Tab 3] [─][□][×] │ ├─────────────────────────────────────────────────────────┤ │ ┌──────────────────┐ ┌───────────────────────────────┐ │ │ │ │ │ │ │ │ │ Left Panel │ │ Main Content Area │ │ │ │ (Selection/ │ │ │ │ │ │ Tree View) │ │ │ │ │ │ │ │ │ │ │ └──────────────────┘ └───────────────────────────────┘ │ ├─────────────────────────────────────────────────────────┤ │ [Action Buttons] [Status] │ └─────────────────────────────────────────────────────────┘ Dialog Windows Simpler tools use standard dialog windows with apply/cancel buttons. Settings Access DBTools settings through the Settings button in the ribbon. Common Settings Setting Description Debug Mode Shows additional logging information Log Level Controls how much is logged Auto-Update Check for updates on startup Tool-Specific Settings Each tool may have its own settings section. Check the individual tool guides for details. Keyboard Shortcuts While in DBTools windows: Shortcut Action Esc Cancel/Close Enter Apply/Confirm Ctrl+A Select All F5 Refresh Tips for New Users 1. Hover for Help Every button has a tooltip explaining what it does. 2. Use Preview Mode Many tools show a preview before applying changes. Review it carefully. 3. Undo is Your Friend DBTools operations can be undone with Ctrl+Z in Revit. 4. Check the Logs If something goes wrong, check the logs at: %APPDATA%\\DBTools\\Logs\\ 5. Start Simple Begin with simple tools (like Framing Joins) before tackling complex ones (like GM). Common Workflows Parameter Mapping (GM) Open Global Mapper Select source and target Map parameters Apply Bulk Tagging (Foundation Tags) Select foundation elements Run Foundation Tags Review generated tags Adjust settings if needed View Template Comparison (VTC) Open VTC Select two templates to compare Review differences Merge or export as needed Getting Help Tool Guides: See the Tools section for detailed guides Troubleshooting: Check Troubleshooting Support: Contact your Revit administrator Next Steps Now that you're familiar with the basics: Explore the Tool Guides for specific tools Check out Tips and Tricks for advanced usage Review the Settings to customize your experience"
  },
  "user-guide/index.html": {
    "href": "user-guide/index.html",
    "title": "User Guide | DB Tools",
    "summary": "User Guide Welcome to the DB Tools User Guide. This documentation is for Revit users who want to learn how to use DB Tools effectively. What is DB Tools? DB Tools is a collection of productivity tools for Autodesk Revit, designed to streamline structural engineering workflows. It provides automation for common tasks like: Global Mapper (GM) - Batch parameter mapping between elements Super Girt Tool (SGT) - Automated girt placement and management Foundation Tags - Smart tagging for foundation elements Transfer Drafting Views (TDV) - Import/export drafting views between projects And many more... Quick Start Install DBTools Open Revit and look for the DB Tools ribbon tab Select a tool and start working! Available Tools Common Tools Tool Description Global Mapper Map parameters between elements in bulk Transfer Drafting Views Import/export drafting views Elevation Tags Auto-update elevation tags 3D Elements From List Visualize elements from Excel/CSV Structural Tools Tool Description Super Girt Tool Automated girt placement Foundation Tags Smart foundation tagging Analytical Snap Snap analytical models to levels Framing Joins Bulk manage framing connections Joist Girder Weight Calculate joist girder weights Organize Foundation Organize foundation types Testing/Utility Tools Tool Description View Template Comparer Compare and merge view templates Getting Help Check the Troubleshooting section for common issues Each tool guide includes a FAQ section Contact support for additional assistance For Developers If you're looking to contribute to DBTools or understand how it works internally, see the Developer Guide."
  },
  "user-guide/installation.html": {
    "href": "user-guide/installation.html",
    "title": "Installation | DB Tools",
    "summary": "Installation This guide covers installing, updating, and uninstalling DBTools. System Requirements Requirement Minimum Revit 2024, 2025, or 2026 Windows 10 or 11 (64-bit) Permissions Standard user account Download Download the latest installer from: Internal: [Network Share Path] (contact your admin) GitHub Releases: github.com/kirsch33/dbtools/releases Installation Step 1: Close Revit Ensure all Revit instances are closed before installing. Step 2: Run the Installer Double-click DBToolsSetup.exe Accept the license agreement Choose installation options: Revit versions: Select which Revit versions to install for Install location: Default is recommended Step 3: Complete Installation Click Install and wait for completion. The installer will: Copy files to the installation directory Register the add-in with each selected Revit version Create configuration directory Installation Locations Add-in Files %LOCALAPPDATA%\\DBTools\\ ├── DBTools.Loader.dll # Bootstrap loader ├── DBTools.dll # Main application ├── vendor/ # Vendored UI assemblies │ ├── DBTools.Fluent.Ribbon.dll │ └── DBTools.ControlzEx.dll └── [version-specific files] Configuration & Data %APPDATA%\\DBTools\\ ├── settings.json # User settings ├── Logs/ # Application logs │ └── DBTools_2025_*.log ├── Cache/ # Tool-specific caches │ └── VTC/ │ └── GM/ └── [tool-specific data] Revit Add-in Manifest Each Revit version gets a manifest file: %APPDATA%\\Autodesk\\Revit\\Addins\\2025\\DBTools.addin Updating Automatic Updates DBTools checks for updates on startup. When an update is available: A notification appears in the ribbon Click to download and install Restart Revit to apply Manual Update Download the latest installer Close Revit Run the installer (it will detect and upgrade) Uninstallation Using Windows Settings Open Settings > Apps > Apps & features Search for \"DBTools\" Click Uninstall Using Control Panel Open Control Panel > Programs > Uninstall a program Find \"DBTools\" Click Uninstall What Gets Removed The uninstaller removes: All add-in files (%LOCALAPPDATA%\\DBTools\\) Revit manifest files (*.addin) Preserved (manual deletion required): User settings (%APPDATA%\\DBTools\\settings.json) Log files (%APPDATA%\\DBTools\\Logs\\) Cache files (%APPDATA%\\DBTools\\Cache\\) Clean Uninstall To remove all DBTools data: # Remove add-in files Remove-Item -Recurse \"$env:LOCALAPPDATA\\DBTools\" # Remove user data Remove-Item -Recurse \"$env:APPDATA\\DBTools\" # Remove Revit manifests (adjust year as needed) Remove-Item \"$env:APPDATA\\Autodesk\\Revit\\Addins\\2025\\DBTools.addin\" Remove-Item \"$env:APPDATA\\Autodesk\\Revit\\Addins\\2024\\DBTools.addin\" Troubleshooting Installation \"Access Denied\" Errors Ensure Revit is closed Run installer as Administrator if needed Check antivirus isn't blocking DBTools Tab Not Appearing Check the add-in manifest exists: %APPDATA%\\Autodesk\\Revit\\Addins\\2025\\DBTools.addin Verify Revit loaded the add-in: File > Options > Add-ins Look for \"DBTools\" in the list Check for startup errors: Look in %APPDATA%\\DBTools\\Logs\\ Search for \"ERROR\" or \"FATAL\" Theme Validation Failed If you see \"DB Tools theme failed to load\": Ensure vendor assemblies exist: %LOCALAPPDATA%\\DBTools\\vendor\\ Try reinstalling DBTools Check for conflicting add-ins Multiple Revit Versions DBTools supports side-by-side installation for multiple Revit versions. Each version has: Its own manifest file Shared DLLs (version-agnostic) Shared settings Silent Installation For enterprise deployment: DBToolsSetup.exe /S /REVIT=2024,2025,2026 Flag Description /S Silent mode (no UI) /REVIT=<versions> Comma-separated Revit versions /D=<path> Custom install directory Next Steps Getting Started - First steps with DBTools Tool Guides - Learn to use specific tools"
  },
  "user-guide/tools/analytical-snap.html": {
    "href": "user-guide/tools/analytical-snap.html",
    "title": "Analytical Snap To Level | DB Tools",
    "summary": "Analytical Snap To Level Quickly align your analytical model elements to specific level elevations with a single click. This tool eliminates the tedious manual adjustment of beam and column endpoints, ensuring your analytical model accurately reflects your structural intent. What is Analytical Snap To Level? Analytical Snap To Level is a productivity tool that moves analytical member endpoints to match a chosen level elevation. Instead of manually editing each beam or column's analytical representation, you can select multiple elements and snap them all to your target level at once. The tool intelligently handles different element types—beams snap both ends to the level, while columns only move the endpoint closest to your target elevation, preserving your column's span in the opposite direction. When to Use Scenario Description Model cleanup After importing or linking models where analytical elements don't align with levels Floor-by-floor coordination Ensuring all framing on a floor shares the same analytical elevation Post-modification fixes After moving levels or adjusting floor-to-floor heights New model setup Quickly establishing analytical geometry for freshly placed members QA/QC workflows Standardizing analytical model before running analysis or export Quick Start Select the analytical beams and/or columns you want to snap Click the \"Analytical Snap To Level\" button on the ribbon Choose your target level from the dialog Review the summary showing how many elements were processed User Interface Ribbon Button The Analytical Snap To Level button is located in the DB Tools ribbon tab. The button is enabled when you have a valid selection in an analytical model view. Level Picker Dialog After clicking the button, a dialog appears listing all levels in your project: Levels are sorted by elevation (lowest to highest) Each level shows its name and elevation value Select a single level as your snap target Click OK to proceed or Cancel to abort Supported Elements This tool works with analytical members only: Element Type Supported Notes Analytical Beams ✓ Includes girders and joists Analytical Columns ✓ Vertical framing members Analytical Braces ✗ Not supported Analytical Walls ✗ Not supported Analytical Floors ✗ Not supported Physical elements ✗ Select the analytical representation, not the physical model Note: If your selection includes unsupported elements, they will be skipped and reported in the summary. Snapping Behavior The tool handles beams and columns differently to produce structurally meaningful results: Beams Both endpoints move to the target level elevation. The beam becomes horizontal at the target level Use this to align framing to a consistent floor elevation Original beam length in plan is preserved Columns Only the closest endpoint moves to the target level. The tool determines which end (top or bottom) is nearest to your target level That endpoint snaps to the level; the opposite end stays fixed Column verticality and opposite connection are preserved Example: A column spanning from Level 1 to Level 2—if you snap to Level 2, only the top endpoint adjusts. If you snap to Level 1, only the bottom endpoint adjusts. Workflows Workflow 1: Align All Floor Framing Goal: Snap all beams on a floor to a single level elevation. Open your analytical model view for the target floor Use Select All or draw a crossing window to select all beams Click Analytical Snap To Level Select the floor level (e.g., \"Level 2\") Click OK Review the summary—all beams should now share the same elevation Workflow 2: Fix Column Tops After Level Change Goal: After adjusting a level's elevation, realign column tops. Select the columns that connect to the moved level Click Analytical Snap To Level Select the level you adjusted Click OK Column tops now match the new level elevation Workflow 3: Mixed Selection Cleanup Goal: Process a selection containing both beams and columns. Select all analytical members in an area (beams and columns together) Click Analytical Snap To Level Choose your target level Click OK Beams snap both ends; columns snap their nearest end Review the summary for any skipped elements Tips & Best Practices Work in analytical views — Selecting analytical members is easier when physical elements aren't competing for your click Use filters — Create selection filters for \"Analytical Beams\" or \"Analytical Columns\" to quickly grab what you need Process by floor — Work one floor at a time to maintain control and easily verify results Check before analysis — Run this tool as part of your pre-analysis QC checklist Verify column spans — After snapping columns, confirm they still connect to the correct levels at both ends Undo is available — The operation can be undone with Ctrl+Z if results aren't what you expected Troubleshooting Issue Cause Solution Button is grayed out No valid elements selected Select analytical beams or columns before clicking \"0 elements processed\" Selection contains no supported types Verify you selected analytical members, not physical elements Element didn't move Element may be constrained or locked Check for constraints on the analytical member Wrong endpoint moved (column) The other end was closer to target Choose a different target level, or manually adjust Beam tilted unexpectedly Endpoints were at different Z values This is expected—both ends now match the level Some elements skipped Braces, walls, or floors were in selection Only beams and columns are supported FAQ Q: Does this modify my physical model? A: No. This tool only adjusts the analytical model representation. Your physical beams and columns remain unchanged. Q: Can I snap to a reference plane instead of a level? A: No. The tool only supports levels defined in your project. Q: What happens if I select elements on multiple floors? A: All selected elements snap to the single level you choose. If you want different floors, process each floor separately. Q: Can I undo the snap operation? A: Yes. Use Ctrl+Z or the Undo button immediately after to reverse the changes. Q: Why don't braces work? A: Braces typically span between different elevations intentionally. Snapping both ends to one level would make them horizontal, which isn't typically desired. Brace endpoints should be adjusted manually. Q: Does this work in Revit LT? A: No. Revit LT does not include analytical model capabilities. Q: Can I snap to a specific elevation instead of a level? A: Not directly. Create a level at your desired elevation, then snap to that level."
  },
  "user-guide/tools/elements-from-list-3d.html": {
    "href": "user-guide/tools/elements-from-list-3d.html",
    "title": "3D Elements From List | DB Tools",
    "summary": "3D Elements From List Place family instances at precise coordinates using data from a CSV file, and create filled regions from existing elements for plan documentation. What is 3D Elements From List? 3D Elements From List is a set of two related commands that help you work with coordinate-based element placement and region creation: 3D Elements From List — Reads a CSV file containing X, Y, Z coordinates and places family instances at each location. This is ideal for importing point data from surveys, external calculations, or other software. Filled Regions From Elements — Converts selected walls or caissons into filled regions on your current view. Useful for creating simplified plan graphics or highlighting structural elements. When to Use Scenario Which Command Importing survey point locations 3D Elements From List Placing markers at calculated coordinates 3D Elements From List Bringing in caisson or pile locations from a spreadsheet 3D Elements From List Creating plan graphics from wall outlines Filled Regions From Elements Highlighting caisson locations on a floor plan Filled Regions From Elements Generating simplified structural diagrams Filled Regions From Elements Quick Start Placing Elements from CSV Prepare a CSV file with X, Y, Z coordinate columns Open your Revit project Click 3D Elements From List on the ribbon Select your CSV file when prompted Elements are placed at each coordinate location Creating Filled Regions Select the walls or caissons you want to convert Click Filled Regions From Elements on the ribbon Filled regions appear in the current view User Interface Ribbon Buttons Button Location When Available 3D Elements From List DB Tools ribbon Any time a document is open Filled Regions From Elements DB Tools ribbon When elements are selected CSV Format Your CSV file must include coordinate columns. The tool is flexible about formatting: Required Columns Column Description X X coordinate (East-West position) Y Y coordinate (North-South position) Z Z coordinate (elevation) Optional Columns Column Description ID Identifier for tracking or reference Format Rules Column headers are not case-sensitive — \"X\", \"x\", and \"X\" all work Columns can be in any order — the tool finds them by name Use standard CSV formatting — comma-separated values with headers in the first row Example CSV id,x,y,z P-001,100.5,200.0,0.0 P-002,150.75,200.0,0.0 P-003,100.5,250.25,0.0 P-004,150.75,250.25,0.0 Or with different column order: z,id,y,x 0.0,P-001,200.0,100.5 0.0,P-002,200.0,150.75 Workflows Importing Survey Points Export coordinates from your survey software as a CSV file Verify the CSV has X, Y, Z columns with headers in the first row Open your Revit project and navigate to the appropriate view Click 3D Elements From List on the ribbon Browse to your CSV file and select it Review the placed elements — the required family is loaded automatically if not already present Creating Plan Documentation from Caissons Open a floor plan or structural plan view Select the caisson elements you want to represent Click Filled Regions From Elements Circular filled regions appear matching the diameter of each caisson Adjust visibility in the view if needed Creating Wall Outlines for Diagrams Open the plan view where you want the regions Select the walls to convert Click Filled Regions From Elements Rectangular regions appear matching the wall bounding boxes Use these for simplified structural diagrams or area studies Tips & Best Practices Check your coordinate units — Ensure your CSV coordinates match your Revit project units Use the ID column — Including an ID helps you track which CSV row created which element Work in appropriate views — For filled regions, make sure you're in a plan view where the regions will be visible Select similar elements — When creating filled regions, select either walls OR caissons, not a mix, for consistent results Backup your CSV — Keep a copy of your original coordinate data for reference Troubleshooting Problem Solution \"Filled Regions From Elements\" button is grayed out Select at least one element first. The button only activates when elements are selected. Elements placed at wrong locations Check that your CSV coordinates are in the correct units and coordinate system for your project. CSV file won't load Verify the file has X, Y, Z column headers and is saved as a standard CSV (not Excel format). Missing column error Ensure your CSV has columns named X, Y, and Z (case doesn't matter, but the names must match). Filled regions not visible Check that you're in a plan view and that the filled region type visibility is turned on. Circular regions are wrong size Filled regions for caissons are based on the element's diameter property. Verify the caisson diameter is set correctly. FAQ Q: What family is used for placed elements? A: The tool uses a specific marker family that is automatically loaded into your project if it's not already present. Q: Can I use different coordinate systems? A: The coordinates in your CSV should match your Revit project's coordinate system. If you're using shared coordinates, make sure your CSV data aligns with that system. Q: What filled region type is created? A: The tool creates filled regions using the \"solid gray\" non-masking filled region type. Q: Can I change the filled region appearance? A: Yes, after creation you can select the filled regions and change their type or properties like any other Revit filled region. Q: How many points can I import at once? A: There's no hard limit, but very large CSV files may take longer to process. For thousands of points, expect a brief wait. Q: Does this work with linked models? A: The Filled Regions From Elements command works with elements in the current document. Elements in linked models must be selected through the link. Q: Can I undo the placement? A: Yes, both commands support standard Revit undo (Ctrl+Z)."
  },
  "user-guide/tools/elevation-tags.html": {
    "href": "user-guide/tools/elevation-tags.html",
    "title": "Elevation Tags | DB Tools",
    "summary": "Elevation Tags Elevation Tags keeps your spot elevation tags perfectly aligned and consistently positioned across all your floor and ceiling plan views. Whether you're documenting finished floor levels or ceiling heights, this tool eliminates the tedious manual adjustment of tag positions. What is Elevation Tags? Elevation Tags is an alignment tool that automatically positions spot elevation tags in your plan views. Instead of manually nudging each tag to maintain consistent text placement, Elevation Tags handles this automatically—either when you open a view or with a single button click. The tool works with spot elevation tags in floor plans and ceiling plans, ensuring that tag text appears in a uniform position relative to the tag's origin point. When to Use Scenario How Elevation Tags Helps Opening an existing floor plan Tags automatically align when the view activates After placing multiple spot elevations Run manual alignment to position all tags consistently Receiving a model from another team Quickly standardize tag positions across all views Preparing sheets for printing Ensure all elevation tags look professional and uniform After moving elements that tags reference Re-align tags that may have shifted Quick Start Open a floor plan or ceiling plan view in Revit If auto-update is enabled, tags align automatically when the view opens To manually align tags, click Align Elevation Tags on the DB Tools ribbon All matching elevation tags in the current view will snap to their aligned positions User Interface Ribbon Button The Align Elevation Tags button is located on the DB Tools ribbon tab. Click this button to immediately align all elevation tags in the current view. Settings Panel Access Elevation Tags settings through the DB Tools settings panel. Here you can configure: Whether tags align automatically when views open Which tag families the tool should process Text positioning preferences Fine-tuning offsets for precise placement Settings Auto-Update Enabled Default: On When enabled, Elevation Tags automatically aligns tags whenever you open or switch to a floor plan or ceiling plan view. Turn this off if you prefer to align tags only when you click the ribbon button. Tag Name Patterns Default: Tags starting with \"DB Elevation Tag\" Specifies which tag families Elevation Tags should process. You can configure up to three patterns to match your tag family names. Only tags matching these patterns will be aligned; other spot elevation tags remain untouched. Examples: Match all tags starting with \"DB Elevation Tag\" Match tags containing \"Spot Elev\" anywhere in the name Match a specific tag family name exactly Text Position Default: Above Controls whether tag text appears above or below the tag's origin point: Above — Text displays above the elevation marker Below — Text displays below the elevation marker Horizontal Offset Default: 0 Fine-tunes the horizontal position of tag text. Use positive values to shift text to the right, negative values to shift left. Adjust this if your tags need to clear nearby elements or align with a specific grid. Vertical Offset Default: 0 Fine-tunes the vertical position of tag text. Use positive values to shift text upward, negative values to shift downward. Helpful when you need extra clearance from the elevation marker. Workflows Aligning Tags in a Single View Open the floor plan or ceiling plan you want to process Click Align Elevation Tags on the DB Tools ribbon All matching tags in the view align to their configured positions Review the results and adjust settings if needed Setting Up Automatic Alignment Open DB Tools settings Navigate to Elevation Tags settings Ensure Auto-Update Enabled is turned on Configure your preferred tag patterns and positioning Close settings—tags will now align automatically when you open plan views Configuring Tag Patterns for Your Project Note the exact names of the elevation tag families you use Open Elevation Tags settings Enter patterns that match your tag family names Test by opening a view with those tags Adjust patterns if some tags aren't being processed Adjusting Tag Positioning Open a view with elevation tags Run Align Elevation Tags to see current positioning If text position needs adjustment, open settings Change Text Position to Above or Below as needed Adjust Horizontal Offset and Vertical Offset for fine-tuning Run alignment again to see the updated positions Tips & Best Practices Standardize tag families — Use consistent tag family names across your project so a single pattern can match them all Test patterns in one view first — Before enabling auto-update, manually run alignment in a test view to verify your patterns match the correct tags Use auto-update for active projects — Enable automatic alignment during active documentation phases to keep tags tidy as you work Disable for legacy projects — Turn off auto-update when working in older models where you don't want to change existing tag positions Coordinate with your team — Ensure everyone uses the same Elevation Tags settings for consistent results across the project Check ceiling plans too — Elevation Tags works in both floor plans and ceiling plans, so configure settings that work for both view types Troubleshooting Tags aren't aligning Possible causes: Tag family name doesn't match any configured patterns You're not in a floor plan or ceiling plan view The tags are a different family type than expected Solutions: Check your tag family names in the Project Browser Verify your tag patterns include the families you're using Ensure you're in a supported view type Some tags align but others don't Possible causes: Multiple tag families with different names Pattern only matches some of your tags Solutions: Review all elevation tag families in your project Add additional patterns to cover all tag families Use a broader pattern that matches multiple families Tags are positioned incorrectly Possible causes: Text position setting doesn't match your preference Offset values need adjustment Solutions: Change Text Position between Above and Below Adjust Horizontal and Vertical Offset values Run alignment again to see updated positions Auto-update isn't working Possible causes: Auto-Update Enabled is turned off Opening a view type that isn't supported Solutions: Check that Auto-Update Enabled is on in settings Verify you're opening floor plans or ceiling plans Getting too many alignment notifications Solution: Warnings can be disabled through the DB Tools warning system if alignment notifications become distracting FAQ Q: Which view types does Elevation Tags support? A: Elevation Tags works in floor plans and ceiling plans. It does not process tags in sections, elevations, 3D views, or other view types. Q: Will this affect tags I don't want to change? A: No. Only tags matching your configured patterns are processed. Other spot elevation tags remain exactly where they are. Q: Can I use different settings for different projects? A: Settings are stored per-user, so they apply across all projects. If you need different settings for different projects, you'll need to adjust them when switching projects. Q: What happens if I undo after alignment? A: Tag alignment changes can be undone using Revit's standard Undo command (Ctrl+Z). Q: Does this work with linked models? A: No. Elevation Tags only processes tags in the current active model, not in linked Revit files. Q: Can I align tags in multiple views at once? A: The manual command aligns tags in the current view only. However, with auto-update enabled, tags will align as you open each view. Q: How do I know which tags were aligned? A: The tool processes all matching tags in the view silently. If you need to verify, compare tag positions before and after running the command."
  },
  "user-guide/tools/foundation-tags.html": {
    "href": "user-guide/tools/foundation-tags.html",
    "title": "Foundation Tags | DB Tools",
    "summary": "Foundation Tags What is Foundation Tags? Foundation Tags is an automated tagging tool that labels structural foundations in your Revit model. Instead of manually placing tags on every footing, pier, or foundation wall, Foundation Tags does the work for you—placing consistent, properly formatted tags on all your foundations in seconds. The tool reads the foundation data directly from your model elements and creates tags that display the information your drawings need, whether that's size dimensions, mark numbers, or other structural properties. When to Use It Foundation Tags is ideal when you need to: Tag new foundations - After placing footings in your structural model, quickly tag them all at once Prepare foundation plans - Get consistent tags across all your foundation plan views Update after design changes - Re-tag foundations when sizes or marks have changed Standardize documentation - Ensure all foundation tags follow the same format across your project Quick Start Open a foundation plan view or any view showing foundations Launch Foundation Tags from the DB Tools ribbon Select which foundation types to tag Click Tag All to automatically place tags Review and adjust any tags that need repositioning Step-by-Step Workflows Auto-Tagging Foundations Tag all foundations in the current view: Open the view where you want tags placed Start the Foundation Tags tool In the dialog, select the foundation categories you want to tag: Structural Foundations (spread footings, isolated footings) Foundation Walls Piers/Columns Choose your tag family and type from the dropdown Click Tag All Tags are placed automatically at the center of each foundation Tag selected foundations only: Pre-select specific foundation elements in your view Start the Foundation Tags tool The tool will only tag your selected elements Click Tag Selected Tag Positioning Foundation Tags places tags at the geometric center of each foundation by default. You can adjust positioning: Default placement: Tags appear centered on the foundation Leader lines are not used by default With leaders: Enable the Use Leaders option for tags with leader lines Useful when foundations are closely spaced Leaders point to the foundation center After placement: Move individual tags as needed using standard Revit tag editing Tags maintain their association with the foundation element Updating Tags After Changes When foundation sizes or properties change: Delete and re-tag - Select existing tags, delete them, then run Foundation Tags again Revit's built-in update - If only parameter values changed (not geometry), tags update automatically If you've added new foundations to an existing tagged view: Run Foundation Tags again The tool will tag only untagged foundations Existing tags remain in place Supported Foundation Types Foundation Tags works with these Revit categories: Category Examples Structural Foundations Spread footings, isolated footings, mat foundations Wall Foundations Continuous footings, strip footings Structural Columns Piers, foundation piers Foundation Slabs Slab-on-grade (when modeled as foundation) The tool recognizes both system families and loadable foundation families. Settings Tag Family Selection Choose which tag family to use from families loaded in your project. Common options include: Structural Foundation Tag Foundation Tag with Size Mark Number Tag Tag Format Options Depending on your selected tag family, tags can display: Mark number - The foundation's mark value Size - Dimensions (width x length x depth) Type name - The foundation family type Custom parameters - Project-specific data Placement Options Option Description Tag untagged only Skip foundations that already have tags Include leaders Add leader lines from tag to element Tag orientation Horizontal or aligned with foundation Tips & Tricks Work in plan views - Foundation Tags works best in plan views where you can see all foundations clearly. Tags placed in 3D views may not appear correctly in plans. Check your tag family first - Make sure you have an appropriate foundation tag family loaded before running the tool. The tag family determines what information displays. Use view filters - If you only want to tag certain foundation types, use view filters to hide others before tagging. Tag by phase - Working on a phased project? Set your view phase correctly before tagging to ensure you're tagging foundations in the right phase. Batch process views - Need the same tags in multiple views? Run Foundation Tags in each view—it's fast enough to tag several views in under a minute. Troubleshooting No foundations are tagged Possible causes: No foundations visible in the current view Foundations are already tagged (and \"tag untagged only\" is enabled) No valid tag family is selected Solution: Check that foundations appear in your view and try selecting a different tag family. Tags appear in wrong location Possible causes: View scale affecting tag placement Foundation geometry is irregular Solution: Tags can be moved after placement. For irregular foundations, you may need to manually adjust tag positions. Tag shows \"?\" or missing data Possible causes: The foundation element is missing the parameter the tag is trying to display Tag family references a parameter that doesn't exist Solution: Check that your foundations have the required parameter filled in, or choose a different tag family. Some foundations not tagged Possible causes: Elements are in a different phase Elements are in a different workset (not loaded) Elements are not actual foundation category objects Solution: Check element properties to confirm they're structural foundations. Verify phase settings match the view. FAQ Can I tag foundations in 3D views? Yes, but it's not recommended. Tags placed in 3D views often don't translate well to documentation views. For best results, tag in plan views. Will tags update if I change the foundation size? Yes. Tags in Revit are linked to elements—if you change a parameter value that the tag displays, the tag updates automatically. Can I tag foundations across multiple levels at once? Foundation Tags works on the current view only. To tag foundations on multiple levels, run the tool in each level's foundation plan view. What if I don't have a foundation tag family loaded? You'll need to load one first. Foundation tag families are typically included in Revit's default structural templates, or you can create custom tag families for your firm's standards. Does this work with linked models? Foundation Tags works with foundations in the current model. Foundations in linked models need to be tagged in their host model or using Revit's tag-by-linked-element functionality. Can I customize what information the tag shows? The displayed information is controlled by the tag family, not this tool. To show different information, edit the tag family or create a new one with the parameters you need."
  },
  "user-guide/tools/framing-joins.html": {
    "href": "user-guide/tools/framing-joins.html",
    "title": "Framing Joins | DB Tools",
    "summary": "Framing Joins Framing Joins provides quick control over how structural framing elements connect to other elements in your model. With two simple commands, you can enable or disable joins at beam and brace endpoints—saving time compared to manually adjusting each connection through Revit's properties. What is Framing Joins? When structural framing elements (beams, braces, etc.) meet columns or other framing, Revit automatically joins their geometry. This joining behavior affects how elements display and export, but isn't always desirable. Framing Joins lets you toggle this behavior on or off for multiple elements at once, applying the change to both ends of each selected member. When to Use Scenario Recommended Action Beams cutting into columns unexpectedly Disallow Join Framing connections not displaying correctly Allow Join Preparing model for structural analysis export Disallow Join (for cleaner geometry) Restoring default connection behavior Allow Join Fixing display issues at beam-to-beam connections Toggle as needed Batch-processing multiple framing elements Either command on selection Quick Start Select one or more structural framing elements in your view Go to the DB Tools ribbon tab Click Allow Join or Disallow Join from the Framing Joins split button Review the summary showing how many elements were modified User Interface Framing Joins appears as a split button on the DB Tools ribbon. A split button has two parts: Top portion: Clicking here runs the currently displayed command (the last one you used) Drop-down arrow: Clicking the small arrow reveals both available commands Available Commands Command Icon Action Result Allow Join Enables joining Both ends of selected framing can connect to adjacent elements Disallow Join Disables joining Both ends of selected framing will not join to adjacent elements Availability The Framing Joins commands are only available when you have at least one structural framing element selected. If the button appears grayed out, check that your selection includes beams, braces, or other structural framing—not columns or other element types. Workflows Disabling Joins for Multiple Beams Use this workflow when beams are cutting into columns or creating unwanted geometry at connections. Select the framing elements Draw a selection box around the beams you want to modify, or Hold Ctrl and click individual beams to add them to your selection Filter your selection (if needed) If you selected other element types, use Revit's Filter tool to keep only structural framing Run the command Click the drop-down arrow on the Framing Joins button Select Disallow Join Confirm the results A message will display how many elements were modified Visually verify the connections now display as expected Restoring Join Behavior Use this workflow to re-enable default joining after previously disabling it. Select the affected framing elements Select beams that previously had joins disabled Run Allow Join Click Allow Join from the Framing Joins split button Verify the connections Check that geometry now joins properly at connections Processing an Entire Level Create a view filtered to structural framing Use a plan or 3D view showing only the level you need Select all visible framing Use Ctrl+A or draw a selection box around all elements Filter to structural framing only if needed Apply your desired join setting Click Allow Join or Disallow Join Review the summary The count should match the number of framing elements on that level Tips & Best Practices Work in appropriate views: Use plan views or filtered 3D views to easily select framing on specific levels Check your selection count: Before running the command, note how many elements are selected to verify the summary matches Use with selection filters: Combine with Revit's selection filter to target only beams or only braces Consider documentation impact: Join settings affect how framing appears in sections and details—verify documentation views after making changes Save before bulk operations: When modifying many elements, save your model first so you can revert if needed Both ends are affected: Remember that each command applies to both endpoints of every selected element—you cannot set different join states for each end using this tool Troubleshooting The button is grayed out Cause: No structural framing elements are selected. Solution: Select at least one beam, brace, or other structural framing element. Note that columns are not structural framing—they are a separate category. Elements weren't modified Cause: Your selection may have included elements that aren't structural framing. Solution: Check that you're selecting beams or braces, not columns, floors, or other element types. Use Revit's Filter command to verify your selection contents. Joins still appear after Disallow Join Cause: The visual representation in your view may not have updated, or the elements at the other end of the connection may still have joins allowed. Solution: Try refreshing the view (close and reopen, or zoom in/out) Check if the connecting elements also need their joins modified Verify you selected the correct elements Some elements changed but others didn't Cause: Only valid structural framing elements are processed. Solution: Elements that weren't modified may be different categories (like structural columns) or may already have had the join state you requested. Model performance after changes Cause: Changing join states on many elements may require Revit to regenerate geometry. Solution: This is normal behavior. Allow Revit to complete its processing. For very large selections, consider working in smaller batches. FAQ Q: Can I set different join states for each end of a beam? A: Not with this tool. Framing Joins applies the same setting to both ends of each selected element. To set different states for each end, use Revit's native properties for individual elements. Q: Does this work on structural columns? A: No. Framing Joins only operates on structural framing elements (beams, braces, joists, etc.). Structural columns are a separate category and require different methods to control their join behavior. Q: Will this affect my analytical model? A: The join setting primarily affects the physical geometry, not the analytical model. However, geometry changes could indirectly impact analysis if your analytical model is tied to physical geometry. Q: Can I undo this operation? A: Yes. Like most Revit operations, Framing Joins can be undone using Ctrl+Z or the Undo button. Q: How many elements can I process at once? A: There is no fixed limit. The tool will process all structural framing elements in your selection. For very large selections (hundreds of elements), expect the operation to take a few seconds. Q: What's the difference between this and Revit's native join controls? A: Revit allows you to control joins one element at a time through the properties palette or by right-clicking connection points. Framing Joins lets you change multiple elements at once and automatically applies to both ends of each element."
  },
  "user-guide/tools/gm.html": {
    "href": "user-guide/tools/gm.html",
    "title": "Global Mapper User Guide | DB Tools",
    "summary": "Global Mapper User Guide Global Mapper (GM) is a powerful tool for managing and replacing elements across your Revit project in bulk. Instead of manually swapping families, types, materials, or styles one by one, Global Mapper lets you plan and execute these changes all at once. What is Global Mapper? Think of Global Mapper as a \"find and replace\" tool for your Revit project, but much smarter. It can: Replace families and types - Swap out one family or type for another across your entire project Find duplicates - Identify similar elements that might be duplicates (like \"Wall Type 1\" and \"Wall Type 1 Copy\") Manage materials - Replace one material with another wherever it's used Handle line and object styles - Swap styling consistently throughout your project Work with shared parameters - Add or map shared parameters to families and categories The tool uses similarity matching to suggest the best replacement candidates, making bulk changes faster and less error-prone. When to Use Global Mapper Global Mapper is ideal for these common scenarios: Scenario How GM Helps Project cleanup Find and consolidate duplicate families, materials, and styles Standards migration Replace legacy families/types with company-standard versions Template updates Apply new material or style standards across the project Family consolidation Merge similar families into one, reducing project bloat Shared parameter rollout Add shared parameters to multiple families at once Pre-handoff cleanup Standardize elements before project delivery Quick Start Get started with Global Mapper in 5 steps: Step 1: Open Global Mapper Click the Global Mapper button on the DBTools ribbon in Revit. [Screenshot: GM button location on ribbon] Step 2: Select Your Category In the Families tab, use the category dropdown to select what type of elements you want to work with (Doors, Windows, Walls, etc.). [Screenshot: Category dropdown] Step 3: Find Elements to Replace Browse the list of families in your project. Each row shows: The family name (source) The number of instances in your project A dropdown to select what to replace it with (target) [Screenshot: Family list with source and target] Step 4: Select Targets Click the dropdown in the Target column to see replacement options. Options are sorted by similarity - the best matches appear at the top with higher percentages. Step 5: Apply Changes Check the Apply checkbox for each mapping you want to make Click the Apply button Review the mapping report Click Commit to apply changes (or Rollback to cancel) The Global Mapper Window When you open Global Mapper, you'll see a window with several main areas: [Screenshot: GM main window with labeled areas] Header Controls Located at the top of the window, these controls affect all tabs: Control What It Does Search box Filter the list by name - type to find specific elements Threshold slider Adjust how similar items need to be for auto-selection (0-100%) Sort mode Toggle between \"Similarity\" (best matches first) or \"Alphabetical\" Filters Show/hide items based on criteria like \"Applied only\" or \"Hide unused\" Main Tabs Global Mapper organizes your work into six tabs: Duplicates - Find and resolve potential duplicate elements Families - Map families and types to replacements Line Styles - Replace line styles Object Styles - Replace object styles Materials - Replace materials Shared Parameters - Manage shared parameter assignments Tab Guide Duplicates Tab The Duplicates tab automatically finds elements that might be duplicates based on name and property similarity. [Screenshot: Duplicates tab] How to use it: Click Run Scan to analyze your project Review the duplicate groups - each shows a source element and potential matches Check the Score column to see how similar items are (higher = more similar) Select which target to keep using the dropdown Check Apply to accept the consolidation Click Accept All to apply all suggestions in a group at once Understanding the columns: Column Description Kind Category of the duplicate (Families, Materials, etc.) Source The element that will be replaced Suggestions Number of potential replacement targets Highest Score Best match percentage Actions Buttons to accept or expand the group Tip: Adjust the threshold slider to control sensitivity. A lower threshold finds more potential duplicates; a higher threshold shows only very similar items. Families Tab The Families tab is where you map families and their types to replacement targets. [Screenshot: Families tab] Main list columns: Column Description Expand (+) Click to see details (types, materials, parameters) Quantity Number of instances of this family in the project Apply Check to include this mapping when applying changes Source The family name Target Dropdown to select the replacement family Working with families: Select a category from the dropdown at the top Find your source family in the list (use search to filter) Choose a target from the dropdown - options show similarity scores in color: Green = High similarity (good match) Orange = Medium similarity Red = Low similarity Check Apply to include this mapping Expanding family details: Click the + button to see: Types - Individual types within the family, with their own target mappings Object Styles - Styles used by this family Materials - Materials used by this family Parameters - Parameter names (for reference) [Screenshot: Expanded family row] Line Styles Tab Map line styles to different line styles across your project. [Screenshot: Line Styles tab] Columns: Column Description Apply Check to include this mapping Source The current line style Target The replacement line style Preview Visual preview of the style Tips: Line styles affect annotation elements, detail lines, and similar graphics Preview swatches help you visually compare source and target Object Styles Tab Map object styles (subcategory graphics) to different styles. [Screenshot: Object Styles tab] How it works: Object styles control the appearance of model elements by subcategory. Use this tab to: Standardize graphics settings across similar subcategories Replace custom object styles with standard ones Clean up unnecessary style variations Additional features: Families Using This Style - Select a style to see which families reference it Preview pane - Shows the visual appearance of selected styles Materials Tab Replace materials throughout your project. [Screenshot: Materials tab] Columns: Column Description Apply Check to include this mapping Source The material to replace Target The replacement material Color Preview Visual swatch showing the material color Families Count Number of families using this material Working with materials: Find the material you want to replace Select a target material from the dropdown The color preview helps you verify you're selecting the right material Check Apply and apply your changes Note: Material changes affect both appearance and any associated physical/thermal properties. Shared Parameters Tab Add shared parameters to families and categories, or map existing parameters to shared parameters. [Screenshot: Shared Parameters tab] Layout: The tab has two panels: Left panel - Browse shared parameter groups and definitions Right panel - See families and types that can receive these parameters How to use it: Select a parameter group from the left panel Select a category from the dropdown (Walls, Doors, etc.) Browse families and types in the right panel Expand a type to see: Existing parameters and their values Available shared parameters you can add Check Apply for each shared parameter you want to add Choose the binding mode: Host-level - Parameter added to the category (project parameter) Embed-in-family - Parameter added inside the family document Instance Navigator: When expanded, you can cycle through instances to see different parameter values: Use the left/right arrows to navigate between instances Click Zoom to Instance to navigate to it in a view Step-by-Step Workflows Workflow 1: Consolidating Duplicate Families Goal: Find and merge duplicate families to reduce project bloat. Open Global Mapper Go to the Duplicates tab Click Run Scan Wait for the analysis to complete Review the Families group For each duplicate group: Expand to see all candidates Check the similarity scores Select the target family you want to keep Check Apply on rows you want to consolidate Click Apply in the header Review the mapping report Click Commit to apply changes Tips: Start with high-similarity matches (90%+) which are almost certainly duplicates Lower the threshold to find more potential duplicates Use Accept All to quickly process obvious duplicates Workflow 2: Replacing a Family with a New Standard Goal: Replace an old family with a new company-standard family throughout the project. Open Global Mapper Go to the Families tab Select the appropriate Category (e.g., Doors) Find your old family in the list Click the Target dropdown Select your new standard family Click + to expand and verify type mappings: Map each old type to the corresponding new type Use for types you don't want to transfer Check Apply on the family row Click Apply in the header Review the mapping report - verify instance counts Click Commit to apply Workflow 3: Adding Shared Parameters to Families Goal: Add a shared parameter to multiple families at once. Open Global Mapper Go to the Shared Parameters tab In the left panel, select the parameter group containing your parameter In the right panel, select the Category (e.g., Mechanical Equipment) Expand the families you want to add the parameter to In the shared parameters section, check Apply for your parameter Choose the binding mode: Host-level for a project parameter (easier, affects category) Embed-in-family to add it directly to the family (requires family edit) Optionally, use Map From to copy values from an existing parameter Click Apply in the header Review and Commit Workflow 4: Standardizing Materials Goal: Replace multiple similar materials with a single standard material. Open Global Mapper Go to the Materials tab Use the Search box to find materials by name For each material you want to replace: Select the standard material in the Target dropdown Check Apply Alternatively, use the Duplicates tab to find similar materials automatically Click Apply in the header Review the mapping report to see affected elements Click Commit Settings and Options Similarity Threshold The threshold slider (0-100%) controls automatic target selection: Threshold Effect High (80-100%) Only very similar items are auto-selected; fewer suggestions Medium (50-79%) Balanced - good matches suggested with some flexibility Low (0-49%) More suggestions shown; useful for finding loose matches Note: Manual selections are never changed by threshold adjustments. Sort Mode Mode Description Similarity Best matches shown first, with color-coded similarity scores Alphabetical Items sorted A-Z; no similarity scoring displayed Filters Filter What It Does Hide Unused Hide elements with zero instances in the project Hide Unscanned Hide families that haven't been deep-scanned Applied Only Show only rows where Apply is checked Deep Scan Some family information (like embedded parameters and nested families) requires a deep scan - a more thorough analysis that opens the family document. When you need deep scan: Viewing parameter details for families with zero instances Getting accurate nested family information Seeing materials and styles used inside the family definition How to deep scan: Find a family row showing \"Scan required\" or missing details Click the Scan Family button in the expanded details Wait for the scan to complete (may take a few seconds) Details will populate once the scan finishes Note: Deep scan results are cached, so you only need to scan each family once per session. Tips and Tricks Power User Tips Use keyboard shortcuts Ctrl+F - Focus the search box Enter - Apply current selection Escape - Cancel and close dialogs Work in batches Check multiple rows, then apply all at once Use \"Accept All\" in duplicates for quick processing Preview before committing The mapping report shows exactly what will change Use Rollback if something looks wrong Save your progress Mapping preferences are saved per-project Reopen GM to see your previous selections Start with duplicates Running duplicate detection first helps identify obvious consolidations Accepted duplicates automatically lock related rows Best Practices Back up first - While GM supports rollback, always save your project before bulk changes Start small - Test with a few mappings before processing hundreds Verify visually - After applying, spot-check some instances in views Use filters - \"Applied Only\" filter helps review what you're about to change Check quantities - The instance count shows how many elements will be affected Troubleshooting Common Issues Problem Possible Cause Solution No families appear Wrong category selected Select a different category from the dropdown Target dropdown is empty No other families in category Load additional families into the project \"Scan required\" message Family needs deep scan Click \"Scan Family\" to analyze the family Apply button is disabled No mappings selected Check the Apply checkbox on at least one row Changes didn't take effect Rollback was clicked Re-apply and click Commit instead Some instances weren't replaced Type mapping incomplete Expand the family and verify all type mappings \"Locked by Families tab\" Nested mapping set elsewhere Change the mapping in the Families tab instead Error Messages Message What It Means What to Do \"Invalid mapping\" Source and target are the same Select a different target \"Target not available\" Target family/type was deleted Reload the family or choose a different target \"Deep scan failed\" Family document couldn't be opened Check if the family file is accessible \"Conflict detected\" Multiple sources map to the same target Resolve in the conflict panel If Global Mapper Won't Open Ensure a Revit document is open and active Check that DBTools is properly loaded (look for the ribbon tab) Restart Revit and try again Check the Revit journal file for error details Frequently Asked Questions General Questions Q: Can I undo changes made by Global Mapper? A: Yes, in two ways: Before clicking Commit, use Rollback to cancel all changes After committing, use Revit's standard Undo command Q: Will this affect linked files? A: No, Global Mapper only modifies elements in the current document, not linked files. Q: How long does applying changes take? A: It depends on the number of elements being modified. A few dozen changes are nearly instant; thousands may take several minutes. A progress overlay shows the current status. Q: Are my mapping preferences saved? A: Yes, your target selections are saved per-project. When you reopen Global Mapper, your previous selections appear (but Apply checkboxes are not automatically re-checked). Families Questions Q: What happens to parameters when I replace a family? A: Parameter values are preserved where possible. If the source and target have parameters with the same name and compatible types, values are transferred. Use the expanded type details to set up parameter mappings. Q: Can I replace a family with one from a different category? A: No, you can only replace families within the same category. This is a Revit limitation. Q: What if the target family doesn't have all the types I need? A: You can create new types directly in Global Mapper. In the expanded type mapping section, click New Type to create a type in the target family. Materials Questions Q: Will replacing a material change its appearance in renders? A: Yes, the replacement material's appearance will be used everywhere the original material was applied. Q: Can I preview materials before replacing? A: Yes, the color preview swatch shows each material's appearance. Select a row to see more details in the preview pane. Shared Parameters Questions Q: What's the difference between Host-level and Embed-in-family? A: Host-level creates a project parameter bound to a category. Easier to set up, but the parameter lives in the project, not the family. Embed-in-family adds the parameter directly to the family definition. Requires editing the family, but the parameter travels with the family to other projects. Q: Can I map an existing parameter to a shared parameter? A: Yes, use the \"Map From\" dropdown to select an existing parameter. Values will be copied from that parameter to the new shared parameter. Keyboard Shortcuts Shortcut Action Ctrl+F Focus search box Enter Confirm current action Escape Cancel/close dialog Tab Move between tabs Space Toggle Apply checkbox (when row selected) Getting Help If you encounter issues not covered in this guide: Check the DBTools log files for detailed error information Contact your BIM Manager or IT support Visit the DBTools support resources Summary Global Mapper streamlines bulk element management in Revit by providing: Intelligent matching - Similarity scoring suggests the best replacements Comprehensive coverage - Families, types, materials, styles, and parameters Safe workflow - Review before committing, with full rollback support Time savings - Replace hundreds of elements in minutes instead of hours Start with the Duplicates tab to find quick wins, then use the Families tab for targeted replacements. Remember to preview your changes in the mapping report before committing!"
  },
  "user-guide/tools/joist-girder-weight.html": {
    "href": "user-guide/tools/joist-girder-weight.html",
    "title": "Joist Girder Weight | DB Tools",
    "summary": "Joist Girder Weight Automatically estimate and update weight values for joist girder elements in your Revit model. This tool calculates approximate weights based on span, depth, number of panel points, and loading conditions—saving you time during design development and helping ensure your models reflect realistic structural weights. What is Joist Girder Weight? Joist Girder Weight is a calculation tool that estimates the self-weight of joist girder elements and writes that value directly to a weight parameter on each element. The tool uses industry-standard moment-based formulas to approximate joist girder weights based on your design parameters. The tool can run manually when you click the ribbon button, or automatically in the background whenever you switch views—keeping your weight values current as your design evolves. When to Use Scenario Description Early design development Get realistic weight estimates before final joist girder selection Load takeoffs Ensure self-weight values are populated for gravity load calculations Model audits Verify all joist girders have weight parameters filled in Design changes Update weights after modifying spans, depths, or loading Before documentation Confirm weight schedules show accurate values Quick Start Open a Revit model containing joist girder framing elements Ensure your joist girder families have the required parameters (see Family Requirements below) Go to the DB Tools ribbon tab Click Update Joist Girder Weights The tool processes all joist girders in the model and updates their weight parameters That's it! Check your joist girder schedules to confirm the weight values have been populated. User Interface Ribbon Button Location: DB Tools tab Button Name: Update Joist Girder Weights What it does: Scans your entire model for joist girder elements and calculates/updates the weight parameter for each one. A summary appears when processing is complete. Settings Auto-Update When enabled, the tool automatically recalculates joist girder weights whenever you activate a different view. This keeps weight values current without manual intervention. Setting Default Description Auto-Update Enabled On Automatically update weights on view change To change this setting: Access DB Tools settings through the ribbon. Toggle the auto-update option for Joist Girder Weight. Note: If you're experiencing performance issues with large models, consider disabling auto-update and running the tool manually when needed. Family Requirements For the tool to calculate and update weights, your joist girder families must include specific parameters. The tool recognizes several common parameter names for flexibility. Required Input Parameters Parameter Purpose Accepted Parameter Names Number of Joists Number of Joists, SpaceNum, Number of Equal Spaces Point Load Panel Point Load, Point Load, Total Load, Joist Load Length Length (standard Revit parameter) Depth Depth (standard Revit parameter) Required Output Parameter Parameter Requirements Wt Must exist and be writable (not read-only or formula-driven) Which Elements Are Processed? The tool targets Structural Framing elements where the family name or type name contains \"joist girder\" (case-insensitive). Elements that don't match this naming pattern are skipped. Workflows Workflow 1: Manual Weight Update Use this workflow when you want to update all joist girder weights at a specific point in your design process. Complete your joist girder layout and verify parameters are filled in Navigate to the DB Tools ribbon tab Click Update Joist Girder Weights Review the completion message for any skipped elements Open a joist girder schedule to verify weight values Workflow 2: Automatic Updates During Design Use this workflow for active design development when parameters change frequently. Ensure auto-update is enabled in DB Tools settings Work on your model as usual—place joist girders, adjust parameters Switch between views periodically (floor plans, sections, 3D) Weight values update automatically each time you change views Check schedules anytime to see current calculated weights Workflow 3: Preparing for Load Calculations Use this workflow before exporting data for structural analysis. Complete all joist girder placement and sizing Verify all required parameters are populated on each element Run Update Joist Girder Weights manually Review the results for any warnings or skipped elements Fix any elements with missing parameters and run again Export your schedule or proceed with analysis Tips & Best Practices Use consistent family naming: Include \"joist girder\" in your family or type names so the tool recognizes them automatically Populate parameters before running: The tool cannot calculate weights if input parameters (point load, number of joists, etc.) are missing or zero Check the Wt parameter setup: Ensure the Wt parameter is not driven by a formula—it must be writable for the tool to update it Run manually for large models: If you have hundreds of joist girders, consider disabling auto-update and running the tool manually to avoid slowdowns during view navigation Verify results periodically: Spot-check calculated weights against manufacturer tables to ensure reasonable values Create a QC schedule: Build a schedule showing joist girders with their input parameters and calculated weight to quickly identify incomplete elements Troubleshooting Weight not updating on specific elements Possible Cause Solution Family/type name doesn't contain \"joist girder\" Rename the family or type to include \"joist girder\" Missing input parameters Add the required parameters to your family Wt parameter is formula-driven Change the parameter to a simple value (remove formula) Wt parameter is read-only Check if parameter is shared and locked; recreate if needed Input parameter values are zero or blank Fill in the number of joists, point load, and verify length/depth Tool seems slow or causes lag Possible Cause Solution Auto-update running on large model Disable auto-update; run manually when needed Many joist girders being processed This is normal for large models; wait for completion Calculated weights seem incorrect Possible Cause Solution Wrong units on input parameters Verify parameter units match expected values Point load value is per-panel vs. total Check which parameter name you're using and ensure correct value type Depth parameter reading incorrectly Verify the family's depth parameter represents the actual joist girder depth Tool is disabled or won't run Possible Cause Solution Warning system has disabled the tool Check for warning messages; resolve any blocking issues No joist girder elements in model Place joist girder framing elements first FAQ Q: Does this tool work with all joist girder families? A: The tool works with any Structural Framing family where the name contains \"joist girder\" and includes the required parameters. It's designed to be flexible with parameter naming to accommodate different family standards. Q: How accurate are the calculated weights? A: The weights are estimates based on moment-based calculations using your design parameters. They're suitable for preliminary design and load takeoffs but should be verified against manufacturer specifications for final design. Q: Can I use this with nested joist girder families? A: The tool reads parameters from the placed family instance. If your nested family exposes the required parameters at the instance level, it should work correctly. Q: What happens if some joist girders are missing parameters? A: Those elements are skipped during processing. The tool will complete and report how many elements were processed successfully. Check the completion message for details. Q: Does the tool modify anything besides the Wt parameter? A: No. The tool only writes to the Wt parameter. All other parameters are read-only inputs to the calculation. Q: Can I undo the weight updates? A: Yes. Like other Revit modifications, the weight updates are part of Revit's undo history. Use Ctrl+Z or the Undo command to revert changes. Q: Why would I disable auto-update? A: Auto-update recalculates weights every time you switch views, which can cause brief pauses on large models. If you prefer snappier navigation, disable auto-update and run the tool manually when you need current values. Q: Does this work in workshared models? A: Yes. The tool updates elements you have permission to edit. Elements owned by other users or checked out to others cannot be updated until you have edit access."
  },
  "user-guide/tools/organize-foundation.html": {
    "href": "user-guide/tools/organize-foundation.html",
    "title": "Organize Foundation Types | DB Tools",
    "summary": "Organize Foundation Types Organize Foundation Types automatically standardizes the naming and type marks for all structural foundations in your Revit model. The tool processes foundation piers, round piers, rectangular footings, and pile caps—renaming them with consistent dimension-based names and assigning sequential type marks. What is Organize Foundation Types? This tool brings order to your foundation type library by: Standardizing names - Renames foundation types to show their actual dimensions in a consistent format Assigning type marks - Creates sequential marks like P-1, F-3.0, or CAP-4.0 for scheduling Merging duplicates - Identifies foundation types with identical dimensions and consolidates them into a single type The result is a clean, organized foundation schedule where every type has a clear, dimension-based name and a unique type mark. When to Use Scenario Why Use This Tool Starting a new project Establish consistent foundation naming from the beginning After importing foundations Clean up types brought in from linked models or other projects Before creating schedules Ensure all foundations have proper type marks for scheduling Foundation types have inconsistent names Standardize naming across the entire model Duplicate types exist Merge types that have the same dimensions but different names Preparing for documentation Create clean, professional foundation schedules Quick Start Open your Revit model containing structural foundations Click Organize Foundation Types on the DB Tools ribbon When prompted about overwriting existing type marks: Click Yes to regenerate all type marks from scratch Click No to keep existing marks and only process new types Review the results in your foundation schedule User Interface Ribbon Button The Organize Foundation Types button is located on the DB Tools ribbon tab. Click it to run the tool on all foundation types in the current model. Overwrite Prompt When you run the tool, a dialog asks: \"Overwrite existing type marks?\" Choice What Happens Yes All foundation type marks are regenerated. Use this when you want completely fresh, sequential numbering. No Existing type marks are preserved. Only foundation types without marks receive new ones. Use this to add marks to new types without disturbing existing ones. Supported Foundation Types The tool processes four categories of structural foundations: Foundation Type Family Name What Gets Processed Rectangular Piers Foundation Pier All pier types with rectangular sections Round Piers Foundation Pier - Round All pier types with circular sections Rectangular Footings Footing-Rectangular All rectangular spread footings Pile Caps Pile Cap-Rectangular All rectangular pile cap types Note: Foundation types using other family names will not be processed by this tool. Naming Conventions Each foundation type is renamed to clearly show its dimensions: Foundation Type Naming Format Example Rectangular Pier Width x Depth (Mark) 2'-6\"x2'-6\" (P-1) Round Pier Diameter DIA. (Mark) 2'-0\" DIA. (RP-1) Rectangular Footing Width x Length x Thickness (Mark) 3'-0\"x3'-0\"x1'-0\" (F-3.0) Pile Cap Width x Length x Thickness (Mark) 4'-0\"x4'-0\"x2'-0\" (CAP-4.0) The type mark is included in parentheses at the end of each name, making it easy to identify types in the Project Browser and schedules. Type Mark Format Type marks follow a prefix-number pattern based on foundation category: Category Prefix Format Examples Rectangular Piers P P-# P-1, P-2, P-3 Round Piers RP RP-# RP-1, RP-2, RP-3 Rectangular Footings F F-#.# F-3.0, F-3.1, F-3.2 Pile Caps CAP CAP-#.# CAP-4.0, CAP-4.1 Sorting Order Type marks are assigned based on size: Piers - Sorted by section area (width × depth), smallest first Round Piers - Sorted by diameter, smallest first Footings and Pile Caps - Sorted by width, then length, then thickness This means smaller foundations receive lower numbers, making it intuitive to understand relative sizes from the type mark alone. Duplicate Merging When the tool finds multiple foundation types with identical dimensions, it merges them: Identifies duplicates - Types with the same width, length, and thickness (or diameter for round piers) Keeps one type - The tool retains one type and transfers all instances to it Deletes extras - Redundant types are removed from the project Example Before running the tool: Footing 1 - 3'-0\" × 3'-0\" × 1'-0\" Spread Footing A - 3'-0\" × 3'-0\" × 1'-0\" Copy of Footing 1 - 3'-0\" × 3'-0\" × 1'-0\" After running the tool: 3'-0\"x3'-0\"x1'-0\" (F-3.0) - Contains all instances from the three original types Workflows Workflow 1: Clean Up an Existing Model Goal: Standardize foundation naming in a model with inconsistent types. Save your model (recommended before any batch operation) Click Organize Foundation Types Click Yes to overwrite existing type marks Open a foundation schedule to verify the results Check the Project Browser to confirm types are renamed Workflow 2: Add Type Marks to New Foundations Only Goal: Assign marks to recently added foundation types without changing existing ones. Click Organize Foundation Types Click No to preserve existing type marks Only foundation types without marks will receive new ones Review the schedule to confirm new marks were assigned Workflow 3: Prepare Foundations for Documentation Goal: Create clean foundation schedules for construction documents. Run Organize Foundation Types with Yes to overwrite Create or update your foundation schedule Add the Type Mark field to the schedule Type marks will display as P-1, F-3.0, etc. Sort the schedule by Type Mark for organized output Tips & Best Practices Run early in the project - Establishing consistent naming early prevents confusion later Use \"Yes\" for full cleanup - When inheriting a model or after major imports, regenerate all marks for consistency Use \"No\" for incremental updates - When adding a few new types to an established project, preserve existing marks Check schedules after running - Verify that all foundation types appear correctly in your schedules Coordinate with the team - Let team members know when you've reorganized types, as their views may update Troubleshooting Issue Cause Solution Some foundations weren't renamed The family name doesn't match supported types Check that foundations use the standard family names listed in Supported Foundation Types Type marks appear out of order You selected \"No\" to preserve existing marks Run again with \"Yes\" to regenerate all marks in sequence Duplicate types still exist Types have slightly different dimensions Check dimensions carefully—even 1/16\" difference creates separate types Foundation schedule is empty Schedule filters may exclude renamed types Update schedule filters to include the new type names Instances moved unexpectedly Duplicate types were merged This is expected behavior—instances transfer to the kept type FAQ Q: Will this tool modify placed foundation instances? A: No. The tool only modifies foundation types (names and type marks). All placed instances remain in their locations unchanged. If duplicate types are merged, instances are reassigned to the remaining type but stay in place. Q: What happens to foundation types I've customized? A: Custom parameter values are preserved. Only the type name and type mark are modified. Q: Can I undo the changes? A: Yes. Use Revit's Undo command (Ctrl+Z) immediately after running the tool to revert all changes. Q: Does this work with foundation families I've created? A: Only if your custom families use the exact family names listed in Supported Foundation Types. Families with different names are not processed. Q: How do I add a foundation type without disrupting existing marks? A: Create your new foundation type, then run the tool and select \"No\" when prompted about overwriting. The new type will receive the next available mark. Q: Why do footings use decimal marks (F-3.0) while piers use whole numbers (P-1)? A: This is a convention to help distinguish foundation categories at a glance. The decimal format for footings and pile caps also allows for potential sub-numbering. Q: Will linked model foundations be affected? A: No. The tool only processes foundation types in the current active model. Linked models are not modified."
  },
  "user-guide/tools/sgt.html": {
    "href": "user-guide/tools/sgt.html",
    "title": "Super Girt Tool (SGT) | DB Tools",
    "summary": "Super Girt Tool (SGT) The Super Girt Tool automates the placement of horizontal girts and opening framing (headers, sills, and jambs) on foundation walls. Instead of manually placing each structural member one at a time, SGT lets you configure an entire wall's worth of girts in one operation. When to Use It Use the Super Girt Tool when you need to: Add horizontal girt members to a foundation wall at regular spacing Frame out openings (doors, windows, penetrations) with headers, sills, and jambs Place multiple girt rows at once instead of one-by-one Ensure consistent spacing and alignment across a wall Edit or update previously placed girt systems Common scenarios: Scenario SGT Helps By... New foundation wall with multiple window openings Auto-detecting openings and framing them Girts at 5'-0\" vertical spacing Pre-seeding rows at correct intervals Mixed girt sizes at different elevations Configuring each row independently Updating girt types after initial placement Editing the existing system in place Quick Start Basic workflow in 4 steps: Launch - Click \"Super Girt Tool\" from the DB Tools ribbon tab Select Wall - Pick the foundation wall or linked wall you want to frame Configure - Adjust girt elevations, types, and opening framing as needed Place - Click \"Place\" to create all the structural members That's it for basic use. The tool handles the technical details of rotation, justification, and positioning automatically. The SGT Window When you launch SGT and select a wall, the main window appears with these sections: Top Bar Control Purpose Offset Distance from the wall face to place girts (0'-0\" means directly on the target layer) Layer Which wall layer to align girts to (for compound walls with multiple layers) Girt Elevations Section This is where you configure your horizontal girts. Each row represents one girt at a specific elevation. Column What It Does Elevation Height above the base reference (editable) Girt Type Family and type to use (e.g., \"C Shapes : C10X15.3\") Rotation Cross-section rotation (0, 90, 180, or 270 degrees) Y-Just Lateral positioning (Left, Center, Right, Origin) Z-Just Vertical positioning (Top, Middle, Bottom, Origin) Flip Mirror the member orientation if needed Left Extent Where the girt starts - Full Length or at a grid line Right Extent Where the girt ends - Full Length or at a grid line Add Row: Type an elevation in the \"Add\" field and click \"Add\" to create a new girt row. Openings Section This section shows detected openings (in Linked mode) or manually added openings (in Foundation mode). Column What It Does Opening Name/ID of the opening Center Along Horizontal position along the wall Center Elevation Vertical center of the opening Width Opening width Height Opening height Left Jamb Enable/disable left vertical framing Right Jamb Enable/disable right vertical framing Header Enable/disable top horizontal framing Sill Enable/disable bottom horizontal framing Preview Panel (Right Side) Shows a live preview of what will be placed: Elevation - Front view showing girts and openings Section - Cross-section view showing member profiles 3D - Interactive 3D view you can orbit and zoom The Role Palette shows what each color represents: Blue = Girts Green = Headers Orange = Sills Purple = Left Jambs Cyan = Right Jambs Bottom Bar Button Action Cancel Close without placing anything Place Create all configured members in Revit Update (Edit mode) Update existing members Remove (Edit mode) Delete the entire girt system Step-by-Step Workflows Creating a New Girt Plan Launch the tool Go to the DB Tools ribbon tab Click \"Super Girt Tool\" Select your wall A prompt appears asking you to select a wall Click on a foundation wall or linked wall The tool analyzes the wall and populates the window Review auto-seeded girts SGT automatically creates girt rows at approximately 5'-0\" spacing Review the elevations and adjust as needed Change girt types if you need different sizes at certain elevations Configure openings (if any) Linked walls: Openings are auto-detected Foundation walls: Click \"Add Opening\" to manually define openings Check/uncheck the boxes for which framing members you want Preview your layout Switch between Elevation, Section, and 3D views Verify everything looks correct before placing Place the girts Click \"Place\" The tool creates all members in Revit Adjusting Girt Elevations To change an existing row's elevation: Click in the Elevation cell for that row Type the new elevation (e.g., \"7'-6\"\") Press Enter - the preview updates automatically To add a new girt at a specific elevation: Find the \"Add\" field at the bottom of the Girt Elevations section Type your elevation (e.g., \"12'-0\"\") Click \"Add\" A new row appears with default settings To remove a girt row: Select the row Press Delete (or right-click and choose Remove) Working with Grid Extents If your project has grids that intersect the wall, you can limit girts to specific grid-to-grid spans: Look at the \"Left Extent\" and \"Right Extent\" columns By default, both show \"Full Length\" (wall end to wall end) Click the dropdown to see available grid lines Select a grid to start or end the girt at that location Example: A wall runs from Grid A to Grid D, but you only want girts between Grid B and Grid C: Set Left Extent to \"Grid B\" Set Right Extent to \"Grid C\" Configuring Opening Framing For each opening, you control which framing members are created: Member When to Use Header Almost always - provides support above the opening Sill Usually for windows; often omitted for doors at grade Left/Right Jambs Usually both enabled; disable if opening is at wall end To customize an opening's framing: Find the opening in the Openings section Check/uncheck the boxes for Header, Sill, Left Jamb, Right Jamb The preview updates to show your changes Editing an Existing Girt System If you've already placed girts using SGT, you can edit them: Select any girt from the system in Revit The \"Modify - Structural Framing\" tab appears Click \"Edit SGT Wall\" (only visible when SGT members are selected) The SGT window opens with your existing configuration Make changes as needed Click \"Update\" to apply changes, or \"Remove\" to delete everything Settings Explained Offset The offset controls how far from the wall's target layer the girts are placed: 0'-0\" = Girt exterior flange is directly on the target layer face Positive values = Girts are offset outward from the wall Negative values = Girts are offset inward into the wall Layer (Compound Walls) For walls with multiple layers (e.g., concrete + insulation + finish), the Layer dropdown lets you choose which layer surface the girts align to: The tool defaults to the most-exterior structural layer Change this if you need girts on a different layer face Rotation Rotation controls how the girt cross-section is oriented: 0 = Default orientation (web vertical, flanges horizontal) 90 = Rotated 90 degrees 180 = Flipped from default 270 = Rotated 270 degrees (same as -90) Most C-channels and I-beams use 0 or 180 rotation for horizontal girts. Y-Justification Controls lateral positioning of the member: Left = Member shifted toward wall start Center = Member centered on the placement line Right = Member shifted toward wall end Origin = Uses the family's origin point Z-Justification Controls vertical positioning of the member: Top = Top of member at the elevation Middle = Center of member at the elevation Bottom = Bottom of member at the elevation Origin = Uses the family's origin point Flip Mirrors the member. Useful when the auto-detected orientation isn't what you need. Tips and Tricks Keyboard Shortcuts Tab - Move to next cell in the grid Enter - Confirm an edit and move down Delete - Remove selected row Escape - Cancel current edit Efficient Workflows Start with defaults, then refine Let SGT auto-seed the girt rows first Then adjust individual rows as needed Use the preview constantly Switch to 3D view to check member orientations Elevation view shows the overall layout quickly Work from bottom to top Configure lower girts first They're less likely to change if you add/remove upper girts Batch similar changes If multiple rows need the same girt type, change them together Multi-select rows in the grid when possible Performance Tips For large walls with many openings, the analysis step may take a moment The progress overlay shows which step is running Don't close the window during analysis - let it complete Troubleshooting \"No structural framing families found\" Cause: Your project doesn't have any structural framing families loaded. Fix: Load at least one structural framing family (like C Shapes or W Shapes) before using SGT. Girts not appearing at expected location Possible causes: Wrong wall layer selected Offset value is pushing girts off the visible area Rotation/justification settings are incorrect Fix: Check the Layer dropdown - make sure you've selected the correct layer Verify the Offset is 0'-0\" or a small value Try switching to 3D preview to see where members actually are Preview shows nothing Possible causes: No girt rows configured All opening checkboxes are unchecked Analysis failed silently Fix: Make sure at least one girt row exists with a valid type selected Check that at least one opening role (Header/Sill/Jamb) is enabled Close and reopen the tool to re-run analysis \"Place\" button is disabled Cause: There's nothing to place - either no girt rows or all rows have invalid settings. Fix: Add at least one girt row Make sure each row has a girt type selected Ensure elevations are valid numbers Girts placed but openings not framed Cause: Opening checkboxes were unchecked, or openings weren't detected. Fix: In Edit mode, check the Openings section Enable the checkboxes for Header, Sill, Left Jamb, Right Jamb as needed Click Update Members have wrong orientation Cause: Auto-detected rotation/justification doesn't match your intent. Fix: Try toggling the \"Flip\" checkbox for that row Change the Rotation value (try 0, 90, 180, 270) Adjust Y-Just and Z-Just if the member position is off Can't edit existing SGT system Cause: You may have selected non-SGT members, or members from a different system. Fix: Make sure you select a member that was placed by SGT If you have multiple SGT systems on different walls, select from the correct wall FAQ Q: Can I use SGT on any wall type? A: SGT works best on foundation walls and linked architectural walls. It's designed for walls where you need horizontal girts at regular intervals. Q: What structural framing families are supported? A: Any standard structural framing family should work, including: C Shapes (channels) W Shapes (wide flanges) HSS (hollow structural sections) Angles Z-shapes are supported for girts only (not for opening framing). Q: Can I have different girt types at different elevations? A: Yes! Each row is independent. You can use C10X15.3 at 0'-0\", C8X11.5 at 5'-0\", etc. Q: What happens if I change the wall after placing girts? A: The girts don't automatically update. You'll need to use Edit mode to adjust or remove and re-place. Q: Can I place girts on only part of a wall? A: Yes, use the Left Extent and Right Extent options to limit girts to a portion of the wall length. Q: Do girts automatically avoid openings? A: Yes. When you place girts, they automatically segment around openings with proper gaps. Q: What's the minimum girt length? A: Girts must be at least 6\" (0.5 ft) long. Shorter segments are rejected. Q: Can I use SGT on curved walls? A: SGT is designed for straight walls. Curved walls are not currently supported. Q: How do I delete all SGT members from a wall? A: Select any SGT member from that wall Click \"Edit SGT Wall\" Click \"Remove\" This deletes the entire girt system for that wall. Q: Why are some rotation/justification options grayed out? A: Some combinations don't produce valid placements (member would be off the wall or incorrectly oriented). SGT disables invalid options automatically."
  },
  "user-guide/tools/tdv.html": {
    "href": "user-guide/tools/tdv.html",
    "title": "Transfer Drafting Views (TDV) | DB Tools",
    "summary": "Transfer Drafting Views (TDV) Transfer Drafting Views (TDV) lets you share drafting views between Revit projects using a central library file. Instead of recreating standard details from scratch in every project, you can import them from your team's shared library - or contribute new views back to that library for others to use. When to Use It TDV is helpful when you need to: Import standard details into a new project from your team's library Share drafting views you've created with the rest of your team Standardize details across multiple projects Back up important drafting views to a central location Migrate drafting views between projects without copy/paste hassles Quick Start Importing Views Open your project in Revit Go to the DB Tools ribbon tab Click Import From Library Select a library file from the list Check the views you want to import Click Transfer Selected Exporting Views Open the project containing the views you want to share Go to the DB Tools ribbon tab Click Export To Library Select which library to export to Check the views you want to export Click Transfer Selected The TDV Window When you click Import or Export, the Transfer Drafting Views window opens with these main areas: +------------------------------------------------------------------+ | [View Type Filter v] [Search________________] [Clear] [Transfer]| +------------------------------------------------------------------+ | Warning Bar (appears if there are naming conflicts) | +------------------------------------------------------------------+ | Views List | Preview Panel | | +------------------------------------+ | +------------------+ | | | [ ] View Name Replace Type | | | | | | | [ ] Standard Detail A [ ] Type1| | | (Preview of | | | | [X] Standard Detail B [X] Type1| | | selected view) | | | | [ ] Standard Detail C [ ] Type2| | | | | | +------------------------------------+ | +------------------+ | +------------------------------------------------------------------+ | Status: Selected: 1 | Replace: 1 | Adds: 0 | +------------------------------------------------------------------+ Toolbar Control Purpose View Type dropdown Filter views by their drafting view type Search box Type to filter views by name Clear Selection Uncheck all selected views Transfer Selected Start the transfer operation Views List Columns Column Description Status icon Shows transfer result: checkmark (success), X (failed), or warning (conflict) Transfer checkbox Check to include this view in the transfer View Name The name of the drafting view (click to edit before transfer) Replace Check to overwrite an existing view with the same name View Type Select which view type to use in the destination Preview Panel Shows a preview image of the currently selected view Use your mouse to pan and zoom Click Reset View to return to the default zoom level Status Bar Shows counts of: Selected - How many views you've checked Replace - How many will replace existing views Adds - How many are new views After a transfer, shows the results summary. Step-by-Step Workflows Importing Drafting Views from the Library Scenario: You're starting a new project and need to import standard details from your team's library. Open your project in Revit Click Import From Library on the DB Tools ribbon Select a library file - if you have multiple libraries configured, choose the one you want Find the views you need: Use the View Type filter to show only certain types Type in the Search box to find views by name Check the views you want to import Review for conflicts: If a view name already exists in your project, you'll see a warning Either rename the view (click the name to edit) or check Replace to overwrite the existing view Choose view types (optional): By default, views keep their original type (\"Retain Original\") Use the View Type dropdown to assign a different type from your project Click Transfer Selected Wait for the transfer to complete - progress is shown for each view Review the results summary Exporting Views to the Library Scenario: You've created a new standard detail that should be available to all projects. Open the project containing your drafting view Click Export To Library on the DB Tools ribbon Select the library file to export to Find your views: Use filters and search to locate the views Check the views you want to export Handle existing views: If a view with the same name exists in the library: Rename your view to add it as a new view, OR Check Replace to update the library version Click Transfer Selected Wait for the export and sync to complete The library file is automatically synced back to central Replacing an Existing Library View Scenario: You've improved a standard detail and want to update the library. Click Export To Library Find your updated view in the list Check the view's Transfer checkbox Check the Replace checkbox Click Transfer Selected The old version in the library is replaced with your new version Importing with Different View Types Scenario: Your project uses different drafting view types than the library. Click Import From Library Check the views you want In the View Type column, select the appropriate type from your project If a type doesn't exist in your project, TDV will create it Click Transfer Selected Settings Configuring Library Files TDV needs to know where your library files are located. To configure: Open DB Tools Settings (click the settings icon on the DB Tools ribbon) Find the Library Files section Click Add to add a library file path Browse to your .rvt library file (Optional) Add a fallback path for users on different networks Click Save Library File Options Setting Description Main Path Primary path to your library .rvt file Fallback Path Alternative path (e.g., if users access from different networks) Multiple Libraries You can configure multiple library files - for example: One for company-wide standard details One for project-specific details One for experimental/draft details When you run Import or Export, you'll choose which library to use. Tips & Tricks Naming Conventions Use consistent, descriptive names for drafting views Include the detail type, scale, or category in the name Example: STD-DETAIL-FOUNDATION-WALL-1X1 Organizing Your Library Keep one \"master\" library file for company standards Periodically clean up unused or outdated views Use clear view type names to categorize details Batch Operations You can select multiple views at once for transfer Use the View Type filter to quickly select all views of a certain type Check multiple views, then use the View Type dropdown to assign the same type to all Keyboard Shortcuts Tab moves between fields in the grid Space toggles checkboxes when a row is selected Ctrl+F focuses the search box Preview Navigation Scroll wheel - Zoom in/out Click and drag - Pan around Reset View button - Return to default zoom Troubleshooting \"No library files configured\" Problem: You see an error that no library files are configured. Solution: Go to DB Tools Settings and add at least one library file path. \"Library file is inaccessible\" Problem: A library file can't be opened. Solution: Check that the file path is correct Verify you have network access to the file location Make sure the file isn't open exclusively by another user Try the fallback path if configured Name conflict warning Problem: Yellow warning bar appears saying views have naming conflicts. Solution: For each conflicting view, either: Edit the view name to something unique Check the Replace checkbox to overwrite the existing view View type not available Problem: You see a warning icon next to a view, and the tooltip says the source type name is unavailable. Solution: Select a specific view type from the dropdown instead of \"Retain Original\". Transfer fails for some views Problem: Some views show a red X after transfer. Solution: Click on the failed view to see the error details Common issues: View type doesn't exist and couldn't be created Elements couldn't be copied (may have missing families) Network issues during sync Changes don't appear in library after export Problem: You exported views but they don't appear when others import. Solution: Ensure the sync to central completed successfully Check the results dialog for any sync errors Have other users reload from central Frequently Asked Questions What gets transferred? TDV copies: All detail lines, text, and annotation elements in the view The view scale The view description Graphic overrides on elements TDV does not copy: Viewports Title blocks Schedules placed on the view View templates (the view type is copied, but not a view template assignment) Can I undo a transfer? For imports: Yes, use Revit's Undo command immediately after the transfer. For exports: No, once synced to central, changes can't be undone. However, you could import the old version back from a backup. Does TDV work with workshared files? Yes. TDV: Creates a local copy of the library file for operations Automatically syncs changes back to central after exports Handles worksharing transparently Can multiple people use the same library at once? Yes, because TDV creates local copies for each operation. However: If two people export different views to the same library simultaneously, one sync might fail Best practice: Coordinate export timing with your team What happens if a family is missing? If the source view contains elements from a family that doesn't exist in the destination: Revit will attempt to copy the family along with the elements If the family can't be copied, those elements will be skipped You'll see a warning in the transfer results Can I transfer views between different Revit versions? Yes, as long as: Both the project and library are compatible with your Revit version The library file is the same version or older than your project How do I create a new library file? Create a new Revit project (you can use the default template) Save it as a central file on your shared network location Add drafting view types as needed Add the file path to TDV settings Use Export to add views to your new library Why is the preview blank? The preview may be blank if: No view is selected in the list The view is empty (no elements) The view couldn't be exported to an image (try selecting a different view) Can I rename views during transfer? Yes! Click on the view name in the list to edit it before transferring. The new name will be used in the destination. For technical details about how TDV works, see the Developer Guide - TDV."
  },
  "user-guide/tools/vtc.html": {
    "href": "user-guide/tools/vtc.html",
    "title": "View Template Comparer (VTC) | DB Tools",
    "summary": "View Template Comparer (VTC) View Template Comparer provides side-by-side comparison of Revit view templates, highlighting differences and enabling selective merging of settings between templates. Whether you're standardizing templates across projects, troubleshooting visibility issues, or transferring templates between documents, VTC makes the process visual and intuitive. What is View Template Comparer? View Template Comparer is a tool that lets you select two view templates and see exactly what's different between them. Instead of manually clicking through template dialogs and comparing settings one by one, VTC displays everything in a tree view with color-coded highlighting showing which settings match, which differ, and which exist in only one template. Beyond comparison, VTC enables you to merge settings selectively—picking individual options from either template to create your ideal configuration. You can apply changes to existing templates or create entirely new merged templates. When to Use Scenario How VTC Helps Template troubleshooting \"Why does this view look different?\" Compare the template against a working one to spot the difference Standardization Compare office standard templates against project templates to identify deviations Template updates See what changed between an old and new version of a standard template Cross-project transfer Export templates to JSON for importing into other projects Template creation Start with an existing template and selectively modify settings to create a new one Documentation Generate text dumps of template settings for review or records Template backup Save templates to the local library before making changes Quick Start Click View Template Comparer on the DB Tools ribbon In the left dropdown, select Template A (your baseline) In the right dropdown, select Template B (the one to compare) Click Compare Review the diff tree—expand categories to see individual settings Optionally select settings and use Apply or Create Merged to make changes User Interface Main Window The VTC window is organized into distinct areas: Template Selection Bar Two dropdown menus at the top for selecting Template A (left) and Template B (right) Compare button to run the comparison Swap button to switch which template is on which side Diff Tree The main area displays comparison results in an expandable tree structure: Display Properties — Detail level, display style, parts visibility, and similar view settings Template Parameters — Which parameters the template controls vs. leaves uncontrolled Category Overrides — Per-category visibility and graphics settings Filter Overrides — Applied view filters and their configurations Action Buttons Located at the bottom of the window: Apply to A / Apply to B Create Merged Template Export / Import options Library access Status Bar Shows summary counts: how many settings are the same, different, or missing from each side. Comparison View Understanding the Diff Display Each row in the tree shows a setting with its values from both templates. Color coding makes differences immediately visible: Color/Icon Meaning No highlight Values are identical in both templates Yellow highlight Values differ between templates Left arrow (←) Setting exists only in Template A Right arrow (→) Setting exists only in Template B Tree Structure The comparison organizes settings into logical groups: Display Properties Detail Level (Coarse, Medium, Fine) Display Style (Wireframe, Hidden Line, Shaded, etc.) Parts Visibility Crop Region Visible And other view display settings Template Parameters Shows which parameters the template controls. A checkmark means the template enforces that setting; unchecked means views can override it. Category Overrides Expandable list of all model and annotation categories showing: Visibility (on/off) Projection lines (weight, color, pattern) Cut lines (weight, color, pattern) Surface patterns and colors Transparency Filter Overrides Lists each view filter applied to the template with: Filter visibility Projection/cut overrides Halftone settings Selecting Settings Click on any row to select it. Use Ctrl+click for multiple selections or Shift+click for ranges. Selected settings can be applied or merged. Merge Operations Apply to A / Apply to B Updates an existing template with selected settings from the other template. Apply to A: Takes selected values from Template B and writes them to Template A Apply to B: Takes selected values from Template A and writes them to Template B Steps: Select the settings you want to transfer (click rows in the tree) Click Apply to A or Apply to B Confirm the operation The target template is updated in the document Create Merged Template Creates a new template combining selections from both sources. Steps: Select the settings you want in your new template Click Create Merged Template Enter a name for the new template Choose which base template to start from (A or B) Click Create The new template appears in your document's view templates list. Export / Import JSON Export Exports template settings to a JSON file that can be imported into other Revit documents. Select a template (or compare two and select specific settings) Click Export → JSON Choose a save location The file contains all exportable template settings JSON Import Imports template settings from a previously exported JSON file. Click Import → JSON Browse to the JSON file Choose whether to create a new template or update an existing one If creating new, enter a template name Click Import Note: Some settings may not transfer if the target document lacks matching categories or filters. VTC will report any skipped settings. Text Dump Generates a human-readable text file listing all template settings—useful for documentation, review meetings, or archival purposes. Select the template(s) to document Click Export → Text Dump Choose a save location Open the resulting text file in any text editor Template Library The Template Library is a local storage area where you can save templates for later use or transfer between sessions. Saving to Library Select a template in the comparison view Click Save to Library Optionally edit the name or add notes Click Save Templates are stored on your computer and persist between Revit sessions. Loading from Library Click Load from Library Browse your saved templates Select one and click Load Choose to create a new template or compare against the current selection Library Location Templates are saved to: %APPDATA%/DBTools/Cache/VTC/ You can back up this folder or share templates with colleagues by copying files. Managing Library Templates Rename: Right-click a library template to rename Delete: Right-click and select Delete to remove from library Notes: Add descriptions when saving to remember template purposes Workflows Troubleshooting a View Display Issue Goal: Figure out why a view looks wrong compared to other views using the same template. Open View Template Comparer Select the template applied to the problematic view as Template A Select the template from a correctly displaying view as Template B Click Compare Look for yellow-highlighted rows in Display Properties and Category Overrides The differences reveal what's causing the display discrepancy Updating Project Templates to Match Office Standards Goal: Bring project templates in line with updated office standards. Open the project file Import the latest office standard template (from JSON or library) Open VTC and select the office standard as Template A Select the project template needing updates as Template B Compare and review differences Select the settings you want to update Click Apply to B to update the project template Creating a Variation of an Existing Template Goal: Make a new template that's similar to an existing one with a few changes. Open VTC and select the source template as Template A Select any other template as Template B (just as a comparison point) Compare Note the settings you want different in your new template Make selections as needed Click Create Merged Template Name your new template The new template is created with your selected settings Backing Up Templates Before Making Changes Goal: Preserve template settings before experimenting. Open VTC Select the template you're about to modify Click Save to Library Add a note like \"Backup before [date] changes\" Now make your changes in Revit If needed, load the library copy to restore original settings Transferring Templates Between Projects Goal: Move templates from one Revit document to another. Open the source document Open VTC and select the template to transfer Click Export → JSON Save the file Open the target document Open VTC and click Import → JSON Select the saved file Create a new template with the imported settings Tips & Best Practices Compare before merging Always review the full comparison before applying changes. A setting you didn't notice might have unintended effects. Use the library for backups Before making changes to important templates, save a copy to the library. It's faster than using Revit's undo. Name merged templates clearly Include source information in names, like \"Floor Plan - Merged from Standard v2.1\" Check filter availability When importing templates with filter overrides, ensure the target document has the same filters. Missing filters are skipped during import. Document with text dumps Generate text dumps of your standard templates for office documentation. They're searchable and can be compared using standard diff tools. Review Category Overrides carefully Category overrides are the most complex section. Expand categories to see projection/cut settings, not just visibility. Start with the simpler template as base When creating merged templates, choose the simpler template as your base to minimize unexpected settings. Troubleshooting No templates appear in the dropdown Cause: The document has no view templates defined. Solution: Create at least one view template in Revit (View tab → View Templates → Create Template from Current View). Some settings show as \"Unable to compare\" Cause: The setting type cannot be compared programmatically (rare). Solution: Note these settings and compare them manually in Revit's View Template dialog. Import fails with \"filter not found\" errors Cause: The JSON file references view filters that don't exist in the target document. Solution: Create the required filters in the target document first, or import will skip those filter overrides. Template library appears empty Cause: Templates are stored per-user. A new Windows profile or cleared AppData will have no saved templates. Solution: Re-save templates to the library, or copy the VTC folder from a backup or another user's AppData. Merged template is missing some settings Cause: Only selected settings are included in merged templates. Unselected settings use the base template's values. Solution: Select all settings you want before merging. Use Ctrl+A to select all, then deselect what you don't need. Apply to A/B button is disabled Cause: No settings are selected, or the selected settings are identical between templates. Solution: Select settings that have differences (yellow-highlighted rows). Comparison takes a long time Cause: Templates with many category overrides or filters require more processing. Solution: This is normal for complex templates. Wait for the comparison to complete—the status bar shows progress. FAQ Q: Can I compare templates from different documents? A: Not directly side-by-side, but you can export a template from one document to JSON, then open the other document and import it to compare. Q: Does VTC modify templates automatically? A: No. VTC only reads templates for comparison. Changes only happen when you explicitly click Apply or Create Merged. Q: What happens to views using a template I modify with Apply? A: All views using that template will update to reflect the new settings, just as if you'd edited the template through Revit's interface. Q: Can I undo changes made through VTC? A: Yes, standard Revit undo (Ctrl+Z) works for changes made by VTC. Q: Are library templates tied to a specific Revit version? A: Library templates are generally compatible across Revit versions, but some settings may not apply if the target version doesn't support them. Q: Can I share my template library with my team? A: Yes. Copy the contents of %APPDATA%/DBTools/Cache/VTC/ to the same location on other computers, or use the JSON export/import for individual templates. Q: Does the comparison catch everything? A: VTC compares all settings exposed through Revit's API. A small number of settings may not be accessible programmatically—these are rare. Q: What's the difference between JSON export and saving to library? A: JSON export creates a portable file you can share or move between computers. The library is local storage on your machine for quick access to frequently used templates. Q: Can I compare more than two templates at once? A: Not in a single view. Compare templates in pairs. For multi-template analysis, generate text dumps and use an external comparison tool."
  }
}